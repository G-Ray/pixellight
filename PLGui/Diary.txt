>> 12.06.2011
[CO]
- "Gui::GetSystemGui()": The internal "SystemGui" class is no longer derived from multiple classes to keep it simple
  (implemented this method orignally on "17.07.2010")



>> 07.06.2011
[CO]
- "Widget" events are now implemented as RTTI signals
- PLGui: "AbstractButton", "AbstractMenu", "AbstractSlider", "AbstractToggleButton" and "AbstractTooltip"
  events are now implemented as RTTI signals



/*********************************************************\
 *  The entries below are in German only
\*********************************************************/



>> 14.11.2010
[CO]
- "Theme::DrawWindow()" um Icon-Parameter erweitert der von "Window::OnDraw()" übergeben wird



>> 20.08.2010
[CO]
- WidgetWindows aktualisiert Maus-Trap sobald Fenster Position oder Größe verändert wurde - bitte nochmal drüberschaun
  ob das so ok ist...



>> 16.08.2010
[SB]
- WidgetWindows: IsTopmost() implementiert.
- An den Stellen, die z.B. ein neues Popup-Widget öffnen, wird nun Gui::GetRootWidget() als Parent verwendet.
  Dies dient eigentlich nur dazu, indirekt den Zeiger auf das Gui-Objekt zu übergeben, das Widget selber ist
  nur ein Dummy und wird auch dann im Contructor des Child-Widgets gleich wieder verworfen.
- ThemeDesktop: An einiges Stellen wurden noch lokal Images geladen, diese wurden nun auch mit ins Objekt geschoben
  und im Konstruktor geladen (wie es sein sollte).
- GraphicsLinux: Korrektur der Größe von Boxen. Bei Rechtecken müsste prinzipiell das gleiche sein, doch dann entstehen
  neue Lücken, weshalb ich das erstmal so gelassen habe, wie es schön aussieht. Sollte man sich aber nochmal ansehen ;-)



>> 11.08.2010
[CO]
- "PLGui3" in "PLGui" umbenannt
- "PLGuiDefinitions.h": PLGui-Namespace hinzugefügt
- "Theme::DrawWindow": Fenster-Titel Parameter hinzugefügt
- "Font::~Font()" & "Font::Font(const Font &cFont)": Es fehlte eine NULL-Abfrage (Implementation kann NULL sein)



>> 04.08.2010
[SB]
- GuiApplication2 ist durch das Verschieben der meisten Funktionalität nach PLCore::ConsoleApplication auch fertig und
  fügt tatsächlich nur noch die virtuelle Methode zum Erzeugen eines Fensters hinzu, ausserdem wird natürlich die
  Gui-MainLoop implementiert, aber ansonsten ist die Klasse erfrischend leer :-)



>> 03.08.2010
[SB]
- Klasse GuiApplication2 erstellt, die von der neuen Basisklasse ConsoleApplication abgeleitet ist. Die Klasse
  ist noch nicht komplett umgestellt, da dafür noch an anderen Stellen viel fehlt bzw. verschoben werden müsste.



>> 17.07.2010
[CO]
- Gui::GetSystemGui(): Die statische Instanz wird nun über ein Singleton verwaltet, damit bleibt natürlich das Problem
  der Deinitialisierungs-Reihenfolge, jedoch ist nun klar wann die Instanz erzeugt wird... wenn zum ersten mal Gui::GetSystemGui()
  aufgerufen wird. Wird PLGui überhaupt nicht verwendet, so verhält sich das System nun passiv, auch wenn man dagegen gelinkt hat -
  Hauptgrund für die Änderung war allerdings ein Anwendungsfall wie dieser in PLViewer Auftritt: PLViewer kann dadurch gestartet
  werden das man auf eine "scene"-Datei klickt, zu diesem Zeitpunkt ist das aktuelle Verzeichnis das Verzeichnis in dem sich
  die scene-Datei befindet... da sich das System-GUI sofort selbst initialisierte konnten dann diverse Images nicht gefunden werden
  da die Anwendung noch keine Chance hatte den Anwendungspfad zu ändern.
  Ich habe das nun einge male Durchdacht, und denke das diese Änderung keine Probleme mit sich bringt. Stefan, schau bitte trotzdem
  nochmal durch ob diese Änderung ok geht oder ob ich etwas nicht bedacht habe. :D



>> 13.07.2010
[CO]
- Widget & WidgetImpl um "GetMousePos()" erweitert welches die aktuelle Mausposition innerhalb des Widgets ermittelt, ist
  die Maus gerade nicht im Widget, gib diese Methode 'false' zurück



>> 10.07.2010
[SB]
- Widget: Es gibt nun einen zusätzlichen Konstruktor, womit ein Dummy-Widget für das Root-Widget einer Gui erzeugt
  werden kann. Dies wird in der Gui gespeichert und kann mittels GetRootWidget() abgefragt werden. Dieses Widget ist
  kein echtes Widget und wird nur dazu verwendet, um den Pointer zur Gui auch an Top-Level Widgets übermitteln zu
  können. Wenn ein Widget mit dem RootWidget als Parent erzeugt wird, nimmt sich dieses den Zeiger auf die Gui,
  anschliessend wird aber das ParentWidget wieder auf NULL gesetzt, damit die Konvention "Top-Level Widgets haben
  NULL als Parent" erhalten bleibt.



>> 08.07.2010
[SB]
- Widget: Neue Methode SetTrapMouse() eingebaut, die verwendet werden kann, um die Maus in einem Widget zu fangen.
  Die Maus kann also solange nicht aus dem Widget herausbewegt werden, wie dieser Modus aktiv ist, damit z.B. bei einer
  1st-Person artigen Steuerung nicht versehentlich der Cursor ausserhalb des Fensters platziert werden kann und man
  dann ein anderes Window aktiviert.
- WidgetWindows: SetTrapMouse() implementiert.
- WidgetLinux: SetTrapMouse() implementiert.



>> 04.07.2010
[SB]
- Widget wieder eingebaut und überarbeitet: ScrollWidget und Splitter.
- SizeHint: Anbindung ans RTTI hinzugefügt und dabei auch Umwandlung von und in Strings implementiert.
- Widget wieder eingebaut und überarbeitet: Splitter.
- Widget wieder eingebaut und überarbeitet: AbstractMenu, MenuBar und PopupMenu.
- ThemeDesktop: Farben überarbeitet und einheitliche MouseOver-Farbe für alle Widgets hinzugefügt.



>> 03.07.2010
[CO]
- PLXmlText auf PLGui3 umgestellt



>> 03.07.2010
[SB] (PLGui3)
- Widget wieder eingebaut und überarbeitet: Slider.
- Widget wieder eingebaut und überarbeitet: Toolbar.
- Widgets wieder eingebaut und überarbeitet: CheckBox und RadioButton.
- ThemeDesktop: Variable m_nControlRound für die abgerundeten Ecken der Controls eingebaut.



>> 02.07.2010
[CO]
- PLGui2 gelöscht



>> 01.07.2010
[SB] (PLGui3)
- Theme-Support für Tooltip eingebaut. Viel kann man damit nicht machen, da der Text immer noch über ein Label
  im Control selbst eingefügt und positioniert wird, das Theme kann daher am Text und dessen Positionierung nichts
  ändern. Aber zumindest der 2 Pixel große Rahmen, der vom Control freigelassen wird, steht dem Theme zur Verfügung,
  so dass hier entschieden werden kann, ob und in welcher Form z.B. ein Rahmen gezeichnet wird oder nicht.
- Widget: Neue Methode GetWidgetState() eingebaut, die die Widget-States zusammen in Form einer Flags-Variablen
  zurückgibt. Die Methode ist virtuell, damit abgeleitete Widgets das Verhalten erweitern oder verändern können,
  z.B. kommt in AbstractButton das Flag WidgetPressed hinein, wenn der Button gerade gedrückt ist, und SystemButton
  modifiziert das Verhalten zusätzlich so, dass nicht der Active-Status des Buttons selber, sondern der des Parent-Windows
  verwendet wird (ein System-Button sollte aktiv sein, wenn das Fenster selbst aktiv ist).



>> 30.06.2010
[SB] (PLGui3)
- Widgets überarbeitet: AbstractButton, AbstractSlider, AbstractToggleButton und AbstractTooltip.
- Widgets überarbeitet: Border und Panel.
- Widgets überarbeitet: Bitmap, Button und SystemButton.
- Widgets überarbeitet: Box, SlimEntry und Window.
- Widgets wieder eingebaut und überarbeitet: Label und Tooltip



>> 28.06.2010
[SB] (PLGui3)
- EWidgetState sind nun Flags, da sich die States ja nicht gegenseitig ausschliessen und beim Zeichnen mehrere States
  gleichzeitig berücksichtigt werden müssen.
- AbstractButton: IsSelected() entfernt, da es mittlerweile IsMouseOver() gibt, welches den gleichen Job macht :-)
- ThemeDesktop: Farben für bläuliches Theme zusammengefasst, damit alle Controls die gleichen Farben verwenden.



>> 27.06.2010
[SB] (PLGui3)
- Alle weitergehenden Widgets erst einmal herausgenommen und in das Verzeichnis '_Unused' verschoben, damit es
  einfacher wird, das alte Theme-System auszubauen und Schritt für Schritt die Widgets umzustellen und die neue
  Theme-Klasse dementsprechend zu erweitern.
- ThemeHelper: DrawButton() implementiert.
- State 'WidgetPressed' für z.B. Buttons hinzugefügt.
- Button und ToggleButton auf neues Theme-System umgestellt.
- Widgets 'Border' und 'Panel' hinzugefügt: Border zeigt einen frei definierbaren Rahmen an, wobei Linientyp, Dicke
  und Farbe festgelegt werden können. Dies ist also für die Verwendung durch den User gedacht, das Aussehen wird
  daher (bis auf die generelle Art, Rahmen zu zeichnen) vom User und nicht vom Theme bestimmt. Panel dagegen ist
  wieder eine logische Definition eines Bereiches in einem Window, wobei dieser entweder 'flat', 'raised' oder
  'sunken' sein kann. Was genau dies bedeutet und wie demnach das Panel aussieht, liegt komplett beim Theme.
- Alte Theme-Klassen entfernt und Methoden aus ThemeHelper nach Theme überführt.
- Theme: Window-Color und Panel-Color hinzugefügt.
- Message 'OnThemeChanged' hinzugefügt. Diese Nachricht wird automatisch gesendet, wenn das Theme von einem Widget
  geändert wurde (hierbei wird PostMessage verwendet, damit das ganze über die Mainloop geht und nicht sofort
  ausgeführt wird, dadurch lassen sich die Probleme mit virtuellen Methoden im Konstruktor vermeiden). Die entsprechende
  neue virtuelle Methode OnThemeChanged() ist per Default so implementiert, dass das Widget neu gezeichnet wird. An
  der Ableitung ContainerWidget wird zusätzlich auch AdjustContent() ausgeführt, da sich die Größe des Content-Windows
  in Abhängigkeit vom Theme verändert haben könnte (z.B. Border-Size).
- Gui, Widget: Theme-Verwaltung überarbeitet. Das Theme wird nun erstmal in Gui gesetzt und automatisch von neu
  erzeugten top-level-Widgets verwendet. Im Falle eine Child-Widgets wird automatisch das Theme vom Parent übernommen.
  In Gui können neue Themes erzeugt oder gesetzt werden, in dem Fall werden auch die Top-Level-Widgets automatisch
  angepasst. Die Instanz des Theme wird von Gui verwaltet und auch später wieder gelöscht. Zusätzlich ist es auch
  möglich, einem Widget direkt ein Theme zu übergeben, in diesem Fall muss die Instanz natürlich selber verwaltet
  werden, ansonsten funktioniert das Theme aber genauso.
- AdjustContent und UpdateContent senden nun Gui-Nachrichten.



>> 26.06.2010
[SB] (PLGui3)
- Window: RTTI Get/Set-Funktionen bei den anderen Funktionen einsortiert und eigenen Block entfernt.
  Aufruf der Basisimplementierung bei den virtuellen Funktionen entfernt.
- AbstractButton und SystemButton überarbeitet.
- ThemeHelper: Größe von SystemButtons ist nun auch variabel und wird von Window verwendet.
- Widget: Neue Methode RedrawAll() eingebaut, die nicht nur das Widget selbst sondern auch alle Child-Widgets neu zeichnet.
- ThemeHelper: Zeichnen von Panels mit Raised- oder Sunken-Border implementiert.
- Themes: Es wird nun davon ausgegangen, dass *immer* ein Theme-Objekt vorhanden ist, dafür wird es dann später
  eine entsprechende Default-Implementation geben. Diese sollte dann so implementiert sein, dass sie z.B. dann
  alles mit einer Textur zeichnet, die gleich zu erkennen gibt, dass hier ein Theme fehlt ("no theme").
- ThemeHelper: DrawRect() zum Zeichnen von Rechtecken mit verschiedenen Linientypen aus ThemePLDefault übernommen.
- ThemeHelper: DrawFocusRect() hinzugefügt.
- EBorderStyle aufgeteilt in EBorderStyle (Sunken, Raised oder Flat) und ELineStyle (Solid, Dashed oder Dotted).



>> 25.06.2010
[SB] (PLGui3)
- PLGuiDefinitions: Neues enum WidgetState hinzugefügt, das Definitionen für den Status eines Widgets, wie
  z.B. Active, InActive oder MouseOver enthält. Das sollte die Theme-Funktionen um einiges einfacher machen,
  da man nicht mehr mehrere bools sondern nur noch eine einzige Status-Variable übergeben muss. Dabei muss
  natürlich der Aufrufer selbst darauf achten, dass der richtige Status übergeben wird, z.B. wenn ein Fenster
  deaktiviert ist, sollte kein MouseOver übergeben werden, selbst wenn dies der Fall ist.
- Theme: Temporär eine neue Klasse namens ThemeHelper eingebaut, die ich dazu verwenden möchte, die Theme-Klasse
  nach und nach zu ersetzen. Zu diesem Zweck hat die Theme-Klasse selbst nun erst einmal eine Instanz der "neuen"
  Theme-Klasse, so dass erst einmal beides nebeneinander existieren kann. Wenn dann alle Widgets umgestellt sind und
  nur noch die ThemeHelper-Klasse verwenden, kann diese in Theme umbenannt und die alte Klasse entfernt werden.
- Zwei Themes begonnen: "Desktop" und "Ingame".
- GraphicsWindows: Beim Zeichnen von Linien wird der Zielpunkt selbst nicht mitgezeichnet. Dies finde ich unintuitiv,
  weshalb ich jetzt den letzten Punkt per SetPixel noch selber zeichne. Man kann sich also darauf verlassen, dass
  in PLGraphics alle angegebenen Koordinaten immer "inklusive" sind, sowohl bei z.B. Boxen als auch bei Linien
  (unter Windows scheint der Standard genau anders herum zu sein).
- ThemeHelperDesktop: Zeichnen von Borders, Windows und System-Buttons implementiert. Die Ränder sind nun mehr wie im
  klassischen Windows-Look, wirken daher nicht mehr flach sondern haben einen deutlichen 3D-Rand, was wie ich finde
  deutlich besser wirkt. Die Farbe der Titelleiste wurde ebenfalls angepasst, die System-Buttons sind nahezu gleich
  geblieben, sind aber nun abgerundet. Dennoch ist dies auch ganz deutlich ein eigener Stil und keine 1:1-Kopie vom
  Windows-XP look. Ich hoffe eigentlich, dass man sich mit diesem Titelleisten-Look nicht mehr zu verstecken braucht...
- Zum Übergang gibt es in Theme nun die Variable m_bUsingNewTheme, die zum Umstieg auf das neue Theme-System dient.
  Wenn alle Widgets umgestellt wurden, kann dies wieder entfernt werden.
- WidgetWindows: Fehler beim Fullscreen-Modus behoben.
- Window und SystemButton auf neue Theme-Klasse umgestellt.
- Window: Es wird nun das neue Theme so verwendet, dass nur noch der Rahmen des Windows gezeichnet wird, der Hintergrund
  des Window selbst ist transparent und der Rest des Platzes wird vom Content-Widget verwendet, so dass es keinerlei
  überlappende Bereiche und damit auch kein Flackern mehr gibt.
- WidgetWindows: Es wird nun das ClipChildren-Flag verwendet, um das Flackern zu vermeiden das entsteht, wenn erst
  das Hintergrund-Widget und dann das Child-Widget gezeichnet werden.


>> 24.06.2010
[SB] (PLGui3)
- Wie besprochen habe ich das mit den Basis-Widget-Typen wieder ausgebaut, es gibt also kein System-Window mit
  System-Titelleiste etc. mehr. Das ganze war ein Versuch, es hat sich aber gezeigt, wie kompliziert es ist, das
  ganze zu managen, weil man dann ständig Fallunterscheidungen hat, je nachdem, wie der Basistyp des Widgets denn
  nun ist. Dies hat sich an vielen Stellen manifestiert, z.B. natürlch bei den Basiseinstellungen für Widgets
  im Backend, beim Frame mit seinen unterschiedlichen Optionen, beim Fullscreen-Modus, bei ShowInTaskbar und hätte
  sich in Zukunft bestimmt noch an vielen anderen Stellen erneut gezeigt. Dies alles unter einen Hut zu bekommen,
  wäre enorm viel Feinarbeit geworden, und das nur dafür, damit man unser Gui-Toolkit versteckt und das Fenster so
  aussieht wie "normale" Fenster auf dem System. Warum das so furchtbar wichtig sein soll, verstehe ich sowieso immer
  noch nicht, denn andere Toolkits kommen nunmal auch mit ihrem eigenen Look daher, und tatsächlich kamen bisher
  in der Richtung keinerlei Beschwerden, dass dies jemanden stören würde. Ich finde daher dieses Mischen, auf der
  einen Seite am eigenen Toolkit festzuhalten, auf der anderen Seite aber um jeden Preis ein "normales" Fenster haben
  zu müssen anstelle unseres eigenen, gut funktionierenden und mittlerweile auch besser aussehenden Frames einfach
  nicht sinnvoll. Wir werden dieses Experiment also nicht weiter verfolgen, PLGui bleibt ein eigenes Toolkit, das denke
  ich vieles zu bieten hat, und wenn das verwendet wird, kommt es eben auch mit einem eigenen Look daher. Auf
  der anderen Seite werden wir verstärkt einfache Möglichkeiten zum Einbetten von PixelLight in andere Toolkits und
  Applikationen anbieten, wer also einen anderen Look haben möchte, kann dann z.B. von vornherein Qt oder ein anderes
  Toolkit verwenden. Dies mag sich für große Applikationen, die viele standard Gui-Controls benötigen, anbieten, da
  PLGui nicht dazu gedacht ist, diese Applikations-Toolkits zu ersetzen und man daher mit Bibliotheken wie Qt sicherlich
  besser bedient ist für z.B. Editoren oder ähnliche Applikationen. Für reine Rendering-Windows und Ingame-Guis
  dagegen wird sich eher PLGui anbieten, welches mehr auf diese Art von Applikationen ausgelegte Widgets anbieten wird
  (siehe z.B. OCD).
- Window entfernt (siehe oben), dafür Frame nun in Window umbenannt.



>> 23.06.2010
[SB] (PLGui3)
- Klasse ThemeHelper begonnen, um die neuen Themes zu entwickeln. In welcher Art und Weise das Theme-System letztlich
  organisiert sein wird, weiß ich noch nicht, offen gesagt gefallen mir wieder die alte Art mit großen Klassen noch
  die neue mit den Theme-Paintern wirklich. Ich nutze dies daher erstmal zum noch einmal neue Wege ausprobieren,
  dann werde ich sehen, wie ich das letztlich ins Theme-System integriere.



>> 22.06.2010
[SB] (PLGui3)
- Neue Message 'OnWakeUp' eingebaut, welche verwendet werden kann, um die Message-Loop aufzuwecken. Dazu gibt es
  auch die Convenience-Funktion Gui::WakeUp(), natürlich macht dies nichts anderes, als PostMessage aufzurufen.
- WidgetWindows: Der Trick bei "SetShowInTaskbar" besteht offenbar darin, dass das Fenster einmal versteckt und
  dann wieder neu angezeigt werden muss, dann verschwindet das Taskbar-Icon und wird natürlich nur dann wieder
  neu erzeugt, wenn das entsprechende Flag gesetzt wurde :-)  Durch das SetVisible(false) geht natürlich auch
  der Fokus verloren, das überlasse ich aber hier dem App-Programmierer, den Fokus hinterher wieder neu zu setzen
  (siehe 98GuiTest). Damit funktioniert nun SetShowInTaskbar() also unter Windows auch zur Laufzeit, nur für den
  Fall, dass BaseWindow verwendet wird, hätten wir noch immer ein Problem, da das WS_EX_TOOLWINDOW dann hier
  stören würde.
- Gui: OnHover-Event eingebaut. Dieses Event wird automatisch in Gui erzeugt und muss nicht vom Backend bereitgestellt
  werden, da die nötigen Informationen aus den OnMouseOver-Nachrichten herausgelesen werden. Das Event wurde dabei so
  verändert, dass nicht mehr die Mausposition innerhalb des Widgets mitgeliefert wird, da dies meist unnötig sein
  dürfte und erfordern würde, dass man diese Information aus der letzten MouseMove-Nachricht auch noch intern wegspeichert.
- Gui: GetHoverTime()/SetHoverTime() eingebaut. Wenn der Timeout auf 0 gesetzt wird, deaktiviert dies alle Hover-Events,
  auch wird der Timer dann gar nicht erzeugt.
- Timer: Ein Timer, der mit StartOnce() gestartet wurde, galt danach immer als aktiv, weil m_bActive niemals zurückgesetzt
  wurde. Dieser Fehler ist nun behoben.
- Gui: Methode ShowTooltip() eingebaut, welche einen einfachen Tooltip anzeigt, indem ein Widget vom Typ 'Tooltip' erzeugt
  wird. Die Widget-Klassen AbstractTooltip und Tooltip wurden dabei noch einmal gründlich überarbeitet, TooltipData wurde
  entfernt. Diese Methode soll ebenfalls nur ein Angebot sein, wenn man eigene, erweiterte Tooltips anzeigen will, sollte 
  man eine eigene Klasse von AbstractTooltip ableiten und diese bei Bedarf anzeigen.
- Modifier 'ModTooltip' wieder hinzugefügt und überarbeitet. Dieser Modifier reagiert dabei auf das MouseHover-Event
  und zeigt daraufhin einen Tooltip an. In abgeleiteten Klassen kann diese Funktionalität ausgetauscht werden, um
  z.B. eine andere Art von Tooltip anzuzeigen.
- Modifier 'ModFrameMoveSize' entfernt und die Funktionalität wieder direkt in Frame implementiert. Modifier zu haben,
  die für bestimmte Widget-Typen vorhanden sein *müssen*, ist irgendwie unschön und schafft implizite Abhängigkeiten,
  die später verwirrend sein könnten. Darum hier doch lieber ein gradliniger Ansatz, auch wenn Frame dadurch größer
  und unübersichtlicher wird.
- Widgets umsortiert und Kategorien verändert, damit dies möglichst einfach verständlich wird und auch nicht zu viele
  Kategorien existieren.
- Mit neuen Widgets begonnen ("SlimWidgets"). Diese sollen von der Art her deutlich einfacher werden als die bisherigen
  Controls, und sich weniger an den bekannten Desktop-Controls orientieren und mehr an den neuartigen Widgets, die man
  z.B. im Web oder auf Handy-UIs und ähnlichem findet. Mal sehen ob dieses Experiment gelingt, natürlich wird sich das
  letztlich doch nicht komplett unähnlich sein, aber z.B. auf sehr komplizierte Controls wie TreeViews oder Tab-Windows
  müsste man eigentlich verzichten können, auch die Controls selber können von der Art hier schlanker gehalten werden.
- ScrollWidget: Der Inhalt der Fensters wurde nicht mehr angezeigt, da auf dem inneren Content-Widget nicht mehr
  AdjustContent() aufgerufen wurde. Dies wurde nun behoben, so dass der Inhalt wieder sichtbar ist. Hier muss allerdings
  noch eine Lösung gefunden werden, dass sich die Größe des inneren Fensters dynamisch seinem Inhalt anpasst.



>> 21.06.2010
[SB] (PLGui3)
- TrayIcon: ShowNotification() funktioniert nun unter Linux mit Gnome. KDE hat ein neues SysTray-Konzept, welches
  ich vorläufig nicht auch noch implementieren werde, und unter XFCE funktioniert zwar das Icon, XFCE unterstützt
  jedoch ganz einfach keine Notifications/Balloons.



>> 20.06.2010
[SB] (PLGui3)
- Widget: Neues Flag 'm_bManaged' hinzugefügt, welches intern von einem Widget gesetzt werden kann, damit es nicht
  von Gui in die TopLevel-Window-Liste eingetragen wird und damit auch beim Beenden nicht automatisch gelöscht wird.
  Dies sollte natürlich nur verwendet werden, wenn sichergestellt ist, dass das entsprechende Widget z.B. im Destruktor
  einer anderen Klasse mit gelöscht wird. Das kann manchmal nötig sein, um doppeltes Löschen zu verhindern.
- TrayIconWidgetLinux hinzugefügt. Dies ist ein Widget, welches von TrayIconLinux verwendet wird, um ein Icon in die
  SysTray unter Linux einzubetten. Dazu unterstützt dieses Widget das XEMBED-Protocol, welches wohl von allen
  größeren Window/Desktop-Managern unter Linux inzwischen unterstützt werden sollte. Damit kann das Fenster dann
  z.B. in die Systray eingebettet werden, ansonsten ist es eigentlich ein ganz normales Widget, welches sein eigenes
  Icon anzeigt. Auch wenn es von uns nicht wirklich benötigt wird, habe ich das gesamte XEMBED-Protokoll implementiert,
  so dass man das später leicht erweitern kann, um z.B. Desktop-Widgets oder ähnliches zu unterstützen. Da wir allerdings
  wohl erstmal nur die Systray verwenden werden, habe ich es direkt hier implementiert und erstmal auf ein allgemeineres
  Interface verzichtet.
- TrayIconLinux ist nun funktionsfähig, allerdings wird das Icon noch nicht mit dem richtigen (transparenten) Hintergrund
  angezeigt.
- GuiLinux: Nach OnMouseButtonUp wird nun auch ein OnMouseButtonClick gesendet.
- TrayIcon: CreateTrayIcon() und DestroyTrayIcon() werden nun wieder korrekt aufgerufen, da nicht jede Implementation
  so wie unter Windows funktionieren muss, wo das Anzeigen/Ausblenden nicht richtig funktioniert und deshalb das
  Icon jedes Mal neu erzeugt wird. Implementation unter Windows daher entsprechend angepasst.
- TrayIcon: ShowNotification() zur Anzeige von Benachrichtigungen (Ballon-Tooltips) eingebaut.



>> 19.06.2010
[SB] (PLGui3)
- WidgetLinux: Das ShowInTaskbar-Flag ist nun standardmäßig auf 'false' gesetzt, ausserdem wird der Status nach einem
  SetVisible() angeglichen, da man die Attribute wohl nur setzen kann, wenn das Fenster gerade sichtbar ist.
- Mit Implementierung von TrayIconLinux begonnen.



>> 18.06.2010
[SB] (PLGui3)
- GuiLinux: Topmost-State implementiert.
- GuiLinux: ShowInTaskbar-State implementiert.
- WidgetWindows: Beim Ändern des Taskbar-Styles muss nun doch das Fenster neu angezeigt werden, ansonsten bleibt es
  unsichtbar. Komisch nur, dass sich dies bei der Transparenz-Einstellung anders verhält. Ausserdem gelingt es mir
  nicht, das Taskbar-Icon nachträglich zu entfernen, es funktioniert also nur, wenn von vornherein SetShowInTaskbar(false)
  eingestellt wurde, bevor das Fenster angezeigt wird. Dies sollte aber in den meisten Fällen auch ok sein, dass man
  sich hier vorher entscheiden muss und das nicht mehr on-the-fly ändern kann. Unter Linux allerdings klappt auch
  das nachträgliche Ändern problemlos :-)
- Timer-Abstürze unter Linux überprüft und hoffentlich behoben. Zunächst einmal gab es eine böse Race-Condition im
  TimerThread, da dieser beim Start m_bRunning auf 'true' setzte, dabei jedoch nicht berücksichtig wurde, dass der
  Start des Threads selbst mit einiger Verzögerung erfolgen kann. Wenn in der Zeit schon ein Stop()-Aufruf erfolgt,
  wird m_bRunning durch den später startenden Thread zurückgesetzt, so dass der Thread sich niemals beendet. Dieses
  Problem ließ sich durch eine kleine Umstellung lösen. Ausserdem ist das Join mit Timeout unter Linux noch nicht
  implementiert, dies habe ich nun so verändert, dass dann ein endloses Join aufgerufen wird, da das Terminieren des
  Threads unter Linux noch zum Absturz führt (und natürlich sowieso vermieden werden sollte).
- GuiLinux: Das Löschen von Fenstern macht einige Probleme, da nach dem Aufruf von Destroy sofort das Fenster und
  alle Unterfenster als zerstört gelten und nicht mehr verwendet werden dürfen, z.B. ein Redraw o.ä. auf einem
  dieser Fenster führt sofort zu einem Fehler. Aber leider erfolgt ja der Destroy-Aufruf auch aus einem Kontext,
  z.B. einem OnClick-Event oder ähnlichem, heraus, in dessen Verlauf z.B. ein Redraw() oder andere Aufrufe für das
  Fenster erfolgen können, bis wieder die Mainloop erreicht wird. Das OnDestroy()-Event, welches das Fenster
  als zerstört markiert, erfolgt jedoch erst später in der Mainloop, weshalb es immer einen haufen von X-Fehler gab,
  wenn ein Fenster zerstört wurde, weil noch etliche Operationen auf diesem Fenster ausgeführt werden.
  Um diese Probleme zu beheben, habe ich erstmal alle möglichen Sicherheitsabfragen eingebaut, damit X-Operationen
  nur noch auf Fenstern stattfinden, die noch nicht zerstört wurden. Des weiteren gibt es jetzt eine interne
  Destroy-Nachricht, die an ein Fenster gesendet wird, wenn es zerstört werden soll. Das verzögert das Zerstören des
  Fensters zumindest bis zum nächsten Aufruf der Message-Loop, verhindert allerdings auch noch nicht alle Fehlermeldungen.
  Letztlich wird dann beim eigentlichen Zerstören des Fensters eine interne Funktion aufgerufen, die rekursiv alle
  Child-Widgets zerstört und deren Destroyed-Flag setzt, damit diese Widgets sofort als zerstört erkannt werden können,
  auch wenn noch keine OnDestroy-Nachricht für sie eingegangen ist. Dadurch wird sichergestellt, dass auf das Widget
  selbst und alle Child-Widgets keine X-Befehle mehr ausgeführt werden, wodurch es auch keine Fehlermeldungen mehr gibt.



>> 17.06.2010
[SB] (PLGui3)
- WidgetWindows: Bei SetZPos() wieder SWP_NOACTIVATE hinzugefügt, da ansonsten z.B. beim Öffnen eines Popup-Menus
  der Fokus wegspringt. Wenn das SetZPos() unter Window nun nicht immer funktioniert, muss das wohl als Windows-Fehler
  angesehen werden ...
- AbstractMenu: Sicherheitsabfragen eingebaut für den Fall, der zu einem ungünstigen Zeitpunkt der Fokus verloren geht.
- ThemePLDefault: System-Buttons passen sich in der Farbe nun an, wenn ihr Parent-Window nicht aktiv ist. Deaktivierte
  System-Buttons werden mit einem helleren grau angezeigt, inaktive Buttons mit einem dunkleren Grau wie die Titelleiste.
- Frame: Nicht verwendete System-Buttons werden nun nicht mehr ausgeblendet, sondern deaktiviert.
- AbstractMenu: Separatoren werden nun übersprungen, wenn man mit der Tastatur im Menü navigiert.
- GuiLinux: Focus und MouseOver-Events eingebaut.
- WidgetLinux: Ich verstehe zwar nicht warum, aber offenbar reicht es unter X nicht aus, die Funktionen in der richtigen
  Reihenfolge aufzurufen und dann die Nachrichten abzurufen, denn z.B. beim Setzen des Focus gibt es dann eine Fehlermeldung,
  weil das Fenster wohl noch nicht sichtbar ist. Daher rufe ich nun nach jedem wichtigen Befehl XSync() auf, damit die
  Nachrichten auch auf jeden Fall abgearbeitet werden, und damit funktioniert auch der anschliessende SetFocus-Aufruf.
  In der Doku steht eigentlich, dass diese Funktion von Client-Apps so gut wie nicht benötigt wird, aber offenbar doch...
- GuiLinux: Enabled/Disabled-Modus für Widgets implementiert.
- GuiLinux: Window-Title und Window-Icon implementiert.
- GuiLinux: Window-States implementiert. Dies funktioniert unter Linux (fast) einheitlich über das Setzen von Properties
  für den WindowManager, wofür es den NetWM-Standard gibt (http://standards.freedesktop.org/wm-spec/wm-spec-1.4.html).
  Für das Minimieren von Fenstern gibt es offenbar eine eigene X-Funktion, was ich für die anderen States nicht
  finden konnte, hier setze ich dann die States direkt (was wiederum fürs Minimieren nicht funktionierte). Zumindest
  unter meinem Ubuntu 10.4 funktioniert damit soweit alles.
- Fullscreen-Modus überarbeitet. Die Nachrichten OnEnterFullscreen/OnLeaveFullscreen werden nun automatisch von Gui
  versendet, wenn ein Wechsel im WindowMode abgefangen wird, und sollten daher nicht mehr von Backend selbst erzeugt
  werden.



>> 15.06.2010
[SB] (PLGui3)
- WidgetImpl: Methode SetIcon() hinzugefügt, um das Icon eines Fensters zu verändern. Wenn das Icon eines Widgets
  gesetzt wird, wird nun automatisch diese Backend-Methode aufgerufen.
- Icons unter Windows implementiert. Da es hier keine eigene Klasse für Icons gibt, wird bei Bedarf aus einem Image
  ein Icon erzeugt, das entsprechende Handle wird dabei direkt in ImageWindows mit gespeichert, damit das Icon
  im Idealfall nur ein einziges Mal erzeugt werden muss. Das Setzen von Icons für Widgets funktioniert nun auch.
- ToolsWindows: Coding-Style überarbeitet.
- Widget: UserData hinzugefügt, welches mittel SetUserData() und GetUserData() gesetzt bzw. abgefragt werden kann.
  Dies wird im Windows-Backend verwendet, um TrayIcon-Messages an das entsprechende TrayIcon weiterleiten zu können.
- TrayIcon: Kleinere Interface-Änderungen und TrayIcon für Windows implementiert.
- Focus und MouseOver-Events wurden noch einmal überarbeitet, damit die Mainloop doch so einfach wie möglich
  bleiben kann, und z.B. alle Nachrichten korrekt behandelt werden, ohne dass noch spezielle Aufrufe oder Hacks dafür
  in der Mainloop selbst eingebaut werden müssen. Dies ist besonders dafür wichtig, wenn man später PLGui-Widgets
  in andere Gui-Toolkits einbetten möchte, denn dann hat dieses andere Toolkit (z.B. Qt) die Kontrolle über die
  Mainloop, man muss also damit auskommen, auf die Nachrichten zu reagieren, die an unsere Window-Procedure geschickt
  werden. MouseOver und Focus-Events werden nun unter Windows wieder korrekt behandelt, beim MouseOver ist es sogar
  einfacher als zuvor, da die Nachrichten hier unter Windows in der richtigen Reihenfolge kommen. Beim Focus ist
  das leider nicht der Fall (es kommt erst KILLFOCUS dann SETFOCUS), weshalb die Behandlung hier im Windows-Backend
  um einiges komplizierter ist, es wird jedoch dafür gesorgt, dass bei der Gui immer erst das neue Widget sein
  OnGetFocus bekommt, und dann erst das alte Widget ein OnLooseFocus erhält, damit in der Zwischenzeit kein OnActivate(NULL),
  mit dem alle Widgets erstmal deaktiviert würden, passiert.
- Gui: Die Mainloop blockiert nun auch wieder, dies war versehentlich zwischenzeitlich nicht der Fall.
- GraphicsWindows: Die Zeichenfunktionen von Windows sind echt schrott. Dass Rectangles immer so angegeben werden müssen,
  dass der rechte und der untere Rand ausserhalb des gezeichneten Bereiches liegen, habe ich ja inzwischen verstanden,
  offenbar ist Windows aber dennoch nicht bereit, Rechtecke mit einer Größe von 1 zu malen, auch wenn man (x, y, x+1, y+1)
  angibt. Darum musste ich diesen Fall nun abfangen und zeichne dann halt gleich einen einzelnen Pixel.
- Focus-Rectangle wird nun wieder angezeigt (zwar noch nicht hübsch, aber da).
- WidgetWindows: Offenbar klappt das mit dem Ändern der Z-Pos nicht, wenn das Window nicht aktiviert ist, deshalb wird
  das Window nun bei einem Aufruf dieser Funktion auch aktiviert. Hoffentlich braucht man das nicht so häufig ...
- Widget: Funktion Activate() hinzugefügt, die das Fenster sichtbar macht, nach oben holt und den Focus setzt.
- WidgetImpl: Es gibt nun doch eine Activate()-Methode im Backend, da es mir nur so unter Windows gelang, ein Fenster
  zuverlässig in den Vordergrund zu bringen und den Focus zu setzen (am Beispiel des TrayIcons). Bringt man das Fenster
  so in den Vordergrund und setzt den Focus, kommt zwar die Focus-Nachricht an, anschliessend ist der Focus aber trotzdem
  noch in der Taskbar, und das ohne eine KILLFOCUS-Nachricht. Hier stimmt also irgend etwas nicht, ein Aufruf von
  ::SetForegroundWindow() scheint das Problem aber zu lösen. Unter Linux und anderen System kann man das dann ja so
  implementieren, dass einfach SetFocus() und SetZPos() vom Widget aufgerufen werden.
- Widget: Methode CanAcceptFocus() hinzugefügt, mit der überprüft werden kann, ob ein Fenster überhaupt den Fokus
  annehmen kann. Dabei wird nicht nur der FocusStyle überprüft, sondern auch, ob das Widget gerade deaktiviert ist.
  Testweise den ersten Button im Frame deaktiviert, und nach dieser Änderung wird der Fokus nun automatisch an den
  zweiten Button vergeben, wenn das Fenster aktiviert wird.



>> 14.06.2010
[SB] (PLGui3)
- Die MouseOver-Message übergibt nun keinen Zeiger mehr auf das aktuelle MouseOver-Widget, sondern nur noch einen
  boolschen Wert, der angibt, ob das jeweilige Widget gerade mouse-over ist oder nicht. Das ist zwar nicht ganz
  so flexibel, aber dafür einfacher zu verwenden :-)
- Frame: Focus-Style auf ChildFocus gesetzt, damit immer das erste Widget korrekt aktiviert wird.
- Widget: Default-Value für m_bTabStop ist nun 'true', damit dies nicht mehr bei jedem Widget einzeln gesetzt werden
  muss, damit die Tab-Stops funktionieren. Ein Widget muss ja sowieso erst einmal seinen Focus-Style auf Accept setzen,
  ansonsten bekommt es keinen Focus und das m_bTabstop spielt auch keine Rolle. Für die Widgets, die den Focus akzeptieren,
  sollte m_bTabstop aber meistens an sein, und nur in Ausnahmefällen kann es dann ausgeschaltet werden.
- Timer: Es konnte eine böse Race-Condition geben, wenn ein Timer z.B. mit einem Widget oder einem Modifier zusammen
  gelöscht wird. Wenn das Widget gelöscht wird, zerstört es automatisch auch den Timer, wenn dieser aber kurz zuvor
  noch gefeuert hat, wird die OnTimer-Message erst beim nächsten Aufruf der Message-Loop gefunden, wenn der Timer
  bereits zerstört wurde. Dann gibt es einen Absturz, weil das Event von einem bereits gelöschten Timer aufgerufen wird.
  Um dies zu verhindern, existiert in Gui nun eine Liste von Timern, wo sich die Timer automatisch ein- und austragen.
  Nachrichten von Timern, die nicht (mehr) in dieser Liste stehen, werden dann einfach ignoriert.
- WidgetWindows: Das Ein- und Ausblenden durch ModBlend führte immer auch dazu, dass das Widget auch den Focus erhielt.
  Um das zu verhindern, wurde nun das Flag SWP_NOACTIVATE hinzugefügt.
- GuiImpl: Methode GetFocusWidget() entfernt, da dies zentral in Gui verwaltet werden sollte.
- Gui: Analog zum MouseOver-Widget wird nun auch das Focus-Widget in Gui verwaltet. Dazu werden die OnGetFocus und
  OnLooseFocus-Nachrichten überwacht, um Änderungen beim Focus-Widget abzufangen.
- Neue Message OnActivate eingebaut, welche einem Fenster mitteilt, wenn es aktiviert oder deaktiviert wurde. Ein Fenster
  ist dann aktiv, wenn es selbst oder eines seiner Child-Widgets den Focus besitzt. Die OnActivate-Nachricht ist daher
  ein zusatz zu OnGetFocus/OnLooseFocus und funktioniert analog zu OnMouseOver und OnMouseEnter/OnMouseLeave.
- GuiImpl: Methode HasFocus() entfernt.
- GuiWindows: Fenster, die in der Taskbar angezeigt werden, bekommen nun auch ein System-Menü, damit kann mit einem
  Klick mit der rechten Maustaste auf das Taskbar-Icon das System-Menü geöffnet werden.
- Widget: Methoden IsActive(), IsMouseIn() und IsMouseOver() hinzugefügt.
- Neuer Focus-Style 'ChildFocusOrSelf' hinzugefügt. Frames sind überlicherweise auf ChildFocus gesetzt, geben also den
  Focus an ihre Child-Widgets ab. Wenn das Fenster jedoch leer ist, gibt es auch kein Child-Widget, welches den Focus
  übernehmen kann, weshalb leere Fenster dann niemals den Focus haben und damit auch niemals aktiviert werden können
  (Titelleiste bleibt grau). Darum gibt es nun den neuen Style 'ChildFocusOrSelf', der besagt, dass erst wie bei ChildFocus
  versucht wird, den Fokus an ein Child-Widget abzugeben, wenn dies aber nicht gelingt, das Widget den Fokus selber akzeptiert.
- ThemePLDefault: Die Titelleiste von inaktiven Frames wird nun grau angezeigt.



>> 13.06.2010
[SB] (PLGui3)
- Layouts funktionieren wieder. Der Einfachheit halber ist es nun auch möglich, den Klassennamen der Layout-Klasse
  ohne PLGui:: anzugeben. Wird die Klasse im ersten Anlauf nicht gefunden, so wird automatisch auch im PLGui-Namespace
  gesucht. Sollte man eigene Layouts in einem anderen Namespace erstellt haben, muss dieser natürlich angegeben werden.
- Auch bei Themes und Modifiers kann nun das "PLGui::" weggelassen werden.
- GuiWindows: Zur Sicherheit die Abfrage wieder eingebaut, ob ein bereits zerstörtes Fenster noch Nachrichten bekommt.
  Dies ist tatsächlich häufig der Fall, weil immer noch eine WM_NCDESTROY-Nachricht nach WM_DESTROY gesendet wird,
  die wir allerdings nicht benötigen und darum auch nicht weiter abfangen. Zur Sicherheit geben ich dann aber hier
  direkt mit DefWindowProc zurück, damit nicht doch aus Versehen noch auf das Fenster zugegriffen wird.
- Gui: Es gibt nun die Methode Shutdown(), mit der das Deinitialisieren der GUI von außen angestoßen werden kann.
  Natürlich wird dies auch automatisch im Destruktor aufgerufen, allerdings ist es für die statische Instanz der
  System-GUI leider notwendig, dies bereits *vor* dem Beenden der Applikation aufzurufen, da man ansonsten wieder
  in das statische Deinitialisierungs-Dilemma hineinläuft. Da kann es dann passieren, dass z.B. Teile von PLCore
  sich bereits deinitialisiert haben, während noch Gui-Message abgerufen werden, und dann stürzt es natürlich ab.
  Gui-Applikation müssen also nun immer vor dem Ende der Applikation Shutdown() von der System-GUI aufrufen, in
  GuiApplikation wurde das bereits entsprechend eingebaut.
- Modifier ModDebug und ModExitOnClick entfernt.
- Modifier ModTimeout wieder eingebaut und an Änderungen angepasst.
- AbstractMenu: Da GetParent() nun doch wieder NULL sein kann, musste dies hier angepasst werden.
- Widget: RegisterHotkey() so verändert, dass es nun eine ID für den Hotkey zurückgibt, anstatt diese bereits als
  Eingabe-Parameter zu erwarten. Die IDs müssen je nach System in bestimmten Wertebereichen vorliegen, daher ist
  es besser, dies dem System zu überlassen und nach dem Erstellen eines Hotkeys diese ID zu speichern, als es dem
  User zu überlassen, IDs zu definieren.



>> 12.06.2010
[SB] (PLGui3)
- WidgetWindows: Zentrale Methode GetWindowStyle eingebaut, die anhand des aktuellen Status und der gesetzten Optionen
  (z.B. Fullscreen oder nicht, transparent oder nicht etc.) die richtigen Window-Styles für das Fenster berechnet.
  Immer wenn es nötig ist, werden dann die Styles entsprechend komplett neu gesetzt, anstatt wie bisher einzelne Flags
  hinzuzufügen oder zu entfernen, was extrem leicht durcheinander kommen kann, wenn verschiedene Dinge gleichzeitig
  passieren. Die Methode UpdateWindowStyle() ändert dann die Styles vom Widget und sorgt dafür, dass diese auch
  geupdated werden (SetWindowPos() mit SWP_FRAMECHANGED).
- Neue Message 'InternalMessage' eingebaut, welche von der Gui selbst verwendet werden kann, um interne Nachrichten
  zu verwenden. Diese Nachrichten werden nicht an Widgets oder Modifier weitergegeben und sind nur dafür da, dass
  die Gui intern z.B. Nachrichten verzögern oder interne Aufgaben koordinieren kann.
- Gui: Es wird nun intern das aktuelle MouseOver-Widget gespeichert, indem die OnMouseEnter/OnMouseLeave-Nachrichten
  überwacht werden. Mittels GetMouseOverWidget() kann abgefragt werden, in welchem Widget sich die Maus gerade befindet.
- Gui: Es werden nun OnMouseOver-Messages versendet. Der Unterschied zwischen OnMouseOver und OnMouseEnter/OnMouseLeave
  besteht darin, dass sich OnMouseEnter/OnMouseLeave immer nur auf exakt das Widget beziehen, in dem sich die Maus gerade
  befindet, das bedeutet, dass man z.B. auch dann eine OnMouseLeave-Nachricht erhält, wenn die Maus in ein Child-Widget
  des aktuellen Widgets verschoben wurde. Wenn man aber wissen will, ob sich die Maus im eigenen *oder* in einem
  Child-Widget befindet, sollte man nicht OnMouseEnter/OnMouseLeave verwenden, sondern OnMouseOver. Diese Nachricht
  wird an alle Fenster versendet, deren MouseOver-Status sich gerade verändert hat, also z.B. an alle Fenster, die
  jetzt nicht mehr MouseOver-Status besitzen, und dann an alle, in denen sich jetzt die Maus befindet (auch, wenn die
  Maus in einem ihrer Child-Widgets ist).
- Modifier 'ModMouseOver' entfernt.
- Modifier 'ModBlend' wieder eingebaut und überarbeitet.
- Gui: Beim Löschen von Widgets werden diese nun auch aus allen Listen und Referenzen ausgetragen.



>> 11.06.2010
[SB] (PLGui3)
- Modifier OnClose hinzugefügt. Dieser Modifier reagiert auf das OnClose-Event und kann dann entweder nur das Fenster
  schließen, oder die gesamte Applikation beenden. Diese Funktionalität nun als Modifier von Außen einem Widget
  hinzufügen zu können ist sehr angenehm, weil man damit nun nicht mehr gezwungen ist, für solche simple Dinge eine
  Ableitung zu erstellen oder aber die Basisklasse mit so etwas unnötig aufzublähen.
- OnDraw und OnDrawBackground werden nun unter Windows wieder korrekt aufgerufen.
- Widget: Themed-Drawing funktioniert auch wieder.
- MessageFilter überarbeitet, hier stimmte noch einiges nicht.
- Modifier ModFrameMoveSize an Änderungen angepasst und wieder eingebaut.
- Modifier ModFullscreen hinzugefügt. Dieser Modifier hört auf die Tastenkombination ALT+ENTER und toggelt daraufhin
  den Fullscreen-Mode des Fensters. Auch hier soll dieser Modifier dazu dienen, diese Funktionalität nur bei Bedarf
  hinzufügen zu können, anstatt dies z.B. direkt in Widget oder Frame einbauen zu müssen, wofür es dann wieder ein
  Flag bräuchte, um dies an- oder auszuschalten.
- GuiWindows: Behandlung von MouseEnter und MouseLeave überarbeitet. Dies geht leider nur, indem in GuiWindows noch
  einmal intern ein Zeiger auf das aktuelle Fenster gespeichert wird, da keine direkte MouseIn-Nachricht unter
  Windows zu geben scheint. MouseLeave dagegen gibt es, daher kann dies auch nicht in Gui erledigt werden, sondern
  muss vom Backend behandelt werden, damit es sich überall identisch verhalten kann.
- GuiWindows: Behandlung von case WM_SYSCHAR eingebaut, wobei dies als ganz normaler Tastendruck mit ALT-Modifier
  weitergegeben wird. Auf diese Weise sollte es möglich sein, das möglichst universell für alle System gleich
  zu behandeln, anstatt hier z.B. einen virtuellen Fullsceen-Key zu definieren, der im Backend festgelegt wäre.
- GuiWindows: Weitere Messages überarbeitet, damit funktioniert z.B. Frame offenbar schon wieder, wie es soll.
  Window und Frame reagieren auch beide wieder korrekt auf System-Buttons, auch der Fullscreen-Mode funktioniert
  bei beiden, wobei bei Window entsprechend der Widget-Type angepasst wird.



>> 09.06.2010
[SB] (PLGui3)
- FontManager nach Gui verschoben, damit alle wichtigen Komponenten von Gui in einem Verzeichnis zu finden sind.
- Analog zu z.B. FontManager gibt es nun die Klasse CursorManager, die über Gui erreichbar ist. Ich möchte die Klasse
  Gui möglichst schlank halten, darum lagere ich nun solche Dinge lieber in eigene Manager aus, von denen in Gui eine
  Instanz liegt, als die Methoden wieder direkt in Gui einzubauen.
- Neue Message OnExit eingebaut, welche nun gesendet wird, wenn die GUI beendet werden soll. Die Message-Loop wurde
  ausserdem so angepasst, dass diese Nachricht nicht mehr gesondert behandelt wird, es muss nun auch nicht mehr false
  zurückgegeben werden, sondern die Nachrichten laufen noch so lange durch, bis keine mehr da sind. Damit dürfte die
  Message-Loop wieder etwas einfacher geworden sein, und weniger am typischen Windows-Design angelegt ;-)
- Neue Klasse WidgetFunction eingebaut, welche die virtuellen Methoden für Widget-Events zur Verfügung stellt. Auf
  diese Weise wird es einfacher, Widgets und Modifier zu implementieren, da beide dann von dieser Klassen abgeleitet
  werden und somit neue Nachrichten nur noch an einer Stelle angepasst werden müssen.
- Widget ist nun von WidgetFunction abgeleitet.
- Modifier ist nun von WidgetFunction abgeleitet.
- Modifier wieder eingebaut. Die Modifier haben nun mittels WidgetFunction eigene Methoden, um über Events vom Widget
  unterrichtet zu werden, was es einfacher macht, da Events nur rein informativ funktionieren, man darüber aber keinerlei
  Kontrolle ausüben kann. So kann es dagegen z.B. später Filter geben, welche Nachrichten an Modifier weitergereicht
  werden sollen, oder man kann z.B. die Reihenfolge der Aufrufe manipulieren oder bestimmte Nachrichten für bestimmte
  Modifier ausschalten - all das wird wohl nötig sein, wenn die Modifier später richtig sinnvoll werden sollen.
- Widget: Icon und Cursor wieder hinzugefügt.
- Themes wieder eingebaut.
- Layouts wieder eingebaut.
- Widgets wieder eingebaut.
- GuiApplication wieder eingebaut.
- Widget: Es kann nun im Konstruktor mit angegeben werden, was für einen Basis-Typus das Widget haben soll. Dies ist
  entweder BaseWidget, um wie biser ein reines Widget vom System erzeugen zu lassen, oder BaseWindow, um vom System
  ein Window erzeugen zu lassen, das bereits Titelleiste und Rahmen besitzt. So wird es also in Zukunft möglich sein,
  zumindest für Applikationsfenster "normale" System-Windows zu verwenden anstelle der PLGui-eigenen Frames. Ich möchte
  allerdings nochmals darauf hinweisen, dass dies die *einzige* Stelle bleiben wird, an der Fenstertypen vom System
  verwendet werden - ich werde nicht wieder dahin zurückgehen, "wenn man schonmal angefangen hat", weitere System-Controls
  bzw. Widgets abzukapseln, denn dann wären wir wieder da, wo PLGui1 mal angefangen hatte. Und das war nicht besonders
  sinnvoll, da man dann für die Ingame-Gui sowieso die ganze Arbeit noch einmal machen müsste und sich ausserdem auf die
  Logiken des jeweiligen Systems einstellen müsste, so dass eine plattformunabhängige Abkapselung sehr schwierig wird.
- Gui: Neue Methode SetUseSystemWindows(), mit der festgelegt werden kann, ob die Gui falls vorhanden System-Windows
  verwenden soll oder nicht. Für System-Guis wird dies standardmäßig eingeschaltet sein, für alle anderen aus (obwohl
  das hier auch egal ist, da diese das sowieso nicht unterstützen werden und dann sowieso auf den Basistypus 'Widget'
  zurückfallen müssen).
- Neue Klasse Window für Widgets mit Rahmen und Titelleiste. Diese Klasse wird dann dafür sorgen, die Unterschiede
  auszugleichen, je nachdem welcher Basistypus verwendet wird.



>> 08.06.2010
[SB] (PLGui3)
- Nachrichten überarbeitet (Linux): OnCreate
- Nachrichten überarbeitet (Windows, Linux): OnDestroy
- Gui: Zeiger auf Root-Widget entfernt, da dies nicht und vor allem nicht überall so funktioniert, wie geplant.
  Statt dessen verwaltet Gui nun eine Liste von Top-Level Widgets, also solchen Widgets, die kein Parent-Widget
  haben. Nach dem Beenden der GUI werden automatisch alle Top-Level Widgets gelöscht, wodurch auch alle anderen
  Widgets mit ins Nirvana gezogen werden sollten. Durch die zentrale Verwaltung von Gui-Nachrichten konnte nun
  auch die Methode DestroyWidget() in Gui wieder entfernt werden, es wird also endlich alles wieder einfacher
  und übersichtlicher :-)
- Gui: Da die Systeme hier wieder einmal unterschiedlich arbeiten, musste das Löschen der Widgets nach dem Beenden
  der GUI noch einmal überarbeitet werden. Zunächst wird die Liste aller Top-Level Widgets abgearbeitet, und das
  erste Widget gelöscht. Unter Windows löst dies sofort eine WM_DESTROY-Nachricht aus, wodurch das entsprechende
  Widget aus der Toplevel-Liste ausgetragen wird. Unter Linux dagegen kommt die Destroy-Nachricht weiterhin über
  die Message-Loop, weswegen hier in der Schleife weiter ProcessMessages() aufgerufen werden muss. Dieses wurde
  so verändert, dass es auch dann noch weiterläuft, wenn die Gui bereits beendet wurde. Wenn die Destroy-Nachrichten
  von allen Top-Level Widgets eingegangen sind, und somit die Liste leer ist, geht der Shutdown weiter mit dem Löschen
  der jeweiligen Widget-Objekte.
- Widget: Es gibt jetzt nur noch zwei Konstrukturen, einen für normale Widgets, den anderen, um einen PLGui-Wrapper
  für fremde Widgets zu erzeugen. RootWidget und DesktopWidget wurden erst einmal entfernt und werden später wieder
  eingebaut.
- FontManager, TrayIcon und Clipboard wieder eingebaut.
- Menu und Timer wieder eingebaut.
- Timer sind wieder lauffähig.



>> 07.06.2010
[SB] (PLGui3)
- Widget: Block "Public RTTI get/set functions" entfernt und die darin enthaltenen Methoden wieder bei den
  anderen Methoden einsortiert. Ich finde es nicht sonderlich hilfreich, diese Methoden da herauszureißen und
  in einen eigenen Block zu setzen, insbesondere weil bei größeren Klassen damit die Einordnung der jeweiligen
  Methoden in inhaltliche Blöcke (z.B. "Position", "Aussehen" etc.) nicht mehr möglich ist. Die Methoden werden
  aber nicht nur über das RTTI aufgerufen, sondern sollen gerade nach wie vor auch direkt über das Interface der
  Klasse aufgerufen werden, daher ist es finde ich wichtiger, das inhaltlich zu sortieren als nach "RTTI oder nicht".
- Message-Behandlung von Gui nach Widget verschoben. Widget hat nun auch eine Methode SendMessage(), welche verwendet
  werden kann, um Nachrichten direkt an ein Fenster zu senden, und welche auch von Gui::SendMessage() aufgerufen wird.
  Von dort werden die Nachrichten an OnMessage() weitergegeben, wo sie vom Widget behandelt werden, dort werden dann
  die entsprechenden virtuellen Funktionen aufgerufen.
- Widget: Die virtuellen OnXYZ()-Methoden sind nun in der Basisklasse leer und können daher frei überschrieben werden.
  Da die Message-Behandlung nun immer zunächst über OnMessage() läuft, werden bereits dort die Events ausgelöst, so
  dass es auch nicht mehr nötig ist, in abgeleiteten Klassen immer die Basis-Implementierung einer Methode aufzurufen.
  Nur für den Fall, dass OnMessage() selbst überschrieben wird, ist dies natürlich immer noch nötig, dies sollte man
  aber sowieso nur tun, wenn man ganz genau weiß, was man da tut - normaler Weise sollte es ausreichen, die virtuellen
  Methoden für das jeweilige Event zu überschreiben.
- MessageFilter wieder eingebaut.
- GuiLinux und WidgetLinux: Wie im Windows-Port werden die System-Nachrichten nun alle einheitlich von Gui behandelt,
  und nicht mehr von Widget. Ausserdem im Linux-Port alles auf Verwendung von GuiMessage umgestellt.
- GuiImpl: Neue Methode PostMessage() hinzugefügt, welche von den System-Backends so implementiert werden muss, dass
  eine PLGui-Nachricht wieder in eine Systemnachricht umgewandelt und in die jeweilige Message-Queue geschickt wird.
  Zur Zeit ist dies für Windows und Linux noch nicht implementiert.
- Widget: SendMessage() wieder entfernt, da diese Methode im Grunde überflüssig ist und sowieso nur die Nachricht
  an OnMessage() weitergibt. Ausserdem wäre es auch nicht gut, wenn direkt OnMessage() von einem Widget aufgerufen
  würde, da in diesem Falle z.B. die MessageFilter übergangen würden, es sollte daher sowieso immer Gui::SendMessage()
  aufgerufen werden. Daher kann diese Methode auch entfallen und damit dieses Problem von vornherein ausgeschlossen werden.
- Image, Graphics und Font wieder eingebaut.



>> 06.06.2010
[SB] (PLGui3)
- Noch einmal mit einem Refactoring der Gui-Basisklassen, damit die Probleme insbesondere bei der Portierung
  auf andere Systeme besser angegangen werden können. Anstatt wie bisher möglichst viel in den System-Backends
  zu behandeln, und von dort Methoden aus Gui oder Widgets aufzurufen, sollen die System-Backends so umgebaut
  werden, dass sie möglichst wenig an Aufgaben selbst übernehmen. Statt dessen sollen hier möglichst nur noch
  die systemspezifischen Nachrichten in plattform-unabhängige PLGui-Nachrichten umgewandelt werden, welche dann
  von Widget selbst, also identisch für alle Plattformen, behandelt werden können. Dies soll dabei helfen, die
  vielen kleine Unterschiede zwischen den Systemen besser abfangen zu können, ohne dass es wie jetzt in einem
  Spaghetti-Code ändert, weil Backends die PLGui-Klassen aufrufen, welches dann wieder die Backends aufrufen...
- Alles bis auf Gui und Widget und einige wenige weitere Klassen entfernt bzw. deaktiviert.
- GuiWindows und WidgetWindows: Die System-Nachrichten werden nun alle einheitlich von GuiWindows behandelt und
  nicht mehr an WidgetWindows weitergereicht. GuiWindows wird damit zentraler Punkt für den Windows-Port, während
  WidgetWindows deutlich kleiner und übersichtlicher wird.
- GuiWindows: Der Zeiger auf das WidgetWindows-Objekt für ein Fenster wird nun so früh wie möglich gesetzt, nämlich
  noch während der Behandlung von WM_CREATE, so dass der Zeiger für alle weiteren Nachrichten dann bereits zur
  Verfügung steht (bisher wurden die ersten Nachrichten unbemerkt verworfen, was einige Probleme erklären könnte,
  da es sich hierbei um initiale WM_MOVE- und WM_SIZE-Nachrichten handelt).



>> 04.06.2010
[SB] (PLGui3)
- Umstellung von PLGui3 auf das neue RTTI, das Projekt lässt sich nun zumindest schonmal wieder übersetzen.



>> 05.04.2010
[CO]
- ClassView: Farben sind nicht mehr auf [0...1] beschränkt, z.B. bei HDR sind durchaus auch Werte außerhalb dieses Bereiches gültig
  (... ja, auch negative, sieht lustig aus *g*)



>> 14.03.2010
[CO]
- An die Änderungen des Konfigurations-Systems angepasst
- ConfigView bekommt nun eine Konfigurations-Instanz übergeben
- "GuiApplication::OnInit()" läd eine Konfiguration mit den Namen der Anwendung, "GuiApplication::OnDeInit()" speichert
  die Konfiguration unter dem Namen der Anwendung. Damit landen automatisch alle Einstellbaren Dinge in z.B.
  "PL triangle sample.cfg" wenn der Name der Anwendung "PL triangle sample" ist. Von "GuiApplication" abgeleitete Klassen
  müssen sich daher um das Laden und Speichern der Anwendungs-Konfiguration nicht mehr kümmern + wenn alles in einer
  Konfigurations-Datei ist, ist das irgendwie übersichtlicher und praktischer. Z.B. kann man so sehr schnell sich mal
  Einstellungen wegkopieren oder wiederherstellen. Jede Anwendung hat des weiteren nun also automatisch seine eigene Konfigurations-
  Datei.



>> 01.02.2010
[SB] (PLGui3)
- WidgetWindows: Fehler behoben: WM_CREATE wurde niemals an das Widget weitergeleitet, da vergessen wurde,
  das Widget-Objekt als Parameter an CreateWindowEx() zu übergeben.
- Gui: Jedes Widget erhält nun beim OnCreate-Event einen Namen, der sich aus dem Namen der Klasse und einer
  fortlaufenden Nummer zusammensetzt. Daraus ergeben sich zunächst einmal eindeutige Namen für alle Widgets,
  allerdings ist zu beachten, dass die Namen per Design nicht eindeutig sein müssen - wenn der Programmierer also
  eigenständig Namen vergibt, kann es sein, dass damit die Namen von Widgets nicht mehr eindeutig sind.
  Wenn ein Widget bereits im Konstruktor einen Namen gesetzt bekommen hat, wird dieser beibehalten und kein
  automatisch generierter Name mehr gesetzt.
- Neue Klasse: MessageFilter. Dies ist eine Basisklasse, die dazu dient, GUI-Nachrichten abzufangen und optional
  auch noch zu filtern. Dazu kann so ein MessageFilter bei der GUI angemeldet werden und bekommt dann alle Nachrichten
  übermittelt, die seinem Filter entsprechen. Welche Nachrichten durchgelassen und welche Gefiltert werden, kann über
  rules definiert werden, die dem Filter hinzugefügt werden (Klasse MessageFilterRule).
- Neue Klasse: MessageFilterDebug eingebaut, welche alle Nachrichten fürs Debuggen auf der Konsole ausgibt.



>> 31.01.2010
[SB] (PLGui3)
- Widget: GetDescriptor() eingebaut. Diese Methode ist hauptsächlich fürs Debugging gedacht und versucht,
  einen lesbaren Namen für ein Widget zurückzugeben. Dies ist entweder der Name des Widget, falls einer
  gesetzt wurde, oder die ID oder als letzte Möglichkeit das Window-Handle.



>> 30.01.2010
[SB] (PLGui3)
- Gui: Interne Behandlung von Messages eingebaut. Vieles, was bisher direkt in den Backend-Klassen war, ist nun
  bestandteil von Gui und somit auf jedem System identisch. Auch können nun einige Methoden und Variablen aus
  dem Backend entfernt werden, die nun direkt in Gui verwaltet werden (z.B. MouseOver-Status etc.)
- WidgetWindows: Message-Behandlung auf PLGui-Messages umgestellt.
- Widget: Event OnCreate hinzugefügt
- GuiMessage: Alle Messages heißen nun MessageOnXYZ, die statischen Konstruktoren heißen analog dazu GuiMessage::OnXYZ.



>> 28.01.2010
[SB] (PLGui3)
- Widget: OnFullscreen() wieder in zwei Events aufgesplittet, da dies irgendwie netter zu verwenden ist.
- Widget: OnUserMessage(): Parameter in uint32 und void* geändert. Da ein Pointer ja auch wieder nur ein
  uint32 (bzw. 64) ist, lässt sich dies weiterhin wie bisher verwenden, der Standardfall scheint mir aber
  meist zu sein, ein Datenwert und optional noch einen Zeiger zu übergeben.
- Widget: Einige Events umbenannt und verschoben, um es etwas einheitlicher zu gestalten.
- Neue Klasse GuiMessage erstellt, die GUI-Nachrichten bzw. Events abkapselt. Ab sofort wird es ein eigenes
  Message-System direkt in PLGui geben, über das alle Events verwaltet werden. Dies wird deutliche Änderungen
  vor allem im Bereich der Backends bedeuten, was auch so gewollt ist, denn insbesondere bei den Backends geht
  mir bisher noch vieles etwas zu sehr durcheinander. Das Problem ist, dass es bisher kein fest definiertes
  Interface gibt, über das Backends mit der GUI und den Widgets kommunizieren. Statt dessen ruft jedes Backend
  selbständig z.B. die Event-Funktionen von Widgets auf und verwaltet auch intern noch einige States, wenn dies
  erforderlich scheint. Das alles führt dazu, dass sich Backends nicht identisch verhalten, was wiederum sehr
  problematisch wird, da man sich dann in einem Widget z.B. nicht darauf verlassen kann, dass Nachrichten in einer
  bestimmten Reihenfolge kommen oder sich bestimmte Funktionsaufrufe auf allen Systemen möglichst identisch verhalten.
  Das Problem wird zwar nicht komplett zu lösen sein, aber ich hoffe, dass eine eigene Nachrichtenverwaltung hier eine
  große Hilfe sein wird, da ein Backend dann möglichst nur noch Systemnachrichten in PLGui-Nachrichten umwandelt sollte,
  während versteckte Funktionalitäten dann in der systemunabhängigen Gui-Klasse implementiert werden und sich somit für
  alle Backends identisch verhalten.



>> 21.01.2010
[SB] (PLGui3)
- Frame: Die kleine Lücke unter der Titelleiste lag nicht am Layout, sondern daran, dass die Titelleiste nicht
  vollständig gefüllt wurde. Das wurde nun behoben.
- Win32: Fenster können nun wieder transparent gegenüber ihrem Parent-Widget sein. Damit dies funktioniert, wurde
  das Flag WS_CLIPCHILDREN für alle Windows entfernt, da ansonsten ja der Hintergrund an der Stelle vom Parent-Window
  nicht gezeichnet würde.
- Win32: GraphicsWindows::DrawBox() kann nun auch transparente Farben, wofür GDI+ verwendet wird (wie auch schon bei
  den Farbverläufen). In diesem Falle sind allerdings keine abgerundeten Ecken möglich, weshalb ich dafür wäre,
  die Funktion aufzusplitten, damit man das zumindest in den Kommentaren vernünftig vermerken kann.



>> 15.01.2010
[SB] (PLGui3)
- ScrollBar repariert. Da war ich wohl schon zu müde, auf jeden Fall waren die Berechnungen für die ScrollBar
  fehlerhaft. Beim Slider war mir das gleich wesentlich besser gelungen, habe daher die Implementation von dort
  übernommen und für die ScrollBar angepasst.
- Neues Widget: ScrollWidget, ein Container, dessen Inhalt sich über eingeblendete ScrollBars verschieben lässt.
  Es kann auch festgelegt werden, welche ScrollBar wann angezeigt werden soll.



>> 14.01.2010
[SB] (PLGui3)
- Ordner-Struktur für Widgets erstellt. Die Widgets sind nun grob nach Typ sortiert, was mir bisher auch sehr übersichtlich
  erscheint. Zu detailliert sollte die Ordnung zwar auch nicht werden, da man dann meistens Klassen nicht mehr findet, wenn
  man nicht den genauen Namen kennt, aber so scheint es mir ganz sinnvoll. Wenn alle Klassen auf einem Haufen sind,
  findet man leider auch nichts mehr, und so sind z.B. die Basisklassen schnell und einfach zu identifizieren.
- Theme: Interface wurde überarbeitet, die virtuellen Methoden sind nun direkt public und nicht mehr mit Prefix 'On'.
  Methoden zum Zeichnen von Rahmen hinzugefügt.
- Neues Widget: Border. Dieses Widget zeigt einen Rahmen um seinen Inhalt herum an.
- ModFrameMoveSize: Der Cursor wird jetzt auch zurückgesetzt, wenn die Maus das Widget verlässt. Bisher blieb manchmal
  ein alter Mauscursor zurück, hoffe dass dies das Problem behebt.
- SizeHint: Die Größe wird nun intern als statt als int gespeichert, damit man per Prozentwerten nicht auf 1%-Schritte
  begrenzt ist. Nach aussen hin verhält sich die Klasse aber genauso wie vorher, es wird also immer ein auf uint32 gecasteter
  Wert zurückgegeben, es sei denn man ruft direkt die neuen GetFloat()/SetFloat()-Methoden auf, was nur im Falle von
  Prozentwerten sinnvoll ist.
- Neues Widget: Splitter. Der Splitter teilt ein Fenster in zwei Unterfenster mit einem kleinen Rahmen dazwischen,
  entweder horizontal oder vertikal. Wenn gewünscht, kann die Größe vom User geändert werden. Die Größenverteilung
  geschieht wieder über die schon bekannten SizeHints und erlaubt dabei recht flexible Einstellungen, so kann man
  entweder feste Werte einstellen oder auch PRozentwerte in Bezug auf die Gesamtgröße des Splitters. Auch kann so
  festgelegt werden, dass entweder die linke oder die rechte Seite eine feste Größe hat, während die andere Seite dann
  den Rest des Platzes erhält.
- Neues Widget: Bitmap. Das Widget zeigt ein statisches Bild an. Wow, dieses Widget hätte ich total vergessen, hätte
  ich nicht gerade das ScrollWidget mit einem großen Bild testen wollen :-)



>> 13.01.2010
[SB] (PLGui3)
- Alle Widgets: DEFINE_CONSTRUCTION_PUBLIC für alle Widgets ausser den abstrakten Basisklassen eingebaut (und aus
  letzteren dafür falls vorhanden ausgebaut).
- Neues Widget: AbstractSlider eingebaut für alle Widgets, mit denen man eine Zahl auswählen/einstellen kann.
- Neues Widget: ScrollBar eingebaut und entsprechenden ThemePainter implementiert. Auch hierfür gibt es wieder
  eine eigene ThemePainter-Basisklasse, damit das Theme kontrolle über alles mögliche bekommt, was ansonsten fest
  im Widget eingebaut werden müsste.
- ScrollBar vollständig implementiert.
- ThemePLDefault: Images für 'left', 'right', 'up' und 'down' eingebaut, die man wohl häufiger brauchen wird.
- Slider ebenfalls implementiert.



>> 12.01.2010
[SB] (PLGui3)
- ThemePainter_Menu: Vernünftiges Interface erstellt, das vom AbstractMenu aus aufgerufen wird, um ein Menu zu malen.
- AbstractMenu: Das Zeichen des Menus sieht nun wieder ganz vernünftig aus. Grundliegende Funktionalität für das Auswählen
  von Items und das Öffnen von Submenus implementiert.
- AbstractMenu: Ping-Pong für das Öffnen von Menüs am Bildschirmrand implementiert ;-)
- Windows: Beim Aktivieren von Windows wird nun darauf geachtet, ob diese den Focus akzeptieren oder nicht. Zuvor
  konnten TopLevel-Windows dennoch den Fokus bekommen, auch wenn sie auf NoFocus gesetzt waren, da Windows einfach
  den Fokus setzt, ohne zuvor zu fragen.
- AbstractMenu: Menus vollständig implementiert. Das Verhalten ist nicht 100%ig identisch zu dem, was ich mir bei
  VisualStudio abgeschaut habe, aber ich bin mir fast sicher, dass dies auch in unterschiedlichen Windows-Programmen
  nicht 100%ig identisch ist (man braucht ja nur mal zu schauen, wie sich die optik von Widgets teilweise im gleichen
  Programm schon unterscheidet). Also ich hoffe, das ist so brauchbar und es sind keine zu bösen Bugs drin :-)
- AbstractMenu: Keyboard-Shortcuts implementiert.
- AbstractMenu: Zeichnen von Separatoren eingebaut.
- MenuItem und Menu: Interfaces noch etwas überarbeitet und verschönert. Es gibt nun ausserdem die Möglichkeit, Items
  so hinzuzufügen, dass sie nicht automatisch gelöscht werden. Dies ist notwendig, wenn man bspw. Menus rekursiv ineinander
  einfügen möchte (was gerade zum Testen enorm praktisch ist, da man so große Menustrukturen simulieren kann).



>> 11.01.2010
[SB] (PLGui3)
- Widget: Layout und ThemePainter sind nun keine Modifier mehr, sondern unabhängige Klassen. So ist es leichter,
  die Objekte zu kontrollieren, weil die Methoden nun direkt aufgerufen werden und nicht mehr über ein Callback,
  welches sich von der Widget-Klasse aus nicht kontrollieren lässt. Die Modifier-Idee ist zwar nett, sollte aber
  denke ich nur für "lose" Zusatzfunktionalität verwendet werden. Für Basisfunktionalität scheint es besser zu
  sein, bei eigenen, spezialisierten Klassen zu bleiben, die dann auch gesondert behandelt werden können, während
  bei Modifiern alles "über einen Kamm geschert" werden muss.
- Im Falle des Menus gibt es nun eine erste spezialisierte ThemePainter-Klasse: ThemePainter_Menu.
  Diese Klasse erweitert ThemePainter um einige Menu-spezifische Methoden, die vom Widget selbst verwendet
  werden (beispielsweise um die Größe eines Items auszurechnen, da dies natürlich sehr vom Theme abhängt).
  Ein Theme muss in diesem Falle also von dieser Klasse ableiten, was aber eigentlich kein Problem darstellen
  sollte. Wenn das Konzept so aufgeht, dürfte das eine einfache Methode sein, um weitere Funktionalität (neben
  den reinen Paint-Methoden) in die Themes auszulagern.



>> 10.01.2010
[SB] (PLGui3)
- Klassen für Anzeige von Menüs erstellt: AbstractMenu, MenuBar und PopupMenu.
- Daten-Klassen Menu, MenuItem und MenuSeparator überarbeitet.



>> 09.01.2010
[SB] (PLGui3)
- TabBarEntry: Zu jedem Tab können nun ein Widget-Pointer und ein beliebiger Data-Pointer gesetzt werden. Dies wird
  von der TabBar selber nicht verwendet und ist dazu da, um Userdaten an einen Tab zu hängen. TabContainer verwendet
  den Widget-Pointer dann dazu, das entsprechende Fenster anzuzeigen.
- TabBarButton: OnMouseEnter auch hier so implementiert, dass der aktuelle Tab ausgewählt bleibt.
- WindowContainer: Methoden für das Auswählen und Abfragen des aktuell angezeigten Fensters hinzugefügt etc.
- TabBar: Neue Events für CreateTab und CloseTab hinzugefügt. Dies sind vom User ausgelöste Events (z.B. durch Klick
  auf die entsprechenden Buttons) und sind nur dazu da, von übergeordneten Programmteilen aufgefangen und entsprechend
  implementiert zu werden. Solange dies nicht geschieht, werden nicht automatisch Tabs hinzugefügt oder gelöscht.
  TabContainer implementiert dies bereits entsprechend, so dass das OnClose-Event abgefangen wird und dann das
  entsprechende Fenster sowie der dazugehörige Tab geschlossen werden. Das OnCreate-Event wird hier durch TabContainer
  nur weiter durchgereicht, so kann das dazugehörige Fenster oder ein anderer Programmteil das entsprechen nutzen,
  um z.B. ein Window in den TabContainer einzufügen.
- TabContainer fertiggestellt. Bestimmt kann man da noch einiges einfacher machen, im Moment gehen mir noch zu viele
  Events hin und her, und ganz sicher werden zu oft SetSelection() von TabBar und TabContainer aufgerufen etc. Das
  kann man aber später noch optimieren, jetzt möchte ich erst einmal mit den wichtigsten Widgets fertig werden und
  damit ein brauchbares Gui-Toolkit haben, danach werde ich nochmal an die Optimierung/Überarbeitung gehen.



>> 08.01.2010
[SB] (PLGui3)
- WidgetWindows: Nach jedem MouseButtonUp() wird nun auch noch ein MouseButtonClick() gesendet. Hier müsste man nochmal
  genau schauen, wie das am besten ist, also was als Click gewertet werden sollte und was nicht.
- Neues Widget: TabBar eingebaut. Die TabBar ist dieses Mal nur das reine Widget, also nur die Bar und nicht die
  dazugehörigen Container-Windows. Das wird später in einem zusammengesetzten Widget implementiert werden (mit einer
  entsprechenden Basisklasse für Window-Container). Das Aussehen der TabBar habe ich aus meinem vorherigen PLGui3-Test
  entnommen und entsprechend im Theme implementiert. Im Gegensatz zum letzten Test, habe ich der Einfachheit halber
  wieder auf Child-Widgets zurückgegriffen, um die TabBar zu implementieren (Klasse TabBarEntry), anstatt wieder eine
  eigene SubWidget-Verwaltung zu schreiben, die letztlich wieder so komplex wird, dann man im Grunde das ganze Widget-System
  noch einmal dupliziert hat.
- TabBar: Einige neue Optionen eingebaut. So kann nun festgelegt werden, für welche Seite die TabBar bestimmt ist
  (links, rechts, oben, unten). Das Theme könnte dann hier eine Unterscheidung machen und die Tabs entsprechend mit
  einer offenen Seite zeichnen, was allerdings im aktuellen Theme nicht passiert, da die Tabs einfach komplett geschlossen
  sind. Die TabBar selbst ordnet ihre Tabs entsprechend dieser Einstellung entweder horizontal oder vertikal an.
  Weitere Einstellungen geben an, ob der User neue Tabs hinzufügen oder Tabs schliessen darf, dies ist zur Zeit aber
  noch nicht implementiert. Ausserdem kann die Größe der Tabs nun festgelegt werden.
- TabBar: Event für die Ereignisse SelectTab, CloseTab und CreateTab eingebaut.
- TabBar: Anzeige von Tabs dynamischer Größe implementiert.
- TabBar: Buttons für 'Close', 'Add', 'Scroll (prev)' und 'Scroll (next)' eingebaut und alles nötig dafür implementiert.
  Die TabBar ist zwar sicher noch nicht besonders hübsch, hat aber dafür nun hoffentlich schon eine ganze Menge mehr
  Funktionalität als in PLGui2 :-)
- Image: Bug behoben. IsEmpty() gab immer false zurück, da immer eine Image-Implentation erzeugt wurde, auch wenn kein
  Bild zu laden war. Auch wurde noch nicht immer darauf geprüft, ob die m_pImageImpl gültig ist oder nicht.
- TabBar: Zusätzlich zum Text kann jeder Tab nun auch noch ein Icon haben. Die Größenberechnungen wurden alle so
  angepasst, dass der zusätzliche Platz für das Icon mit einberechnet wird.
- Neue Klasse: WindowContainer. Dies ist die Basisklasse für Container, die das Umschalten zwischen verschiedenen
  Fenstern ermöglichen. Eine erste Implementation ist der TabContainer, der eine TabBar anzeigt und je nach ausgewählten
  Tab das entsprechende Fenster anzeigt.



>> 06.01.2010
[SB] (PLGui3)
- Label: OnPreferredSize() setzt nun bei der gewünschten auch dann den X-Wert korrekt, wenn -1 in RefSize übergeben
  wurde. Bisher wurde hier zwar dann eine unendlich lange Zeile angenommen, aber nicht zurückgegeben, wie groß die
  Zeile im Optimalfall sein müsste, statt dessen wurde einfach wieder -1 zurückgegeben.
- Gui: Tooltips implementiert. In der Gui gibt es dafür eine Methode DisplayTooltip(), um einen Tooltip anzuzeigen.
  Ausserdem kann die Zeit für den Timeout festgelegt werden. Die Funktion achtet darauf, dass ein Tooltip für das
  gleiche Widget nur einmal angezeigt wird, danach werden weitere Aufrufe ignoriert, bis einmal der Tooltip für
  ein anderes Widget angezeigt wurde. Wenn man manuell auf jeden Fall einen Tooltip anzeigen will, kann hier NULL
  übergeben werden.
- Neue Klasse TooltipData eingebaut. Diese Klasse kann dafür verwendet werden, um beliebige weitere Daten für den
  Tooltip zu hinterlegen, die dann von erweiterten Tooltip-Klassen verwendet werden können. Die Klasse selbst ist nur
  eine leere Basisklasse und dient zur Ableitung von erweiterten Klassen, die dann die zusätzlichen Daten zur
  Verfügung stellen.
- Widget: Methoden zum Setzen des Tooltips erweitert. Neben dem Tooltip-Text können nun auch weitere Daten mittels
  der Klasse TooltipData für den Tooltip hinterlegt werden. Wenn der Tooltip für ein Widget gesetzt wird, wird
  automatisch ein ModTooltip-Modifier zum Widget hinzugefügt, der für die Anzeige des Tooltips sorgt.
- Theme: Neue virtuelle Methode CreateTooltip() hinzugefügt. Ein Theme ist damit in der Lage zu bestimmen, was für
  ein Widget als Tooltip erzeugt wird. Im Standardverhalten ist dies zunächst die Klasse Tooltip, ein Theme kann
  jedoch diese Methode überschreiben und eine beliebige andere von AbstractTooltip abgeleitete Klasse erzeugen.
  Diese Klasse könnte dann z.B. eine dazugehörige abgeleitete Klasse von TooltipData verwenden, um weitere Daten
  neben dem Tooltip-Text anzuzeigen (z.B. ein Bild oder beliebige andere Dinge). Damit sind Tooltips vollkommen
  flexibel und können beliebig erweitert werden.
- PLDefault-Theme: ThemePainter für Tooltip-Widget eingebaut.



>> 05.01.2010
[SB] (PLGui3)
- Neue Klasse ClipBoard mit Backend-Klasse und Backends für Windows und Linux eingebaut. Unter Windows wurde die
  Klasse soweit implementiert, dass Text ins ClipBoard geschrieben und von dort gelesen werden kann.
- Widget: Neues Event OnMouseHover eingebaut. Wenn die Maus eine bestimmte Zeit lang über einem Widget stand,
  wird dieses Event ausgelöst.
- Gui: Implementierung des OnHover-Events durch Erweiterung der SetMouseOverWidget()-Funktion. Solange ein Backend
  regelmäßig und wahrheitsgemäß über das aktuell selektierte Widget berichtet, sollte nun also die Hover-Funktionalität
  von der Gui selbst korrekt gehandhabt werden. Zusätzlich kann noch die Zeitspanne, nach der ein Hover-Event
  ausgelöst werden soll, in der Gui abgefragt oder eingestellt werden. Der Standardwert liegt bei 1 sek.
- Gui: Jetzt kommt doch der erste 'Hack' in die Mainloop, leider weiß ich aber nicht, wie man es besser lösen könnte.
  SetMouseOverWidget() wurde so erweitert, dass ein Aufruf von SetMouseOverWidget(NULL) nicht sofort ausgeführt wird,
  sondern statt dessen nur ein Flag gesetzt wird. Wenn dann später, aber noch während des gleichen Aufrufs von
  ProcessMessages() ein anderes Fenster zum MouseOver-Widget wird, wird dieses Event komplett vergessen. Ansonsten wird
  nach dem Ende von ProcessMessages() das MouseOver-Widget auf NULL gesetzt und alle entsprechenden Events werden
  ausgelöst. Dies ist notwendig, da ansonsten bei jedem Leave-Event erst einmal das MouseOver-Window auf NULL gesetzt
  wird, obwohl dies nicht korrekt ist, da zwar ein Fenster verlassen aber dafür das nächste betreten wurde. Man kann
  aber leider auch nicht einfach die Leave-Messages ignorieren, da man dann nicht mitbekommen würde, wenn ein
  TopLevel-Window verlassen wird, denn da gibt es nur noch ein Leave-Event, aber kein Enter- oder MouseMove-Event
  in einem anderen Window, da dieses nicht mehr zu eigenen Applikation gehört. Diese Lösung ist zwar nicht schön, sollte
  aber erstmal funktionieren (und hoffentlich keine zu großen Probleme verursachen).
- Modifier: ModMouseOver implementiert. Dieser Modifier stellt ein einfaches Event dafür zur Verfügung, um zu Tracken,
  wann sich die Maus im eigenen Fenster befindet oder dieses verlässt, wobei hier auch alle Child-Windows eingeschlossen
  werden (dies ist bei den Event 'MouseEnter' und 'MouseLeave' nicht der Fall). Da diese Funktionalität wohl eher
  selten benötigt wird, sollte ein Modifier hier das richtige Werkzeug sein, wenn man es noch mal braucht.
- Gui: Hover-Timer so überarbeitet, dass immer nur 10ms gewartet wird, und dann hochgezählt wird, um den eigentlichen
  Timeout zu erreichen. Wenn einfach so Sleep verwendet wird, führt dies zu einer deutlichen Verzögerung jedes Mal,
  wenn der Thread aufgerufen wird, was ich sehr seltsam finde. Hoffe, dass dies nicht zu einem generellen Problem
  mit den Timern wird...
- ModTooltip implementiert. Dieser Modifier zeigt für ein Fenster einen Tooltip an.



>> 04.01.2010
[SB] (PLGui3)
- DataObject: Liste von Dateinamen als Typ 'DataFiles' und 'DataEmpty' für den leeren Zustand hinzugefügt.
- Widget: Neues Event OnDrop() für Drag&Drop eingebaut. Das Event bekommt ein DataObject übergeben, in dem
  die eigentlichen Daten übermittelt werden. Anhand des Typs lässt sich feststellen, was für Daten übermittelt
  werden, daher gibt es nun kein getrennten DropFiles-Event mehr, sondern es wird einheitlich die gleiche
  Methode für alle Drag&Drop-Events verwendet. Im Windows-Backend wurde wieder WM_DROPFILES implementiert,
  so dass man schonmal Dateilisten per Drag&Drop übermitteln kann.
- ContainerWidget: In der Basisklasse wird nun erstmal das ContentWindow auf die gesamte Größe des Containers gesetzt.
  Abgeleitete Klassen wie Frame können dieses Verhalten dann anpassen.
- Widget: UpdateLayout() und AdjustContent() (im ContainerWidget) wurden zusammengefasst, da beide Events dem gleichen
  Zweck dienen, nämlich den Inhalt des Fensters an die aktuelle Größe anzupassen. Es gibt daher nun nur noch ein
  Event AdjustContent() in Widget, welches sowohl von den Layouts verwendet wird, als auch in der Ableitung von
  ContainerWidget, um das Content-Widget der Größe des Fensters anzupassen. Ich denke, so ist das einfacher zu durchschauen
  und auch zu verwalten, da als nächstes versucht werden muss, auf alle Events, die eventuell die Neuausrichtung des
  Contents zur Folge haben könnten, entsprechend abzufangen. Da ist es besser, wenn man das nur einmal machen muss :-)
- Widget: Events UpdateWidget() und UpdateChildWidget(), sowie die Funktion UpdateWidget() eingebaut. Diese muss aufgerufen
  werden, sobald die Eigenschaften eines Widgets so verändert wurden, dass sich die Größe des Widgets geändert
  haben könnte (beispielsweise, wenn ein Text verändert wurde, ändert sich mit ziemlicher Sicherheit auch die Größe
  des Widgets). Das Event wird dann verwendet, um AdjustContent() auf dem Parent-Widget aufzurufen, damit das Layout
  entsprechend angepasst werden kann.
- LayoutHints: Event Update() eingebaut, das ausgelöst wird, wenn die Einstellungen der LayoutHints geändert wurden.
  Dies wird vom jeweiligen Widget abgefangen und führt zum Aufruf von UpdateWidget(), wieder damit das Layout geupdated
  werden kann.
- Label: Verwendung von UpdateWidget() eingebaut, damit passt sich nun das Label in der Größe automatisch an, wenn
  z.B. der Text verändert wurde, was wiederum zur Neuberechnung des Layouts führt.
- Widget: Default-Titel eines Widget ist nun "No Title", das wirkt denke ich professioneller, als wenn da gar nichts steht.
- Widget: Neben dem Namen gibt es nun auch noch eine ID für jedes Widget. Diese ist ebenfalls rein optional, kann aber
  z.B. benutzt werden, um zu identifizieren, welcher Button gedrückt wurde o.ä.
- Frame: Option 'Resizable' hinzugefügt, damit kann festgelegt werden, ob der User die Größe des Frame verändern kann oder nicht.
- Frame: MinSize und MaxSize hinzugefügt. Diese Werte legen fest, wie groß oder klein der Frame beim Resizen gemacht werden
  darf, spielt aber ansonsten keine Rolle (bei einem manuellen SetSize() würden diese Werte nicht überprüft werden!).
- Basisklasse Dialog eingebaut.
- Frame: Wenn das Fenster geschlossen wird (OnClose()), wird es nun standardmäßig gelöscht.
- ContainerWidget, Frame: Es wird nun ein Default-Layout gesetzt.
- MessageBox implementiert.
- Frame: Es kann jetzt festgelegt werden, welche von dem System-Buttons angezeigt werden sollen und welche nicht.
  Bei Frames werden standardmäßig alle System-Buttons angezeigt, bei Dialogen der 'Schliessen'-Button.



>> 03.01.2010
[SB] (PLGui3)
- Gui: Funktion DestroyWidget() eingebaut, die wiederum vom Backend aufgerufen werden muss, sobald ein Widget zerstört
  wurde. Die Funktion sorgt dann dafür, dass das Widget überall ausgetragen wird und setzt es dann auf die Liste der
  zerstörten Widgets. Das Widget selber bleibt also noch zumindest für einen Durchgang erhalten und wird dann beim
  nächsten Aufruf von GetMessage() endgültig gelöscht.
- Widget: Event OnRemoveWidget hinzugefügt und implementiert, damit z.B. das Layout angepasst wird, wenn ein Widget entfernt wurde.
- LinuxWidget: Löschen von Widgets korrigiert, Behandlung von DestroyNotify eingebaut.
- ContainerWidget: Funktion AdjustContent() hinzugefügt, damit dies auch von aussen aufgerufen werden kann.
- Frame: Funktion Get/SetShowBorder() und Get/SetShowTitleBar() eingebaut, mit denen bei einem Frame die Anzeige von
  Rahmen und Titelleiste ein- und ausgeschaltet werden können. Intern wird dies verwendet, wenn ein Frame auf Fullscreen
  gesetzt wird, es kann aber auch manuell aufgerufen werden.
- WidgetHandler wieder eingebaut (SmartPointer für Widgets).
- Neue Klasse DataObject eingebaut. Diese Klasse ist ein reiner Speicher für Daten verschiedenen Typs, z.B. Strings,
  Values/IDs oder Binärdaten und soll verwendet werden, um Daten innerhalb der Gui zu übermitteln, bspw. durch Drag&Drop
  oder durch Verwendung des Clipboards.



>> 02.01.2010
[SB] (PLGui3)
- Test für MouseEnter/MouseLeave implementiert, um die Unterschiede im Verhalten zwischen Windows und Linux
  besser erkennen zu können.
- Gui: Funktionen eingebaut, um das aktuelle MouseOver-Widget abzufragen und zu setzen (Letzteres nur für Backends).
  Auf diese Weise soll garantiert werden, dass das Verhalten auf allen Systemen identisch ist, denn auch hier kann
  es wieder feine unterschiede geben (bspw., ob es ein MouseLeave-Event gibt, wenn ein Child-Widget des aktuellen
  Widgets betreten wird). Backends sollten also nun diese Funktion verwenden und nicht mehr selber OnEnter/OnLeave
  Nachrichten versenden.
- Widget: Funktion SetCaptureMouseOver(bool) eingebaut. Ein Widget kann diese Funktion verwenden, um darüber informiert
  zu werden, welches Widget gerade von der Maus selektiert wird. Dies bekommt es dann über das Event OnMouseOver
  mitgeteilt. Normaler Weise sollten die OnEnter()/OnLeave()-Nachrichten ausreichen, allerdings schliessen diese nur
  das eigene Widget, nicht aber Child-Widgets mit ein. Wenn man also genau wissen will, ob die Maus gerade das eigene
  Widget inklusiver aller Child-Widgets selektiert hat, sollte dafür diese neue Funktion verwendet werden (natürlich kann
  dies auch dafür verwendet werden, um völlig andere Widgets zu 'überwachen').
- GuiWindows: MouseOver-Widget entfernt, da dies nun bereits in Gui selbst geschieht.
- Gui: AddWidget() und RemoveWidget() hinzugefügt, allerdings noch nicht implementiert. Im Destruktor von Widget wird
  jedoch bereits RemoveWidget() aufgerufen, was dazu benutzt wird, um Widgets, die sich noch in irgendwelchen Listen
  befinden, dort rechtzeitig wieder auszutragen, wenn ein Widget gelöscht wurde.
- ModBlend: Umgestellt auf OnMouseOver(), dadurch blendet das Fenster nun wie gewünscht ein, wenn das Widget selber
  oder eines seiner Child-Widgets ausgewählt ist.



>> 01.01.2010
[SB] (PLGui3)
- Widget: Neues Event OnMousePosUpdate() eingebaut. Dieses Event ist notwendig, um anzuzeigen, wie die neue Mausposition
  in einem Fenster ist, wenn nicht die Maus, sondern das Fenster sich bewegt hat. Bisher gab es hier einfach ein
  weiteres MouseMove-Event, was jedoch extrem problematisch ist, da man damit nicht unterscheiden kann, ob dieses
  Event deswegen gesendet wird, weil die Maus wirklich bewegt wurde, oder weil das Fenster "unter der Maus weg" bewegt
  wurde. Diese Information ist aber unbedingt notwendig, damit z.B. mehrere Modifier, die das Fenster bewegen, korrekt
  nebeneinander arbeiten können. Zudem gab es noch das Problem, das je nach System anders mit den zusätzlichen
  MouseMove-Nachrichten umgegangen wurde, so dass die Implementation des Modifiers nicht für alle Systeme gleich
  funktionieren konnte. Daher gibt es nun dieses Extra-Event, welches dem Programmierer mehr Informationen mitgibt
  und es daher leichter machen sollte, solche Dinge korrekt und sauber zu implementieren.
- WidgetLinux: Aufruf von OnMousePosUpdate() nach dem Verschieben eines Widgets implementiert.
- ModFrameMoveSize: An OnMousePosUpdate-Änderungen angepasst.
- WidgetWindows: Aufruf von OnMousePosUpdate() nach dem Verschieben eines Widgets implementiert.



>> 26.12.2009
[SB] (PLGui3)
- Graphics, GraphicsLinux: Fehlende Implementierung und damit einhergehende Abstürze unter Linux behoben.



>> 21.12.2009
[SB] (PLGui3)
- Widget: Schleife in ActivateLastTabStop() korrigiert, nun sollte eigentlich nichts mehr abstürzen.
- FocusStyle und Tabstop-Optionen für die bisherigen Widgets gesetzt, damit funktioniert das nun z.B. bei den
  Buttons schonmal so, wie ich es erwarten würde.
- Steuerung von TabStops über CursorTasten eingebaut.
- WidgetImpl: SetEnabled() und IsEnabled() in das Backend eingebaut. Ich wollte dies zuerst selbst verwalten, aber
  es besteht eigentlich keinen Grund, nicht auf die Basisfunktionalität des Betriebssystem zurückzugreifen, wenn sie
  denn schon vorhanden ist. Das macht die Verwaltung einfacher, nur bei Backends, die das nicht schon selber mitbringen
  (wie z.B. die Ingame-Gui), muss das natürlich dann doch per Hand gemacht werden. Aber für die anderen Backends
  ist die Implementierung dann umso einfacher.
- Widget: Bei den TabStops werden nun deaktivierte Widgets übersprungen.



>> 21.12.2009
[SB] (PLGui3)
- WidgetWindows: Beim OnMove waren X und Y vertauscht, ausserdem wurden keine negativen Werte übermittelt (unsigned).
- Neuen Modifier 'ModSnap' implementiert. Dieser Modifier erlaubt das 'Snapping' von Widgets aneinander, was ich gerade
  zum ausrichten von Windows zueinander sehr praktisch finde. Also so eine Art 'Docking Lite', wobei ein Fenster auf
  ein anderes zuspringt, wenn man das eine sehr nah an den Rand des anderen bringt, und so lange daran kleben bleibt,
  bis man es mit etwas mehr 'Nachdruck' davon wegbewegt. Im Gegensatz zum Docking besteht diese Verbindung dann aber
  nicht dauerhaft, weshalb das andere Fenster auch gar nichts davon zu wissen braucht, wenn ein Fenster es zum Snapping
  verwendet. Bei der Implementation solcher Modifier muss beachtet werden, dass sich verschiedene Modifier natürlich
  leicht ungewollt beeinflussen können, weshalb in diesem Falle ModFrameMove angepasst werden musste. Mit etwas Mühe
  beim Implementieren solcher Modifier, dürften sich diese Probleme aber wie in diesem Falle beheben lassen (man sollte
  nur daran denken, dass man evtl. nicht der einzige Modifier ist, der gerade das Fenster bewegt). Das schöne an der
  Modifier-Lösung ist ausserdem, dass solche Funktionalität nicht mehr unveränderlich in der Basisfunktionalität
  verankert ist, so dass jeder selbst entscheidene kann, ob er z.B. die Docking-Modifier nutzen möchte, oder evtl.
  eigene, bessere entwickelt, so dass man sich das Benutzerfeeling vollkommen frei zusammenstellen kann :-)



>> 20.12.2009
[SB] (PLGui3)
- Widget: Jedes Widget berechnet nun in einer virtuellen Funktion seine bevorzuge Größe, welche dann abgefragt
  werden kann. Im Falle von Layouts (welche eigentlich immer verwendet werden sollten), wird diese Information
  dann benutzt, um z.B. die Minimalgröße entsprechend anzupassen. Im Falle manueller Ausrichtung kann die Methode
  FitSize() verwendet werden, um die Größe des Widgets auf die bevorzugte Größe anzupassen. Diese Funktionalität
  ist sehr wichtig, da ansonsten Widgets in Layouts unnatürlich groß gezogen werden, solange noch nicht verwendeter
  Platz vorhanden ist. Ein einzelner Button würde so bisher das gesamte Fenster ausfüllen, was sicherlich nicht
  gewünscht sein dürfte.
- LayoutHints: Neue Option 'Spacing'. Diese gibt an, wie viel Freiraum zwischen zwei Elementen in einem Layout
  eingefügt werden soll, der Standardwert ist 10 (Pixel). Bei dieser Voreinstellung geht es, wie generell beim
  Layout, darum, dass möglichst gute Ergebnisse erzielt werden, ohne dass die Voreinstellungen angepasst werden
  müssen. Eine Lücke von 10 zwischen den Elementen sollte daher einen guten Standardwert darstellen, wenn testweise
  ein Layout "zusammengeworfen" wird. Für ein richtig gutes GUI-Design dagegen sollten die Standardwerte sowieso
  angepasst werden, in diesem Falle mag es sinnvoller sein, Spacing nicht zu nutzen und statt dessen eine individuelle
  Einstellung z.B. des Margin-Wertes zu verwenden. Dies erfordert aber mehr Handarbeit, deswegen gibt es zusätzlich
  den Spacing-Wert, um "automatisch" recht brauchbare Ergebnisse zu erzielen.
- LayoutBox: Behandlung von Spacing und PreferredSize eingebaut. Da der Standardwert für Widgets auf (-1, -1), ergibt
  dies zunächst einmal keinen Sichtbaren Unterschied (ausser dem zusätzlichen Spacing). Nun müssen die Widgets so
  implementiert werden, dass sie eine möglichst vernünftige PreferredSize für sich selber setzen.
- PreferredSize eingebaut: Button, ToggleButton.
- PreferredSize eingebaut: BitmapButton, BitmapToggleButton, CheckBox, RadioButton, SystemButton.
- Theme: Das Zeichnen des Widgets wird nun wieder im Widget selbst erledigt, der ThemePainter für Label wurde entfernt.
  Damit gehört Label nun zu den Widgets, die nicht 'themable' sind, ebenso wie z.B. ImageButton etc., also alle
  Widgets, die nur direkt aus z.B. einem Bild oder einem Text bestehen.
- PreferredSize: Es kann nun zur Berechnung noch eine Referenzgröße mit angegeben werden, um die gewünschte Größe
  in einem mehrstufigen Prozess zu ermitteln. Dies ist beispielsweise beim Label sinnvoll: Die Anzeige eines Textes
  mit Zeilenumbrüchen kann je nach Zeilenlänge unterscheidlich sein, je nachdem kann das Label also entweder nach
  rechts oder nach unten wachsen. Daher ist es schlecht möglich, eine feste Größe als Preferred-Size zurückzugeben,
  da man nicht wissen kann, ob es sinnvoller ist, eine möglichst lange Zeile anzuzeigen oder lieber mehr
  Zeilenumbrüche zu verwenden. In diesem Fall wird die Referenzgröße bei CalculatePreferredSize() verwendet: Im ersten
  Schritt wird (-1, -1) übergeben, also keine Referenzgröße. Da das Widget hier noch nichts ermitteln kann, sollte es
  ebenfalls (-1, -1) zurückgeben, also so viel Platz wie möglich in alle Richtungen für sich reservieren. Mit dieser
  Information teilt das Layout dem Widget nun eine Größe zu, welche beim zweiten Aufruf mit übergeben wird. Jetzt
  kann das Widget mit dieser Information eine genauere Angabe über die gewünschte Größe machen und zurückgeben.
  Im Ergebnis ermöglicht dies, wenn ein Label in einer HorizontalBox eingebaut wird, dass die Größe des Widgets sich
  nach unten hin anpasst, wenn das Fenster verkleinert wird und dadurch mehr Zeilenumbrüche nötig werden.
- PreferredSize eingebaut: Label.
- ModFrameMoveSize: Änderung der Position oder Größe ist nun nur noch möglich, wenn das Fenster nicht maximiert ist.
- Widget: Neben dem Title kann nun auch ein Icon für das Widget gesetzt werden.
- Theme: DefaultIcon eingebaut.
- Frame-ThemePainter: Es wird nun das Icons des Fensters angezeigt, wenn keines definiert ist, wird das Default-Icon
  des Themes verwendet.
- Image: Methode IsEmpty() eingebaut, mit der man abfragen kann, ob überhaupt ein Image geladen ist.



>> 18.12.2009
[SB] (PLGui3)
- Menu-Klassen (MenuItem, Menu und MenuSeparator) wieder eingebaut.
- TrayIcon-Klassen wieder eingebaut (noch nicht für Linux implementiert).
- Frame: System-Buttons eingebaut und Farben von Buttons, Rahmen etc. minimal angepasst.
- WidgetWindows: Einige System-Messages eingebaut, zwar momentan nicht wichtig, aber gut zu haben (sollte später
  noch vervollständigt werden).



>> 17.12.2009
[SB] (PLGui3)
- Timer: Noch einige böse Bugs behoben.
- GuiWindows/WidgetWindows: MouseEnter- und MouseLeave-Events implementiert.
- Modifier 'ModTimeout' und 'ModBlend' wieder eingebaut. Beim Blendout besteht noch das generelle Problem, dass nicht
  nur das Fenster selbst, sondern auch alle seine Child-Widgets als "im Fenster befindlich" gelten müssten. Dieses
  Problem ist aber ein generelles, über das ich mir später Gedanken machen werde. Der Modifier an sich funktioniert
  jedenfalls wieder.
- Widgets wieder eingebaut: AbstractButton, Button, BitmapButton. Entsprechenden ThemePainter für Button erstellt
  und Funktionalität aus der alten Theme-Klasse dorthin verschoben.
- ThemePLDefault: Optionen für Farben, Abrundungen etc. in die Theme-Klasse als public-Variablen eingebaut. Ebenso
  bietet die Klasse nun auch einige Hilfsfunktionen zum Zeichnen von Elementen (z.B. Rahmen). Die Optionen sollten
  später ans RTTI angebunden werden und es somit ermöglichen, das Theme noch einmal zu variieren, indem man die
  Einstellungen ändert. Ob man das noch weiter verallgemeinern sollte, weiß ich noch nicht, ich denke aber eher,
  dass jedes Theme seine eigene Logik und damit seinen komplett eigenen Einstellungen und Funktionen definieren sollte.
- Widgets wieder eingebaut: AbstractToggleButton, ToggleButton, BitmapToggleButton. Entsprechenden ThemePainter für
  Toggle Button erstellt und Funktionalität aus der alten Theme-Klasse dorthin verschoben.
- ButtonGroup in Gui/ wieder eingebaut.
- Widget wieder eingebaut: SystemButton. Entsprechendem ThemePainter erstellt und Funktionalität dorthin verschoben.
- Widgets wieder eingebaut: CheckBox, RadioButton. Entsprechendem ThemePainter erstellt und Funktionalität dorthin verschoben.



>> 16.12.2009
[SB] (PLGui3)
- Timer eingebaut. Im Gegensatz zu den anderen Klassen wie Image, Font etc. besitzt der Timer nun kein Backend mehr,
  sondern wird nun immer über Threads realisiert (was früher der ThreadTimer war). Allerdings gibt es einen wichtigen
  Unterschied: Der Timer feuert nun nicht mehr direkt, und damit vorbei an der Mainloop, sondern es wird das
  Gui-Backend verwendet, um eine interne Timer-Nachricht abzusetzen. Die jeweilige Gui-Implementation ist dann dafür
  verantwortlich, dass ein Timer-Event in die Message-Queue eingespeist und vernünftig verarbeitet wird. Beim
  nächsten Aufruf von GetMessage() sollte das System dann diese Nachricht finden und daraufhin erst das Timer-Event
  auslösen. So kann man sicher sein, dass der Aufruf des Timer-Events im Main-Thread passiert und die Message-Loop nicht
  umgangen wird, was bisher zu einigen Problemen geführt hat (siehe Eintrag von Christian vom 03.08.2009).
- Timer für Windows implementiert.
- Timer für Linux implementiert. Ich würde ja jetzt am liebsten drauf los ranten, wie schlecht und bescheuert die
  Dokumentation für Xlib etc. ist, aber das spare ich mir einfach mal ;-) Die Atoms sind nun in Gui statt in Widget,
  da dieses ja eigentlich nur einmal global gebraucht werden und nicht individuell pro Fenster. Hoffe, dass das keine
  ungeahnten Probleme nach sich zieht. Für die Timer-Nachrichten musste leider ein unsichtbares Fenster erstellt werden,
  da es ansonsten nicht möglich war, eine Nachricht einfach so an die Applikation zu senden. Und schließlich habe ich
  auch noch XInitThreads() etc. verwendet, da es ansonsten wohl Probleme mit MultiThreading unter X geben *kann*.
  Soweit ich es testen konnte, scheinen die Timer nun jedenfalls auch unter X zu funktionieren :-D



>> 14.12.2009
[SB] (PLGui3)
- Label: Noch einen Fehler im Zeilenumbruch behoben, "\n" wird nun immer bevorzugt behandelt gegenüber dem automatischen
  Zeilenumbruch. Dadurch sollte es nun nicht mehr passieren, dass eine freie Zeile eingefügt wird, wenn das Wort sowieso
  zu lang für die Zeile ist und hinterher noch ein manuelles "\n" gelesen wird.
- Label: Unterstrichener und durchgestrichener Text wird nun auch bei zeilenumbrüchen angezeigt.



>> 13.12.2009
[SB] (PLGui3)
- Font: Im Default-Constructor wird nun ein Standardfont gesetzt, da das Implementations-Objekt ansonsten nicht erzeugt
  wird, was natürlich an anderen Stellen zum Absturz führt. In allen Ressourcen-Klassen sollte daher darauf geachtet
  werden, dass immer eine Implementation erzeugt wird.
- Theme: DefaultFont in die Theme-Basisklasse eingebaut.
- Das Widget 'Label' wieder eingebaut und an die neue Basis angepasst. ThemePainter für PLDefault erstellt.
- Label: Optionen wie Textfarbe, Ausrichtung und Textumbruch eingebaut.
- Label: Anzeige mit allen Ausrichtungsarten, inklusive Blocksatz und manuellen Newlines implementiert. Bestimmt alles
  viel zu kompliziert, aber was solls, hauptsache es funktioniert. Hoffe, dass damit erstmal alle Wünsche erfüllt sind,
  was Text und Ausrichtung angeht ;-)



>> 12.12.2009
[SB] (PLGui3)
- Layout: Margin implementiert. Der Margin-Wert gibt an, wie viel Platz um das Element herum freigelassen werden soll.
  Im Gegensatz zu anderen GUI-Toolkits kann hierbei der Wert frei für alle vier Seiten bestimmt werden. Damit können
  also die Lücken definiert werden, die beim anordnen in einem Layout zwischen den einzelnen Elementen eingefügt
  werden sollen. Hierbei werden auch wieder alle Typen von Angaben (statisch, prozentual oder floating) erlaubt,
  wodurch auch eine dynamische Anordnung im Sinne von left/center/right hierüber möglich wäre. Vermutlich werde ich
  das aber trotzdem noch einmal separat anbieten, um es für den User einfacher zu machen.
- Layout: Padding implementiert. Der Padding-Wert gibt bei einem Container an, wie viel Platz an den Rändern nach
  innen hin gelassen werden soll. Die Padding-Werte werden also vom Inhalt des Containers abgezogen, der Rest, der
  noch übrig bleibt, wird von den Child-Widgets belegt, die darin angeordnet werden.
- Widget: UpdateLayout() als Funktion und Event implementiert. Das Problem besteht darin, dass in PLGui alle Widgets
  bereits im Constructor einem Parent-Widget zugeordnet werden (anderswo gibt es eine Add-Funktion). Dadurch ist
  es nicht möglich, die Eigenschaften des Widgets festzulegen, *bevor* dieses in sein Parent eingefügt wird, was dazu
  führt, dass das Layout erstmalig berechnet wird, noch bevor die Eigenschaften des letzten Child-Widgets gesetzt werden.
  Darum muss in diesem Falle manuell UpdateLayout() vom Parent aufgerufen werden, nachdem man Eigenschaften eines
  Widgets verändert hat, damit das Layout entsprechend angepasst wird (bei allen Eigenschaften, die geändert wurden,
  automatisch UpdateLayout() aufzurufen, ist kaum möglich und scheint mir auch nicht sinnvoll, dies passiert daher
  nur bei solchen Eigenschaften, wo es unbedingt nötig ist, wie z.B. die Größe eines Widgets oder wenn neue Child-Widgets
  hinzugefügt wurden).
- Layout: Alignment-Einstellungen hinzugefügt. Ein Container kann damit festlegen, wie seine Widgets angeordnet werden
  sollen, wenn sie in eine Richtung nicht die volle zur Verfügung stehende Länge ausnutzen (links/recht/mittig bzw.
  oben/unten/mittig). Diese Einstellung tritt allerdings nur dann in kraft, wenn keine floating-Elemente verwendet
  werden, da diese ansonsten den gesamten restlichen Raum einnehmen und somit keine Notwendigkeit mehr für das
  Alignment besteht. Der Fall, der hiervon nicht abgedeckt wird, ist der, wenn ein Element zwar auf floating eingestellt
  ist, aber gleichzeitig eine Maximalgröße eingestellt hat, die kleiner ist als die Größe, die das Element wegen der
  floating-Einstellung zugeteilt bekommen hat. In diesem Falle wird die Größe der zugeteilten Fläche vollständig erteilt,
  damit das Layout insgesamt nicht kleiner wird als durch das floating erwartet, das Element bleibt jedoch so groß, wie
  es seine Maximalgröße erlaubt, wodurch die Lücke nach dem Element größer wird. In diesem Fall führen die Alignment-
  Optionen nicht dazu, dass ein solches Element rechtsbündig oder zentriert in der ihm zugeteilten Fläche angeordnet
  wird, da dies nicht unbedingt immer erwünscht ist, dass diese Anordnung mit der anordnung des gesamten Layouts
  identisch sein soll. Um das zu erreichen, sollten daher geschachtelte Layouts verwendet werden, da damit genau das
  gewünschte Verhalten festgelegt werden kann.
- Widget, Modifier: Verwaltung der Modifier überarbeitet. Der Name von Modifiern wird nun nicht mehr im Modifier selbst
  festgelegt, sondern erst beim Anmelden eines Modifiers bei einem Widget. Der Name eines Modifiers muss dabei eindeutig
  sein, wenn ein schon vorhandener Namen angegeben wird, so wird der alte Modifier mit diesem Namen gelöscht und durch
  den neuen ersetzt. Natürlich können auch Modifier ohne Namen eingefügt werden, insbesondere für vordefinierte Zwecke
  werden jedoch Namen verwendet (z.B. "Theme" und "Layout" sind vordefinierte Modifier-Namen).
- Widget: Interface für Verwaltung von Layouts erweitert, Layouts können nun z.B. auch per Name und Optionen erzeugt werden.
- Widget: Interface für Verwaltung von Themes erweitert (weitgehend äquivalent zu den Layouts).
- ThemePLDefault_Frame: Es wird nun der Fenstertitel des Widgets angezeigt.



>> 11.12.2009
[SB] (PLGui3)
- LayoutHints eingebaut. Diese Klasse beinhaltet zusätzliche Information darüber, wie ein Widget vom Layout-Manager
  angeordnet werden soll. Jede Instanz von Widget besitzt daher nun zusätzlich ein LayoutHints-Objekt, wo diese
  Einstellungen vorgenommen werden können. Im Gegensatz zur tatsächlichen Größe etc. eines Widgets stellen diese
  Daten allerdings nur Hinweise für das Layout dar, je nach Layout-Manager können die Daten aus dieser Klasse
  für das Layout verwendet werden (oder eben auch nicht). Daher schien es mir besser, hieraus eine eigene Klasse
  zu machen, als das direkt im Widget einzubauen.
- SizeHint hinzugefügt. Diese reine Datenklasse beschreibt eine eindimensionale Größe, wobei verschiedene "Maßeinheiten"
  möglich sind: feste Größenangabe in Pixel, dynamische Größenangabe in Prozent des verfügbaren Raums und vollständig
  dynamisch (so groß wie möglich). Diese Klasse wird für alle Größenangaben in Layouts verwendet, damit man hier die
  volle Flexibilität hat, die Größe eines Widgets bei dynamischen Fenstergrößen festzulegen.
- LayoutBox: Verwendet nun die in den LayoutHints angegebene Größe zur Berechnung der tatsächlichen Größe eines
  Widgets. Durch die Verwendung von Floats und relativen Größenabgaben kann damit nun erstmals ein Fenster dynamisch
  in der Größe verändert werden :-)



>> 09.12.2009
[SB] (PLGui3)
- Layout: Beim OnSize-Event des Widgets angemeldet und virtuelle Methode zum Ausrichten der Child-Widgets
  (ApplyLayout) eingebaut.
- Layout-Test eingebaut und testweise die Funktionalität von LayoutBox implementiert.
- Widget: OnAddChild()-Event eingebaut.
- Widget: GetContentWidget() in der Widget-Basisklasse eingebaut. Für "einfache" Widgets wird einfach ein
  Pointer auf das Widget selbst zurückgegeben, komplexe Widgets dagegen haben ein eigenen Content-Window.
  Das scheint mir so sinnvoll, da man nun einfach immer GetContentWindow() als parent angeben kann, ohne wissen
  zu müssen, welche Widget ein ContentWindow besitzen und welche nicht (lazy-programmer ;-)).



>> 07.12.2009
[SB] (PLGui3)
- Klassen FontInfo und FontManager eingebaut. FontInfo fasst noch einmal alle Einstellungen für einen Font zusammen,
  entsprechend wurde Font so erweitert, dass man einen Font auch mittels dieser Info-Klasse erstellen kann oder von
  einem bereits geladenen Font alle Informationen gemeinsam in einer solchen handlichen Info-Klasse abfragen kann :-)
  FontManager soll später dazu dienen, alle in einem System verfügbaren Fonts aufzuzählen, sowie einzelne Fonts
  hinzuzufügen. Diese Klasse ist bisher nur rudimentär vorhanden und noch nicht implementiert.
- FontManager: Auflisten von Fonts implementiert (Windows und Linux).



>> 06.12.2009
[SB] (PLGui3)
- CursorLinux: Einladen von Bildern als Custom-Cursor implementiert. Mit den Standard Xlib-Funktionen ist dies zwar nicht
  möglich, da man dort nur einfarbige Shapes verwenden kann, aber es gibt eine Extension (Xcursor), die dies übernimmt.
  Und sobald man mal unter den wenigen und schlecht gewarteten Informationen, die es darüber gibt, herausgefunden hat, wie
  das zu benutzen ist, geht alles wie von selbst ;-)
- ToolsLinux: Überarbeitet und Namen der Funktionen etwas aussagekräftiger gemacht.
- CursorWindows: Dummen Fehler behoben, das Verwenden von Bitmaps als Custom-Cursor geht nun auch unter Windows wieder.
- Cursor: Beim Laden eines Custom-Cursors aus einem Image sollte auch der Hotspot-Punkt für den Cursor mit übergeben
  werden können. Das Interface wurde entsprechend erweitert.
- Backend: Interfaces sind nun standardmäßig public.



>> 05.12.2009
[SB] (PLGui3)
- Wie ich gerade beim Versuch, die bisherigen Klassen nach Linux zu portieren, feststellen durfte, gibt es unter X
  keine Möglichkeit, einfach so den aktuellen Mauscursor zu setzen. Statt dessen muss man hier den Mauscursor immer
  in Abhängigkeit zu einem Fenster setzen, es kann also festgelegt werden, welcher Cursor angezeigt werden soll, wenn
  die Maus sich über einem bestimmten Fenster befindet. Unter Windows ist es fast genau umgekehrt, zwar gibt es auch
  eine Einstellung für den Mauscursor über einem Fenster, diese wird jedoch in der WindowClass festgelegt und lässt sich
  nicht dynamisch ändern, dafür kann man jedoch, solange diese Einstellung auf NULL steht, den Cursor zu jeder Zeit
  global ändern. Um diese zwei Systeme unter einen Hut zu bekommen, habe ich die Verwaltung des Cursors in PLGui3 nun
  so umgebaut, dass sie dem Prinzip unter X entspricht: Jedes Fenster kann festlegen, welcher Cursor auf diesem Fenster
  angezeigt werden soll, es gibt jedoch keine globale SetCursor()-Methode in GUI mehr. So herum lässt sich das auf jedem
  System implementieren, wenn es nur die globale Funktion gibt lässt sich mit ihrer Hilfe die Pro-Fenster-Funktion
  abbilden, andersherum ist das leider nicht möglich. Die Windows-Implementation wurde so umgebaut, dass mit Hilfe
  der Nachricht WM_SETCURSOR der Cursor für ein Fenster gesetzt wird, und die Verwendung in den Widget-Klassen (Frame)
  wurde auch entsprechend verändert. Der Wert 'CursorDefault' wurde wieder entfernt, da er so keinen Sinn mehr ergibt.
- WidgetLinux: Ändern des Mauscursors ist auch unter Linux nun funktionstüchtig.
- CursorLinux: Linux-Port implementiert (es fehlen allerdings noch Bitmap-Cursor).
- WidgetWindows: Wenn der Mauscursor eines Fensters geändert wurde, wird dieser nun auch angepasst, wenn sich die Maus
  noch nicht relativ zum Fenster bewegt hat (in diesem Falle gibt es zwar eine MouseMove-Nachricht, aber keine
  SetCursor-Nachricht). Dies ist z.B. beim Verschieben eines Fensters der Fall.
- Die Definitionen der Standard-Cursor erweitert und nicht mehr strikt die Windows-Namen übernommen. Da sich die Systeme
  hier natürlich sehr unterscheiden, gibt es nun je nach System einige Cursor, die z.B. auf einem System alle das
  gleiche Bild darstellen, auf einem anderen aber unterschiedlich sind. Dementsprechend wurde das z.B. für das Vergrößern
  von Fenstern so verwendet, dass es sowohl unter Linux als auch unter Windows letztlich dem System-Standard entsprechen
  sollte.
- FontLinux: Fonts für Linux implementiert (es fehlt allerdings noch das Laden aus einer Font-Datei).
- ThemePLDefault: Mehrere Standard-Fonts eingetragen, die die Klasse nacheinander versucht, einzuladen. Mir fällt leider
  keine elegantere Lösung ein, da die Fonts unter Windows und Linux völlig andere Namen haben und es da keine großen
  Überschneidungen zu geben scheint. Einzige Lösung scheint also zu sein, entweder die Fonts mitzuliefern, oder mehrere
  Alternativen aus Standard-Fonts auf möglichst vielen Systemen einzutragen.
- CursorLinux, FontLinux: Interface und Implementation vereinheitlicht.
- CursorWindows, CursorLinux: Behandlung von CursorNone implementiert.
- ImageLinux: Image für Linux implementiert. Von Hause aus kennt X leider keine Transparenz, darum muss bei jedem Image
  noch eine Mask mitgespeichert werden, in der transparente Pixel verzeichnet sind. Beim Einladen setze ich nun alle
  Pixel mit Alpha > 0 als sichtbar, nur die Pixel mit Alpha == 0 bleiben unsichtbar. Alternativ kann natürlich auch
  der ColorKey verwendet werden (ist ja im Interface von Image sowieso schon drin).



>> 04.12.2009
[SB] (PLGui3)
- Gui: SetCursor() implementiert. Dies setzt den Mauscursor, der zur Zeit aktiv sein soll. Dabei ist darauf zu achten,
  dass andere Einstellungen, z.B. der Cursorm der zum aktuellen Widget gehört, diese Einstellung sofort wieder
  überschreiben können.
- Widget: SetCursor() implementiert. Diese Einstellung setzt den Mauscursor, der angezeigt werden soll, wenn die Maus
  sich gerade im Bereich des Widgets befindet. Die Standardeinstellung für alle Widgets ist CursorArrow, als Standard
  soll also immer der Pfeil angezeigt werden. Ein Fenster, das den Mauszeiger dynamisch ändern möchte, sollte dagegen
  diese Einstellung auf CursorDefault setzen, was soviel bedeutet wie "kein Standard-Cursor für dieses Fenster gesetzt".
  Der Mauscursor wird in diesem Fall also nicht automatisch zurückgesetzt und kann deshalb durch das Fenster dynamisch,
  also durch Aufruf von Gui::SetCursor(), gesetzt werden (dies wird bei Frame verwendet, um den Mauscursor für Bewegen
  und Zoomen dynamisch anzupassen).
- Gui: Die Standard-Cursor werden nun in der Gui in einem Array zwischengespeichert, damit diese nur einmal und nicht
  immer wieder erzeugt werden. Beim Erzeugen einer neue Cursor-Instanz wird dann zunächt geschaut, ob bereits eine
  Backend-Instanz bei der Gui vorhanden ist und diese dann gemeinsam verwendet.
- Frame: Mauscursor nach üblichem Muster implementiert (Pfeile beim Resize).
- Frame: SetShowInTaskbar() wird für Frames nun per Standard auf 'true' gesetzt.
- Neue Klassen lassen sich nun auch unter Linux compilieren, funktionieren aber noch nicht (Image, Font etc.).
- GuiLinux: ErrorHandler für Exception des X-Servers hinzugefügt. Dieser gibt den Inhalt des Fehlers auf der Konsole
  aus, bricht aber nicht gleich das Programm ab (im Gegensatz zum Default-Handler).
- WidgetWindows: Beim Anzeigen eines Fensters wird nun wieder SW_SHOW anstatt SW_SHOWNA verwendet, damit top-level Windows
  auch wieder automatisch aktiviert werden (den Fokus bekommen). Mal sehen, ob dies später an anderer Stelle wieder
  Problem macht, oder nicht ...



>> 03.12.2009
[SB] (PLGui3)
- Image, Font und Cursor nochmals leicht überarbeitet und vereinheitlicht, was den Aufbau und die Verwendung des
  internen Implementation-Objekts betrifft.



>> 02.12.2009
[SB] (PLGui3)
- Font-Klasse erweitert. Die Eigenschaften von Fonts können nun einzeln gesetzt und geändert werden, intern werden
  dann Implementationsobjekte geteilt und wenn nötig neue erzeugt, damit die Änderungen nur den aktuellen Font
  betreffen und nicht andere Objekte, die bisher das gleiche Implementationsobjekt verwendeten.
- Klasse Cursor für die Verwendung von Mauscursorn wieder eingebaut.



>> 01.12.2009
[SB] (PLGui3)
- Klassen aus 'Resources' nach 'Gui' verschoben, damit es nicht zu viele verschiedene Verzeichnisse werden. Alles,
  was so zu den "Grundklassen" für das Gui-System gehört und zu klein ist, um eine eigene Kategorie zu bekommen,
  wird zukünftig daher wieder in 'Gui' zu finden sein.
- Hint in GraphicsHint umbenannt, da damit eindeutiger ist, in welchem Kontext das verwendet werden kann/soll.
- Klasse Image für das Laden und Anzeigen von Bildern in der GUI wieder eingebaut (inkl. Backends etc.).
- ThemePainter besitzen nun einen Zeiger auf das dazugehörige Theme, damit dort geteilte Resourcen verwaltet werden
  können. Theme dagegen besitzt einen Zeiger auf Gui, der z.B. für das Laden von Resourcen notwendig ist.
- Klasse Font für das Laden von Textarten wieder eingebaut.
- Font erweitert und für Windows implementiert.



>> 14.11.2009
[SB] (PLGui3)
- Implementierung von ContainerWidget und Frame begonnen.
- Zusammenspiel von Widgets und ThemePainter implementiert und erste (noch leere) ThemePainter erstellt.
- Neuer Modifier: ModExitOnClick fügt die Funktion hinzu, das Programm mit einem Rechtsklick auf das Widget zu beenden.
- Neuer Modifier: ModFrameMoveSize fügt die Funktionalität hinzu, Frames zu verschieben (Klick und Drag auf die Titelleiste)
  oder in der Größe zu verändern (Klick und Drag auf den Rand). Der Modifier sollte sich nun ziemlich genau so
  verhalten, wie überlicherweise (zumindest unter Windows) erwartet, also Vergrößern nur in eine Dimension bei Klick
  auf einen Rand, Vergrößern in zwei Dimension bei Klick auf eine Ecke, wobei die Ecke etwas größer definiert ist als
  die tatsächliche Ecke :-) Es fehlt allerdings noch das Verändern des Mouse-Cursors, da dies momentan in der Gui noch
  nicht wieder implementiert ist. Dieser Modifier wird automatisch in allen Frames hinzugefügt.
- Neuer Modifier: ModExitOnClose beendet die Applikation, wenn das Fenster geschlossen wird. Wird bei AppWindow eingefügt.
- Frame: FocusStyle auf AcceptFocus gesetzt. Ansonsten hat man unter Linux das Problem, dass das Fenster zwar richtig
  angezeigt wird, aber der Fokus bei dem zuvor geöffneten Fenster einer anderen Applikation bleibt, und man böse
  Überraschungen erlebt, wenn mal beispielsweise ALT+F4 drückt ;-) Ausserdem würde dies später auch dazu führen,
  dass der Frame nicht aktiviert werden kann, weil weder er selbst noch eines seiner Child-Widgets den Fokus besitzt.
  Daher werden Frames nun automatisch den Fokus annehmen, dies kann man auch dazu nutzen, um später z.B. das Verschieben
  von Frames über Cursortasten einzubauen (das finde ich ab und zu ganz nett zu nutzen).
- WidgetLinux: Fehler umgangen, der bei Größenänderungen von Fenstern auftrat. Wenn die Größe verändert wird, bekommt
  das Fenster die neue Position und Größe mitgeteilt. Offenbar wird hier jedoch die Position immer auf (0, 0) gesetzt,
  wenn die Größe geändert wurde, und in einer zweiten Nachricht wird dann die korrekte Position noch einmal gesendet.
  Das ist natürlich ein Problem, weil damit Fenster immer auf (0, 0) springen, wenn die Größe verändert wird, daher
  ignoriere ich nun die Position immer dann, wenn die Größe sich geändert hat. Ist nicht schön, aber funktioniert
  (zumindest bei mir...)
- WidgetLinux: MouseCapture implementiert. Das Ändern von Position und Größer eines Fensters funktioniert nun auch
  unter Linux.



>> 14.11.2009
[SB] (PLGui3)
- PLGuiDefinitions.h durchgesehen und momentan nicht benutzte Definitionen entfernt oder zeitweilig auskommentiert.
- WidgetState wieder in WindowState umbenannt.
- GetWidgetHandle() wieder in GetWindowHandle() umbenannt.
- Modifier haben nun individuelle Namen und können über diese von einem Widget abgefragt werden. Dabei wird es einige
  vordefinierte Namen für Modifier geben, die einen bestimmten Zweck erfüllen, z.B. "Layout" oder "Theme". Generell
  kann ein Modifier aber einen beliebigen Namen bekommen, und die Applikation kann dieses Feature für ihre eigenen
  Zwecke nutzen oder auch nicht.
- Widgets können nun auch einen Namen haben. Dieser ist erstmal rein optional und wird auch *nicht* an das System-Window
  weitergegeben, auch wenn einige Systeme dies unterstützen könnten. Der Name kann also frei verwendet werden und ist
  zumindest momentan hauptsächlich fürs Debugging gedacht, da man so Fenster sehr leicht identifizieren kann.
- DebugModifier eingebaut. Dieser Modifier hört auf *alle* Events eines Widgets und schreibt bei deren Eintreffen eine
  Meldung auf die Konsole. Dadurch müssen für's debuggen nicht mehr ständig Systemausgaben hinzugefügt und später
  wieder entfernt werden, sondern man gibt einfach dem zu beobachtenden Widget diesen Modifier und hat somit auch noch
  eine genaure Kontrolle darüber, welche Widgets einen interessieren und welche nicht :-)
- Verzeichnis und Basisklassen für Themes erstellt (noch leer).
- Verzeichnis und Basisklassen für Layout erstellt (noch leer).
- Gerüst für Themes implementiert. Zunächst einmal gibt es ein Theme-Objekt, welches von der Gui verwaltet wird und
  das gesamte Theme repräsentiert. Das Theme hat einen Namen und kann optional noch eigene Einstellungen enthalten,
  bspw. Farbwerte, wodurch ein Theme in der Lage wäre, mehrere leicht unterschiedliche Varianten darzustellen.
  Dieses Theme-Objekt wird automatisch an Widgets weitergegeben, es ist jedoch später auch möglich, dass ein Widget
  individuell ein anderes Theme verwendet. Das Theme-Objekt ist dann dafür zuständig, für jedes Widget einen
  spezialisierten ThemePainter zu erzeugen, der für das eigentliche Theming des Widgets sorgt. Ein ThemePainter ist
  dabei ein Modifier, der automatisch den Namen "ThemePainter" erhält und sich in die entsprechenden Events des
  Widgets einklinkt, um z.B. das Zeichnen des Widgets zu übernehmen. Es ist aber natürlich auch möglich, beliebige
  andere Events abzufangen, wodurch ein Theme auch in der Lage ist, neben dem Aussehen auch das Verhalten von Widgets
  zu modifizieren. Dies geht natürlich nur in soweit, als dass die eigene Implementation des Widgets natürlich nicht
  modifiziert werden kann und somit das Widget nicht daran gehindert werden kann, Dinge auszuführen. Ein Event wird
  ja immer nur zusätzlich zur eigenen virtuellen Methode aufgerufen, wenn darin also etwas geschieht, was nicht
  erwünscht ist, kann das im Event nicht verhindert werden. Allerdings kann versucht werden, die Widgets so allgemein
  zu halten, dass ein Theme hier weite Spielräume erhält, die Funktionalität eines Widgets zu beeinflussen, bspw. durch
  das Hinzufügen von Modifiern zum Widget.
- Themes: Wenn ein Widget erzeugt wird, versucht das aktive Theme, einen ThemePainter für den Typus des Widgets zu erzeugen.
  Wenn es sich aber nun um eine abgeleitete Klasse handelt, z.B. ApplicationFrame von Frame, kann diese natürlich im
  Theme nicht bekannt sein. Deswegen werden nun angefangen bei der tatsächlichen Klasse des Widgets alle Basisklassen
  durchlaufen, solange bis eine davon dem Theme bekannt ist und ein ThemePainter dafür erstellt werden kann. Eine Klasse
  ApplicationFrame hätte also einen ThemePainter_Frame, was aber auch genau richtig sein sollte. Mal sehen, wie sich
  das alles in der Praxis verhält...



>> 13.11.2009
[SB] (PLGui3)
- Linux-Implementationen durchgesehen und überarbeitet, die letzten Überbleibsel und nicht Style-konformen Stellen
  entsprechend entfernt oder korrigiert.
- Alle Dateien noch einmal durchgesehen und Style korrigiert.
- Fokus-Test eingebaut. Dabei ist schonmal zu sehen, dass in der Windows-Implementierung ein Top-Level-Window
  manchmal auch dann den Fokus bekommen kann, wenn sein Focus-Style auf NoFocus steht. Mal sehen, ob es unter Linux
  ähnliches Probleme gibt.
- Fokus-Management unter Linux funktioniert nun einiger Maßen. Es fehlt allerdings wie unter Windows noch die Behandlung
  der FocusStyle-Eigenschaft, im Moment kann noch jedes Fenster den Fokus bekommen.
- Fokus-Management überarbeitet. Es gibt nun drei Optionen, die ein Fenster durch Setzen des FocusStyle hat:
  * AcceptFocus: Das Fenster akzeptiert den Fokus selbst.
  * NoFocus: Das Fenster akzeptiert niemals den Fokus, wird ein solches Fenster angeklickt, so wird der Fokus
    entweder beim aktuellen Fenster bleiben, oder auf NULL gesetzt (falls vorher eine andere Applikation aktiv war).
  * ChildFocus: Das Fenster versucht, den Fokus an ein Child-Window weiterzugeben. Dies geschieht rekursiv, das erste
    Child-Window, das den Fokus akzeptiert, bekommt ihn. Sollte versucht werden, einem Fenster mit diesem Flag den Fokus
    zu geben, während bereits eines der Child-Windows den Fokus hat, bleibt der Fokus unverändert und wird nicht auf
    das erste Child-Window mit dem Flag AcceptFocus zurückgesetzt.
  Die Windows und Linux-Implementierungen wurden entsprechend angepasst und funktionieren nun wie gewollt. Bei neuen
  Backends muss hier ein wenig aufgepasst werden, denn es darf natürlich zu keinen Endlosschleifen kommen. Daher muss
  strikt zwischen zwei Typen von Nachrichten unterschieden werden: Denen, die versuchen, den Fokus zu setzen, und denen,
  die darüber informieren, dass der Fokus gesetzt wurde. Wenn versucht wird, den Fokus zu setzen, sollte das Backend die
  Funktion m_pWidget->SetFocus() aufrufen und den Rest dieser Funktion überlassen. Wenn jedoch der Fokus gesetzt wurde,
  darf diese Funktion nicht mehr aufgerufen werden (Endlosschleife!), statt dessen sollte hier noch einmal überprüft werden,
  ob das genannte Widget wirklich AcceptFocus gesetzt hat, wenn ja wird OnFocus() aufgerufen, ansonsten wird das ignoriert.
- Tab-Stops eingebaut. Dieses Mal kommt das ganze auch ohne manuelle Zeiger aus, dafür ist allerdings die interne Logik
  auch nicht unkompliziert. Falls jemand weiß, wie man das ganze vereinfachen kann, möge er bitte Bescheid sagen :-)
  Es wird nun automatisch nach dem nächsten oder vorherigen TabStop-Widget gesucht, und dann versucht, diesem oder einem
  seiner Child-Widgets den Fokus zu geben. Dabei wird auch die Reihenfolge, also letztlich alle Blätter des Baumes entweder
  vorwärts oder rückwärts aufgezählt. Durch das TabStop-Flag kann ein Widget bestimmen, ob es per Tab-Stop aktivierbar
  ist oder nicht. Für ein Widget, das den Fokus nicht akzeptiert, ist das TabStop-Flag wirkungslos.
- Tastatureingaben unter Linux implementiert. Dabei werden die Modifier-Keys an die Gui weitergereicht, wo ihr aktueller
  Status gespeichert wird. Dies ist nicht schön, ich weiß aber nicht, wie man das anders lösen kann. Problematisch dürfte
  es werden, wenn z.B. Shift gedrückt wird, dann zu einer anderen Applikation gewechselt wird und erst dann Shift wieder
  losgelassen wird. In diesem Fall wird unsere Applikation, wenn sie wieder aktiviert wurde, denken, dass Shift immer
  noch gedrückt ist, da sie von dem Release-Event natürlich nicht informiert wurde. Allerdings ist genau diese Art
  von Fehlern auch bei anderen Applikationen immer wieder zu beobachten, ist also durchaus ein häufiges Problem und
  daher vielleicht nicht allzu kritisch. Damit funktionieren die Tab-Stops und das navigieren mittels Tab/Shift-Tab
  nun auch unter Linux.



>> 12.11.2009
[SB] (PLGui3)
- Klassen durchgeschaut, Style korrigiert und Interface überarbeitet: Widget und WidgetImpl.
- Linux-Port neu begonnen: GuiLinux, WidgetLinux. Header angepasst und Style korrigiert.
- Testapplikation begonnen, um die einzelnen Funktionalitäten von PLGui3 möglichst unabhängig voneinander
  zu demonstrieren und auch zu testen. Momentan wird hierzu PLSamples2/99Test verwendet, später könnte dies
  aber direkt in die Tests verschoben werden, wenn sich das als sinnvoll herausstellt. So wäre es später möglich,
  z.B. anhand eines möglichst einfachen Beispieles nur die Fokus-Funktionalität zu testen, damit man nach
  Änderungen im PLGui-Kern mögliche Fehler sofort lokalisieren kann. In kompletten Gui-Applikation ist es dagegen
  nur noch schwer festzustellen, ob der Fehler nun z.B. an einem falsch funktionierenden Fokus-System liegt, oder
  an einem bestimmten Widget, etc.
- GuiLinux: EnumerateScreens() fragt nun zuerst den Namen des geöffneten Displays ab, und zählt dann die Screens
  dieses Displays auf. Zuvor hätte jedes andere Default-Display ausser ":0.0" einen Fehler verursacht, da die Namen
  immer als ":0.i" aufgezählt wurden. Dies wurde nun behoben.
- GraphicsLinux: Die notwendigsten Teile der Implementation wiederhergestellt. Damit ist der Initial-Test, ein leeres
  weißes Window zu öffnen und anzuzeigen, nun auch unter Linux funktionsfähig.



>> 10.11.2009
[SB] (PLGui3)
- Ok, Neustart PLGui3. Ich denke, wir wissen inzwischen ungefähr, wo die Probleme mit PLGui2 lagen und was es dieses Mal
  zu vermeiden gilt. Auch bei PLGui3 war ich leider immer noch nicht komplett konsequent und habe immer noch einige
  Altlasten mit übernommen, was ich nun noch einmal auszuräumen gedenke :-) Daher wird PLGui3 noch einmal auf die Basis
  heruntergestript, und mittels einfacher Testprogramme die Basisfunktionalität nachprüfbar gemacht. Dabei sollten dieses
  Mal auch die Basiskonzepte ganz deutlich definiert werden, denn gerade da ist bisher vieles durcheinander gekommen,
  was die Basis für viele Probleme war (z.B. Konzept Fensterverwaltung - wer löscht was wann, oder Konzept Fokus, da ging
  vieles wild durcheinander). Ebenfalls überarbeiten möchte ich die Resourcen, auch wenn ich da noch kein Konzept habe,
  aber aus genau dem Grunde lasse ich die erstmal weg, dann werden sich sicherlich auch neue Ideen ergeben. Wenn die Basis
  dann wieder steht, wird auch endlich der Linux-Port Form annehmen können, da es natürlich einfacher ist, auf einer schlanken
  Basis eine Portierung zu erstellen, als wenn gleich alles mögliche da drin sein muss. Einige der neuen Konzepte, die ich
  in PLGui3 bereits ausprobiert habe, haben sich auch nicht so bewährt, daher kann ich hier auch noch einmal neu anfangen
  und es noch einmal leicht anders probieren (z.B. Theming oder ComplexWidget). Anderes hat dagegen bereits sehr gut
  funktioniert, und das bleibt dann natürlich auch so (z.B. Modifier) :-)
- Alles bis auf das allernötigste aus PLGui3 entfernt. Es gibt nun nur noch Gui, Widget und ein paar weitere Klassen. In den
  Interfaces spiegelt sich aber immernoch viel vom alten System, das muss als nächstes gründlich aufgeräumt werden.
- Klassen durchgeschaut, Style korrigiert und Interface überarbeitet: Gui, GuiImpl und Screen.



>> 03.08.2009
[CO]
- Ich fand gerade heraus warum es vorkommen konnte das alles scheinbar "Einfrohr". Das Problem lies sich reproduzieren
  wenn man z.B. im Scene Viewer in den Debug Dialog ging, dort eine Scene Node auswählte, die Maus in den Variable Inspector
  brachte und das Mausrad drehte - dann frohr alles ein bis man z.B. die Maus wieder bewegte... es stellte sich heraus das
  "GuiWin32::SystemProcessMessages()" -> "GetMessage()" das "Problem" war. Es waren keine Nachrichten vorhanden und darum
  blockte diese Funktion dann bis Nachrichten ankamen - das sollte aber ja bereits in "Gui::PendingMessages()" abgefragt
  werden ob Nachrichten da sind. Als ich mir die Funktion genauer anschaute merkte ich allerdings das diese Funktion auch
  "true" zurückgibt wenn gerade Timer oder Redraw in einer Liste ist - das war wohl mein Fehler von vor Jahren. Die Funktion
  gibt dadurch natürlich dann "true" zurück und dann geht das bis zu "GetMessage()" durch wo sich dann rausstellt das nicht
  wirklich Nachrichten da sind und dann wird geblockt.
  Ich habe das dadurch "geflickt" das ich in "Gui::ProcessMessages()" die do-while Schleife in der "SystemPendingMessages()"
  genutzt wird zu einer einfachen while Schleife machte wenn man Gefahr läuft das nicht wirklich Nachrichten da sind. In PLGui3
  haben wir das gleiche Problem wenn ich das richtig sehe, habe aber meine Finger davon gelassen. Stefan, bitte schau mal drüber.



>> 17.06.2009
[CO]
- PLGui3: "ThreadTimer::Run()" sollte nicht mehr Feuern wenn nach dem Sleep der Timer bereits gestoppt wurde... etwas
  das momentan noch ein kleines Problem ist da das Sleep noch nicht unterbrechbar ist...



>> 11.06.2009
[SB]
- Linux-Implementation an neues PLGraphics angepasst. Das Projekt lässt sich nun erstmal wieder unter Linux übersetzen.



>> 12.05.2009
[CO]
- "WindowWin32::WindowProc()": "WM_DESTROY": "pSysWnd->m_hWnd = NULL;" sollte erst nach "pWindow->Destroy();"
  aufgerufen werden damit sich alles sauber Deinitialisieren kann (z.B. "PLRendererOpenGL::SurfaceWindow::DeInit()"
  benötigte diesen native Window Handle noch einmal)



>> 10.05.2009
[SB] (PLGui3)
- Auf Verwendung von PLGraphics2 umgestellt.



>> 01.05.2009
[SB] (PLGui3)
- TrayIcon: Es fehlte an einer Stelle die Überprüfung, ob das Backend erzeugt werden konnte, wodurch es unter Linux
  zu einem Absturz kam, da hier TrayIcon noch nicht implementiert worden ist.
- WindowLinux: Da X-Window eine Größe von (0, 0) nicht mag, wird dies in der Linux-Implementierung überprüft und
  im Falle von (0, 0) auf (1,1) gesetzt.



>> 28.04.2009
[CO]
- "Gui::CloseAll()": Hier fehlte das wirkliche zerstören der Fenster. Dies wird in "Gui::DeInit()" genutzt und dortigen
  überflüssigen Code entfernt... viel in einem Projekt auf in dem man "Frontends" zur Laufzeit austauschen kann...



>> 27.04.2009
[CO]
- "WindowWin32::WindowProc()": "WM_MOUSELEAVE" hinzugefügt da ich das für ein laufendes Projekt korrekt funktionierend
  brauche... bis jetzt bekam man kein 'mouse leave' wenn die Maus von einem PLGui raus in ein 'normales' Windows fenster
  ging. (spickte bei PLGui3 wie das funktioniert :)



>> 16.04.2009
[SB]
- PLGui3Test entfernt und durch das Projekt PLSamples2/21GuiWidgets ersetzt.



>> 08.04.2009
[CO]
- "Gui": "m_lstReDrawWindows" & "m_lstTimerFired" sind nun ein "Array" anstatt "List" damit man von der "Reset()"
  Funktion profitieren kann => weniger dynamische Speicherbehandlung :D



>> 24.02.2009
[SB]
- Gui: Es wurden nur die MouseDown-Events für die linke und rechte Maustaste weitergeleitet. Habe dies so
  erweitert, dass alle Tasten durchgeleitet werden, die vom Backend kommen, allerdings wird nur für die
  linke und rechte Maustaste ein DoubleClick-Event generiert.
- Gui: Im Falle eines Doppelklicks wurde das MouseDown-Event komplett weggelassen. Das ist allerdings blöd, wenn
  einen nur das MouseDown selber interessiert. Deshalb sende ich nun in jedem Falle das MouseDown, und im Falle
  eines Doppelklicks noch zusätzlich das DoubleClick-Event hinterher. Hoffe, das bricht nichts in den bisherigen
  Applikationen.
- GuiWin32: Mittlere Maustaste für MouseDown und MouseUp hinzugefügt.



>> 21.02.2009
[CO]
- 'Gui::Init()': Seit '16.02.2009' wurde die Default Schrift anderst gesetzt wie vorher da dies in 'SystemInit()' geschieht und danach die
  Varibalen initialisiert wurden...



>> 18.02.2009
[SB]
- Linux-Version der neu eingefügten EDesktopSetting-Funktionalität korrigiert.



>> 16.02.2009
[CO]
- 'Gui': Einige Variablen wurden nicht initialisiert + 'DeInit()' und 'Init()' setzen nun alles auf bekannte
  Zustände



>> 12.02.2009
[SB]
- Graphics: DrawTiledImage() um Flags erweitert, über die z.B. nur in X oder Y Richtung gekachelt werden kann. Das wird
  im Moment benötigt, um auch dann noch vernünftig kacheln zu können, wenn man auf einem System leider keine Rectangle-Texturen
  zur Verfügung hat (siehe auch PLEngine-Diary).



>> 04.02.2009
[CO]
- 'Gui': 'EDesktopSetting' und 'SystemGetDesktopSettings()' hinzugefügt über die man z.B. gerade beim Destkop
  eingestellte Farbtiefe und Bildwiederholfrequenz ermitteln kann



>> 30.01.2009
[CO]
- 'WindowWin32': In 'SystemWrapWindow()' müssen wir unsere eigene Window Prozedure setzen - ansonnsten bekommen
  wir keinerlei Events vom Fenster. Allerdings bekommt dann die Anwendung die das 'Eingebettete' Fenster nutzt
  wiederum keine Events vom Fenster weil wir das umgeleitet haben. Daher müssen wir uns die Original
  'Window Prozedure' intern merken und 'CallWindowProc()' aufrufen. ("Window Chaining")



>> 24.01.2009
[CO]
- 'Gui': 'SystemSetMousePos()' hinzugefügt das das Gegenstück zu 'SystemGetMousePos()' darstellt und hin und wieder mal recht hilfreich ist.
  (z.B. um den Mauszeiger über das einzigste GUI Element zu plazieren so das man nur noch klicken muss)
  In PLGui3 konnte ich keine entsprechenden Funktionen finden und machte daher hier erstmal nix da ich nicht weis ob das Absicht ist.



>> 21.01.2009
[CO]
- 'GuiApplication::OnInit()': Bei 'PLEngine.cfg' & 'PLCore.cfg' stand 'Config\' im Name... was nicht sein sollte
  da dies das Loadable System automatisch handhabt und man dann 'Config\Config\' als Verzeichniss hatte was natürlich
  nicht korrekt ist.



>> 12.01.2009
[CO]
- GuiApplication: Hört nun auf das 'EventDestroy'-Event des Hauptfensters... und setzt dann den internen
  Zeiger auf NULL



>> 09.01.2009
[CO]
- 'Graphics': Neue Funktion: 'DrawTiledImage()' ist 'fast' identisch mit 'DrawImage()' nur das das Bild nicht
  'verzogen' sondern 'wiederholt' wird



>> 30.12.2008
[CO]
- 'GuiApplication::GetMainContentWindow()' hinzugefügt das einem die Fallunterscheidung abnimmt ob das 'Hauptfenster' ein 'Frame' ist oder nicht...
  denn im 'Frame'-Fall will man dann hin und wieder das 'Content'-Window haben anstatt den Frame selbst. (also ohne die Titelleiste etc. :)



>> 12.12.2008
[SB]
- Gui::Label: Farbe hinzugefügt, mit der der Text gezeichnet wird. Bisher wurden Labels nur in der Standardfarbe ausgegeben,
  was aber natürlich nicht so bleiben sollte. Darum baue ich das nun erstmal wieder direkt ein, damit man zumindest wieder
  problemlos farbige Texte ausgeben kann, bis wir auf PLGui3 umgestellt haben.



>> 05.12.2008
[CO] (+ PLGui3)
- Object::GetCommonParent()/Window::GetCommonParent(): "Optimierte" die Funktion indem ich die verkette Liste herausnahm. Ist weiterhin die gleiche
  Komplexität (+ sogar die gleiche Anzahl Zeilen Code *g*) ... aber ohne den Overhead dynamischer Speicherverwaltung.



>> 03.12.2008
[CO] (PLGui3)
- 64 Bit VC Projekt Einstellungen hinzugefügt



>> 03.12.2008
[SB]
- GuiApplication: Es gibt jetzt zusätzlich zu Run() noch die Methode Embed(), womit eine beliebige Application
  in ein fremdes Fenster eingebettet werden kann. Da hierbei davon ausgegangen werden muss, dass das übergeordnete Programm
  bereits die Message-Loop abfragt, darf die eingebettete Application das nicht noch einmal tun. Es wird also
  die Application wie gewohnt initialisiert, aber keine Messageloop ausgeführt. Nachdem das übergeordnete Programm
  beendet wurde, muss die Methode StopEmbedded() aufgerufen werden, damit die Applikation auch wieder deinitialisiert
  wird und keine Speicherlecks entstehen. Ob die übergeordnete Applikation eine PL-Applikation oder eine fremdes
  Programm ist, spielt dabei keine Rolle - um an ein PLGui::Window für ein fremdes Fenster zu gelangen, kann
  PLGui::NativeWindow() verwendet werden. Natürlich wird dies erstmal hauptsächlich z.B. für das Browser-Plugin
  oder ähnliche Situationen, wo PL in andere Applikationen/Gui-Toolkits etc. eingebettet werden soll. Durch diese
  Lösung ist es aber auch möglich, z.B. innerhalb eines Hauptfensters mehrere Application-Instanzen zu erstellen und
  diese in das Hauptfenster einzubetten. Application ist damit nicht mehr nur darauf ausgelegt, als alleiniges Programm
  mit voller Kontrolle über die Mainloop zu laufen, sondern ist flexibel genug, auch neben anderen Applications verwendet
  werden zu können.



>> 29.11.2008
[CO]
- ClassFlagsDialog::ClassFlagsDialog(): 'sValue.IsSubstring(sName)' als Abfrage ob ein Flag gerade gesetzt ist war natürlich wie Russisches Roulette...
  das ich in 'SNMMouseMoveController' verloren hatte da es hier 'RightMouseButton' & 'NoRightMouseButton' Flags gibt und dann natürlich beides mit dieser
  Abfrage ein 'true' liefert. *g*
  Der Konstruktor von ClassFlagsDialog bekommt nun direkt die gerade gesetzten Flags als 'uint32'. ClassView nutzt 'pVar->GetFlagsFromString(sValue)' um
  aus einem String 'uint32'-Flags zu machen.



>> 22.10.2008
[SB] (PLGui3)
- Shortcuts in den Menüs implementiert (z.B. bei "&File" kann man nun 'f' drücken, um das Menü/Item zu aktivieren)



>> 20.10.2008
[SB] (PLGui3)
- Separators in den Menüs implementiert (Menu, AbstractMenu und Theme).



>> 19.10.2008
[SB] (PLGui3)
- ComplexWidget: 'ActivePart' herausgenommen. Wie sich bereits beim Menü zeigte, ist eine solche Verallgemeinerung
  nicht so einfach. Es mag zwar Widgets geben, wo es genau einen 'active' part gibt (z.B. TabBar), die meisten
  Widgets haben jedoch ihre eigenen Regeln und Zustände für die enthaltenen Parts. Daher sollte das zukünftig
  in den Widgets selber über eigene Zustandvariablen verwaltet werden, die zusätzliche Informationen zu den
  im ComplexWidget enthaltenen Parts und deren Zustände speichern. In AbstractMenu ist das bereits geschehen,
  und in TabBar wurde die Funktionalität des ActivePart übernommen. ComplexWidget verwaltet nun also nur noch,
  in was für Bereiche ein Widget aufgeteilt wird (Parts), und auf welchen dieser Parts gerade mit der Maus gezeigt
  wird (Selected Part). Alles andere muß in der jeweiligen Klasse selbst verwaltet werden.
- Neue Klasse TrayIcon, die es ermöglicht, ein Icon in die SysTray einzubetten. Wie üblich nach dem Backend-Prinzip
  aufgebaut und zunächst die Windows-Version implementiert.
- Window: OnUserMessage() hinzugefügt. An diese Methode werden benutzerdefinierte Nachrichten geschickt (unter Windows
  sind das Nachrichten dessen ID >= WM_USER ist). Dies wird in TrayIconWindows verwendet, um die Nachrichten vom
  TrayIcon abzufangen.
- TrayIcon für Windows implementiert und auch alle nötigen Events eingebaut. Das dürfte erstmal reichen, um
  typische Applikationen mit Tray-Icons zu erstellen.



>> 18.10.2008
[SB] (PLGui3)
- Interfaces und Implementation von AbstractMenu noch einmal komplett überarbeitet. Alle Funktionen, wie z.B. 'Item selektieren',
  'Menu öffnen', 'Menu schliessen' spiegeln sich nun direkt im Interface der Klasse wieder und werden von den einzelnen
  Steuerungsmöglichkeiten, also Tastatur und Maus, nur noch aufgerufen. Dadurch wird die gesamte Steuerung der Menus einheitlicher
  und einfacher, und doppelter Code wird vermieden. Die Tastatursteuerung wurde dadurch noch einmal etwas übersichtlicher und
  ist meiner Meinung nach nun kaum noch von anderen Windows-Programmen zu unterscheiden.
- MenuHelper entfernt und die Funktionalität direkt in AbstractMenu untegebracht. Es wird allerdings immer noch ein verstecktes
  Fenster für den Focus benutzt, da man ansonsten keine FocusLost()-Meldung bekommt, wenn man auf den Frame klickt, in dem
  das Menu eingebettet ist.
- Optionen für die Orientation von Submenus hinzugefügt. Damit kann festgelegt werden, ob ein Menü seine Submenu nach links
  oder rechts sowie nach oben oder unten aufmachen soll. Wenn ein Menu am Rand geöffnet werden soll, wird automatisch die
  Richtung geändert, damit das Menü komplett auf den Bildschirm passt. Diese Richtung wird von Menu zu Menu 'vererbt', damit
  die Menus sich gleichmäßig über den gesamten Bildschirm verteilen und nicht am Rand 2 Menus Ping-Pong-artig hin- und herwechseln.
  Für MenuBars gibt es nur Up/Down, hier kann es auch interessant sein, von Anfang an ein Menu nach oben zu öffnen (siehe Beispiel),
  falls z.B. die MenuBar unten im Frame angeordnet wird
- Window: Method GetScreen() hinzugefügt, die den Screen zurückgibt, auf dem sich ein Fenster gerade befindet. 



>> 14.10.2008
[SB] (PLGui3)
- Tastatursteuerung noch etwas verfeinert - wenn z.B. links gedrückt wird, während das erste Menü einer Menübar
  geöffnet ist, wird das jetzt als "wähle das Menü links davon aus" interpretiert, und nicht mehr als "schließe
  das Untermenü". Genauso kann man dort jetzt auch rechts drücken, um zum nächsten Menü zu gelangen, auch wenn man
  sich weit unten in einer Hierarchie von Untermenüs befindet. Die Implementation schaut dabei auf den Orientation-Wert
  des obersten Menüs, der nur bei Menü-Bars auf "Horizontal" steht.
- Tastatursteuerung generell noch etwas überarbeitet. Das sollte nun erstmal abgeschlossen sein, es läßt sich zwar
  nicht 100%ig so bedienen wie Windows-Menüs (wobei die bestimmt auch nicht alle konsistent sind), sollte aber
  denke ich so gut genug sein :-)



>> 12.10.2008
[SB] (PLGui3)
- Beim Öffnen von Untermenüs bleibt das Item dieses Menüs nun selektiert und damit blau unterlegt
- Die Tastatursteuerung von Untermenüs folgt jetzt dem Mauscursor, da mir dies am intuitivsten erscheint



>> 12.10.2008
[CO]
- GuiApplication: Wie besprochen gibt 'OnCreateMainWindow()' nix mehr zurück sondern das Hauptfenster wird 'direkt' hier gesetzt



>> 11.10.2008
[SB] (PLGui3)
- Theme: Draw-Funktionen für die Menüs so umgebaut, dass ein Zeiger direkt auf das Widget übergeben wird, anstatt
  alle wichtigen Daten nochmal per Hand zu übergeben. So wird wohl das gesamte Theme Stück für Stück umgebaut werden,
  da es so einfach sinnvoller scheint.
- MenuBar: Das gerade geöffnete Menü wird nun weiß unterlegt.
- PopupMenu: Der Pfeil neben einem Item wird jetzt nur noch für Submenus angezeigt.



>> 11.10.2008
[CO]
- GuiApplication::OnInit() & GuiApplication::OnExit(): Teile von dem was bisher in 'PLEngine::PL' lag hierher verschoben.
  Das ist keineswechs 'final' sondern nur dazu gedacht das alles wie gehabt läuft und man schonmal das grob so hat wie
  es sein 'könnte'.
- 'GuiApplication::OnInit()' hat nun bool Rückgabewert der Anzeigt ob die Initialisierung erfolgreich war oder nicht, im Fehlerfall
  kann die Anwendung direkt wieder beendet werden... :D
- GuiApplication: 'SetMainWindow(OnCreateMainWindow())' von 'OnRun()' in 'OnInit()' verschoben. Es ist einfach sehr unhandlich wenn
  diese 'Set'-Funktionen 'nach' der 'OnInit()'-Funktion kommen. Das gleiche gilt für alle weiteren Application-Klassen. In PLSceneViewer
  wird z.B. in der 'OnInit()'-Funktion direkt die Szene geladen, das ist sehr komfortabel, ging aber bis jetzt nicht da zu diesem Zeitpunkt
  die Szene an sich noch nicht erzeugt wurde.
- PLGui: GuiApplication: 'OnExit()' in 'OnDeInit()' umbenannt damit das konsistent zu ähnlichen Stellen ist



>> 10.10.2008
[SB] (PLGui3)
- AbstractMenu: Tastatursteuerung eingebaut :-)



>> 09.10.2008
[SB] (PLGui3)
- WindowWindows: Die Nachricht WM_MOUSEACTIVATE wird nun abgefangen und setzt den Focus auf das "aktivierte" Fenster,
  falls dieses das entsprechende MouseFocus-Flag besitzt. Ich hatte das Problem, dass zuvor nur Top-Level Windows
  (wie z.B. PopupMenus, die ja keinen Parent besitzen) den Focus bekamen, wenn man drauf klickte, nicht jedoch die
  MenuBar, die in einem Frame eingebettet ist. In dem Fall bekam der Frame den Focus, nicht aber die Menubar. Ich
  hoffe, diese Lösung funktioniert nun, und macht nicht später anderswo Probleme ...
- AbstractMenu: Verhalten der Menüs in Bezug auf Mausevents genau ausgetüftelt. Es verhält sich nun genau so, wie
  ich das eigentlich erwarten würde und wie es bei anderen Programmen auch der Fall zu sein scheint (z.B. lassen
  sich Menüs auch wieder schließen, wenn man noch einmal drauf klickt, Menüs lassen sich auch öffnen wenn man die
  Maustaste gedrückt hält und aktivieren ein Item beim Loslassen der Taste, etc.).
- AbstractMenu: Orientation hinzugefügt, damit man zwischen horizontal (MenuBar) und vertikal (PopupMenu) angeordneten
  Menu-Widgets unterscheiden kann.



>> 08.10.2008
[SB] (PLGui3)
- Window::OnLooseFocus() um einen Parameter erweitert, über den das neue Focus-Window übergeben wird
- AbstractMenu: Alle wichtigen Funktionalitäten aus MenuBar und PopupMenu vereinheitlich und in die Basisklasse
  verschoben, da beide Widgets sich bis auf ganz wenige Kleinigkeiten identisch verhalten sollten. Das gesamte
  Verhalten, wie das Öffnen von Untermenüs etc., konnte daher nun einheitlich in AbstractMenu implementiert werden,
  wobei es mir gelungen ist, das so einfach wie möglich zu halten (trotzdem ist die Bedienung weit einfacher
  und Windows-ähnlicher als im alten Gui). Es werden eigentlich nur ButtonDown und ButtonUp benutzt und einige
  Statusvariablen, in denen gespeichert ist, ob gerade ein Untermenü geöffnet ist.
- Neue Klasse MenuHelper hinzugefügt. Das ist ein unsichtbares Fenster, das dazu benutzt wird, um Focus und
  Keyboard-Nachrichten im Zusammenhang mit den Menüs zu verwalten. Ich habe es zunächst ohne versucht, aber dann
  ist es äußerst kompliziert, z.B. alle Menüs auf einmal zu schließen, wenn ausserhalb der Menüs geklickt wird.
  Zwar könnte ein Menü auf LostFocus reagieren, aber diese Nachricht kommt ja auch dann, wenn zwar das aktuelle
  Menü nicht mehr den Focus hat, dafür aber z.B. ein Menü darüber oder darunter - in dem Fall darf aber nicht
  das gesamte Menü geschlossen werden, was das Widget selbst jedoch nicht unterscheiden kann. Weitere ähnliche
  Probleme wird es auch mit der Maus geben, wenn z.B. ein Untermenü geöffnet wird, jedoch noch die Steuerung
  des vorherigen Menüs mit der Tastatur möglich sein müßte. Darum erzeuge ich nun ein einziges Helper-Widget und
  gebe diesem Fenster den Focus und einen Zeiger auf das gesamte Menü - das macht es wesentlich einfacher, die
  Steuerung des gesamten Menüs global zu verwalten, und wenn der Focus verloren geht kann gleich nachgeprüft werden,
  ob noch ein Teil des Menüs aktiv ist oder ein fremdes Fenster den Focus bekommen hat.



>> 07.10.2008
[SB] (PLGui3)
- MenuItem: Command-ID hinzugefügt, die bei einem Event übergeben werden soll
- AbstractMenu hinzugefügt, damit die Menü-Funktionalität in einer Basisklasse zusammengefasst werden kann. MenuBar
  und PopupMenu von dieser neuen Klasse abgeleitet.
- AbstractMenu: Event für das Anklicken eines Menu-Items hinzugefügt
- AbstractMenu: Methode 'ShowSubMenu' hinzugefügt, die ein neues PopupMenu öffnet zur Darstellung eines Untermenüs
  Dabei wird das Menu-Event des SubMenus abgefangen und weitergeleitet, so dass automatisch das Event beim
  obersten Menu ankommt, mit dem sich die Applikation verbunden haben sollte
- WindowWindows: SetVisible() nutzt nun SW_SHOWNA, damit der Focus nicht automatisch gesetzt wird, wenn ein Fenster
  sichtbar gemacht wird. Oh mann, das ist so ein Gefummel, bis man diesen ganzen Kram endlich mal sauber getrennt hat ...



>> 06.10.2008
[SB] (PLGui3)
- Window: In SetZPos() den Default-Wert pWindow = NULL hinzugefügt, da man das Fenster nur braucht, wenn man die
  Fenster relativ zueinander anordnen will. Meist sagt man aber eher SetZPos(Top)
- Window: KeyUp und KeyDown bekommen nun neben der gerade gedrückten Taste auch noch die zur Zeit gedrückten Modifier-Keys
  übergeben (Alt, Ctrl etc.). Ansonsten ist es schwierig, auf z.B. Shift+Taste oder Ctrl+Taste zu reagieren, weil ein
  Windows dies dann selber speichern müßte, und wenn ein Modifier gehalten wird, während der Focus zu einem anderen
  Window wechselt (z.B. Shift+Tab), weiß dieses neue Focus-Window dann natürlich nichts vom Modifier
- Window: Testweise Shift+Tab implementiert
- MenuBar: Erste Tests, Menüs zu öffnen
- MenuItem und Menu: IsMenu() hinzugefügt, damit man unterscheiden kann, ob es sich um ein Submenu oder Item handelt
- WindowWindows: In 'CreateRegularWindow' wurde nach dem Erzeugen des Fensters automatisch das Fenster angezeigt,
  in den Vordergrund geschoben und der Focus gesetzt. Da das aber alles aus dem Window-Konstruktor ausgerufen
  wird, führte dies dazu, dass die Nachrichten zu früh generiert wurden, noch bevor die Konstruktion des jeweiligen
  Windows abgeschlossen ist, was dazu führte, dass die entsprechenden virtuellen Funktionen nicht aufgerufen
  wurden. Nachdem ich das komplett entfernt hatte, kamen die Focus-Nachrichten endlich korrekt beim jeweiligen
  Fenster an, und auch das Hauptfenster öffnet sich nun plötzlich zuverlässig im Vordergrund :-D
- GuiApplication: Änderungen aus PLGui nach PLGui3 übernommen und angepasst



>> 06.10.2008
[CO]
- About-Dialog: 'GetApplicationName()' & 'SetApplicationName()' in 'GetApplicationTitle()' & 'SetApplicationTitle()' umbenannt damit
  konsistent zu 'PLCore::Application::SetTitle()'



>> 05.10.2008
[CO]
- GuiApplication::OnInit(): Ruft kein "ChangeIntoAppDirectory()" mehr auf, das bleibt super spezialisierten Application Klassen
  vorbehalten :D
- 'PLCore::Application': 'OnInit()' in 'GuiApplication' verschoben
- GuiApplication: 'OnShutDown()' entfernt, 'ShutDown' wird nun in PLGui umgeleitet



>> 30.09.2008
[SB] (PLGui3)
- Frame: SetFullscreenEnabled hinzugefügt, damit kann bestimmt werden, ob ein Frame mittels Alt+Enter in den Fullscreen-Modus
  geschaltet werden kann. Der Standardwert ist 'false', denn normale Frames sollten diese Funktion nicht bieten.
- Das Zeichnen des Hintergrundes unter Windows basiert nun wieder auf dem Wert von sPaint.fErase, dafür wird die
  Nachricht WM_ERASEBKGND nicht mehr behandelt. Damit flackert das Fenster beim Vergrößern/Verkleinern deutlich weniger,
  auch wenn es dafür beim zu schnellen ziehen Grafikfehler geben kann (was aber bei anderen Programm auch so ist).
  Ach ja, die Windows-Logik ist einfach total konfus ...
- Buttons: Es wird nun nicht mehr grundsätzlich neu gezeichnet, wenn die Maus das Widget betritt oder verlässt. Dies ist
  nur notwendig, wenn das Control da eine visuelle Rückmeldung (z.B. Farbänderung) geben will, und daher sollte man das auch
  nur dann machen, ansonsten flackern die Controls unnötig. Nun flackert bei mir fast nichts mehr :-)
- Window: Color zu BackgroundColor gemacht, da dies einfach deutlicher darstellt, wofür die Farbe verwendet wird.
- FocusStyle hinzugefügt. Damit kann man bestimmen, ob und wie ein Window den Keyboard-Focus erhalten kann.
- AbstractButton: Logische Funktionen für das "Drücken" und "Loslassen" des Buttons hinzugefügt, damit man diese in
  verschiedenen Situationen (z.B. Mauseingabe und Tastatureingabe) nutzen kann.
- AbstractButton: Buttons akzeptieren nun generell den Focus und lassen sich dann auch per Tastatur steuern (Space).
- Testweise die Anzeige eines gepunkteten Rahmens eingebaut, wenn ein Widget den Focus hat (im Moment nur bei Buttons benutzt)
- Nochmal genau das Malen von Rahmen und Boxen durchgegangen. Irgendwie ist das bei Windows total komisch, wenn ich Rectangle mit
  z.B. Pos1=(0, 0) und Pos2=(3, 3) aufrufe, bekomme ich 3 Pixel (statt 4, die ich eigentlich will). Ok, also scheint die zweite
  Ecke ausgeschlossen zu werden, damit an sich könnte ich ja noch leben. Aber ich habe es überhaupt nicht hinbekommen, mit dieser
  Funktion genau *einen* Pixel zu zeichnen! Pos1=(0, 0) und Pos2=(1, 1) gibt keinen Pixel aus. Und ab (2, 2) habe ich dann wieder
  gleich 2*2 Pixel. Habe jetzt also einen manuellen Check eingebaut und nutze in dem Falle die Linienfunktion - total
  blöd, aber funktioniert jetzt wenigstens...
- Testweise mal Tab-Stops implementiert. Das muss aber noch überlegt werden, wie man das genau lösen will ...



>> 29.09.2008
[SB] (PLGui3)
- GuiApplication: Kommandzeilen-Option "--display" hinzugefügt. Hierüber kann bestimmt werden, auf welchem Screen die Applikation
  angezeigt werden soll. Wird diese Option angegeben, so versucht die GuiApplikation nach dem Öffnen des Fensters, dieses
  automatisch auf den angegebenen Screen zu verschieben. Gerade unter Linux ist dies eine Standardoption und daher ist es oftmals
  ein Ärgernis, wenn diese fehlt. Daher ist es denke ich gut, wenn in PL jede Gui-Applikation das gleich von Haus aus mitbringt :-)
- Gui: GetScreenSize() entfernt, statt dessen sollte nun GetDefaultScreen()->GetSize() verwendet werden.
- Zugriff auf das Desktop-Window hinzugefügt, falls man mal ein Fenster direkt im Desktop einbetten will. Da dies etwas anderes
  ist als das Root-Window, das sozusagen als virtueller Parent für alle Fenster fungiert, habe ich das noch etwas kommentiert,
  damit der Unterschied deutlich wird.
- Hotkey-Funktionalität aus PLGui2 hinzugefügt.
- Window: OnWindowState() hinzugefügt. Diese Methode wird aufgerufen, wenn der Status eines Fenster (z.B. Maximized oder Normal)
  geändert wurde.
- Window: OnFullscreen() hinzugefügt. 'Fullscreen' wird in PLGui3 genauso als Window-State behandelt wie 'Normal', 'Maximized'
  und 'Minimized'. Damit kann also jedes Fenster in den Vollbildmodus geschaltet werden, wobei das bei normalen Fenstern erstmal
  keinen Unterschied zu 'Maximized' macht. Theoretisch kann so natürlich auch ein Button oder ähnliches in den Fullscreen-Modus
  geschaltet werden, was erstmal merkwürdig erscheint. Allerdings stellt dies kein Problem dar, denn ebenso war es ja schon immer
  möglich, einen Button z.B. zu maximieren, obwohl das natürlich wenig sinnvoll ist. Da ein Button aber ja keine Titelleiste hat,
  kann der Benutzer diese Funktion überhaupt nicht anwenden, und ebenso kann 'Fullscreen' nur durch einen Hotkey aktiviert
  werden, der erst in Frame registriert wird. Der Programmierer kann also weiterhin Unsinn treiben, aber davor sollte man ihn
  auch nicht bewahren, denn evtl. gibt es ja tatsächlich mal eine Situation, wo das tatsächlich gewollt ist :-)
- Ein Frame kann nun in den Vollbildmodus geschaltet werden und blendet dann automatisch Titelleiste und Rahmen aus. Nun müßte
  noch überlegt werden, wie man bestimmen will, welche Frames das tun sollen und welche nicht (Flag? Oder eigene Klasse?)



>> 27.09.2008
[SB] (PLGui3)
- Klassen und Funktionen hinzugefügt, um die auf einem System verfügbaren Screens zu verwalten (z.B. mehrere Monitore).
  In der Gui können dabei alle vorhandenen Screens aufgezählt sowie deren Position und Größe abgefragt werden.
  Fenster können auf einen anderen Screen gelegt werden, oder relativ zu einem gegebenen Screen zentriert werden.



>> 22.09.2008
[SB] (PLGui3)
- Habe PLGui3 nun als eigenständiges Projekt direkt in den Trunk gelegt, anstatt es wie bisher als einen Branch von PLGui
  zu behandeln. Das Arbeiten mit Branches dieser Art ist irgendwie überhaupt nicht angenehm, da man ständig hin- und her
  'switch'en müsste, um auch den Branch immer aktuell zu halten, und das ist irgendwie nicht praktikabel. So als eigenständiges
  Projekt dürfte dies nun kein Problem mehr sein, und aufgrund unterschiedlicher Namensräume und Projektnamen können das aktuelle
  PLGui und PLGui3 auch problemlos nebeneinander stehen.
- Diaries gemerged, alles was sich auf PLGui3 bezieht habe ich mit (PLGui3) gekennzeichnet und werde das auch weiterhin so machen,
  bis wir dann PLGui komplett durch PLGui3 ersetzen :-)



>> 07.09.2008
[CO]
- "PLGui.pak": Die Bilder liegen nun in einem "GuiPL/"-Unterordner damit es nicht zu schnell zu Namenskonflikten kommen
  kann



>> 23.08.2008
[CO]
- Nur bei Haupt-Header 'Win32' zu 'Windows' gemacht da für 32 Bit als auch für 64 Bit... da wir derzeit hier einen 'Windows'
  Ordner haben konnte man die Windows Backend Klassen nicht so ohne weiteres zu 'Windows' machen. :/
  Da sollten wir bei PLGui3 direkt schaun das dies hier nicht mehr der Fall ist...



>> 21.08.2008
[SB]
- Slider: Da wir nun schon die PLGui2 auf Events umgestellt haben, möchte ich es auch etwas komfortabel haben ;-)
  Habe daher den Slider um ein Event erweitert, das aufgerufen wird, wenn der Wert des Sliders sich verändert hat.



>> 20.08.2008
[SB]
- HTMLView entfernt (siehe auch PLGeneral-Diary)



>> 17.08.2008
[CO]
- 'Hot Key'-Funktionen hinzugefügt. Dies wird benötigt wenn man z.B. 'Alt-Return' zum Vollbild-Modus wechseln nehmen will was eine
  recht gängige Kombination ist. Momentan musste 'Strg-Alt-Return' gedrückt werden.



>> 08.08.2008
[CO]
- ClassView: ColorDialog & ClassFlagsDialog sind hier nun immer Topmost, das macht das Arbeiten damit etwas bequemer da diese Fenster
  nicht so einfach unter irgendetwas anderem verschwinden wenn man kurz etwas in einem anderen Fenster anklickt



>> 07.08.2008
[CO]
- ColorDialog: 'EventColorChange'-Event hinzugefügt damit man von außen mitbekommen kann wenn die Farbe verändert wurde
- ColorDialog::SetSelectedColor() -> Eine Funktion die 'Color4' bekommt reicht
- ColorDialog: Speichert intern nun die übergebene 'Original'-Farbe, wird der Dialog 'abgebrochen' wird auf diese Farbe zurückgesetzt
- ClassView: Noch während man in einem ColorDialog an den Farben dreht sieht man sofort die Auswirkungen
- ClassFlagsDialog: 'EventFlagsChange'-Event hinzugefügt damit man von außen mitbekommen kann wenn die Flags verändert wurden
- ClassFlagsDialog: Speichert intern nun die übergebenen 'Original'-Flags, wird der Dialog 'abgebrochen' wird auf diese Flags zurückgesetzt
- ClassView: Noch während man in einem ClassFlagsDialog an den Flags dreht sieht man sofort die Auswirkungen



>> 06.08.2008
[CO]
- GuiApplication: In 'OnShutDown()' wird das GUI beendet
- 'EventExit' in 'Gui'-Klasse eingebaut das erzeugt wird wenn 'Exit()' aufgerufen wird
- 'GuiApplication' hört auf das 'EventExit' der 'Gui'-Klasse und ruft dann selbst 'ShutDown' der 'Application'-Klasse auf
  (in der alten 'PL::Update()'-Funktion wird das über Polling gemacht)



>> 05.08.2008
[CO]
- 'Window'-Klasse um Events erweitert
- 'Window::OnDeActivate()' zu 'Window::OnDeactivate()' gemacht
- 'OnSize()' Methoden auf PLGui3-Style (Vector2i) umgestellt
- 'OnMove()' Methoden auf PLGui3-Style (Vector2i) umgestellt
- 'MouseMove()' Methoden auf PLGui3-Style (Vector2i) umgestellt
- 'OnLButtonDown()', 'OnLButtonUp()', 'OnLButtonDoubleClick()', 'OnRButtonDown()', 'OnRButtonUp()' und 'OnRButtonDoubleClick()'
  Methoden auf PLGui3-Style ('OnMouseButtonDown', 'OnMouseButtonUp', 'OnMouseButtonDoubleClick' + Vector2i) umgestellt
- 'WindowListener' und 'WindowInformer' Klassen entfernt und dort wo diese genutzt wurden auf Events umgestellt
- Timer auf PLGui3 Event-Style umgestellt + 'TimerListener' und 'TimerInformer' Klassen entfernt und dort wo diese genutzt
  wurden auf Events umgestellt
- 'Listener' und 'Informer' Klassen entfernt, diese wurden nirgends verwendet
- 'DialogListener' und 'DialogInformer' Klassen entfernt, diese wurden nirgends verwendet



>> 23.07.2008
[SB]
- Neues Control: HTMLView implementiert. Diese Control soll ein kleiner HTML-Viewer sein, der aber nicht dafür gedacht ist, echte
  Webseiten anzuzeigen. Unterstützt wird nur ein HTML-Subset, um z.B. kleine Infotexte oder ähnliches darzustellen.



>> 17.07.2008
[CO]
- GuiLoaderPL: Um Format Versions Informationen erweitert



>> 04.07.2008
[CO]
- GuiApplication: 'OnCreateMainFrame()' in 'OnCreateMainWindow()' umbenannt da mich das jedesmal etwas irritierte das der Funktions
  Name von 'Frame' spricht, es aber tatsächlich ein abstrakteres 'Window' ist. (Bei GetMainWindow() und SetMainWindow() das gleiche)
  Ich hatte ein weilchen hin und her überlegt ob man 'OnCreateMainFrame()' nicht lassen sollte und stattdessen hier auf 'Frame'
  umsteigen sollte - das würde z.B. das ändern des Frame-Titels etwas vereinfachen da man nicht casten müsste, entschied mich dann
  aber dagegen da es etwas 'einschränkend' wäre.



>> 28.06.2008
[SB]
- Habe die Möglichkeit eingebaut, ein PLGui::Window für ein bereits bestehendes System-Fenster zu erzeugen. Wenn man ein
  System-Handle für ein schon bestehendes Fenster übergibt, wird dieses gewrappt anstatt ein eigenes neues Fenster zu erstellen.
  Das brauchen wir, sobald wir die Engine mal in andere Fenster einbetten wollen oder z.B. mit anderen Gui-Toolkits wie Qt,
  Gtk oder wxWidgets verkoppeln wollen.  



>> 27.06.2008
[CO]
- GuiApplication: In 'OnInit()' wird die GUI initialisiert, in 'OnExit()' De-Initialisiert
- Gui: Neue Funktion: 'IsInitialized()'



>> 09.06.2008
[SB] (PLGui3)
- Neue Klasse PopupMenu hinzugefügt.
- Theme: DrawMenu und DrawMenuItem angepasst.
- Theme: Beim Zeichnen der Tabbar wird nun der gerade aktive Tab immer weiß angezeigt, auch wenn die Maus
  den Tab gerade markiert (sieht so irgendwie hübscher aus).



>> 29.05.2008
[SB] (PLGui3)
- Theme: DrawTabBar und DrawMenuBar hinzugefügt.
- Neue Klasse ComplexWidget hinzugefügt. Diese Klasse kann für Fenster verwendet werden, die intern aus mehreren
  Teilen bestehen, aber dafür keine eigenen Childwindows erzeugt. Die Klasse bietet dafür Hilfsfunktionen wie
  z.B. das Auffinden von Parts unter der Maus oder das auswählen von bestimmten Parts.
- TabBar auf ComplexWidget umgestellt.
- MenuBar auf ComplexWidget umgestellt.
- MenuBar: Die Größe der einzelnen Parts wird nun auch im Theme bestimmt, da diese je nach Theme unterschiedlich
  ausfallen kann. Daher trägt das Theme beim Zeichnen der Menubar die Position und Größe der einzelnen Parts
  in die Part-Liste ein, welches dann vom Control verwendet wird, um z.B. den aktuell ausgewählten Part zu ermitteln.
  Dadurch ist die Größe der Menü-Items nun endlich auch variabel :-)



>> 28.05.2008
[SB] (PLGui3)
- TabBar implementiert: Dieses Widget zeigt eine Reihe von Tabs an. Funktionalität für das Zeichnen von Tabs im
  Theme etwas angepasst.
- MenuBar hinzugefügt: Diese Widget zeigt ein Menü in Form einer horizontalen Menübar an. Funktionalität für das
  Zeichnen von Menüs im Theme etwas angepasst.



>> 27.05.2008
[SB] (PLGui3)
- MenuItem und Menu hinzugefügt. Dies sind reine Datenklassen zur Definition von Menüstrukturen, sind aber nun vom
  eigentlichen Widget entkoppelt.



>> 26.05.2008
[SB] (PLGui3)
- ImageToggleButton: Die möglichen Grafiken etwas geändert, es gibt nun für jeden Check-State (Checked,
  NotChecked und PartiallyChecked) jeweils ein Bild für Selected und für Unselected. Ausserdem noch ein
  einziges Bild für Disabled. Insgesamt also 7 mögliche Bilder, dafür aber keines mehr für Pushed.
- AbstractToggleButton: es kann nun festgelegt werden, ob der State 'PartiallyChecked' erlaubt ist oder nicht.
  SetChecked löst nun ausserdem auch ein Event aus, wenn damit der Zustand des Buttons verändert wurde.
- Neue Klasse ButtonGroup hinzugefügt, mit der ToggleButtons zu Gruppen zusammengefasst werden können. Die Klasse
  ist extrem einfach gehalten und legt zur Zeit noch nicht einmal eine Liste der Buttons an, da dies eigentlich
  gar nicht gebraucht wird. Sie speichert nur einen Zeiger auf den aktuell aktivierten Button (oder den letzten
  aktivierten, wenn mehrere aktiviert sein können), und löst ein Event aus, sobald sich dieser verändert. Die
  Buttons registrieren ein Callback auf dieses Event, wenn sie der Gruppe hinzugefügt werden, und können daher
  darauf reagieren. Sollte später mal mehr benötigt werden, ist das schnell hinzugefügt, aber erstmal hielt ich
  einfacher für besser :-)
 


>> 25.05.2008
[SB] (PLGui3)
- Enabled: Ist nun nur noch eine Eigenschaft des virtuellen Fensters und wird nicht mehr im Backend kontrolliert. Dies
  sollte so funktionieren, da das Backend diese Eigenschaft eigentlich nicht benötigen sollte und wir ja sowieso alle
  Controls selber implementieren. Wenn es damit Probleme geben sollte, könnten wir das aber wieder ändern.
- Das Verhalten von Buttons komplett überarbeitet, damit sich Buttons genau so verhalten, wie man das erwartet (beispielsweise
  wenn die Maus den Button mit gehaltener Maustaste verlässt und dann wieder zurückbewegt wird etc.). Dafür musste
  die Logik etwas überarbeitet werden und auch MouseCapture verwendet werden, um die Mausbeweungen bei gedrückter
  Maustaste genau beobachten zu können.
- Die gesamte Logik von Buttons in der Klasse AbstractButton zusammengefasst und überarbeitet. Es gibt nun drei Events,
  die der Button aussendet: EventPressed, EventReleased und EventClicked. Jeder Button kann einen Text und ein
  Image besitzen - ob diese jedoch angezeigt werden, hängt vom jeweiligen Button-Typus ab. Ausserdem wird auch das
  wiederholte Klicken bei gedrückter Maustaste in AbstractButton festgelegt, hierfür können zwei Optionen gesetzt
  werden: RepeatDelay (die Zeit vom Drücken der Maustaste bis zum ersten Click-Event) und RepeatInterval (die Zeit
  zwischen zwei Clicks). Durch diese Unterteilung von Logik und Aussehen ist es sehr einfach, neue Button-Controls
  zu implementieren, da dafür eigentlich nur noch die Draw-Methode überschrieben werden muss. Dadurch lassen sich die
  Unterschiede zwischen den vielen Button-Arten leicht in unterschiedliche Klassen aufteilen, was wesentlich übersichtlicher
  ist als früher, wo alles zusammen in einer großen Klasse vereint war.
- Abgeleitet von AbstractButton gibt es nun ebenfalls eine Klasse AbstractToggleButton, welche die gesamte Logik für
  Toggle-Buttons enthält. Ein Toggle-Button kann dabei drei Zustände haben (NotChecked, Checked oder PartiallyChecked).
  Immer, wenn der Button gedrückt wurde, wird der Zustand entsprechend umgeschaltet und ein Event ausgesendet.
- Klasse Button implementiert: Ein normaler rechteckiger Button, der einen Text und optional ein Bild anzeigt.
- Klasse ToggleButton implementiert: Ein normaler rechteckiger Toggle-Button.
- Klasse CheckBox implementiert: Eine Checkbox, basierend auf AbstractToggleButton.
- Klasse RadioButton implementiert: Ein RadioButton, basierend auf AbstractToggleButton.
- Klasse BitmapButton implementiert: Ein Button, der nur aus Images für den jeweiligen State besteht. Besonders für Ingame-GUIs. 
- Klasse BitmapToggleButton implementiert: Ein Toggle-Button aus Images. Siehe oben.



>> 23.05.2008
[SB] (PLGui3)
- Win32: Alle wichtigen Maus-Events werden nun abgefangen und weitergegeben (MouseDown, MouseUp und DoubleClick für
  LeftButton, RightButton und MiddleButton).
- Neues enum EMouseButton hinzugefügt (das ist einfach lesbarer, man kann aber natürlich auch weiterhin einfach von 0
  an durchzählen).
- Standard Theme: Double-Click auf die Titelleiste maximiert nun wie im Native-Gui von Windows das Fenster.
- Standard Theme: Die Größe oder Position eines Fensters läßt sich nun nur noch dann verändern, wenn das Fenster gerade
  nicht maximiert ist.
- Standard Theme: Das Verschieben und Vergrößern/Verkleinern von Fenstern noch etwas abgerundet (z.B. genau darauf
  geachtet, wann der MouseCursor geändert wird etc.)
- Mit der Zeit werden bestimmt noch viele Modifier implementiert werden, die irgendwie total offensichtlich sind und
  ganz allgemein für alle möglichen Fenster nützlich sind. Habe einen solchen "Obvious-Modifier" hinzugefügt: ModTimeout,
  der ein Fenster nach x Sekunden automatisch wieder schließt (man denke an Splash-Screens).
- Window: IsActive() und Activate() hinzugefügt, dies kann aber erst richtig getestet werden, wenn das mit dem Fokus
  bereits implementiert ist und es auch einige Controls gibt, die den Fokus verwenden. Das aktive Fenster ist dasjenige
  top-level Fenster, in dem das Control vorhanden ist, welches den Fokus beinhaltet. Als ausnahme kann es auch sein,
  dass ein Popup-Window, das zu diesem Window gehört, den Focus beinhaltet (beispielsweise ein komplizierter Tooltip
  mit Treeview o.ä.). Beim aktivieren eines Fensters muss also der Fokus korrekt gesetzt werden, ebenso muss ein
  Fenster aktiviert oder deaktiviert werden, wenn der Fokus auf ein anderen Fenster gesetzt wird.
- Window: GetTopLevelWindow hinzugefügt. Diese Methode gibt einen Zeiger auf das Top-Level Window zurück, zu dem das
  aktuelle Fenster gehört.
- Window: Noch einmal genau das Zeichnen von Fenstern überarbeitet. Zunächst wird unterschieden, ob der Hintergrund eines
  Fensters auch gezeichnet werden muss oder nicht. Diese Information bekommt man zumeist vom System übermittelt, unter
  Window wird beispielsweise der Hintergrund immer neu gezeichnet, wenn die Größe eines Fenster verändert wird, nicht aber
  wenn das Fenster nur verschoben wird. In PLGui wird dafür die Methode DrawBackground() aufgerufen, die folgendes tut:
  Als erstes wird die Hintergrundfarbe des Fensters gezeichnet, sofern diese gesetzt ist (Standard: Weiß). Wenn man dies
  nicht möchte, z.B. weil das Fenster transparent sein soll oder weil der Hintergrund komplett selber gezeichnet wird,
  sollte man diese Farbe mittels Window::SetColor() auf Transparent setzen. Als nächstes wird die virtuelle Methode
  OnDrawBackground aufgerufen, in der ein Fenster festlegen kann, wie der Hintergrund gezeichnet wird. Nach dem Zeichnen
  des Hintergrundes wird wie bisher die Funktion Draw() aufgerufen, die ihrerseits die virtuelle Methode OnDraw() aufruft.
  Auf diese Weise kann nun sehr genau festgelegt werden, wie der Inhalt eines Fensters und dessen Hintergrund gezeichnet
  werden soll. Im allgemeinen sollte man aber nach wie vor nur die Methode OnDraw() benötigen, mit dem Hintergrund sollte
  man nur arbeiten, wenn es dafür wirklich einen Grund gibt und man so bspw. Flackern verhindern kann.
- Win32: Die Window-Styles waren extrem merkwürdig gesetzt. Das fiel mir auf, als ich nach dem Grund suchte, warum beim
  Neuzeichnen eines Fensters alle Controls in der Titelleiste ständig flackern. Der Grund lag einfach darin, dass beim
  Zeichnen der Titelleiste zunächst ein blauer Kasten gemalt wird, der auch den Inhalt der darauf liegenden System-Buttons
  komplett übermalt. Danach werden die System-Buttons wieder drüber gemalt, was dann natürlich das Flackern auslöst.
  Beim Vergrößern oder Verkleinern von Fenstern fiel dies extrem negativ auf, weil hier ständig der gesamte Fensterinhalt
  neu gezeichnet wird, und somit ständig die Buttons übermalt und wieder neu gemalt werden. Eigentlich sollte dies aber
  nicht der Fall sein, weil Windows die Bereiche eines Fensters, die von Child-Windows verdeckt werden, beim Zeichnen
  automatisch clippen sollte. Daher schaute ich mir die Window-Flags an und merkte, dass die entsprechenden Flags nicht
  gesetzt waren. Vorher sah es so aus:
	uint32 nWinStyle = hParent ? (WS_CHILD | WS_CLIPSIBLINGS) : (WS_POPUP);
  Das habe ich nun geändert in:
	uint32 nWinStyle = (hParent ? WS_CHILD : WS_POPUP) | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;
  Child-Windows und Sibling-Windows sollten nun also immer geclippt werden, wodurch nun auch endlich nichts mehr flackert.
  Ich weiß nicht, warum das so merkwürdig gesetzt war, dies war aber in der alten Gui auch schon so. Sollte dies einen
  speziellen Grund gehabt haben, warum WS_CLIPCHILDREN normaler Weise nicht gesetzt wurde (evtl. ist dies für transparente
  Fenster nötig), müssen wir hier einen Weg finden, für diese speziellen Fenster einen Sonderweg zu gehen. Aber bitte
  auf keinen Fall diese Flags wieder herausnehmen, da dies für das extreme Flackern der PLGui verantwortlich war, was
  einen extrem instabilen und unschönen Eindruck machte!



>> 12.05.2008
[SB] (PLGui3)
- Mouse-Cursor für Windows implementiert
- SetMouseCursor und SetMouseVisible in Gui eingebaut



>> 11.05.2008
[SB] (PLGui3)
- Die System-Buttons werden nun komplett über das Theme bestimmt und auch verändert, wenn z.B. das Fenster maximiert
  wird. Dadurch ändert sich nun auch das Icon von "Maximize" zu "Restore".
- Neue Klasse: ModDefaultFrame. Dieser Modifier gehört zum Theme "Default" und wird automatisch in alle Frames eingefügt.
  Er sorgt dann dafür, wie sich ein Fenster bedienen läßt (Größe ändern, Verschieben etc.)
- Neue Resource: Cursor, zur Behandlung von Mauszeigern.



>> 07.05.2008
[SB] (PLGui3)
- Neue Klasse: Container. Dies wird die Basisklasse für alle Fenster mit einem Content-Window, wie z.B. Frame.
  Ich hoffe eigentlich, dass ich auf die Fensterklasse "ContentWindow" verzichten kann, die ich damals eingeführt
  hatte, damit man auch im Parent-Window über die Events im ContentWindow (z.B. Mausbewegung) unterrichtet wird,
  als wäre es im eigenen Fenster. Eigentlich dürfte das aber nicht wirklich notwendig sein, also schaue ich mal,
  ob das nicht ohne geht.
- Neue Klasse: Frame. Altbekannte Klasse, nun reimplementiert als Container.
- Neue Klasse: AbstractButton. Dies ist in den meisten anderen GUI-Systemen so üblich, und da es mir sehr sinnvoll
  erscheint, übernehme ich das nun einfach mal :-) Der AbstractButton implementiert die typische Button-Funktionalität,
  also z.B. die States die ein Button haben kann, das Aussenden von Events wenn der Button geklickt wird, der Timer
  der das Event regelmäßig wiederholt wenn das gewollt ist etc. Dies ist allen Buttons gleich, daher kann das in diese
  Basisklasse ausgelagert werden, während sich das Aussehen und der Inhalt von Buttons sehr stark unterscheidet (z.B.
  Icon/ohne Icon, Text/ohne Text, Rahmen/Ohne Rahmen, Aufklappbar oder nicht, usw.). Darum werden verschiedene
  Button-Klassen von AbstractButton abgeleitet, dann ist das wesentlich übersichtlicher und man muss nicht alles in eine
  einzige Klasse hineinstopfen, was sehr unübersichtlich wird.
- Neue Klasse: SystemButton. Dieser Button ist besonders einfach zu implementieren, da er nur ganz bestimmte vordefinierte
  Ereignisbuttons repräsentiert, die in der Titelleiste eingefügt werden (Vergrößern/Verkleinern von Windows etc.).
  Die Größe und das Aussehen dieses Buttons wird daher komplett vom verwendeten Theme bestimmt, so dass der Button keine
  eigenen Optionen mehr anzubieten braucht.



>> 06.05.2008
[SB] (PLGui3)
- Definitionen aus Window.h nach PLGuiDefinitions.h verschoben
- Layout-Positionierungen in Window eingefügt (min/max-size, flexible)
- Neue Klasse: Layout. Diese Klasse ist dafür zuständig, die Position und die Größe von Fenstern innerhalb des
  Vater-Fensters zu managen. Zu diesem Zweck werden Position und Größe nicht mehr direkt über das Fenster gesetzt,
  sondern nur noch Informationen wie MinSize, MaxSize und Flexible verwendet. Anhand dieser Informationen kann das
  Layout dann die tatsächliche Größe und Position der Fenster errechnen und dynamisch anpassen (z.B. beim Vergrößern
  oder Verkleinern eines Fensters).



>> 05.05.2008
[SB] (PLGui3)
- Standard-Design um weitere Draw-Funktionen erweitert.
- Alle Farben und Draw-Funktionen genau durchgegangen und weiter aufeinander abgestimmt.
- Image: Habe wieder eine Colorkey-Funktion eingebaut. Es ist zwar unhandlich, ständig Bitmap+Colorkey durch die
  Gegend zu geben, wie es früher in PLGui der Fall war, aber z.B. innerhalb eines Theme-Objektes ist dies kein Problem.
  Hier werden die Bilder einmal geladen, und dabei kann man auch gut einen festen Colorkey mit angeben. Dafür dürfte
  es dann weniger Problem mit der Transparenz z.B. unter Linux geben.
- Folgende Standardelemente können nun gezeichnet werden: Border, Rule, Separator, TitleBar, Toolbar, TabBar, Tab,
  MenuBar, MenuBar-Items, Menu, MenuItem, Toolbutton. Bevor ich mich an das Zeichnen der Controls mache, werde ich
  nun erstmal die entsprechenden Widgets implementieren.



>> 04.05.2008
[SB] (PLGui3)
- Alle bisherigen Definitionen an einen zentralen Platz verschoben: PLGuiDefinitions.h
  Meistens braucht man diese Definitionen an mehr als einem Platz, z.B. Alignment ist sehr allgemein und wird bei
  weitem nicht nur für Labels benutzt. Da wäre es sehr lästig, wenn man dafür immer Label einbinden müßte oder das
  gleiche in mehrfacher Ausfertigung bereitstellen müßte. Hier werden nun alle Definitionen gesammelt, das ist schön
  übersichtlich und lässt sich daher auch leichtert finden.
- Alle mögliche States erfunden und hinzugefügt ;-)
- Angefangen, alle möglichen Draw-Funktionen im Theme zu implementieren. Das fängt zunöchst einmal mit Primitiven
  an, aus denen man alles andere zusammensetzt, besonders wichtig sind hier z.B. die Rahmen (Borders). Habe hier
  die meisten üblichen Rahmentypen implementiert, einige wenige wo mir der Unterschied nicht wirklich klar war habe
  ich weggelassen (falls die jemand will, kann man das später leicht hinzufügen).
- Im Standard-Theme angefangen, die wichtigsten Controls zu zeichnen und damit auch den Stil und die benutzten Farben
  genauer festzulegen. Nach einiger Zeit stellte sich sowas wie ein Muster ein und ich konnte viele Farben entfernen
  oder mit anderen zusammenlegen, so dass nun mit relativ wenigen Strichen und Farben denke ich ein sehr hübsches
  Design entstanden ist :-)



>> 03.05.2008
[SB] (PLGui3)
- Noch einmal alle Interfaces überarbeitet, Benennungen angeglichen, Kommentare angepasst etc.
- Warnungen deaktiviert: "'this' : used in base member initializer list". Bei der Initialisierung
  muss der this-Pointer übergeben werden, da er später zum Aufruf der Methoden benötigt wird. Es wird
  aber nicht während der Initialisierung bereits versucht, auf das Objekt zuzugreifen, daher ist diese
  Verwendung in Ordnung und die Warnung kann ignoriert werden.
- FontLinux überarbeitet.
- ImageLinux überarbeitet. Leider kann das nicht richtig getestet werden, weil die Klassen von PLGraphics
  unter Linux gerade nicht mehr beim RTTI angemeldet werden, den Grund für diesen Fehler konnte ich leider
  noch nicht finden. Daher können zur Zeit auch keine Images geladen werden. ImageLinux dürfte trotzdem
  so ok sein und wird nochmal überprüft, wenn der Fehler behoben ist oder das neue RTTI eingebaut ist :-)
- Window: Fehler behoben, durch den keine Fenster in andere Fenster eingebettet werden konnten.
- WindowWin32: Root-Window und Desktop-Window sind nicht identisch, daher darf nicht das HWND vom Desktop
  für Toplevel-Windows verwendet werden. Aber gut zu wissen, dass man dies später noch erweitern könnte,
  um z.B. Widgets in den Desktop einzubinden.
- Neues Widget: Label übernommen.



>> 02.05.2008
[SB] (PLGui3)
- Alle Resourcen (Image, Font etc.) entsprechend jetzt dem Backend-Prinzip. Auch alle Interfaces wurden einander
  angepaßt (GetGui(), GetImpl()).
- Timer nun ebenfalls nach dem Backend-Prinzip umgestaltet.
- ThreadTimer nach Backend verschoben. Diese Klasse ist zwar die Implementation eines Backends, aber da immer noch besser
  aufgehoben als bei den plattformunabhängigen Klassen in Resources.
- TimerWin32: WM_TIMER-Nachrichten werden nun in der Message-Loop direkt abgefangen, wodurch direkt das zur ID gehörige
  Objekt aus der Liste herausgesucht werden kann ohne dass erst der Timer und dann wieder die Gui aufgerufen werden muß.
  Dadurch konnte auch der statische Pointer auf die GuiWin32-Instanz wieder entfernt werden.



>> 27.04.2008
[SB] (PLGui3)
- Directory-Layout verändert.



>> 26.04.2008
[CO]
- ClassView: Color4: 'Alpha' wird in der Preview ignoriert da es hier nicht wirklich hilfreich ist und die Farbe dann nicht mehr korrekt
  Dargestellt wird wenn Alpha!=1 ist...



>> 25.04.2008
[CO]
- EditBox::IsTextValid(): Hier wird nun zusätzlich auf '+' und '-' getestet damit man in einem leeren Zahlenfeld mit '-' anfangen
  kann zu schreiben ohne erstmal eine Zahl eingeben und dann nachträglich ein '-' davor setzen zu müssen.


>> 23.04.2008
[SB] (PLGui3)
- WindowWin32 bekommt nun, genauso wie WindowLinux, auch einen Zeiger auf die System-Gui übergeben.
- Die Events MouseEnter und MouseLeave funktionieren nun unter Windows endlich vernünftig.
- Timer wieder eingebaut. Die Logik des Win32-Timers mußte ich etwas verändern, da die statische Hashmap beim
  Deinitialisieren einen Absturz verursachte. Deswegen wird diese nun nicht mehr statisch im Timer, sondern statt
  dessen im GuiWin32-Objekt vorgehalten.
- Transparenz in WindowWin32 etwas verändert, da es ansonsten immer flackerte, wenn die Transparenz auf 1.0 gesetzt
  wurde. Es sollte daher unterschieden werden, ob Transparenz benutzt aber auf 1.0 gesetzt wird, oder ob die
  Transparenz generell ausgeschaltet werden soll.
- Modifier 'ModBlend' implementiert. Dieser macht ein Fenster durchsichtig, wenn die Maus das Fenster verläßt,
  und wieder undurchsichtig, wenn die Maus über das Fenster bewegt wird. Ein sehr hübscher Effekt, vor allem
  für Ingame GUIs :-)



>> 22.04.2008
[SB] (PLGui3)
- Die Gui-Implementation kann nun auch über das RTTI erzeugt werden.
- Window-Title wieder eingebaut.
- Theme-Test: Anzeige eines einfachen Fensters. Dann das auch unter Linux zum Laufen gebracht und die
  dafür nötigen Methoden im Backend implementiert.
- Events für alle Window-Nachrichten hinzugefügt. Dies ersetzt das alte Listener-Prinzip, wenn man auf eine
  dieser Nachrichten von Aussen reagieren möchte, muss man nur einen entsprechenden EventHandler erstellen und
  bei dem jeweiligen Event registrieren.
- Neue Basisklasse 'Modifier' implementiert :-) Mir geistert schon seit längerem im Kopfe herum, dass man das
  Modifier-Prinzip, das bei unserem Szenegraph schon so hervorragend funktioniert hat, auch prima auf die
  GUI übertragen könnte. Dadurch sollte es möglich werden, die Klassenhierarchie der Widgets deutlich zu
  verkleinern, weil man nicht mehr für jede Funktionalität eine neue Basisklasse schaffen muß. Beispielsweise
  würde man ja normaler Weise so etwas wie DockingWindow implementieren, um neuen Fenstern Docking-Eigenschaften
  hinzuzufügen. Wenn man nun beispielsweise so etwas wie ein Button mit Docking-Eigenschaften haben will, muß man
  entweder den Button zu einem Docking-Window machen (was aber keiner tun würde), oder man wäre dabei, die gleiche
  Funktionalität mehrfach zu implementieren. Das ist also das typische Problem mit großen Klassenhierarchien, dass man
  hier verschiedene Zweige für unabhängige Eigenschaften aufmachen muss und diese dann hinterher nicht mehr kombinieren kann.
  Will man ein Fenster haben, das unterschiedliche Eigenschaften aus verschiedenen Teilbäumen übernimmt, muß man entweder
  alles in eine gemeinsame Basisklasse einbauen, oder man implementiert Dinge doppelt, was eigentlich gar nicht nötig ist.
  Mit dem Modifier-Prinzip läßt sich dieses Problem lösen, wie ja im Szenegraph schon eindrucksvoll gezeigt wurde :-)
  Dadurch kann man bestimmte, an sich vollkommen unabhängige Eigenschaften, aus der Klassenhierarchie herausnehmen und
  einmal generisch implementieren. Hinterher kann dann diese Eigenschaft einem beliebigen Fenster hinzugefügt werden, indem
  man einfach den entsprechenden Modifier auf das Fenster anwendet - egal, um was für ein Fenster es sich dabei handelt.
  Auf diese Weise kann man z.B. auch normale Controls mit Docking-Eigenschaften ausstatten, oder ein Fenster bewegbar machen,
  das diese Eigenschaft normaler Weise nicht besitzt. Diese Dinge würde man niemals alle in eine Basisklasse bauen, aber
  als Modifier ist das extrem simpel zu implementieren. *Schwärmerei beendet*
- Modifier 'ModMove' implementiert. Diese Modifier erlaubt es, ein Fenster zu bewegen oder dessen Größe
  zu verändern. Nichts aufregendes also, aber ich könnte es mir sehr nützlich vorstellen, dass man diese
  Funktionalität nun nicht mehr einem Fenster fest einpflanzen muß, sondern im Nachhinhein ein beliebiges Fenster
  damit ausstatten kann, wenn man es mal braucht (z.B. im Gui-Editor?) :-)
- Modifier 'ModExit' implementiert. Dieser Modifier beendet die Ausführung der Applikation, wenn ein Fenster geschlossen
  wird.



>> 21.04.2008
[SB] (PLGui3)
- Alle Basisklassen noch einmal durchgegangen und aufgeräumt, Sichtbarkeiten angepasst, Methoden sortiert etc.
- Statische Instanz der System-Gui hinzugefügt. Diese kann über GetSystemGui() abgefragt werden.
- Neue Methode zum Erzeugen eines Pseudo-Fensters für das Root-Fenster bzw. den Desktop einer GUI hinzugefügt.
  Die Gui ist nun selbst kein Object mehr, die Basisklasse Object wurde komplett entfernt. Es ist einfach schöner
  und macht weniger Probleme, wenn Window eine Basisklasse ist und man somit keine Fallunterscheidungen mehr zu machen
  braucht. Dafür gibt es jetzt eine Instanz von Window für das Root-Fenster.
- Funktionalität aus Object und Window nach Window_2 übertragen: GetCommonParent, GetAbsPos, GetRelativePos, Center, CenterOn
- Linux Implementation von Gui und Window fertiggestellt.
- Neue Klasse Theme eingebaut, die Style ersetzen wird. Theme ist anscheinend der gängigste Begriff dafür, auch wenn es
  natürlich wieder mal nur unterschiedliche Bezeichnungen für ein und dasselbe sind. Ausserdem kann ich so Style einfach
  später entfernen und dadurch das Umbenennen von Style_2 vermeiden :-)
- Neue Klasse Hint eingebaut. Einem Graphics-Objekt können nun von irgendwoher Hint-Objekte hinzugefügt werden, die
  beliebige Informationen enthalten können. Diese können später vom Gui-Renderer ausgelesen werden und dadurch z.B.
  weitere Effekte hinzugefügt werden, von denen ein Fenster, das gerendert wird, selbst überhaupt nichts zu wissen
  braucht. Ich bin sehr gespannt, für was dieses später verwendet werden wird :-D
- Die neuen Basisklassen sind jetzt wieder am RTTI angemeldet.



>> 20.04.2008
[SB] (PLGui3)
- Alle wichtigen Basisklassen bis hin zu Graphics und Font sind wieder implementiert und unter Windows bereits lauffähig.
  Im Moment wird ein einfaches Fenster ohne Titelleiste und Rahmen angezeigt.
- Die Basis läuft rudimentär auch bereits unter Linux (ohne Abstürze!) :-)
- Die Basisklassen wurden verschlankt und gründlich aufgeräumt. Beispielsweise werden jetzt überall Vektoren verwendet,
  Methoden wie GetX() etc. habe ich entfernt, da die nur das Interface aufblasen und wenig verwendet werden. Auch
  Fenster-IDs habe ich erstmal entfernt, da man wohl gut ohne auskommen dürfte. Sollte man das irgendwann doch einmal
  unbedingt brauchen, ist es in 5 Minuten wieder implementiert. Auch an vielen anderen Stellen wurden die Klassen
  wenn möglich vereinfacht.



>> 19.04.2008
[SB] (PLGui3)
- Basisklassen auch unter Linux lauffähig.



>> 18.04.2008
[SB] (PLGui3)
- Major Rewrite begonnen: PLGui3 :-)
- Nachdem ich eine zeitlang versucht habe, die Basis von PLGui auf's Nötigste zu reduzieren und zu verändern, habe ich
  mich entschlossen, dass es besser ist, dies komplett neu aufzuziehen. So grundlegende Veränderungen funktionieren
  leider einfach nicht, da alles auf die alten Eigenschaften hin ausgelegt ist, daher gab es nur merkwürdige
  Abstürze, Bugs etc. Die Basisklassen werden also noch einmal komplett neu gemacht, damit einige grundlegende
  Fehler und Design-Flaws endlich mal grundlegend beseitigt werden können und die Gui von Anfang an z.B. für Theming
  ausgelegt ist und auch vernünftig unter Linux läuft. Das Interface wird dabei natürlich relativ ähnlich bleiben,
  so dass sich dann die Controls und die anderen higher-level Klassen hoffentlich auf das neue Basissystem anpassen
  lassen werden.
- Basisklassen (Gui, GuiImpl, Window und WindowImpl) implementiert und unter Windows lauffähig.



>> 17.04.2008
[CO]
- DialogChooseFile: Das Verzeichniss in dem man sich gerade befindet wird oben wieder korrekt Anzeigt + man kann auch wieder Problemlos
  in ein Verzeichniss wie z.B. 'c:\' wechseln
- ClassView.cpp: FilenameEditBox::OnDropFiles(): Die Basis-Funktion wird nun NICHT mehr aufgerufen da diese Funktion hier den Input nochmal
  eventuell ändert und erst DANACH darf 'InformOnCommand()' aufgerufen werden - ansonnsten steht weiterhin ein absoluter Dateiname in der
  entsprechenden RTTI Variable...



>> 05.04.2008
[SB]
- Klassen für das neue Application-Framework hinzugefügt: GuiApplication.



>> 12.02.2008
[CO]
PLGui:
- ToolBar::AlignControls(): Sah Iterator mäßig 'sehr' merkwürdig aus...



>> 20.01.2008
[CO]
- FileSystemView entfernt und die Funktionalität in LoadableManagerView eingebaut



>> 14.01.2008
[SB]
- Der Basispfad zum Auffinden der Gui-Grafiken wurde noch aus der alten Umgebungsvariable ausgelesen. Habe dies ersetzt,
  der Pfad wird nun aus der Registry ausgelesen (HKEY_LOCAL_MACHINE\SOFTWARE\PixelLight\PixelLight-SDK).
- Der FileDialog funktionierte nach dem Umstellen auf das neue FS nicht mehr vernünftig, da sich z.B. das Verhalten
  der / am Ende von Pfaden verändert hat. Das wurde behoben.



>> 13.10.2007
[CO]
- WindowWin32::WindowProc(): Eigene 'WM_MOUSEWHEEL'-Definition entfernt da es mittlerweile scheinbar nicht mehr benötigt wird.
  Falls es unter VC7 Probleme geben sollte _WIN32_WINDOWS oder _WIN32_WINNT größer als 0x0400 definieren - dann 'müsste'
  es gehen. Hoffentlich klappt das auch so - dann sind wir dieses dumme Define hier los :D
- 'Window'-Klasse: 'OnKeyPressed()' in 'OnKeyDown()' umbenannt und eine Funktion Namens 'OnKeyUp()' hinzugefügt -> damit
  ist das konsistent zu z.B. 'OnRButtonUp'.
- 'Window'-Klasse: Ich spielte gerade warum auch immer etwas mit dem GUI-Editor herum... und da viel mir auf das beim ändern
  der Variablen 'BorderStyle' und 'BackgroundColor' das Element nicht neu gezeichnet wurde
- 'GuiLoaderPL'-Konstruktor: Die GUI-Format Dateierweiterung sollte natürlich klein geschrieben werden damit das einheitlich
  ist



>> 21.09.2007
[CO]
- TreeView: Neues Style-Flag: 'IgnoreRoot'. Ist dieses Flag gesetzt so wird die der Name bereits andeutet die 'Wurzel' des
  Baumes beim Zeichnen, Selektieren etc. ignoriert. Das macht die Implementation zwar nicht einfacher, dies ist allerdings
  eine Sache die man recht häufig haben will... denn oft ist die Wurzel reine Formalität und bringt für den User außer mehr
  auf dem Bildschirm keinen sonderlichen Nutzen.



>> 20.09.2007
[CO]
- GroupBox::OnSize(): Content Window etwas besser positioniert
- StylePL::DrawGroupBox(): Der Hintergrund um das Text-Feld wurde nicht gelöscht
- SystemView etwas aktualsiert
- Flags Dialog aus 'ClassView.cpp' herausgenommen und zu öffentlicher 'ClassFlagsDialog'-Klasse gemacht da man dies eventuell
  auch woanderst verwenden kann + damit 'ClassView.cpp' zumindestens minimal kleiner wird.



>> 17.09.2007
[CO]
- Alle Projekte von PLBool auf bool zurückgestellt (siehe PLBase Diary-Entrag von heute)



>> 23.08.2007
[CO]
- Ein paar [TODO] aus Frame entfernt. Ziel war es da mal das die Title Bar 'grau' ist wenn das Fenster gerade nicht aktiv
  ist, aber irgendwie bekam ich das absolut nicht korrekt zum laufen. Darum hab ich das nun erstmal komplett raus, das sollte
  man sich bei Zeiten aber nochmal anschaun.



>> 22.08.2007
[CO]
- Stellte die 'Image'-Verwaltung innerhalb von PLGui komplett auf Reference-Counting um. Das wollte ich schon lange mal
  ausprobieren ob das da Sinn macht bzw. wie gut das in der Praxis funktioniert... vorallem da momentan die Bilder nicht
  wirklich Verwaltet wurden und nach einem Weilchen es vorkommen konnte das immer mehr unbenötigte Dinge im Speicher
  herumlagen. (in PLGui sind nun ne Handvoll [TODO] weniger drinnen :)
  Das akuelle System ist im Grunde fast genauso wie vorher. Nur das anstatt mit direkten Zeigern nun über 'Smart Pointer'
  die Bilder Referenziert werden. Also jeder der ein Bild über längere Zeit nutzen will, macht das über Smart Pointer. PLGui
  selbst fügt nur eine Referenz hinzu. Das hat zwar den Nachteil das man so wie ich es momentan Implementiert habe den
  Image-Header auch in z.B. dem Bitmap-Header direkt Einbinden muss, allerdings ist es wirklich sehr komfortabel zu
  bedienen + da der Image-Header sehr schlank ist, fällt das wohl nicht wirklich stark ins Gewicht.
  Gui::ProcessMessages() schaut dann hin und wieder die Liste der Bilder durch und prüft ob etwas nicht mehr benötigt wird...
  also ne art von 'Image Garbage Collector'. Wüsste nicht wie man das derzeit anderst lösen könnte da der 'Image Manager' nix
  vom erhöhen/veringern von Referenzen mitbekommt. Insgesammt funktioniert das System jedoch erstaunlich gut. :D



>> 21.08.2007
[CO]
- ClassView: Flag-Dialog vereinfacht + dieser passt seine Breite nun dynamisch an



>> 07.08.2007
[CO]
- Window::IsShowInTaskbar(): Ich wunderte mich schon ein paar mal das das Minimieren von Fenstern derzeit nicht mehr wirklich
  ging und schaute mir das nun endlich mal kurz an... Diese Funktion war der Übeltäter. :D
  Früher vor der 'Object'-Umstellung war "!m_pParent" ok, aber nun muss es "m_pParent == m_pGui" heißen.
- 'Object'-Klasse: Nahm 'TypeUnknown' heraus da 'undefinierte Dinge' meistens alles nur komplexer machen als nötig. Der
  Typ dieses Objektes wird dem Konstruktor übergeben, und wenn etwas erzeugt wird wird man schon wissen was man gerade
  erzeugt. :D
  Konstruktor protected gemacht.
- Window: Was möglich ist wird direkt in der Konstruktor Initialisations Liste initialisiert
- WindowImpl: Neue Funktion SystemSetOpacityAndTransparency(): Damit kann man bestimmte Teile eines Fensters über einen
  Color Key durchsichtig machen, oder über einen Alpha Wert das gesammte Fenster Transparent machen. In Window eine Funktion
  Namens SetOpacityAndTransparency() eingebaut... diese Funktion verweist allerdings erstmal nur direkt auf die System
  Implementation ohne das diese Funktionalität ans RTTI angebunden ist + es gibt noch keine 'Get'-Funktion da ich das fürs
  erste so einfach wie möglich halten wollte.
- Frame: Die Knöpfe rechts im Balken sind erstmal nicht 'Transparent' da derzeit das Neuzeichnen des Hintergrundes dieser
  Buttons bei 'Transparenz' nicht wirklich klappt und dann sehr unschöner 'Schrott' zu sehen ist sobald man so einen Button
  einmal drückt etc... das ist der Grunde für diese neue SetOpacityAndTransparency()-Funktion, aber leider schaffe ich es
  nicht wirklich das Problemchen damit zu lösen. :(
- LogoWindow so erweitert das es auf Wunsch 'weich' ein/ausblenden kann
- Einfachen About-Dialog hinzugefügt der in allen PixelLight Projekten verwendet wird so das dies nicht jedesmal neu
  Implementiert werden muss, sondern nur die dort dargestellten Informationen jeweils gesetzt werden müssen. Bei Zeiten
  kann man das Teil noch etwas erweitern so das der Dialog z.B. automatisch seine größe passend Einstellt.



>> 08.07.2007
[CO]
- Fügte in "GuiManager.cpp" ein  #error "Unsupported platform"  hinzu



>> 06.07.2007
[CO]
- Die Datei & Klassen Namen der GUI Implementationen folgten nicht der Benennung der anderen PL Dateien + der Datei & Klassen
  Name von z.B. GuiWin32/Win32Gui war nicht identisch



>> 30.06.2007
[CO]
- Ich denke ich bin nun mit den Änderungen von 27.06.2007 soweit durch. Nun müsste es u.a. einige Stellen weniger geben
  wo man über NULL als Parameter übergeben Crashs verursachen kann. :)



>> 29.06.2007
[CO]
- Machte die Änderungen von 27.06.2007 weiter



>> 27.06.2007
[CO]
- Fing damit an die Klassen-Interfaces nochmal durchzuschaun und fehlende oder ungenaue (was passiert z.B. wenn man bei
  Zeigern NULL übergibt?) Dokumentationen zu verbessern.
- Fing ebenfalls damit an wo möglich und sinnig Zeiger zu Referenzen zu machen - wie gehabt reduziert das potentielle
  Fehlerquellen + man spart sich Sicherheitsabfragen die wie ich in PLGui bis jetzt sah auch sehr oft überhaupt nicht
  gemacht wurden so das man bereits durch einfaches übergeben von NULL an eine Funktion einen Crash versursachen konnte...
  soetwas muss wirklich nicht sein, es gibt genug andere, weniger triviale (jaja, ich weis, eigentlich darf ich als Student
  dieses liebgewonne Wort noch nicht verwenden *g*) Stellen wo man sich Crash-Bug mäßig austoben kann. *g*
- Fand und entfernte eine 'tote' (also nicht mehr Implementierte) Funktion in Window: 'InitWindow()'
- Reduzierte wo möglich & sinnvoll die Sichtbarkeit über protected oder gar private - machte aber wie gehabt public in
  abgeleiteten Klassen nicht z.B. private da dies laut diverser Quellen 'böse' ist. Dies macht die Sache etwas Übersichtlicher
  und für den Benutzer kompakter. Man muss weniger eigentlich vom Benutzer nicht benötigte Funktionen Exportieren + private
  Dinge erscheinen bei uns auch nicht in den automatischen Dokumentationen so das auch diese etwas besser Handhabbar werden.
  (es gibt in meinen Augen also nur Gewinner :)
-> sind zwar alles wieder kleinfussel Dinge, aber das ist für die Prüfungszeit genau das richtige - denn da kann ich mich
   nicht auf komplexere Dinge konzentrieren, will aber auch nicht komplett auf PL verzichten da dies eine angenehme abwechslung
   & entspannung zum Prüfungsstress ist. Nebenbei verbessern diese Änderungen nochmals unsere Code-Qualität. In PLBase zeigte
   sich bereits, das diese Änderungen wirklich sehr Sinnvoll sind... gerade auch das auf den ersten Blick eventuell sinnlos
   erscheinende Dokumentieren in Klassen ob ein Zeiger NULL (nach dem Motto 'Zeiger können IMMER NULL sein, also IMMER prüfen und
   das braucht man daher auch nicht zu Dokumentieren' -> unrealistischer Overhead! :) sein kann oder als immer gültig
   vorausgesetzt wird - denn es gibt bereits jetzt (nach 'erst' 5 Jahren Entwicklungszeit *g*) diverse Stellen wo ich erstmal
   wieder rausfinden muss ob ein Zeiger denn nun mal NULL werden könnte oder immer gültig zu sein hat. Darum Dokumentiere
   ich das nun gleich mal sauber damit man da später nicht nochmals schaun musst was wie abgeht - denn soetwas kann sehr
   schnell in üblen Crash-Bugs ausarten wenn man sich keine Spielregeln aufstellt. :(



>> 17.05.2007
[CO]
- GuiLoaderPL::SaveWindowRec() & GuiLoaderPL::Save() & Window::SetZPos() & ToolBar::AlignControls() nutzen intern nun
  List-Iteratoren was hier natürlich besser ist
- 'pWnd' in 'pWindow' umbenannt da besser lesbarer
- Gui::SetActiveWindow(): 'Activate new windows'-Teil auf 'richtigen' Stack umgestellt
- Window::Destroy() Funktion noch um ein paar Kommentare erweitert
- Window::Destroy(): Fenster Handler werden sofort hier entladen anstatt erst im Destruktor
- Image::SystemLoadImage() gibt nun einen Fehler-Code zurück
- Gui::CreateImage() entfernt da unnötig, zudem wurden Bilder nicht in die interne Liste eingetragen, derzeit läuft das nun
  also alles komplett über Gui::GetImage() ab
- Gui eine interne HashMap für Image spendiert damit Gui::GetImage() effizienter Arbeiten kann



>> 10.05.2007
[CO]
- Sortierte ins Diary so richtig alte Einträge aus "PLSDK/internal/old_diaries.zip" ein



>> 09.05.2007
[CO]
- Fügte ins Diary alte Einträge aus "PLSDK/internal/old_diaries.zip" von zwischen "06.04.04" und "03.08.2003" ein.
  Zwar hatten wir damals dort teils kein Datum dazugeschrieben - nun haben wir aber zumindestens endlich wieder
 'alle beieinander' *g* was mir irgendwie wichtig ist damit man wirklich alles nachlesen kann.



>> 05.05.2007
[CO]
- TabBar: Neue Funktion: RemoveTab(): Zum entfernen einzelnder Tabs + behob ein kleines Speicherleck
- Menu::OnLButtonUp(): 'ItemDisabled' wurde nicht berücksichtigt



>> 30.04.2007
[CO]
- TreeViewItem hatte ein paar öffentliche Funktionen mit 'internen' Parameter welche für Rekursive durchläufe benötigt
  werden - da soetwas aber im Interface sehr unschön und Fehleranfällig ist fügte ich interne Rekursive Varianten hinzu
  welche einfach von der jeweils öffentlichen Funktion aufgerufen werden.
- ListBox::SetSelection() mit dem mehrere Items auf einmal Selektiert werden können bekommt nun als Parameter einen Array
  mit den Item ID's anstatt einen Zeiger auf ein Feld von ID's. Das ist so etwas 'sicherer'. :)
- TreeViewItem: Neue Funktion: GetNumOfSelected(): Gibt die Anzahl der gerade selektierten Items zurück
- TreeViewItem: GetSelectionRec() + dazu gehörende GetSelection() Funktion: Bekommt nun als Parameter einen Array mit den
  Item ID's (siehe ListBox Änderung weiter oben)
- TreeViewItem: SetSelectionRec() + dazu gehörende SetSelection() Funktion: Bekommt nun als Parameter einen Array mit den
  Item ID's (siehe ListBox Änderung weiter oben)



>> 27.04.2007
[CO]
- Button & ComboBox & EditBox & GroupBox & ListBox & Menu & Mover & PDButton & Slider & Spinner & Splitter & TreeView:
  OnDisable(): Bei dei meisten Controls war noch keine korrekte behandlung Implementiert wenn ein Control Deaktiviert wird
- In 'FileSystemView' lassen sich Einträge nun nach oben/unten verschieben



>> 09.04.2007
[CO]
- Einige 'return' entfernt



>> 29.03.2007
[CO]
- Timer: Stop() & SystemStopTimer(): 'nTimeout'-Parameter hinzugefügt so das man bei bedarf den Wert per Hand ändern kann
  (war bisher in ThreadTimer fest eingestellt)



>> 24.03.2007
[CO]
- ComboBox Bugfix: Wird das Control deaktiviert, so wird auch die ListBox dieses Controls deaktiviert



>> 23.03.2007
[CO]
- ClassView: Bei Dateinamen-Variablen wird versucht den über Drag'n'Drop übergebenen Dateinamen relativ zu machen



>> 16.03.2007
[CO]
- Las dies zufällig in der DirectX Dokumentation bei der Thematik 'Porting to 64-bit':
  "Some Win32 APIs have been deprecated and replaced with more neutral API calls such as SetWindowLongPtr in place of SetWindowLong."
  Im Win32-Port wird nun 'GetWindowLongPtr()' anstatt 'GetWindowLong()' und 'SetWindowLongPtr()' anstatt 'SetWindowLong()'
  verwendet - so ist man 64 Sicher, auf 32 Bit Systemen ist das nur ne olle Definition (igh, schon wieder das Wort *g*) auf
  die alte Funktion. So müsste man hier 'Zukunftssicher' sein. :)
  (ich hoffe mal das VC7 die Funktion auch bereits kennt...)



>> 13.03.2007
[CO]
- Musste die Linux Header kräftig entrümpeln da ich es ansonnsten nicht Übersetzt bekam



>> 12.03.2007
[CO]
- Machte die gleichen Änderungen wie in den letzten Tagen in PLBase. Ich lies mal in allen Projekten nach '#include' suchen,
  früher waren das >10000, mittlerweile 'nur' noch ca. 9000. Bin schon schwer gespannt wie groß die Zahl noch ist wenn ich
  mit allen Projekten durch bin. *g* Diese Header Änderungen machen einem also auch das Leben etwas einfacher da jeder
  Header bereits alles mitbringt was er benötigt und man nicht selbst jedesmal alles von neuem zusammen puzzeln muss. Will
  ich z.B. eine ListBox nutzen, muss ich wirklich im Grunde nur den ListBox Header einbinden, der Rest kommt automatisch.



>> 08.03.2007
[CO]
- An TreeView weitergearbeitet, ist zwar noch nicht optimal aber zumindestens wieder Nutzbar :)
- 'Eingebette Fenster' in ListBox wieder funktionsfähig gemacht damit ClassView wieder korrekt läuft



>> 06.03.2007
[CO]
Alle Projekte:
- An ein paar Stellen wurde noch unnötig auf 'Gui' als Parent reduziert, stellte an den Stellen wo Sinnvoll auf 'Object' als
  Parent im Konstruktor um



>> 03.03.2007
[CO]
- ListBox: Hat ein Item ein Tooltip, so wird dieser genutzt, ansonnsten der Tooltip der ListBox selbst. Das klappt aber leider
  noch nicht sonderlich gut da man u.a. keine Change hat von der ListBox aus einen neuen Tooltip zu setzen wenn die Maus über
  ein anderes Item geht. :(



>> 01.03.2007
[CO]
- ResourceManagerDialog: Speicher Button hinzugefügt damit sich Resourcen auch direkt aus dem Debug Dialog heraus speichern lassen
  (ganz nebenbei kann man so z.B. Meshs auch in ein anderes Format 'konvertieren' *g*)



>> 28.02.2007
[CO]
- DialogChooseFile::ListDirectory(): Beim Auflisten von Verzeichnissen war noch etwas nicht ok: Wenn kein '/' am Dateinamen
  war, so wurde in die Liste das Verzeichniss + '/' eingetragen, ansonnsten nix... was natürlich nicht korrekt war *g*
- DialogChooseFile zeigt nun auch Archive als Ordner an so das man wie bei ganz normalen OS Verzeichnissen direkt 'reingehen' kann



>> 26.02.2007
[CO]
- Nahm wie besprochen die Maus Sichtbarkeits & Bild Dinge aus der Window-Basisklasse heraus. An der Handvoll Stellen wo man
  wirklich mal diese Dinge ändern will ist das auch schnell anderst Realisiert, und bei den überarbeiteten Gui-Controls musste
  das Maus Bild sowieso bereits von Hand geändert werden da innerhalb eines 'Window' mehrere Elemente untergebracht werden.
- Die Standard System Cursor Definitionen liegen nun direkt in der Gui Klasse
- ComboBox: Sobald in der Pull-Down Liste eine Auswahl getroffen wurde, muss das Control natürlich neu gezeichnet werden :)
- Nahm wie besprochen die Font aus der Window-Basisklasse und Implementierte es dort wo es Sinn macht: In den konkreten Controls.
  In z.B. ListBox kann nun jedes Item eine andere Schrift haben. In Controls die noch überarbeitet werden müssen wie z.B. Menu
  oder TabBar machte ich erstmal keine zu großen Font-Änderungen.



>> 23.02.2007
[CO]
- Frame: Flickte hier und da etwas damit das erstmal brauchbar ist und nicht ständig dank ReDraw wild flackert



>> 21.02.2007
[CO]
- Win32Window::WindowProc(): WM_DROPFILES: Da man hier leider nicht ohne weiteres rausbekommen kann ob ASCII ausreichend ist
  oder Unicode benötigt wird, wird zur Sicherheit IMMER die Unicode-Variante verwendet
- GuiWin32::CopyTextToClipboard(): Support für Unicode hinzugefügt
- An Stellen wie z.B. Win32Window::SystemSetTitle() wird nun neben 'Unicode' auch 'UTF8' geprüft, ist es ein UTF8 String
  müssen die Daten als Unicode zurückgegeben werden damit kein Informationsverlust stattfinden kann... da Windows nur wchar_t
  und kein direktes UTF8 kann muss leider immer Konvertiert werden, aber da kann man nix dran ändern. (ähnliche Thematik dann
  unter Linux, nur umgekehrt *g*)
- GuiWin32::GetTextFromClipboard(): Unicode-Support hinzugefügt. Leider klappt das nicht wirklich so gut wie ich will, denn
  Windows sagt mir immer das ein Unicode String da ist auch wenn ich einen ASCII reinkopiert habe, anderst herum ist's genauso.
  Der zweite Test auf ASCII ist also 'nur' zur Vollständigkeit da. :(



>> 19.02.2007
[CO]
- Spinner und ComboBox (und auch später alle anderen Controls die ähnlich arbeiten) geben der EditBox den Fokus damit man
  sofort wie man es erwartet lostippen kann
- EditBox::StopEdit(): Sobald die Eingabe abgeschlossen wird gibt die EditBox den Fokus aus der Hand - so klappt das mit dem
  'Loose Focus'-Listenern wie z.B. Spinner ganz wunderbar (ansonnsten würde es recht umständlich werden rauszubekommen wann
  eine Eingabe fertig ist oder ob diese abgebrochen wurde)
- ListBox Bearbeitung über zeitweise eingeblendete EditBox Implementiert



>> 18.02.2007
[CO]
- Ging alle Projekte durch und entfernte das unsichtbar machen von z.B. ListBox/TreeView bevor viel eingefügt wird + das danach
  wieder sichtbar machen. (waren vergleichsweise wenig Stellen) Das war vor einigen Jahren als wir noch kein ReDraw() hatten nötig
  da es ansonnsten wie wild flackerte und extrem langsam ging da sofort nach jedem einfügen eines neuen Items neu gezeichnet wurde.
  Mittlerweile ist das jedoch unnötig, unschön und Problematisch dazu. Z.B. wurde meistens nicht geprüft ob das Control vorher
  überhaupt sichtbar war, danach aber sichtbar gemacht so das sich einfach ungewollt Sichtbarkeits Zustände änderten. Entfernte
  entsprechende Kommentare in ListBox & TreeView.
- StylePL::DrawListBox() um berücksichtung von Item Flags erweitert



>> 17.02.2007
[CO]
- ComboBox überarbeitet, StylePL entsprechend angepasst. Vom Prinzip her ähnlich wie beim Spinner, also EditBox NUR wenn gerade
  bearbeitet wird.
- StylePL::DrawButton(): Verwendet Button Hintergrund Farbe damit u.a. der Color Dialog noch richtig aussieht
- ListBox: Wird der vertikale Slider nicht benötigt, so wird dieser nun ausgeblendet
- Fing damit an TreeView zu überarbeiten, StylePL entsprechend angepasst



>> 16.02.2007
[CO]
- FileSystemView aufgeräumt
- Neuer (Debug)-Dialog: LoadableManagerView. Das war so ähnlich früher in FileSystemView drinnen, da dies aber mittlerweile
  getrennte Systeme sind sollten es auch getrennte Dialoge sein :)
- Bei den Gui Controls viel mir gerade auf das die Kommentare zu enums hin und wieder nicht ok waren... denn das sind keine
  'Fragen', sondern 'Tatsachen'. (nicht 'Zeichnest du das?' sondern 'Zeichne das!' *g*) Schaute kurz alle enum Kommentare
  durch und verbesserte wo nötig.



>> 15.02.2007
[CO]
- ListBox komplett überarbeitet, StylePL entsprechend angepasst. Die neue Implementation ist 'sehr' viel schlanker und
  übersichtlicher als früher wo EditBoxes genutzt wurden + das Laufzeitverhalten ist ebenfalls spürbar besser. Wie beim
  Spinner wird nun alles 'direkt' gezeichnet und 'nur' wenn gerade etwas vom User bearbeitet wird, wird eine EditBox
  'übergeblendet'. Ein paar kleinigkeiten fehlen in der Implementation noch.
- Nahm die Timer aus der Window-Basisklasse heraus, alle Projekte entsprechend angepasst - dabei markierte ich Stellen wo ein
  Timer 'nur' zum Input abfragen/verarbeitet genutzt wird (das kann man später sicherlich Eleganter lösen :)
- Menu auf StylePL umgestellt und 'Unterstrich-Funktionen' wie z.B. 'GetSubMenu_' in 'GetSubMenuByIndex' umbenannt. Hatte mir
  zuerst überlegt nur noch jeweils eine Funktion anzubieten, aber die Unterscheidung in Command ID und Index ist durchaus
  Handlich: Per Index wenn man alles durchgeht, oder direkt eine Command ID angeben wie z.B.
    "m_pMenu->SetItemChecked(ID_MENU_SHOW_VERTICES, true)"
  was zudem auch gleich in Untermenüs nach diesem Item sucht was eine nette Arbeitserleichterung ist. Da man am häufigsten
  direkt die Command ID angibt habe ich 'GetSubMenu' etc. nicht umbenannt.
- Machte die Variablen in Object private - nur Window welches bereits ein Freund war und Gui (machte es zum Freund) haben
  direkten Zugriff, ansonnsten kann man in abgeleiteten üblen Unfug treiben *g*



>> 14.02.2007
[CO]
- GroupBox überarbeitet, StylePL entsprechend angepasst
- Label vereinfacht, wie besprochen stellt dieses Control 'nur' noch Text da, selektieren kann man nichts



>> 13.02.2007
[CO]
- Frame: Wenn ein Frame gerade nicht aktiv ist so wird die Titel-Leiste grau gezeichnet (irgendwie will das aber noch nicht wirklich...)
- Window::OnDropFiles() auf unsere String Klasse umgestellt
- ListBox::GetSelection(): Liefert nun über einen Array die selektierten Items zurück, das ist so wesentlich weniger Fehleranfällig und
  einfacher zu verwenden als vorher. GetNumOfSelected() gibt die Anzahl der selektierten Items zurück. Passte alle Projekte
  entsprechend an.
- Slider: Wenn das Minimum/Maximum ereicht ist werden die entsprechenden Buttons 'deaktiviert'
- MessageBox auf unsere String Klasse umgestellt + das Bildchen wird nun direkt gezeichnet anstatt ein Bitmap-Control zu nutzen
- Slider Optik noch etwas verfeinert
- Spinner komplett überarbeitet, StylePL entsprechend angepasst. Solange ein Spinner nicht über Tastatur-Eingaben bearbeitet wird
  werden KEINE eingebetteten Gui Controls mehr verwendet. Sobald der Benutzer allerdings auf das Eingabefeld klickt wird intern
  eine temporäre EditBox erzeugt und über den Spinner gelegt. Sobald die Eingabe beendet ist verschwindet diese wieder...
  der User merkt davon nichts, und da die EditBox recht aufwändig ist wollte ich das unter keinen Umständen mehrmals in verschiedenen
  Controls nochmal komplett neu Implementieren - aber ständig eingebettete EditBoxes zu nutzen erwies sich wie wir wissen ebenfalls
  als nicht sonderlich prall. Ich denke dieser Kompromiss ist genau richtig. *g*
  In 'InformedOnLooseFocus()' wird die EditBox geschlossen - allerdings funktioniert das nicht immer da anscheinend der Spinner
  nicht immer korrekt Informiert wird...



>> 12.02.2007
[CO]
- EditBox komplett überarbeitet, einige Details fehlen jedoch noch. (siehe [TODO], die Edit Box ist etwas recht komplexes,
  auch wenn man das als User gar nicht merkt ;) Passte alles entsprechend an - einige andere Controls welche bis jetzt
  EditBox eifrig einbetten sehen momentan nicht ganz ok aus.
- Gui::SystemConvertToCharacter(): Auf unsere String Klasse umgestellt (wird u.a. in EditBox genutzt, und so gibts keine
  Unicode Probleme)
- Gui::InputBox(): Auf unsere String Klasse umgestellt
- Win32Graphics::DrawGradientBox(): Verarbeitete die angegeben Werte nicht korrekt, wir übergeben Start- und Endpunkte, die
  Windows Funktion nutzt Startpunkt + Dimension
- StylePL::DrawSlider() berücksichtigt 'GetEnabled()'
- StylePL::DrawSlider(): Damit es im schlimmsten Fall beim neuzeichnen nicht 'Flackert' wird Overdraw beim Hintergrund löschen
  vermieden



>> 11.02.2007
[CO]
- Auf VC 2005 umgestellt



>> 07.02.2007
[CO]
- Win32Timer::TimerFunction(): Berücksichtigt nun IsOnce()
- Label komplett überarbeitet. Dieses Control ist nicht mehr von EditBox abgeleitet, bietet aber auch an das man Text
  zumindetens Selektieren kann um etwas 'herauszukopieren'.
- Button überarbeitet, StylePL entsprechend angepasst (da kann man aber sicherlich noch einiges dran verbessern :)
- ProgressBar überarbeitet, StylePL entsprechend angepasst
- CheckBox überarbeitet, StylePL entsprechend angepasst
- Slider überarbeitet, StylePL entsprechend angepasst. Slider kommt nun komplett ohne eingebetete Controls aus - das kann
  man natürlich noch weiter verbessern, (siehe [HACK] :) ist nun aber denk ich schonmal um einiges besser als vorher.



>> 06.02.2007
[SB]
- Graphics Objekte: ReleaseGraphics() entfernt, die Objekte können direkt mit delete gelöscht werden.
  Um zu verhindern daß nur zum Feststellen einer Textgröße ständig Graphics-Objekte erstellt und wieder gelöscht werden
  müssen, gibt es in der Klasse Gui nun die Funktion GetOffscreenGraphics, die eine globale Instanz von Graphics zurückgibt.
  Es muß aber darauf geachtet werden, daß dies natürlich nicht thread-safe ist, es würde mit sicherheit zu Problemen kommen,
  wenn zwei Threads parallel auf das Graphics Objekt zugreifen würden (und z.B. unterschiedliche Fonts setzen)



>> 06.02.2007
[CO]
- Etwas am Bitmap Control geschraubt - aber viel gibts da ja nicht zum schrauben *g*
- Tooltip überarbeitet, StylePL entsprechend angepasst
- LogoWindow vereinfacht



>> 03.02.2007
[CO]
- DialogChooseFile und DialogChooseDirectory um Drag'n'Drop Support erweitert (das macht das Leben oft sehr viel einfacher :)
- Etwas aufgeräumt:
  - Einige 'using namespace' entfernt (wir sollten davon so wenig wie möglich nutzen um eventuelle Namens Konflikte zu vermeiden)
  - Einige Code Stellen minimal umformuliert um diese übersichtlicher zu machen
  - Ein paar Stellen vereinfacht (z.B. unnötige Init()-Funktionen entfernt und das direkt in die Konstruktoren verschoben)
  - Ein paar Leerzeichen & Tabs korrigiert
  - Einige [TODO] eingefügt, vorallem bei Stellen wo man noch auf die String Klasse umstellen müsste oder bei auskommentierten
    Code wo ich nicht sicher war ob man das noch braucht
  - Ein paar const eingefügt



>> 28.01.2007
[CO]
- VC Projekt-Datei wie besprochen in den Grundordner verschoben



>> 27.01.2007
[SB]
- CMake Projektdateien für PLGui hinzugefügt 



>> 25.01.2007
[CO]
- Bugfix: SystemView: In der Klassen Übersicht werden nun die Klassen wieder korrekt Hierarisch angezeigt



>> 17.01.2007
[CO]
- ClassView: Verwendung von 'sscanf' und 'strstr' entfernt + hier und da etwas vereinfacht + aufgeräumt



>> 09.01.2007
[SB]
- Die Klassen Point und Size durch Vector2i ersetzt und nach PLMath verschoben. Alle Projekte angepaßt. 



>> 20.12.2006
[CO]
- Gui::RemoveTimer(): Die Abfrage 'if (m_lstTimerFired.IsElement(pTimer))' ist unnötig da so oder so nach diesem Zeiger
  gesucht wird, wird er nicht gefunden, passiert auch nix. Hatte vor einigen Tagen als wir das schonmal kurz ansprachen
  das Kommentar der Container-Funktion etwas erweitert so das dieses Verhalten eindeutig ist. (doppelte Durchläufe
  sollte man wo immer vermeiden :)



>> 19.12.2006
[CO]
- TreeView::UpdateEditBoxes(): Beim Umstellen auf die Object Basis Klasse kam hier ein kleiner GetSize()-Bug rein: Die
  höhe der Edit Boxes wurde auf die höhe des TreeView-Controlls gesetzt. :)



>> 18.12.2006
[SB]
- Window: Farbwerte größtenteils entfernt, man wird im Laufe der Implementierung der einzelnen Controls sehen, welche
  Farben wirklich notwendig ist. Im Moment gibt es in Window nur noch BackgroundColor.
- Alle Farben in PLGui auf Color4 umgestellt. Auch wenn im Moment die System-Implementation den Alpha-Wert ignoriert, scheint
  es mir sinnvoller gleich möglichst überall Color4 zu benutzen. Im Ingame-Gui kann man das gleich verwenden, und auch die
  System-Guis werden wohl früher oder später echte Transparenzen nutzen.
- Habe den Color-Key bei den Bitmap-Funktionen entfernt, statt dessen sollen nun dort, wo Transparenzen genötigt werden,
  gleich Bitmaps mit Alpha-Channel verwendet werden. Windows bietet inzwischen auch Funktionen an, um mit Alpha-Channel
  zu zeichnen, und Laden aus png etc. ist ja schon seit langem auch in der PLGui möglich. Das ständige Angeben des
  Color-Keys dürfte damit nicht mehr nötig sein. Momentan funktioniert es allerdings noch nicht so, wie gewollt - Christian,
  wenn Du magst schau Dir das doch bitte mal an (siehe PLSampleGui zum Testen des Transparenz). Generell scheint es zu
  funktionieren, aber die meisten Icons haben noch nicht die richtige Transparenz, und auf blauem Hintergrund wird
  alles weiß ... Entweder arbeiten die Win32 Alpha-Blending Funktionen nicht so, wie man es sich vorstellt, oder es liegt an den
  umgewandelten png Dateien :-)   



>> 16.12.2006
[CO]
- In ResourceManagerDialog ist nun auch direkt die 'Reload' Funktionalität Implementiert da dies nun durch das Loadable
  System alles sehr universell geworden ist. Desweiteren ist die 'Open' Funktionalität wieder Implementiert da in der
  Loadable Basis Klasse der absolute Dateiname gespeichert wird aus dem die Resource stammt... dieser absolute Dateiname
  wird als Tooltip für die einzelnen Listen Einträge genutzt so das man direkt sehen kann WOHER die Resource stammt.



>> 08.12.2006
[CO]
- DialogChooseFile: Fügte AddFiltersFromLoadableType()-Funktion hinzu welche alle zu einem Loadable-Typ gehörenden Formate
  einträgt... da man dies häufiger braucht (momentan an 29 Stellen :) ist das etwas umständlich das jedesmal per Hand neu
  zu Implementieren. Passte alle Projekte entsprechend an und nahm bei der Gelegenheit auch die "*.*"-Filter heraus wo diese
  unnötig sind da man eigentlich immer 'nur' die unterstützten Formate sehen will.



>> 02.12.2006
[SB]
- Kleinen Timer-Fehler behoben
- Klasse Graphics überarbeitet:
  - Farben und sonstige Optionen entfernt, diese werden jetzt den Funktionen direkt übergeben. Das ist irgendwie natürlicher
    und leichter verständlich, zumal es nur ganz selten mal vorkam, daß vor einer Zeichenfunktion nicht alle Farben neu
    gesetzt wurden, sprich eine Farbe über einen längeren Zeitraum für mehrere Aufrufe verwendet wurde.
  - System-Funktionen entfernt, die Zeichen-Funktionen werden nun direkt implementiert, damit fallen die doppelten
    Funktionen weg.
  - Alle Controls angepaßt.
- BorderStyle::Frame hinzugefügt und in Frame verwendet.Damit sind nun erstmal alle wichtigen Border-Typen vereinheitlicht und können
  in einer Funktion gezeichnet werden. 
- Die Handhabung von Default-Fonts war etwas konfus, daher habe ich versucht das zu vereinfachen. In GuiPL gab es noch eine eigene
  Font-Variable (m_pFont), welche am Anfang geladen wurde, anstatt den Default-Font zu setzen. In der Basisklasse Gui dagegen wurde
  ein Default-Font gesetzt, mit dem z.B. die GuiPL-Implementation nichts anfangen kann. Habe das ganze nun so umgeändert:
  - In der Basisklasse Gui wird der Default-Font auf NULL gesetzt, die Zeichenfunktionen sollten in dem Fall also einen Fehler
    zurückgeben und ansonsten nichts tun 
  - In SystemInit muß jede Gui-Implementation ihren persönlichen Default-Font setzen.
- Erste Vorbereitungen für's Style-System getroffen (einiges wird sogar schon darüber gezeichnet). Der richtige Einbau von Styles
  kann aber erst passieren, wenn die Controls neu geschrieben werden und dabei unterschieden wird, was vom Control und was vom
  Style entschieden wird. Dazu werde ich noch genaueres in Guidelines.txt schreiben, wie das am besten funktioniert :-)
- Kleinen Gradient-Test hinzugefügt. Funktioniert ganz gut - erstaunlich, gdiplus ist nicht so schlecht wie man es von der Windows API
  sonst gewöhnt ist ;-) Muß aber noch richtig implementiert werden (Richtung, übergebene Farben benutzen)
- Gradient-Funktion eingebaut, wie sie voraussichtlich erstmal bleiben kann. Die Implementierung für GuiPL fehlt noch
- Gui::GetWindows() hinzugefügt und dafür die alten Funktionen zum Zugriff auf die Fensterliste entfernt
- Allgemein noch etwas aufgeräumt



>> 01.12.2006
[CO]
- Passte ein paar Kommentare an die Doxygen anmeckerte. @note ist für Stichpunktartige Notizen, @remarks für etwas umfangreichere
  zusammenhängende Methoden Beschreibungen.
- Nahm die Fenster Lade/Speicher Funktionen aus Gui heraus da diese mittlerweile als eigenständige Loader-Klassen vorliegen.
  Window müsste man nun von PLGeneral::Loadable Ableiten damit sich ein Fenster selbst Laden/Speichern kann.



>> 30.11.2006
[CO]
- ClassView: Ist eine RTTI Variable vom Typ PL_VAR_FILENAME oder PL_VAR_PLFILENAME so wird in den Annotations
  nun neben 'Ext' auch nach 'Type' gesucht. Darüber kann man direkt angeben vom welchem Datei Typ die Datei sein
  soll ohne immer jedesmal per Hand alle möglichen Dateiendungen eintragen zu müssen welche zudem meistens dynamisch
  über Plugins erweiterbar sind. Passte alle Projekte entsprechend an.



>> 29.11.2006
[SB]
- GetGui() von Window nach Object verschoben
- Center-Funktionen überarbeitet, es ist nun auch möglich, bezüglich eines beliebigen anderen Fensters zu zentrieren. Meist
  wird aber doch wohl eher gegenüber dem Parent oder gegenüber der Gui zentriert :-)
- Tooltip überarbeitet



>> 28.11.2006
[SB]
- Timer funktionieren wieder. Es gibt jetzt eine eigenständige Timer-Klasse, die ein Callback aussendet wenn der Timer abgelaufen
  ist. Diese Timer-Objekte können jetzt also beliebig verwendet werden und gehören nicht mehr nur zu einem Fenster. 
- Neue Basisklasse Gui::Timer eingebaut, die nach dem typischen Backend-Prinzip funktioniert. Abgeleitete Klassen existieren
  für die jeweiligen Systeme
- Gui::ThreadTimer ist eine Timer-Implementation, die einen Timer mittels eines Threads implementiert. Die Klasse ist ebenfalls
  unter Base zu finden, was natürlich aus dem Rahmen fällt, da es sich um eine "System-Implementation" handelt. Diese Implementation
  ist aber sehr universell und könnte in verschiedenen Backends verwendet werden, daher ist es sinnvoller sie hier anzubieten
  damit sie jeder benutzen kann, anstatt sie einer Gui-Implementation zuzuordnen. Im Moment wird diese Implementation für GuiPL
  verwendet.
- Die Methode Timer::Fire() geht einen kleinen Umweg: Sie ruft nicht direkt die Timer-Callbacks auf, sondern trägt den Timer
  in der Gui in eine Liste ein. Beim nächsten ProcessMessages werden dann die Timer-Callbacks benachrichtigt. Dieser Umweg
  ist dazu da, möglichen Problemem mit der Thread-Implementation aus dem Wege zu gehen, denn diese würde ansonsten die Callback
  Methoden direkt aus einem anderen Thread heraus aufrufen, was zu Problemen führen kann, wenn die Callback-Methoden das nicht
  wissen und nicht entsprechende Sicherheitsvorkehrungen wie Semaphoren etc. verwenden. Daher ist es besser wenn sichergestellt
  wird, daß alle Gui-Callbacks immer im Main-Thread nach einem ProcessMessages Aufruf passieren.
- Um erstmal die Kompatibilität zu wahren, gibt es in Gui::Window weiterhin die alten Methoden, um einen Timer für das aktuelle
  Fenster zu verwenden. Diese Funktionen sollten später rausfliegen, beim Umbau der Controls und Dialoge sollte dann also gleich
  die neue Timer-Klasse direkt verwendet werden.
- Typedefs bei den Systemklassen entfernt.  Dies war wirklich unschön, und war entstanden da ich mir nicht sicher war ob man überall
  einen Backend-Mechanismus wie bei Window -> SysWindow braucht oder nicht. Daher hatte ich die anderen systemabhängigen Klassen mit
  dem Prefix Sys versehen, dann aber einfach einen Typedef benutzt, so daß z.B. SysFont = Font war.
  Dies habe ich nun entfernt, da es nicht notwendig ist und nur verwirrt. Die Basisklassen heißen nun einfach Font, Image etc., und
  werden wie bisher für die Systemabhängigen Klassen abgeleitet. Nur Window besitzt ein Zeiger auf das Backend, das nun WindowImpl
  heißt.
- Neue Funktion Window::IsTopLevel(): Gibt an, ob ein Window ein Top-Level-Window ist, also nur den Desktop als Parent besitzt.
  Früher wurde hierfür immer parent == NULL abgefragt, das geht nun nicht mehr da ein Top-Level-Window als Parent das Gui-Objekt
  hat. Sollten jemandem noch Stellen auffallen, in denen das so abgefragt wird, bitte gleich durch IsTopLevel() ersetzen :-)
- Durch diese Änderung werden Frames jetzt auch wieder in der Taskleiste angezeigt
- Einige Tool-Funktionen in PLGui::Object:
  - GetCommonParent() gibt das gemeinsame Vaterobjekt zweier Objekte zurück. Entsprechende Funktion in Gui gelöscht
  - GetPos(Object *pObject) gibt die Position eines Objektes relativ zu einem beliebigen anderen Objekt zurück  



>> 26.11.2006
[SB]
- Gui MainLoop/Update-Funktionen neu aufgebaut. Die alte MainLoop war eine Katastrophe, da hier mit der Zeit immer
  mehr getrickst wurde und keine klare Linie mehr drin war, was die Update-Funktionen eigentlich tun sollen. Die Methoden
  Update und WaitForUpdate wurden nun ersetzt durch PendingMessages und ProcessMessages, und deren entsprechenden
  System-Funktionen. Diese werden wie immer im Backend für ein System implementiert und *müssen* folgenden Ansprüchen
  genügen:
  - PendingMessages gibt zurück, ob Nachrichten zum Abarbeiten da sind. 'true' = Es sind Nachrichten da, 'false' = Keine Nachrichten
  - ProcessMessages arbeitet eine Nachricht aus der Liste der wartenden Nachrichten ab. Sollte keine Nachricht da sein, wartet
  (blockiert) die Funktion so lange, bis eine Nachricht da ist und arbeitet diese dann ab.
  Durch diese Veränderung wurde die Main-Loop wieder wesentlich einfacher, und die meisten Hacks konnten wieder entfernt werden
  (z.B. Synchronize-Flag, Exit-Flag, Sleep). Es liegt nun beim Benutzer zu entscheiden, ob er ständig updaten will oder die
  blockierende Funktion verwendet, um Nachrichten abzufragen. In PLGui::Run() ist eine typische Main-Loop implementiert,
  die blockiert wenn keine Nachrichten vorliegen, dadurch ist die Prozessorauslastung bei einer reinen PLGui-Applikation auch
  automatisch bei 0% wenn sich gerade nichts tut, ohne dabei irgendwelche Sleep-Aufrufe zu benötigen.
  In PLEngine dagegen wird eine nicht-blockierende Main-Loop verwendet, um ständig den neuen Frame zu zeichnen. Dabei wird das
  Update der Engine wieder direkt in der Main-Loop ausgeführt, nicht in einem Gui-Listener, da dies die Main-Loop unnötig
  verkompliziert hat.
- Zu folgendem Kommentar aus PLGui:
  // [TODO] the hack GetNumOfWindows()>1 is currently needed
  // because without this hack the programm doesn't quit when the Frame, which has been
  // created with new Frame(), doesn't calls the Exit() function when the window gets closed
  Das ist richtig, wenn ein Frame geschlossen wird und dabei nicht Exit() aufruft, wird die Main-Loop natürlich niemals verlassen.
  Das ist aber kein Fehler in der Gui, sondern völlig korrektes Verhalten. Genau das gleiche passiert auch, wenn man z.B. mit dem Win32-API
  eine typische Gui-MainLoop programmiert und vergißt, beim Schließen des Hauptfenster PostQuitMessage() aufzurufen. Die MainLoop arbeitet
  so lange, bis die Gui "beendet" wurde, also liegt es in der Aufgabe z.B. des Hauptfensters, Exit() aufzurufen wenn es geschlossen wurde.
  Anstatt also so einen Hack einzubauen sollte geschaut werden, warum der entsprechende Frame nicht Exit() aufruft, der Fehler liegt
  dann im Frame, nicht in der Gui.
- Timer funktionieren zur Zeit in der PLGui nicht, da die auch nochmal komplett überdacht werden müssen. Ich hoffe wir kommen einige
  Zeit ohne Timer aus :-)



>> 25.11.2006
[SB]
- PLGui-Rewrite begonnen. Nicht erschrecken, zunächst wird die Verwendung von PLGui nicht deutlich einfacher
  werden, da die Änderungen wie immer Schritt für Schritt erfolgen müssen und wenn möglich alles dabei
  lauffähig bleiben soll.
- Gui::Object eingebaut: Dies ist eine neue Basisklasse für Gui Objekte. Sie beinhaltet die
  Basisfunktionen für den Baum (Parent, Children) sowie Funktionen um die Position und die Größe
  der Objekte zu setzen.  Von dieser Klasse wir sowohl Gui als auch Window abgeleitet, was dazu führt
  daß die ständigen Unterscheidungen, ob ein Fenster ein Parent besitzt oder nicht, wegfallen.
  Daher ist der Rückgabewert von GetParent() nun immer gültig (außer beim Gui Objekt),
  man kann also z.B. einfach GetParent()->GetSize() aufrufen und bekommt immer einen
  gültigen Wert. Handelt es sich dabei um ein toplevel window, so bekommt man die Größe
  der Gui (des Desktops) zurück. Dadurch fallen also viele Unterscheidungen weg, die
  vorher alles recht kompliziert gemacht haben.  Für den Fall daß man den Parent nur erhalten möchte,
  wenn es sich um ein Fenster handelt, gibt es die Funktion GetParentWindow(), die NULL zurückgibt wenn
  das Fenster nur noch die Gui als Parent besitzt.
  Auch muß im Konstruktor nicht ständig unterschieden werden, ob ein Window entweder
  die Gui oder ein anderes Window als Parent haben kann. Dies wurde sowieso nicht überall
  eingehalten und machte die ganze Sache unnötig kompliziert. Nun gibt es nur noch einen
  einzigen Konstruktor und es muß nicht mehr zwischen Window und Gui unterschieden werden.
  Beim Erzeugen eines Windows mit pParent = NULL wird nun immer die System-Gui verwendet.
  Dies scheint mir am logischsten, und wesentlich sicherer als der vorherige Hack (die zuletzt
  erzeugte Gui-Instanz zu benutzen). Werden Fenster für eine andere als die System-Gui erzeugt,
  muß also immer das Gui-Objekt (oder ein Parent-Window) angegeben werden, was aber auch nur logisch ist.
- GuiManager eingebaut: Diese Singleton-Klasse soll benutzt werden um die Gui Instanzen zu verwalten.
  Hier werden neue Gui Instanzen erzeugt und abgefragt, und es gibt eine Funktion  um einen Zeiger auf
  die System-Gui zu erhalten.
- Typedef von GuiNative entfernt.  Dies war eine unschöne Art, Plattformunabhängigkeit zu erreichen,
  indem einfach der Name der Systemklasse in GuiNative umbenannt wurde. Dies wurde entfernt und
  durch eine Funktion im GuiManager ersetzt
- Neue Klassen Point und Size eingebaut, welche durchgehend verwendet werden



>> 24.11.2006
[CO]
- An das Loadable-System angepasst



>> 14.10.2006
[SW]
- finale version für das visibility attribute feature vom gcc.



>> 11.10.2006
[SB]
- Bei *allen* Listenern und Informern den fehlenden Constructor hinzugefügt.
  Wir müssen ja nicht warten bis der nächste Fehler auftaucht, sondern sollten das lieber
  gleich beheben, wenn wir herausgefunden haben womit es Probleme gibt ...
- Diverse Kleinigkeiten verändert: Fehlende oder falsche Kommentare, Leerzeilen, etc.



>> 11.10.2006
[SW]
- Das projekte verwendet das neue visibility feature vom gcc, wenn vorhanden.
- WindowListener, DialogListener, Listener und CommandListener: default ctor hinzugefügt
  damit werden die probleme mit dem visibility-feature vom gcc behoben



>> 28.09.2006
[SW]
- linux port an die Änderungen angepasst.



>> 26.09.2006
[CO]
- Auf PLBool umgestellt (war erstaunlich wenig zu tun :)



>> 25.09.2006
[CO]
- Machte ein paar Style anpassungen



>> 13.09.2006
[CO]
- Beseitige Warnungen die erscheinen wenn der Compiler auf Warnungs-Level 4 gestellt wird



>> 12.06.2006
[CO]
- ClassView: TFlagDialog: Das mit den Flag Werten war fehlerhaft, denn die Reihenfolge der Flags ist beliebig...
  (da ich das gerade brauchte, musste ich das korrigieren)



>> 30.05.2006
[SW]
- LinuxImage: An das verschieben der Image enums angepasst.



>> 26.05.2006
[CO]
- Win32Image::SystemLoadImage() & LinuxImage::SystemLoadImage(): Es wurde dem einzuladenden Bild vorne 'Data/' hinzugefügt
  was nun aber durch diverse Änderungen Probleme machte. Innerhalb des Guis werden derzeit die Bilder als z.B. "btn_left.bmp"
  angegeben während in den Tools z.B. "Data/Textures/DollyCamera.bmp" geschrieben wird. Da aber 'Data/' nochmal angehängt wird,
  klappt das natürlich nicht - keine Ahnung wieso das vorher ging. ;-)
  Um die Änderungen minimal zu halten, es aber trotzdem wieder sauber am laufen zu haben so das man auch in den Tools diverse
  Bilder sehen kann entschloss ich mich diese ganzen kleinen Standard Gui Bilder zu einem Päckchen Namens 'PLGui.pak' zu packen
  welches im 'PLRuntime/Data' Ordner liegt. Die Bilder wurden aus den ganzen anderen Projekten entfernt. Bei 'SystemLoadImage'
  wird KEIN 'Data' mehr angehängt. In GuiSys::GuiSys() wird dem FS dieses 'PLGui.pak' als Basispfad eingefügt damit die Gui
  Standard Bilder immer problemlos gefunden werden.



>> 25.05.2006
[CO]
- DialogChooseFile: Bugfix: Beim auswählen einer Datei zum speichern konnte es noch Probleme geben



>> 21.05.2006
[SB]
- Projekte an FS-Änderungen angepaßt



>> 18.05.2006
[SW]
- Den Sizer des Frame-Windows unter linux unsichtbar gemacht, da dieser Probleme
  unter OpenGL Anwendungen macht.
  Der sichtbare OpenGL context wird nicht aktualisiert wenn der sizer nicht 
  zum teil oder ganz verdeckt ist.



>> 15.05.2006
[CO]
- Fehlerhafte -1 zuweisungen verbessert



>> 14.05.2006
[SW]
- linux build update



>> 14.05.2006
[SB]
- An PLGeneral Änderungen angepaßt



>> 11.05.2006
[SB]
- An PLGeneral Änderungen angepaßt (DEFINE_GROUP entfernt).
- SystemView entsprechend angepaßt: Man kann nun nur noch zwischen Classes und Modules wählen,
  bei der Klassenansicht wird der gesamte Ableitungsbaum per Treeview angezeigt. 



>> 22.03.2006
[CO]
- Slider: m_nStyle wurde im Konstruktor nicht Initialisiert was dann im Release Modus in SetSize() üble folgen hatte da 
  ich davon ausgehe das wenn das entsprechende Flag gesetzt ist,auch die entsprechenden Buttons vorhandend sind. Ist das 
  nicht der Fall, geht etwas total schief und darum hab ich hier keine extra Sicherheitsabfragen... und da hier dank nicht 
  Initialieren von m_nStyle etwas total schief lief, gabs nen Crash... mit Sicherheitsabfragen wäre das nie aufgefallen. :)
  Da hab ich nun fast den gesammten Morgen nach dieser kleinigkeit gesucht die den unregelmäßigen Crash in den vorallem 
  den Editoren erzeugte. (aber natürlich nur Crash im Release Modus, denn bei Debug hätte man das ja viel zu schnell gefunden)



>> 20.03.2006
[CO]
- EditBox: GetSelectedText() & RemoveSelectedText(): Das letzte Zeichen wurde nicht korrekt mit zurückgegeben



>> 19.03.2006
[CO]
- ClassView::OnCommand(): PL_VAR_FILENAME/PL_VAR_PLFILENAME: nFilterID muss natürlich Vorzeichen aufnehmen können da der 
  Datei Dialog bei Abbruch '-1' zurückgibt...



>> 15.03.2006
[CO]
- DialogChooseFile: Die einzelnen Filter werden nun intern in einer Liste mit Filter Strings gespeichert anstatt in einem 
  String statischer größe mit durch '\0' getrennte Filter. SetFilter() funktionierte durch die Umstellung auf die String 
  Klasse sowieso nicht mehr wie es sollte da '\0' ja das Ende eines Strings bedeutete. :)
  Nam die Funktion SetFilter() heraus. Passte alle anderen Projekte an diese Änderung an.



>> 14.03.2006
[SB]
- Einige Style Anpassungen vorgenommen und unfertigen Code entfernt. Bitte auf folgendes achten:
  - Zum schnellen Auffinden von unfertigen oder möglicherweise fehlerhaften Stellen im Code bitte die Tags
    [DEBUG], [TEST], [TODO] verwenden. Diese benutzen wir um schnell danach suchen zu können und z.B.
    mittels Suchfunktion sofort eine Liste aller Stellen im Code zu haben, die man sich nochmal anschauen muß.
    Daher bitte *nur diese Tags* verwenden, und nicht beliebig anders nennen!
    Also z.B. // [TODO] - nicht // TODO und auch nicht [TODO LINUX].
  - #ifdef LINUX so selten wie irgend möglich einsetzen. Im Allgemeinen trennen wir die Implementierungen
    für die Systeme ab, so daß nur die Includes unterschieden werden müssen. In ganz seltenen Fällen kann
    auch an anderer Stelle mal eine Unterscheidung nötig werden, aber bitte immer schauen ob es wirklich nötig ist,
    in den allermeisten Fällen sollte statt dessen eine neue Systemfunktion eingebaut werden, welche dann wiederum
    für jedes System implementiert wird. Im Falle eines Problemes wie mit "#define None" ist das #ifdef
    völlig in Ordnung, sowas wird dann wie geschehen mit einem Tag gekennzeichnet.
  - Nicht in Ordnung ist es so wie bei SetBackgroundColor geschehen. Neue Funktionen werden entweder - nach Absprache!! - 
    komplett eingebaut, oder aber rausgelassen, aber nicht halb oder nur für ein System oder für später einmal
    irgendwo einbauen und dann nicht verwenden, aber auskommentiert dringelassen.
    So sehen leider die meisten Quelltexte aus und es endet damit daß man an zig Stellen auskommentierte Dinge drinhat,
    von denen keiner mehr weiß wer sie wofür eingebaut hat (bzw. einbauen wollte), und ob diese noch sinnvoll sind, später
    eingebaut werden sollen oder zu überhaupt nichts mehr gut sind oder ob und welche probleme es damit gab.
    Daher habe ich diese Funktion nun komplett entfernt. Also so etwas bitte entweder ganz einbauen oder gar nicht, und natürlich
    nur mit vorheriger Rücksprache!



>> 08.03.2006
[SW]
- ist wieder unter linux übersetzbar.
- habe ein paar allgemeine fehler entfernt wie z.b. ein String &sText = ... (in ClassView.cpp)



>> 07.03.2006
[CO]
- ClassView: Hier wurde noch 'PLTColorX' verwendet, nahm das 'PLT' vorne weg - nun kann man auch wieder Farben ändern :)
- Win32Window::WindowProc(): WM_DESTROY: Hier setzte ich zur Sicherheit den Fenster Handle auf NULL
- Window::Destroy(): Sicherheitsabfrage eingebaut ob Fenster schon zerstört
- Slider::SetStyle(): Erzeugt nun die Button Fenster NUR noch wenn sich wirklich etwas am Style geändert hat
- Slider::OnSize(): Mißbrauchte SetStyle() zum aktualisieren der Button Positionen was bewirkte das JEDESMAL wenn hier sich 
  etwas an der Größe änderte die Buttons wieder zerstört und erzeugt wurden NUR um die Button Position zu aktualisieren... 
  hm, das war dann doch minimaler Overhead. ;-)
- ListBox::OnSize(): Hier wurden wenn sich etwas an der Anzahl der benötigten Edit Boxes etwas änderte AALLLEE Edit Boxes 
  gelöscht und neu erzeugt - auch dann wenn nun nur eine Box weniger benötigt wurde... oder wenn gar nur eine neue 
  hinzukam... ebenfalls nichts was die Performance steigert. ;-)



>> 28.02.2006
[CO]
- Leerzeichen/Tabs durchgeschaut und dort wo es nicht ok war verbessert. Im Linux Teil hab ich nur ein wenig was geändert 
  da es hier teils heftig zugeht - da lohnt es momentan nicht auf diese kleinigkeit zu achten, das machen wir dann gleich 
  beim überarbeiten von PLGui mit. :)



>> 25.02.2006
[SB]
- Alles an PLGeneral Änderungen angepasst



>> 24.02.2006
[CO]
- Stellte wie besprochen dort wo möglich/sinnig von globalen Definitionen auf Klassen abhängige enum Definitionen um, so 
  ist's nun gleich sehr viel schöner zu Lesen :)
  (in Sys.h gibts noch ein paar Definitionen die ich bei Zeiten noch verschieben müsste)
- Machte ein paar Hilfs-Klassen/Strukturen zu privaten Klassen/Strukturen da diese z.B. NUR von einem speziellem Control 
  benötigt werden
... passte alle anderen Projekte an diese PLGui Änderungen an



>> 23.02.2006
[CO]
- An PLGeneral Änderungen angepasst. In GuiSys kommentierte ich das mit den Threads für die Timer erstmal aus - ich hatte 
  keine Lust da etwas zurech zuschustern - das wird sowieso ja nochmal Überarbeitet sobald wir mit PLGeneral soweit fertig 
  sind und da hat es keinen Sinn hier jetzt großartig Zeit reinzustecken. :)



>> 22.02.2006
[CO]
- Die Haupt-Header der Projekte haben nun am Anfang des Namens wieder ein PL
- Doxygen Makefile angepasst



>> 15.02.2006
[CO]
- GuiSys::Update(): Das entfernen von Elementen aus einer Liste während gerade ein Iterator darüberläuft ist eine sehr 
  gefährliche Sache, daher änderte ich das hier so das zu löschende Fenster in eine 'To Delete'-Liste eingetragen werden.
 (das mit den Timern wird zwar nochmal überarbeitet, sollte aber bis dahin halbwechs sauber laufen :)



>> 06.02.2006
[CO]
- Alles auf String::Format() umgestellt + dort wo möglich von %f auf %g umgestellt da dadurch nur das nötigste ausgegeben wird
- Baute an ein paar Stellen an denen Slider::SetRange() verwendet wird Sicherheitsabfragen ein, so das Max keine negativen 
  Werte übergeben wird
- EditBox::SetCursorPosition(): Wenn m_nCursorPos gleich Null ist, so ist auch die Grafische Cursor Position bei 0


>> 22.01.2006
[CO]
- An uint32 Änderungen angepasst



>> 19.01.1006
[CO]
- Alles auf Namespaces umgestellt



>> 17.01.2006
[CO]
- An PLGeneral Änderungen angepasst
- Fand und behob in GuiSys::GetFont() ein Speicherleck: Es konnte passieren das der Iterator nicht mehr gelöscht wurde



>> 22.12.2005
[CO]
- GuiDialog::OnClose(): NUR wenn der Dialog Modal ist, wird er beim schließen nicht zerstört, nicht Modale Dialoge hingegen 
  werden hier nun gekillt. Der Dialog speichert in einem entsprechenden Flag ob er gerade Modal angezeigt wird oder nicht.
- GuiComboBox: Dieses Control muss seine 'auspoppende' Liste selbst löschen da diese kein Child-Window ist, ansonnsten bleibt
  diese nach der Zerstörung des Controls noch am Leben... 
... ich wunderte mich schon das es im Laufe der Zeit immer mehr Fenster im Gui System wurden - diesen zwei Bugs hatte man 
das zu verdanken.



>> 20.11.2005
[SB]
- Aufrufe von PLTContainer::Add() angepaßt
- Include <Log.h> eingefügt



>> 06.11.2005
[CO]
- GuiDialogChooseFile: Verbesserte Fehlerbehandlung wenn ein Verzeichniss welches verwendet werden soll nicht vorhanden ist



>> 24.10.2005
[CO]
- SaveWindows() auf XML Format umgestellt, hier gibts noch das 'Problem' das 'überflüssige' Fenster ebenfalls mitgespeichert 
  werden - also z.B. Buttons in der Titelleiste eines Frames etc. Da müsste man sich etwas überlegen wie man 'zu speichernde' 
  Fenster entsprechend Markiert, oder beim Laden prüft ob das entsprechende Fenster bereits vorhanden ist. (z.B. bereits 
  durch den Frame selbst automatisch erzeugt wurde)
- In LoadWindowRec() können die konkreten Fenster noch nicht wirklich korrekt erzeugen da hier noch das mit den Parametern 
  nicht Implementiert ist um z.B. dem Fenster sein Parent zu übergeben.



>> 14.10.2005
[CO]
- TFlagDialog::OnCommand(): Leitet nun Befehle auch an seine Basis Klasse weiter. Somit funktioniert hier jetzt auch der  
  Frame Quit Button. Dieser Dialog hat nun auch immer eine Mindestgröße so das die Buttons sichbar bleiben. Beim Klassen 
  Inspektor erscheint bei Flag-Variablen nun nur noch der Edit Button wenn es bekannte Flags gibt - wenn nicht ist dieser 
  Edit-Dialog sowieso Sinnfrei. :)



>> 09.10.2005
[CO]
- GuiPDButton um Styles erweitert. GuiPDButton kann nun auch als einfache 'Button Sammlung' verwendet werden.
- GuiSys::SetMouseOverWindow(): Sobald Tooltips durch die Standardposition aus dem Bildschirm ragen werden diese anderst 
  platziert
- GuiConfigView: In der Auswahlliste werden nur noch Config-Klassen aufgelistet in denen sich auch wirklich etwas zum 
  Einstellen befindet



>> 02.10.2005
[CO]
- Erweiterte GuiWindow um die Funktion GetChildWindowIterator() welche bereits im PL Ingame Gui Verwendung findet
- GuiDialogChooseFile: Wird ein File-Dialog nun geöffnet, so wird das aktuelle gewählte Verzeichniss nur auf Wunsch 
  zurück zum angegebenen Start Verzeichniss gesetzt.
- Tooltips werden nun erst nach einer Einstellbaren Verzögerung angezeigt
- GuiWindow: Neue Funktion: GetTimer() zum Abfragen des Timers



>> 07.09.2005
[CO]
- GuiSpinner: 'Korrigiert' nun Fehlerhafte Eingaben
- GuiColorDialog: Bei den Farb Eingabe-Feldern kann man nun keinen Unfug mehr eingeben wie z.B. bei Blau 
                  'nee, bin nüchtern' :)
- GuiSys::Update(): bUpdateAgain: wird nun wieder korrekt gesetzt und damit verschwanden gleich wieder diverse 
  merkwürdigkeiten wie z.B. das der Cursor in der Edit Box nur noch blinkte wenn die Maus bewegt wurde oder der iirrsinnig 
  laaangsame Aufbau in den Tools macher Dialoge wie z.B. beim Color Dialog. Ist natürlich wie gesagt nur ne Zwischenlösung.
- GuiEdit Box um zwei weitere Flags erweitert welche das Verhalten wenn es sich um ein Eingabe-Feld für Zahlen handelt noch 
  genauer definieren können (keine Fließkommerzahlen, keine Negative Zahlen)



>> 05.09.2005
[CO]
- GuiFrame: Titel Leiste hat eine etwas hellere Farbe, war mir einfach zu düster
- GuiSlider & GuiSpinner: Reagierten nun auch auf Tasten
- GuiSpinner: Um die '0' für das Scroll Rädchen noch einen Kasten gezeichnet so das man erkennen kann das dieses 
              Symbol zum Element gehört
- GuiEditBox: Überarbeitete nochmal das 'Scrollen' des Textes wenn dieser nicht mehr auf einmal in die Text Box passt. 
              Da jedes Zeichen eine andere länge hat reicht es nicht eine Statische Buchstabenlänge anzugeben. :(
              Das 'verschieben' des Sichtbaren Bereiches ist nun alleinige Aufgabe der Darstellung somit ist die ganze Sache 
              gleich nen Stückchen übersichtlicher. Desweiteren wird bei Zahlen Eingabefelder nun auch ein '-' am Anfang 
              akzeptiert. (könnte doch hin und wieder praktisch sein ;-)



>> 17.07.2005
[CO]
- GuiMenu: Neue AddSubMenu() um auch Untermenü Items Command ID's geben zu können & GetSubMenu() Funktionen um sich 
           Untermenüs zurückgeben lassen zu können.



>> 14.07.2005
[CO]
- GuiButton: Drück man den Kopf wird beim loslassen nur ein Signal verschickt wenn sich die Maus immer noch im Knopf befindet
- GuiWin32::SystemCaptureMouse(): Irgendwie fehlte hier noch eine Abfrage ob das Gui Window überhaupt der Mause
                                  Nachspionieren darf. Das gleiche in GuiLinux::SystemCaptureMouse().



>> 05.07.2005
[SW]
- Timer-Thread eingbaut, dadurch wird der sleep-aufruf hinfällig :),  muss nur noch im Win32-backend eingebaut werden.



>> 03.07.2005
[CO]
- Passte PLGui an neuen Kommentar Style an
- GuiWindow: SetVisible() Default Wert ist nun 'true'
- Packte alle Texte wie 'Cancel' in das Makro PLT() damit diese Sprach Abhängigen Dinge gekennzeichnet sind
- Setzte RTTI Variable Namen so das man z.B. nicht mehr 'm_sName' sondern 'Name' schreiben kann



>> 02.07.2005
[SW]
- PLGui: Minimier-/Maximier funktioniert jetzt problemlos, habe desweiteren die SetMouseOverWindow-Funktion etwas
  abgeändert, damit sie jetzt auch NULL-zeiger "verarbeitet". Dadurch wird jetzt die Gui dem letzten Gui-Window,
  in welchem die Mouse war, auch mitteilen, das sich der Mouse-Zeiger nicht mehr im Fenster befindet, wenn der 
  Mouse-Zeiger sich auserhalb des Hauptfenster ist. Das war nötig, da beim drücken des Max-buttons, bei maximierten
  Fenster, der button immer noch meinte, das sich der Mouse-Zeiger immer noch in seinem Fenster befindet.Obwohl sich
  der Pointer sich ausherhalb befand.



>> 26.06.2005
[SW]
- Habe den Sleep Aufruf ins Backend verlegt, da unter Linux das Verschieben/Größeändern eines Fensters, wegen des 
  Sleep Aufrufs (von 1ms) in GuiSys::Update "durcheinander" gebracht hat. Denn durch den Sleep-Aufruf kamen die 
  Xlib-Events verspätet an. Und das hat z.b. beim Verschieben eines Fensters zu sprüngen des Fensters geführt 
  (Chris weis was ich meine ;)).  Durch reduzieren des sleeps unter linux auf 1 nanosec war das problem weg. Und 
  zusätzlich habe ich einen signal-handler für ein paar System-Signale eingebaut(z.b. SIGINT, 
bei strg+c in der 
  konsole, von dem aus das Program gestartet worden ist,)
- Desweitern würde ich vorschlagen, das man dem Hauptframe(das RootFenster als Parent) die decoration des Systems 
  wiedergibt. Da es z.b. unter Gnome nicht möglich ist, das Haupt-Fenster/Frame zu minimieren, wenn man auf den 
  Minimieren-Button klickt. Ich bin eh der Meinung, das die Fenster auch unter Linux genauso aussehen wie unter Windows,
  obwohl die System-decoration verwendet wird (Ein gutes beispiel ist dafür Opera). Das Linux Backend ist da schon soweit 
  umgestellt, nur das Win32-Backend muss noch umgestellt/getestet werden.
- GuiEditBox: - Hatte das Control einmal den Fokus wurde der Timer beim Fokus verlust nicht wieder deaktiviert, korrigiert.
              - Drückt man eine Taste wird der Blinkende Cursor sofort wieder sichtbar, sieht netter aus :)


>> 24.06.2005
[CO]
- Neues Control: GuiPDButton: Ein Button bei dem eine Liste an Auswahl möglichkeiten 'aufklappt' sobald man die linke
  Maustaste gedrückt hält. Dieses Element brauche ich für die Kamera Optionen in den Tools damit sich die Kamera über das 
  Gui möglichst bequem und auf 'gewohnte art und weise' bedienen lässt. ;-)
  (PD steht für 'Pull Down' mir wurde das zu lang das immer wieder mit GuiPullDownButton voll auszuschreiben...)



>> 17.04.2005
[CO]
- GuiSplitter::SizeWindowContents() -> Da das vergrößern der Felder irgendwie nicht mehr so recht funktionierte, nahm ich
  die Fehlerhaften Abfragen raus. Bei Zeiten müsste man das alles nochmal überarbeiten.



>> 03.03.2005
[CO]
- GuiClassView: Fügte die Controls zum Manipulieren von Vektoren und Farben erstmal direkt in die Viewer Klasse ein damit 
                man diese Dinge wieder im WE Bearbeiten kann. Es bleibt die Frage ob wir diese Dinge direkt da drinlassen,
                dadurch wird zwar PLGui auch von PLMath abhängig, aber immer noch besser als wenn PLMath von PLGui abhängig
                wird. :)
- Fand einen der Gründe wieso vor allem ClassView immer etwas träge ist. In GuiWindow::ReDraw() muss man wenn ein Element
  nicht sichtbar ist es auch nicht in die neuzuzeichnende Liste eintragen, denn sobald es wieder Sichtbar wird wirds ja 
  Automatisch neu gezeichnet. Wieder mal so nen Typischer Fall von kleines 'Phuibah' - große Auswirkung. ;-)



>> 02.03.2005
[CO]
- GuiDialogChooseFile::OnCommand() -> Falls die ausgewählten Dateinamen keine Erweiterungen wie z.B. '.bmp' haben, so wird 
  die Erweiterung des aktuell ausgewählten Filters hinzugefügt. (falls dieser Filter nicht '*.*' ist)



>> 01.03.2005
[CO]
- GuiListView::AddColumn(): Der Titel Text ist nun Standardmäßig linksbündig. Zentriert ist meistens etwas ungünstig.
  (über GetColumnTitleAlignment() kann dies aber ja jeder Einstellen wie er will)
- GuiClassView::OnCommand() -> PL_VAR_FLAGS wird nun korrekt gesetzt



>> 23.02.2005
[CO]
- Bei GuiClassView::SetValue() -> case PL_VAR_ENUM: wurde falsch gecastet. Desweiteren wird nun bei jeder Variable in den
  Annotations nach 'boolean' gesucht, wurde es gefunden wird die Variable als boolean angesehen.



>> 22.02.2005
[SB]
- PLGui an die neuen RTTI-Makros angepaßt



>> 17.02.05
[CO]
- GuiGroupBox: Verwendet nun kein GuiButton mehr für seine Titel-Leiste
- GuiEditBox: Um Style PLGUI_EDITBOX_NOBORDER erweitert um das Zeichnen des Rahmens zu deaktivieren
- GuiComboBox: Verwendet keinen Button mehr für das 'aufklappen'-Feld



>> 15.02.05
[CO]
- GuiGroupBox::OnDraw() -> Titel-Style etwas geändert da es im ME nicht sonderlich übersichtlich war. Ist momenten nicht 
  soo schön gelöst, schöner wäre es mittlerweile komplett ohne extra Button-Element - aber da Stefan derzeit an PLGui 
  werkelt wird das möglicherweise sowieso nicht übernommen und darum wollt ich da jetzt nicht viel Zeit reinstecken. Auf 
  jedenfall siehts so wesentlich besser aus.



>> 04.02.05
[CO]
- Neuer Dialog: GuiResourceManager -> Von diesem Template werden die einzelnen konkreten und erweiterbaren Resource Manager
                abgeleitet.



>> 01.02.05
[CO]
- GuiFileSystemView: Breiter gemacht da die Pfade nie komplett reinpassten :(
- Neuer Dialog: GuiConfigView -> Zum Betrachten und Manipulieren der Konfigurationen



>> 01.02.05
[SB]
- Habe die Projektdateien etwas aufgeräumt, in beiden Solutions ist nun erst einmal nur PLGui selbst
  enthalten, genau wie bei den anderen Projekten ja auch, denn der Test gehört ja inzwischen zu PLTests.
  Später kommen ja noch diverse Gui-Plugins hinzu



>> 27.01.05
[CO]
- Bei den VarChanged Funktionen fügte ich else hinzu, denn wenn ne Variable gefunden wurde kann man sich die weiteren
  Abfragen sparen.  



>> 18.01.05
[CO]
- GuiWindow::OnMessage() entfernt da mittlerweile unerwünscht



>> 10.01.05
[CO]
- GuiListBox: pUserDate der Items wird nun Initialisiert
- GuiDialogChooseFile: Ist kein Filter vorhanden so wird nun immer *.* als Filter eingetragen



>> 03.01.05
[CO]
- GuiTooltip & GuiMessageBox: Texte welche über mehrere Zeilen gehen sind nun möglich
- GuiDialogChooseFile und GuiDialogChooseDirectory: Eigene Dialoge implementiert so das nun nicht mehr die Windows Dialoge
  verwendet werden. Derzeit kann man noch nicht so einfach auf andere Partitionen wechseln - weis nicht wie ich das mit dem FS
  realisieren kann. Derzeit muss man direkt den Partitions Namen oben im Verzeichniss eingeben. Desweiteren kann man im
  FileDialog noch keine Dateien löschen oder umbenennen. Aber der Rest funktioniert bereits sehr gut - wenn man also später
  noch Zeit und Lust hat kann man das ja Erweitern, aber fürs erste sollte das reichen!
- Ging nochmal alle Gui Elemente durch und machte die Destruktoren protected damit man diese nicht einfach über delete löschen
  kann was ja zu problemen führen könnte.
- Hier und da an verschiedenen Controls noch etwas Bugfixing betrieben



>> 30.12.04
[SW] + [CO]
- GuiWin32Image: Auf neues FS umgestellt
- GuiSysGraphics: - Neue System Funktion SystemDrawRect() damit ein Rechteck nicht umständlich über 4 Linen gezeichnet
                    werden muss. Kann ja jedes Backend dann selbst machen wie es will. :)
      - Bei SystemDrawLine() etc. kann man nun noch die Linenbreite mitangeben
- Ingesammt gesehen müsste das Linux Gui Backend nun soweit passen - jetzt muss es nur noch übersetzt und
  getestet werden.



>> 27.12.04
[CO]
- Win32: Tool Klasse TColorCursor entfernt und GuiWin32Tools eingeführt in der nun alle Platform abhängigen Tool
         Funktionen liegen.
- GuiSys: SystemGetTickCount() und SystemSleep() entfernt da diese Funktionen nun in PLTPlatform sind.



>> 25.12.04
[CO]
- Neuer Dialog: GuiFileSystemView: Zum manipulieren der FS Einstellungen



>> 22.12.04
[CO]
- Stellte alles auf neue Container Klassen um



>> 18.12.04
[CO]
- Die Behandlung des Fokus noch etwas verbessert
- GuiMenu Überarbeitet, sieht nun besser aus und ist generell sauberer Realisiert
- GuiMenuBar Überarbeitet -> Ist nun nur noch ein Tool Window mit internen Menü. GuiMenu selbst hat
  intern ein Flag das entscheidet ob es ein normales Menü oder ein Menü Balken ist.
- GuiWindow, GuiCheckBox, GuiButton: RTTI Variablen auf korrekte Default Werte gesetzt
- GuiCommandInformer::InformOnCommand() kann nun Optional noch eine weitere CommandID an die Listener schicken
  ... das ist u.a. in GuiMenu recht praktisch. :)
- GuiSys: Neue Funktionen LoadWindows() & LoadWindowRec() & SaveWindows() & SaveWindowRec() -> Zum
  laden und Speichern von Fenstern. PLGui verwendet nun somit das neue FileSystem. (bis jetzt hatte
  es ja noch kein FS verwendet)
  -> Bei LoadWindowRec() wird noch nicht die korrekte Fenster Klasse erzeugt da dies derzeit ohne
     Automatische Möglichkeit zu Umständlich wäre... 
  -> Bei SaveWindows() konnte ich noch nicht rausfinden wie man mit dem FS eine neue Datei erzeugt wenn man nur einen
     absoluten Dateinamen hat.

     

>> 18.12.2004
[SB]
- PLGui: Hauptdatei PLGui.cpp hinzugefügt, in welcher das PLGui-Modul registriert wird



>> 17.12.04
[CO]
- GuiComboBox: Um GetUserData() und SetUserData() erweitert



>> 15.12.04
[CO]
- GuiListView & GuiListBox: Tooltip Text lässt sich nun pro Item Einstellen



>> 13.12.04
[SB]
- GuiComboBox:          SetTopMost() entfernt, dieses Flag ist nur für besondere Fenster gedacht, die immer im Vordergrund seien sollen, aber nicht für einfache Controls
- GuiSystemView:        An Änderungen in PLTSystem angepaßt
- GuiWindow, GuiDialog: Sind nun als Gruppen definiert



>> 12.12.04
[CO]
- GuiTreeView und GuiListBox etwas erweitert
- Neuer Dialog: GuiSystemView -> Dient u.a. zum ein- und entladen von Modulen (für PixelLight praktisch das :)



>> 09.12.04
[CO]
- GuiMessageBox: Um Styles: PLGUI_MESSAGEBOX_YESNOALL und PLGUI_MESSAGEBOX_YESNOCANCEL erweitert



>> 30.11.04
[SB]
- GuiFrame: Es gibt jetzt ein neues Flag m_bQuitOnClose, das bewirkt, daß die Applikation automatisch beendet wird,
  wenn der Frame geschlossen wird. Dies ist nützlich, wenn man keine eigene Klasse für das Hauptfenster verwendet,
  sondern einen einfachen Frame erzeugt, und somit auch nicht einfach OnClose() überschreiben kann. Der Standardwert
  für m_bQuitOnClose ist aber false, da dieser Fall wohl nicht all zu oft eintreten sollte.



>> 19.11.04
[CO]
- Import/Export an PLGeneral Style angepasst



>> 15.11.04
[CO]
- GuiFrame: Sizer verschwindet nun wenn das Style PLGUI_FRAME_HIDE gesetzt ist



>> 04.10.04
[CO]
- GuiContentWindow: Beim zerstören von Fenstern konnte es vorkommen das das Parent NULL war und es durch die fehlende
                    Sicherheits Abfrage dann zum Crash kam -> Nun wird immer geprüft ob der Zeiger gültig ist.



>> 30.09.04
[CO]
- Passte PLGui an die neue Klasse PLTImage aus PLGeneral an, somit muss PLGui keine Bilder mehr selbst laden etc. 



>> 22.09.04
[CO]
- GuiWin32::SystemSetMouseImage() - Funktioniert nun endlich :)
- Implementierte die verwendung von Fonts nun mal richtig - denn u.a. beim Selektieren bei EditBox muss man wissen welche
  Font verwerden werden soll um die Text länge zu ermitteln. Bis jetzt war in GuiWin32Window::WindowProc() WM_PAINT eine
  Standard Schrift gesetzt. Nun kann jedes Fenster seine eigene Schrift haben welche man über GuiWindow::GetFont() und
  GuiWindow::SetFont() ermitteln/setzen kann, jedoch wird als Default eine globale Schrift verwendet welche man über
  GuiSys::GetDefaultFont() ermitteln kann.
- GuiScrollWindow: Scroll Window wird nun darüber informiert wenn das Content Window seine größe ändert - um dann die Scroller
  anpassen zu können.



>> 14.09.04
[CO]
- GuiWindow::SetTooltipText() -> Dort kann man nun auch Parameter in den Strings angeben



>> 13.09.04
[CO]
- GuiSys: Neue Funktionen: GetTextFromClipboard() & CopyTextToClipboard() -> Zum auslesen und setzen von Texten aus/in das
          System Clipboard... soweit ich weis gibt es sowetwas unter Linux nicht, da kann man dann ja einfach einen Gui
          internen Buffer nehmen. :)
- GuiEditBox: Um Clipboard Funktionen erweitert. (strg-c, strg-v, shift-entf, shift-einfg)
              Damit ist das Arbeiten mit den Editoren gleich noch nen stückchen komfortabler. :)



>> 06.09.04
[CO]
- Ein paar kleine Verschönerungen an Jans Änderungen vorgenommen. (Leerzeilen raus, Einrücken etc.)
  Nun stimmt der Code style wieder soweit. (im Flags Dialog hab ich erstmal nichts gemacht :)
- In GuiClassView den Flags Dialog in die cpp Datei verschoben damit das Interface sauber bleibt.



>> 04.09.04
[CO]
- GuiSys::Update() -> Beim zerstören wird das Fenster nun zuerst aus der Liste der zu zerstörenden Fenster genommen da
  es ansonnsten zu Problemen kam wenn z.B. die Engine in einem Fenster Destruktor aktualisier werden sollte.
  (endlos Rekursion :)



>> 28.08.04
[CO]
- GuiWindow: GetPos() und GetSize() verwenden nun wieder die System Funktionen zum ermitteln der aktuellen Werte, in den
  eigenen Zwischenvariablen standen teils zu bestimmten Zeitpunkten nicht korrekte Werte so das z.B. GuiMenu nicht korrekt
  funktionierte.
- GuiColor entfernt und überall durch PLTColor3 aus PLGeneral ersetzt
- Da durch GuiColor schon einige Dateien geändert wurden hab ich auch gleich noch PLGui an die neuen Daten Typen angepasst



>> 26.08.04
[CO]
- GuiDialogChooseFile und GuiDialogChooseDirectory lassen sich nun nicht mehr doppelt öffnen
- GuiListBox: Die Trennlienen werden nun korrekt dargestellt



>> 25.08.04
[CO]
- GuiListBox: - Neue Funktion: UpdateEditBoxesSelection() -> wird intern verwendet wenn die Selektion geändert wurde
              - Intern etwas Optimiert so das beim hinzufügen von neuen Texten nicht immer alles aktualisiert werden muss was
                bei sehr vielen neuen Einträgen sehr langsam wurde.
- GuiWindow: System Fenster wird nun erst im GuiWindow Destruktur zerstört da es ansonnsten sein konnte das das System
  Fenster noch z.B. gezeichnet wurde obwohl kein Fenster-Handler mehr vorhanden war was in ReDraw dazu führte das alles
  gelöscht wurde und es flackerte. (konnte man gut beim beenden der Editoren beobachten :)
  Desweiteren wird bei ReDraw() das Fenster normalerweise nur in eine Liste zu erneuernder Fenster gesetzt, so kann man
  es vermeiden das Fenster zu oft unnötig aktualisiert werden.



>> 11.08.04
[SB]
- GuiWindow: Klassen ans RTTI angepaßt
- GuiControls: Klassen ans RTTI angepaßt
- Die wichtigsten Attribute der PLGui-Klassen müßten nun über das RTTI System ansprechbar sein. In einigen Fällen wird
  es noch nötig sein, die Klassen etwas umzugestalten, um weitere Attribute verfügbar zu machen, da diese in vielen
  Fällen gar nicht als Variable vorliegen sondern bisher nur über Methoden ansprechbar sind. Für's erste dürfte dies
  aber reichen, um z.B. den Gui-Editor anzupassen :-)



>> 10.08.04
[SB]
- Alle Fensterklassen werden nun beim PLGeneral-RTTI-System angemeldet, das alte interne Makro PLGUI_CLASSID wurde entfernt
- GuiWindow: Um den Zugriff über das RTTI sinnvoll zu machen werden alle wichtigen jetzt in Variablen zwischengespeichert
  (z.B. m_nX, m_nY, usw). Nach einer Veränderung dieser Variablen werden die Zustände durch einen Funktionsaufruf
  automatisch angeglichen, damit kann GuiWindow jetzt also über das RTTI gesteuert werden
- GuiBase: Klassen ans RTTI angepaßt



>> 08.08.04
[CO]
- GuiWindowListener: Musste die Virtuellen Funktionen umbenennen da der Compiler in GuiComboBoxList Probleme hatte
  herauszufinden welches OnDeActivate er in der Basisklasse GuiListBox aufrufen sollte - trotz der unterschiedlichen
  Parameter! Hab nun überall ein 'Informed' davorgehängt, somit ist die Namensgebund dort eindeutig und der Compiler
  hat keine Probleme mehr. Da Window Listener bis jetzt nur in PLGui selbst verwendet werden war die Umbenennung nicht
  so schlimm da die paar Stellen schnell angepasst waren.
- GuiListBox lässt sich nun auch bequem über Tasten Steuern was z.B. im WE oder ME extrem hilfreich ist wenn man aus 
  einer Liste schnell alles oder Teile auswählen will.



>> 06.08.04
[CO]
- PLTWindow::SetVisible() kann man nun Optional mitgeben ob das Fenster auch Aktiviert werden soll oder nicht wobei aktivieren
  beim Sichtbar machen wie vorher auch Standard ist. GuiTooltip gingenen macht sich selbst nicht aktiv sobald es Sichtbar wird
  da ich es als Störend empfand das z.B. eine ComboBox zuklappte sobald ein Tooltip erschien.
- GuiSys::SetActiveWindow() -> Setzt nun zuerst das neue Aktive Fenster und informiert dann das alte - so kann dieses dann
  eventuell das neue Aktive Fenster abfragen (das brauchte ich so in GuiComboBox, siehe unteren Punkt :)
- GuiComboBox: Das aufklappen/zuklappen verhält sich nun besser



>> 04.08.04
[CO]
- GuiSys: Neue Funktionen: GetTooltipsEnabled() & SetTooltipsEnabled() -> Damit lassen sich Tooltips global aktivieren/
          deaktivieren. Die Editoren bieten z.B. in den Einstellungen an die Tooltips zu deaktivieren falls diese Stören.



>> 28.07.04
[CO]
- GuiSlider, GuiListView: MouseWheel-Support verbessert, der Fokus wird nun meist an den Slider weitergegeben
                          damit sich das Element komfortabler Bedienen lässt. Vorallem der Entity Variable Inspector
                          lässt sich nun gleich viel besser Bedienen da man mit dem MouseWheel schnell scrollen kann.
- Informer & Listener: Listener wissen nun von den Informern so das wenn Listener zerstört werden diese die Informer
                       über ihr Ableben informieren können. Merwürdig das dies bis jetzt noch nicht aufgefallen war - erst als
                       ich das mit dem MouseWheel-Support verbesserte gabs plötzlich einen Crash da der Informer nicht mehr
                       vorhandene Listener informieren wollte. ;-)



>> 22.07.04
[CO]
- Fand und behob das Fokus Problem in GuiWin32Window::SystemCreateWindow() durch setzen des NULL
  parents.



>> 15.07.04
[CO]
- Machte Destruktoren von GuiSysFont, GuiSysGraphics, GuiSysImage virtuell



>> 08.07.04
[CO]
- GuiContentWindow::OnSize() -> Machte probleme im Ingame GUI, daher nahm ich die Benachrichtigung des
                                Parent Windows erstmal raus...



>> 07.04.04
[CO]
- GuiSys: Neue Funktion: SaveImageData() speichert Image Daten im entsprechenden Format



>> 06.04.04
[CO]
- GuiSys: Neue Funktion: GetImageData() erzeugt ein Image aus den gegebenen Daten wobei dieses Image System unabhängig ist
          und auch von der Engine zum einladen von Texturen verwendet wird. Somit wird DevIL NUR noch von PLGui verwendet
          welches nun komplett für das einladen von Bildern verantwortlich ist.



>> 08.03.04
[CO]
- GuiSpinner noch etwas angepasst (setzen/lesen von double)



>> 21.02.04
[CO]
- Verfeinerte noch etwas PLGui (Bug fixing etc. :)



>> 19.02.04
[CO]
- GuiListView und GuiListBox erweitert. Die Eigenschaften der Items lassen sich nun noch genauer einstellen.
  Desweiteren lassen sich nun auch eigene Fenster in die Items 'einbetten'. (siehe PLGuiDemo)



>> 18.02.04
[CO]
- GuiListView ist nun Einsatzbereit -> Im GuiDemo gibt es nun u.a. einen Inspector Test welcher GuiListView verwendet
- PL Entity Variable Inspector reimplementiert (siehe Debug Dialog und World Editor)



>> 15.02.04
[CO]
- GuiWin32Image::SystemLoadImage() auf DevIL umgestellt. Dadurch kann man im Gui nun diese Formate einladen:
  bmp, cut, ico, jpg, pcx, tif, png, tga, dds, psd
- GuiListView funktioniert nun zu ca. 80%
- Diverse kleine verbesserungen/erweiterungen an den PLGui Controls



>> 14.02.04
[CO]
- GuiPanel in GuiScrollWindow umbenannt
- GuiSplitter: Erweitert/verbessert



>> 13.02.04
[CO]
- Die Bitmaps befinden sich nun erstmal im Data Unterordner damit diese im HDRI Viewer nicht direkt im
  Grundverzeichniss liegen
- GuiSys::Update() -> Kann man nun als Parameter mitgeben ob ein Sleep zum Prozessor entlasten verwendet
  wird oder nicht
- Neues Window Element: GuiPanel: Ist ein Fenster welches ein größeres Content Window haben kann. Ist das
  Content Window größer als sein Parent Window so erscheinen optional Slider im Panel.



>> 11.02.04
[CO]
- GuiDialogChooseFile::SetStartDir() -> Will man IMMER bei jedem Öffnen des Dialoges diesen Pfad haben so muss man diese
  Funktion immer vor dem Öffnen des Dialogs aufrufen und den Pfad setzen. Ansonnsten wird der Start Pfad nur einmal gesetzt.
- GuiGraphics: Print() & GetTextWidth() -> Man kann nun die Text länge per Hand angeben falls man z.B. nicht die Länge
  des gesammten Textes haben will
- GuiEditBox: Text lässt sich nun mit der Maus auch markieren. Is Text markiert und wird eine Taste gedrückt so wird der
  markierte Text gelöscht.



>> 07.02.04
[CO]
- Die neuen Maus Relevanten Funktionen nochmals umbenannt damit diese mit Mouse Capture stimmiger sind.
  PLGui Doku an Änderungen angepasst.



>> 06.02.04
[CO]
- GuiSlider: Neue Funktionen: - GetMinMoverSize() & SetMinMoverSize() -> Zum Einstellen der minimalen Mover größe
- GuiDialogChooseFile::SetStartDir() -> Konvertiert nun intern alle Slashs (/) in Backslashs (\) da der Windows
  Datei Dialog sonst diesen Pfad nicht verwenden kann
- GuiWindow::OnRButtonUp() -> Popup Menüs welche nicht dieses Fenster als Parent haben (da diese Menü z.B. nicht
  vom Fenster 'abgeschnitten' werden sollen) werden nun korrekt platziert
- Musste Fenster Tasten Nachrichten von char cKey auf int nKey umstellen da ansonnsten nicht alle Tasten umfasst
  wurden. (da virtual key code)
- EditBox: Neues Style: PLGUI_EDITBOX_NUMERIC -> Damit kann man nur die Eingabe von Zahlen erlauben



>> 05.02.04
[CO]
- GuiSys: Neue Funktion: SystemSleep() -> Lässt die Anwendung 'schlafen'
- GuiSys::Update() ruft nun am Ende immer SystemSleep für eine Millisekunde auf und kann zudem durch Nachrichten
  etc. vorzeitig wieder unterbrochen werden. Wird dies nicht getan so ist die CPU auslastung immer bei 100%
- unter Windows wie auch unter Linux. Per sleep ist dies so die schönste und einfachste Lösung welche zudem
  voll kompatible mit z.B: PL Ingame Menüs ist! Das über einen System Timer zu lösen wäre mehr aufwand und zudem
  problematischer. Jan viel diese 100% CPU auslastung bereits im Viewer unangenehm auf und daher musste das endlich
  final gelöst werden.
- Neue System Metric Parameter: GUI_SYSTEMMETRIC_CXCURSOR und GUI_SYSTEMMETRIC_CYCURSOR -> Geben die größe des
  Maus Zeigers zurück
- GuiSystem: Neue Funktionen: - SystemSetMouseCursor() -> Setzt das Maus Zeiger aussehen
                              - CreateImage() -> Erstellt ein Image und läd auf wunsch auch gleich den Inhalt
                              - GetMouseCursorVisible(), SetMouseCursorVisible() -> Zum Einstellen ob der Maus
                                Zeiger allgemein sichtbar ist. Im Vollbild sollte z.B. der Windows Zeiger NIE
                                sichtbar sein!
                              - SystemConvertToCharacter() -> Wandelt einen Tasten Code in ein ASCII Zeichen
                                bzw. einen Character um
- GuiWindow: Neue Funktionen: - GetCursorVisible() & SetCursorVisible() -> Zum Mauszeiger sichtbar/unsichtbar
                                machen über einem Fenster
                              - GetCursorImage(), SetCursorImage() -> Setzen das Maus Bild über diesem Fenster
- GuiTreeView: Man kann nun auch auf die +/- Kästchen klicken um einen Baum zu öffnen
- GuiEditBox: Cursor lässt sich nun bewegen etc.
- PLGuiDemo um Mouse Cursor Test erweitert in welchem man die neuen Features austesten kann, desweiteren in Tab 2 ein
  Beispiel eingefügt wie man eine Check Box Gruppe machen kann in der immer nur eine Box auf einmal markiert sein kann



>> 04.02.04
[CO]
- GuiDialogChooseFile::SetMode() -> Wenn bMustExist nicht gesetzt ist wird nun noch ein spezielles Flags fürs Speichern
  gesetzt. Desweiteren wird dort nun zwischen einem Laden und Speichern Dialog untschieden. (je nachdem wie bMustExist
  gesetzt ist)
- GuiEditBox: Neue Styles: PLGUI_EDITBOX_UNDERLINETEXT -> Damit wird der Text unterstrichen
                           PLGUI_EDITBOX_CROSSOUTTEXT  -> Damit wird der Text durchgestrichen



>> 29.01.04
[CO]
- GuiTooltip: SetText() liefert nun 1 zurück wenn der Tooltip aktiv ist, ansonnsten 0.
  GuiSys::SetMouseOverWindow() setzt nur noch Tooltip Eigenschaften wenn dieser auch aktiv ist.
- GuiEditBox: Element 'flackert' nun nicht mehr wenn sich die Maus darüber bewegt
- GuiSlider: Slider Position und Schritt von int auf float umgestellt damit auch kleine zwischenschritte
  nicht verloren gehen (was im HDRI Viewer bei Exposure der Fall)



>> 26.01.04
[CO]
- GuiBitmap: Neue Funktionen GetImagePosX(), GetImagePosY() und SetImagePos() mit welchen man die Bitmap position
  im Button beeinflussen kann



>> 24.01.04
[CO]
- GuiWin32Window::SystemSetZPos: SetWindowPos() um Flag SWP_NOACTIVATE erweitert damit u.a. keine Fokus Nachricht beim 
  setzen der Z Position gesendet wird. (war im HDRI Viewer fatal da dann alles durch eine unendlich schleife blockiert
  wurde! :)



>> 10.01.04
[CO]
- GuiWin32::SystemGetMetrics() liest nun auch die Virtuelle Bildschirm größe aus. Damit ist es nun auch möglich die korrekte
  Bildschirmgröße herauszubekommen wenn mehrere Bildschirme zu einem zusammengeschaltet wurden
  Anstatt GUI_SYSTEMMETRIC_CXSCREEN/GUI_SYSTEMMETRIC_CYSCREEN sollte man also IMMER GUI_SYSTEMMETRIC_CXVIRTUALSCREEN/
  GUI_SYSTEMMETRIC_CYVIRTUALSCREEN verwenden damit man sicher gehen kann das auch alles problemlos über mehere Bildschirme
  funktioniert. Da die meisten Grafiker über mehere Bildschirme arbeiten ist dies ein nicht zu vernachlässigendes Thema. :)
  (ich hoffe wirklich Jens und Jan sind nun endlich zufrieden :)



>> 09.01.04
[CO]
- GuiComboBox: Neue Funktion: SetText() -> Setzt den aktuellen Combo Box Edit Box Text
- GuiWindow: Neue Informer Funktionen OnEnable() und OnDisable() -> werden aufgerufen wenn ein Element aktiv/deaktiv wird
  (Gui Doku um diese virtuellen Funktionen erweitert)
- GuiControls: Ein paar Controls riefen noch nicht ihre Basis Klassen auf (siehe SB 02.01.04)



>> 02.01.04
[SB]
- GuiControls: Bei der Arbeit an Jans GuiEditor wurde deutlich, daß viele Controls noch nicht
  die Basisfunktionen überschriebener virtueller Fenstermethoden aufriefen. Da die Weiterleitung
  der Events an die WindowListener innerhalb von GuiWindow passiert, wurden natürlich auch diese
  Funktionen nicht mehr aufgerufen. Dies wurde nun behoben, alle Controls rufen jetzt immer die
  Basisimplementierung mit auf.



>> 02.01.04
[CO]
- GuiWindowListener: Da wir immer wieder neue Funktionen im Listener brauchten hab ich nun mal komplett alle möglichen
  Funktionen implementiert damit man das nicht stückchweise nachreichen muss. (Jan braucht für den Gui Editor immer wieder
  neues :)
  OnWindowActivate() und OnWindowSize() umbenannt so das diese nun genauso heisen wie in GuiWindow.
  Für OnTooltip() gibts keine Listener Funktion da dies absolut keinen Sinn machen würde. ;-)



>> 30.12.03
[CO]
- GuiWindow.h -> PLGUI_CLASSID -> GetClassID hat nun den Default Wert NULL damit man direk mit GetClassID() arbeiten kann



>> 20.12.03
[CO]
- GuiContentWindow: Anzahl der On'Event' Funktionen welche an das Parent Window weitergeschickt werden erweitert
- GuiWindowListener: Um OnDropFiles() erweitert
- GuiMenu: AddSubMenu() & AddItem() -> Name steht nun hinten damit man diesen auch komfortabel konstruieren kann
  (auch GuiMenuBar angepasst sowie PLTools, PLGuiDemo und PLSample)
- PLTGuiAbout: Konstruktor wird nun exportiert so das man den About Dialog auf von außerhalb erzeugen kann
- GuiSys: Neue System Funktionen: SystemGetMouseCursorVisible() & SystemSetMouseCursorVisible() -> Um den Maus Zeiger
  sichtbar/unsichtbar zu machen
- PLGui Maus Zeiger wird in Modell Editor, World Editor und PLDemo nun unsichtbar gemacht
- Im Gui gab es noch ein Problem mit dem Fenster Fokus:
  Wurde z.B. auf ein anderes Programm umgeschaltet so wurden im Gui die Fenster nicht korrekt deaktiviert.
  Kleine Änderun in GuiWin32Window::WindowProc() und GuiSys::SetActiveWindow()
- GuiWindow: m_pPopupMenu wird nun initialisiert



>> 13.12.03
[SB]
- GuiDialog: Virtuelle Funktion OnClose() mußte auch exportiert werden
- GuiWindow: Neue Funktion SetPopupWindow() eingebaut, mit dieser kann jedem Fenster ein Popup-Window zugewiesen werden,
  welches automatisch mit der rechten Maustaste geöffnet wird. Dies ermöglicht es nun, auch ohne eigene Fensterklasse
  Popup-Menüs zu verwenden, was vor allem dann nützlich ist, wenn man eine fertige Fensterklasse benutzen muß (PLTRenderFrame)
- GuiMenu: Zur Vereinfachung wurde die Funktion AddSeparator() eingebaut
- GuiFrame: Die virtuellen Methoden rufen nun jeweils ihre Basis-Implementierung auf



>> 13.12.03
[CO]
- GuiFrame: Sobald der Frame Balken ausgeblendet wird kann man mit der Maus diesen auch nicht mehr verwenden. Dadurch kann
  man nun z.B. in einem Vollbild Frame ohne Balken den Frame nicht mehr umherschieben.
- GuiPL::SystemGetTickCount() auf PL::Timer.GetTickCountLow() umgestellt -> Somit stimmt im GUI dort das Timing wieder



>> 25.11.03
[CO]
- PLGuiAbout.cpp: Änderte 1999-2003 in 2002-2003 damit es über all einheitlich steht.



>> Einträge aus altem Diary, damals noch ohne genaue Datum angaben. (oben -> unten = neuer -> älter)
[SB] GuiWindowHandler wurde nach GuiTools verschoben
[SB] Fehler in GuiContentWindow behoben, der dazu führte, daß Frames auch noch unterhalb der Titelleiste verschoben
     werden konnten (da die Mausereignisse vom Contentwindow durchgereicht wurden, ohne auf die Position des ContentWindow
     innerhalb des Frames zu achten)
[SB] Neue Systemfunktion GuiSysWindow::SystemRestoreSize(), um die ursprüngliche Größe eines Fenster nach dem Minimieren
     oder Maximieren wiederherzustellen. Dies ist nötig, damit der aktuelle Status eines Fenster im System korrekt bleibt
[SB] Wenn ein Fenster, das nicht in der Taskleiste angezeigt wird, minimiert wird, wird es jetzt auf eine eingestellte
     Minimierungsgröße gesetzt, auf welche durch GetMinimizedSize() und SetMinimizedSize() zugegriffen werden kann. Bei
     GuiFrame wird die Höhe automatisch der Höhe der Titelleiste angepaßt
[SB] Neue Systemfunktion GuiSys::SystemCaptureMouse() eingebaut. Diese Funktion wird beim Mousecapturing aufgerufen,
     dadurch wird das Portieren der Gui weiter vereinfacht, da das Mouse-Capturing damit beim Portieren nicht mehr
     "vergessen" werden kann
[SB] GuiMenu: Um den vorher genannten Fehler in dieser Klasse zu beheben, mußte ein neuer Konstruktor eingebaut werden,
     der die Gui-Instanz übernimmt. Dies sollte bei Controls eigentlich nicht der Fall sein, jedoch entsprach der alte
     Konstruktor auch schon nicht den Konstruktor-Normen (NULL als Parent)
[SB] Fehler behoben: Einige Controls haben zur Laufzeit neue Fenster erstellt, dabei jedoch nicht die zu verwendende
     Gui angegeben, wodurch das neue Fenster nicht unbedingt zur gleichen Gui gehörte wie das alte Fenster :-)
     (betraf: GuiToolTip, GuiComboBox, GuiMenu)
[SB] Fehler in GuiSys behoben: Beim De-Initialisieren wurden nicht unbedingt alle Fenster gelöscht, da Update nicht
     mehr durchlaufen wurde
[SB] Fehler in einigen Controls behoben: Im Destruktor oder beim Deinitialisieren haben manche Controls versucht, ihre
     child-windows explizit zu löschen. Da das Löschen von child-windows jedoch automatisch geschieht, waren diese
     bereits gelöscht, was zu einem Absturz führte
[SB] GuiSys: Statt m_pLastInstance gibt es nun die statische Variable m_pFirstInstance, welche die erste Gui-Instanz
     speichert. Dies ist für den Programmierer einsichtiger und leichter zu durchschauen, die 1. Gui ist damit die
     Standard-Gui welche verwendet wird, wenn keine andere Instanz explizit angegeben wurde
[SB] Beim Maximieren eines Fenster wird nun auch wirklich die Systemfunktion verwendet, beim Verschieben oder
     Vergrößern eines maximierten Fensters wird der Maximiert-Status aufgehoben
[SB] Methoden zum Minimieren und Maximieren wurden nach GuiWindow verschoben
[SB] GuiWin32 Implementierung wurde angepaßt
[SB] GuiSys: Die Maus-Funktionen wurden in das System-Interface übernommen, damit werden Active-Window, Focus-Window
     und DoubleClick automatisch von GuiSys übernommen, die Systemfunktionen müssen also nur noch diese Funktionen aufrufen
[SB] GuiSys: Es gibt nun ein System-Interface in dem die Funktionen enthalten sind, die von der GuiSys-Implementierung
     aufgerufen werden. Virtuelle Funktionen sollen also nicht mehr direkt aufgerufen werden, was die Portierung
     erleichtert, da vorher manche Funtkionen direkt aufgerufen werden mußten während andere automatisch aufgerufen wurden.
     Das System-Interface muß noch komplettiert werden
[SB] GuiSys: Über SetDoubleClickTime() und GetDoubleClickTime() läßt sich die Zeit für einen Doppelklick nun in der Gui
     selbst einstellen. Beim Starten der Gui übernimmt GuiNative die vom OS eingestellte Zeit, die Ingame-Gui übernimmt
     die von der Native-Gui
[SB] GuiSys: GetWindow() eingebaut, um ein bestimmtes Fenster abzufragen
[CO] GuiSpinner: Neue Funktionen: GetScrollerStep() & SetScrollerStep() -> Damit lässt sich die Schrittweite des Maus
     Scrollers einstellen (Buttons und Scroller haben nun seperate Schrittweiten)
[CO] GuiSlider & GuiGroupBoxGroup: Neue Funktionen: GetSliderStep() & SetSliderStep() -> Damit kann man einstellen wie
     groß die Schrittweite des Sliders ist
[SB] Die Verwendung von Farben wurde vereinheitlicht, dies geschieht nun immer über IDs (z.B. PLGUI_GRAPHICS_DRAWCOLOR),
     nicht mehr wie vorher in einigen Klassen direkt über verschiedene Funktionsnamen
[SB] Die Listener haben nun eine Standardimplementierung, um den typischen Java effekt zu vermeiden, daß von einem
     Interface alle Methoden implementiert werden müssen :-) (Änderungen auch in GuiToolbar)
[SB] PLGeneral eingebaut
[SB] GuiToolbar: SetToolbarPos() dockt nun automatisch auch das Fenster an, dies war vorher nicht der Fall. Um Zyklen
     zu verhindern wurde die Funktion in zwei Teile aufgeteilt (SetToolbarPos und AlignToolbar)
[SB] Docking-Funktionen erweitert: GuiWindow::Dock(nPos, pWindow) kann verwendet werden, um ein Fenster an eine
     bestimmte Position anzudocken, während die alte Funktion Dock() versucht, an der aktuellen Position anzudocken
[SB] GuiToolBar: Die Toolbar achtet nun per GuiWindowListener darauf, wenn das Fenster, an dem sie angedockt ist, in
     der Größe verändert wird und versucht dann, die Docking-Position wieder herzustellen
[SB] GuiWindow ist nun ein GuiWindowInformer
[SB] Neuen Listener: GuiWindowListener. Dieser Listener ist dafür da, um von außerhalb auf Ereignisse des Fensters
    (z.B. Aktivierung) reagieren zu können
[SB] GuiDialogChooseFile: Stringlänge auf 1024 erhöht, um Fehler durch zu lange Pfadnamen oder Filterstrings zu
     vermeiden :-)
[SB] GuiWindow: Neue Methode GetClassID(), die den Namen der Fensterklasse (und aller Basisklassen) zurückgibt. Zur
     Definition dieses Klassennamens wird ein neues Makros verwendet
[SB] Habe die PLGui auf die Verwendung von PLGeneral umgestellt und die betroffenen Toolklassen entfernt
[CO] GuiWindow: Neue virtuelle Funktion: OnMouseWheel() -> Liefert Informationen über das Maus Rad -> GuiSlider kann
     nun auch mit dem Maus Rad bedient werden
[CO] Neues Control: GuiGroupBoxGroup -> Verwaltet eine Gruppe von Group Boxes und positioniert diese korrekt wenn eine
     Popup Group Box geöffnet/geschlossen wird
[CO] GuiGroupBox: Hat nun ebenfalls wie GuiFrame ein Content Window
[CO] GuiGroupBox ist nun auch eine Ableitung von GuiCommandInformer und sended eine Nachricht aus sobald die Popup-Group
     geöffnet/geschlossen wurde
[CO] GuiSpinner: Erweitert
[CO] GuiSys::Update: Löschen der Fenster verbessert - wenn ein Fenster gelöscht wird ist es möglich das dieses beim
     Löschen weitere Fenster der 'Zu Löschen'-Liste hinzufügt
[CO] GuiWindow::OnDropFiles ruft standardmäßig OnDropFiles() seines Parent Windows auf. GuiContentWindow::OnDropFiles()
     doppel implementation entfernt. GuiWin32Window::WindowProc() Parent Drop Files Information entfernt.
[CO] GuiMenu: Das Menü und seine Untermenüs werden nun immer so positioniert das diese nie ihr Parent Window bzw. den
     Bildschirm verlassen
[CO] Kleinen fehler in PLTList::Remove(int nIndex) behoben
[CO] GuiTreeViewItem: Kommentare um hinweis erweitert das TreeView unsichtbar gemacht werden sollte wenn viele neue
     Elemente eingefügt werden
[CO] GuiListBox: Neue Funktion: RemoveText()
[CO] GuiComboBox: Die ausfahrende Liste ist nun kein Child von ComboBox mehr und wird daher auch nicht z.B. innerhalb
     einer GroupBox störenderweise 'abgeschnitten'
[CO] GuiWin32::SystemUpdate(): Die Nachrichten werden nun so lange abgearbeitet bis keine mehr in der Nachrichten
     schleife sind -> Somit wäre das problem mit dem langsamen Bildaufbau gelöst!
[CO] GuiSpinner: Nochmals verbessert - hat nun noch jemand etwas dran auszusetzen? ;-)
[CO] GuiSlider: Setzt sein Maximum nun nicht mehr automatisch auf 1 wenn 0
[CO] GuiSpinner: Interface um integer-Funktionen erweitert, ist nun eine Ableitung von GuiCommandInformer und sended
     nun Nachrichten bei veränderungen
[SB] GuiSys::Update() überprüft jetzt auch, ob ein Timer aktiv ist, und nur wenn das der Fall ist, wird ein weiteres
     Update erzwungen. Damit gibt es 3 Fälle, die ein Update erzwingen: Listener, Update(true) und aktive Timer
[SB] GuiWin32::SystemGetKeyPressed überprüft nun, ob die Taste zur Zeit gedrückt ist, und gibt nur dann 'true' zurück
[SB] GuiWin32Window::SystemCreateWindow() vereinfacht: Das Setzen der Window-Styles passiert jetzt vereinheitlicht an
     einer Stelle und nicht mehr verteilt an mehreren Stellen in der Funktion, auch kann das setzen des Extended-Styles
     sofort beim Erstellen des Fensters erfolgen und muß nicht nachträglich durch SetWindowLong() erfolgen
[SB] GuiWin32Window::SystemSetTopmost() vereinfacht: Die mehrfachen IF-Verschaltelungen wurden gelöscht und statt
     dessen lokale Variablen verwendet
[SB] Aus dem Bereich der sinnlosen Verschönerungen: Kleinere Fehler in der Dokumentation von GuiTabBar verbessert
[SB] Die Konstanten von GuiMessageBox hatten noch den Präfix GUI_, dies wurde nun zu PLGUI_ vereinheitlicht
[CO] GuiWindow::OnDropFiles: Informiert standardmäßig sein Parent Window
[CO] GuiSys::DeInit(): Dort wird nun nach schließen aller Fenster eine Aktualisierung ERZWUNGEN
[CO] GuiSys::Update(): Schleife in der alle Fenster durchlaufen wurden um zu prüfen welche z.B. gelöscht werden sollten
     wurde entfernt da es in den Editoren teils weit über 1000 einzelne Fenster gab und dadurch alles immer langsamer
     wurde. Wenn Fenster zerstört werden oder diese einen aktiven Timer haben werden diese in GuiSys in entsprechende
     Listen eingetragen.
[CO] GuiTooltip::OnDraw: Es wird nun versucht den Tooltip so zu positionieren das dieser IMMER komplett im Bildschirm ist
[CO] GuiListBox: Multiselektion geht nur noch wenn man dabei strg gedrückt hält
[CO] GuiSys: Neue System-Funktion: SystemGetKeyPressed() -> Prüft ob gerade eine Taste gedrückt ist oder nicht ->
     eigene Tasten Definationen in GuiKeys.h
[CO] Alte standard Windows Dialoge zum auswählen von Dateien oder Pfaden fürs erste wieder eingebaut da man diese u.a.
     in den Editoren benötigt und es wahrscheinlich noch etwas dauern wird bis die eigenen Dialoge dafür funktionsfähig
     sind
[CO] GuiWindowHandler eingebaut -> Damit kann man problemlos einen Zeiger auf ein Fenster verwalten und wenn das Fenster
     zerstört wurde wird dieser Zeiger automatisch auf NULL gesetzt -> wird in Engine z.B. dafür verwendet um
     festzustellen ob ein Dialog schon geöffnet ist oder nicht
[CO] GuiStatusBar umgeschrieben, desweiteren ist diese nun eine Ableitung von GuiToolBar
[CO] GuiMessageBox: Größe passt sich nun der Text Länge an
[CO] Diverse kleine und sinnlose Detail 'verschönerungen und vereinheitlichungen' wie z.B. überall bei z.B.
     #ifndef  __PLGUI_SYS_WINDOW_H__ die unterstriche vorne und hinten so das nun alles wieder etwas einheitlicher
     aussieht, ein paar Kommentare hinzugefügt/ausgebaut. Virtuelle Funktionen von Basis Klassen nach unten
     verschoben damit man diese immer ohne großes suchen findet und weis welche Funktionen überschrieben werden
[CO] GuiWindow: OnDropFiles() liefert nun eine bereits zerlegte Liste an Dateien zurück so das man diese sofort
     verwenden kann ohne diese selbst noch entsprechend auswerten zu müssen
[CO] GuiWin32Window::SystemCreateWindow() -> Jedes Fenster aktzeptiert nun Dateien über Drag'n'Drop
[CO] GuiMenu: Um weitere Funktionen implementiert damit Items auch anhand deren Command ID manipulierbar sind (was
     recht praktisch ist :)
[CO] Probleme mit dem Aktivieren/Deaktivieren im zusammenspiel mit mehreren Sub-Menüs behoben
[CO] GuiSysWindow::SystemActivateTimer() entfernt
[CO] GuiWindow::ActivateTimer() -> Timer umgeschrieben, die Timer werden nun von der Gui selbst verwaltet anstatt die
     Windows Timer zu verwenden da diese probleme verursachten, diese wurden machmal nicht aufgerufen obwohl dies
     eigentlich de Fall hätte sein müssen etc. -> Nun gibts keine 'merkwürdigen' Timer-Probleme mehr! ;-)
     -> GuiSys::Update() -> SystemWaitForUpdate() kann man dort nun leider nicht mehr Einsetzen da sonst auch die
     eigenen Timer einfrieren :(
[CO] GuiSys: Neue Funktion: SystemGetTickCount() -> Liefert die Zeit zurück seit das System gestartet wurde
[CO] GuiWin32Window::WindowProc: In WM_PAINT wird nun beim Graphik-Objekt eine Standard Schrift gesetzt da die
     'default' Schrift zu groß und fett war, desweiteren weis man nun welche Schrift gesetzt wurde :)
[CO] Fehler in GuiSysGraphics behoben, zweites GetFont() durch SetFont() ersetzt
[CO] Fehler in GuiWin32Window::SystemSetTopmost() behoben -> Dadurch wurde ein Fenster automatisch Sichtbar was
     oft nicht erwünscht war
[CO] GuiComboBox: Die größe des Control-Fensters wird nun angepasst wenn die Liste ausgeklappt oder wieder eingefahren
     wird -> Somit wird das dahinterliegende wieder korrekt dargestellt
[CO] GuiListBox: Neue funktion: GetNumOfTexts() -> Gibt die Anzahl der Texte in einer Liste zurück
[CO] GuiProgressWindow vervollständigt
[CO] GuiListBox & GuiComboBox & GuiTreeView sind nun eine Ableitung von GuiCommandInformer und senden u.a. ein Signal
     aus wenn z.B. die Auswahl verändert wurde
[CO] Neues Window: GuiToolWindow -> Eine einfache Ableitung von GuiFrame welche dort im Konstruktor das ToolWindow Style
     Flag setzt
[CO] GuiFrame: Neues Style: PLGUI_FRAME_HIDE -> Verbirgt alle speziellen Frame Elemente wie z.B. die Titelleiste -> Wird
     z.B. für einen Vollbild-Modus benötigt
[CO] GuiWindow: Neue Funktion: OnMessage() -> Wird GuiWin32Window::WindowProc aufgerufen wenn eine Nachricht nicht
     zugeordnet werden konnte (z.B. bei der Engine Alt-Return)
[CO] GuiSys: Neue Funktionen: GetForceUpdate() & SetForceUpdate() -> Damit kann man ein aktualisieren der Gui
     erzwingen... ist z.B. bei der Engine nötig (über GuiInfomer wäre es dort zu umständlich)
[SB] GuiSys: Neue Funktionen zum Erzeugen und Löschen von Graphics-Objekten eingebaut
[CO] GuiSplitter: Mit der Maus lässt sich nun die größe verändern
[CO] GuiFrame: Lässt sich nur noch durch einen doppel klick auf die Titel-Leiste vergrößern wenn auch ein
     Maximize-Button vorhanden ist
[CO] Neues Control: GuiMenuBar
[CO] GuiWindow: Neue Funktionen: GetAbsPos() & GetAbsX() & GetAbsY() -> liefern die Realen Bildschirm positonen eines
     Fensters zurück
[CO] GuiMenu: Ist nun auch eine Ableitung von GuiCommandInformer und informiert seine Items über aänderungen der Listener
     über die Virtuellen Informer funktionen damit diese Items die Nachrichten immer an die korrekten Listener schicken
[CO] GuiCommandInformer & GuiDialogInformer: Neue Funktionen: Anzahl der Listener und einen bestimmten Listener zurückgeben,
     desweiteren gibt es nun virtuelle Funktionen welche aufgerufen werden wenn ein Listener hinzugefügt oder gelöscht wird
[CO] GuiColorDialog um Slider erweitert
[CO] GuiEditBox & GuiSlider: Senden nun immer eine Nachricht aus damit man auf Eingaben/veränderungen reagieren kann
[SB] Fehler in GuiWin32Window::SystemSetShowInTaskbar() behoben: Beim Aufruf dieser Funktion wurde das Fenster automatisch
     angezeigt, wodurch alle Frames gleich nach dem Erstellen sichtbar wurden
[CO] Neuer Dialog: GuiColorDialog
[CO] Kleinen fehler in GuiColor behoben, Farbwerte wurden teils nicht im richtigem Format zurückgegeben
[SB] Fehler in GuiSys behoben: Beim Löschen eines Fenster wurde dieses zwar aus der Fensterliste gelöscht, jedoch nicht aus
     den Docking-Listen. Dadurch kam es beim nächsten Docking-Versuch zum Absturz, wenn versucht wurde, auf dieses Fenster
     zuzugreifen
[SB] Gui::MessageBox() und Gui::InputBox() implementiert
[SB] Gui::ShowDialogModal() eingebaut, diese zeigt eine modale Dialog an und übernimmt dabei die Mainloop, am Ende wird das
     Ergebnis der Dialogbox zurückgegeben (Dies dient auch zu weiteren Vereinfachung der Gui, der Programmierer hat nun die
     Wahl, welche Methode er für die Dialoge verwenden will)
[SB] Um die Gui noch komfortabler zu machen, gibt es nun eine Run-Funktion, welche eine eigene Mainloop beinhaltet.
     Applikationen können also entweder eine eigene Loop bauen, oder Run() benutzen und ggf. über den GuiListener zusätzliche
     Funktionen beim Update aufrufen
[SB] Um die Prozessorauslastung zu minimieren, gibt es nun zusätzlich neben der Normalen Update-Funktion eine Funktion
     WaitForUpdate(), diese führt ein Update durch und wartet dann auf das nächste Ereignis
[SB] Neuer Listener: GuiListener, wird beim Update der Gui aufgerufen
[SB] Namensänderung: Producer heißen nun Informer, um eine einheitliche Namensgebung zu erreichen (ansonsten käme es bald
     wieder zu Inkonsistenzen, da Namen wie ProduceUpdate irreführend sein könnten)
[CO] Kleinen fehler in GuiMessageBox::OnCommand korrigiert und in GuiDialog::CloseDialog() ProduceDialogClosed() nach unten
     verschoben da es sein könnte der der User den Dialog dann nach dem schließen Löscht (auf jedenfall ists so etwas sicherer :)
[SB] Dialoge umgestellt: Die alten Dialoge wurden entfernt, GuiMessageBox und GuiInputBox sind nun von GuiDialog abgeleitet
     und nach GuiDialogs verschoben worden
[SB] Modale Dialogboxen eingebaut: Beim Öffnen über ShowModal() wird das Owner-Window deaktiviert, bis der Dialog wieder
     geschlossen wurde. Die Hauptschleife wird dabei allerdings nicht von der Gui übernommen, es kann also nicht auf die
     Rückkehr aus der Funktion gewartet werden (dafür kann allerdings der DialogListener verwendet werden)
[SB] GuiDialogListener eingebaut, über diesen kann sich ein Objekt über das Schließen eines Dialoges informieren lassen
[SB] GuiDialog implementiert: Ein Dialog ist ein Frame, jedoch mit folgenden Eigenschaften: -> Beim Schließen des Dialoges
     wird das Fenster nicht zerstört sondern nur unsichtbar gemacht (auch bei Klick auf das X), außerdem besitzt der Dialog
     einen Rückgabewert, der beim Schließen gesetzt und von außen ausgelesen werden kann
[SB] GuiWindow: m_bEnabled entfernt, dafür werden nun die Systemfunktionen verwendet (dies erforderte auch Anpassungen in
     GuiButton und GuiEditBox)
[SB] Zwei neue Systemfunktionen eingebaut (hoffentlich die letzten): SystemGetEnabled() und SystemSetEnabled(), hierdurch
     können Fenster aktiviert und deaktiviert werden
[CO] GuiTreeView: Selektion implementiert
[CO] GuiTabBar: Größe der Tab-Button wird nun der Text Länge angepasst, über das Style PLGUI_TABBAR_MULTIROW kann man
     Einstellen ob mehere Reihen an Tab-Buttons erlaubt sind
[SB] Kleinen aber bösartigen Fehler in GuiWin32Window entfernt: (GuiWin32Window*)pWnd castet unkompatible Typen, wodurch
     GuiWindow falsche Werte bekommt, richtig ist (GuiWin32Window*)pSysWnd :-)
[SB] Das Überprüfen der Unsnap-Distanz wird nun auch in GuiWindow::Move() vorgenommen (betrifft GuiWindow, GuiFrame,
     GuiMover)
[SB] GuiMenu: delete entfernt und durch Destroy() ersetzt
[SB] Docking: Es gibt nun zwei Werte, welche das Docking beeinflussen, PLGUI_SNAP gibt den Abstand an, ab dem versucht
     wird ein Fenster anzudocken, PLGUI_UNSNAP gibt an, wie weit die Maus sich bewegen muß, um das Fenster wieder abzudocken.
     Dadurch sind auch die "Grafikfehler" beim Andocken behoben (das Fenster sprang zwischen der neuen und der alten
     Position hin und her)
[CO] GuiMenu: Funktioniert nun problemlos
[CO] Kleine Änderung in GuiListBox, es wird nun davon ausgegangen das IMMER ein Slider vorhanden ist und dementsprechend
     werden die Edit Boxes eingestellt - das gleiche in GuiTreeView - kurz Overlapp Fehler behoben :)
[CO] GuiFrame: Lässt sich durch doppelklick auf Titelleiste auch vergrößern/normalisieren
[CO] GuiWindow: Neue Funktionen: OnLButtonDoubleClick() & OnRButtonDoubleClick() -> Maustasten doppelklick (wird in
     GuiWin32Window über eine Zeitmessung geregelt)
[SB] Die TopMost-Eigenschaft kann nun auch für Chid-Windows gesetzt werden, dieser Fall wird von der PLGui selbst
     verwaltet (wieder eine Win32-Unlogik entfernt ;-)
[SB] Toolbar: Im angedockten Zustand wird kein Rahmen mehr angezeigt
[SB] Frame: Das Bitmap-Control wird nun ausgeblendet, wenn kein Icon angezeigt wird, dadurch kann man den Frame nun auch
     an dieser Stelle der Titlebar verschieben (dies war vorher nicht möglich, da das Bitmap-Control "im weg" war)
[SB] Beim Aktivieren eines Fensters wird dieses nun in den Vordergrund gebracht (und auch alle seine mitaktivierten
     parent-windows)
[CO] GuiSysWindow: Neue Funktion SystemMinimize() und SystemMaximize -> Minimiert/Maximiert ein
     Fenster -> GuiFrame::Minimize() angepasst
[CO] GuiWin32::SystemGetMetrics: Auslesen von Menü Daten rausgenommen da mittlerweile überflüssig
[CO] GuiCheckBox: Sendet Befehl nun ebenfalls erst nach dem loslassen der Maustaste
[CO] GuiButton: Bei normalen Buttons wird der Befehl nun nur noch geschickt wenn die Maustaste wieder losgelassen
     wird uns sich die Maus immer noch über dem gleichen Button befindet
[CO] GuiWindow: Neue Funktionen: GetMouseCapture() und SetMouseCapture() -> Damit lässt sich Einstellen ob die Maus
     für ein Fenster 'eingefangen' wird oder nicht... bei normalen Buttons sollte dies nicht der Fall sein damit das
     Senden des Befehles erst stattfindet wenn die Maustaste wieder losgelassen wurde und sich die Maus immer noch über
     dem gleichen Button befindet (betrifft auch GuiWin32Window)
[SB] Fehler beim Deinitialisieren behoben (da die Fenster in beliebiger Reihenfolge gelöscht werden, dürfen Fenster nicht
     mehr auf ihr Parent-window zugreifen)
[SB] GuiSys: Methode zum Überprüfen eines Window-Pointers eingebaut (IsWindow())
[SB] Die Timer wurden so umgestellt, daß (wie es in den meistens APIs üblich ist) ein Timer nur einmal ausgelöst wird
     und dann neu aktiviert werden muß
[SB] GuiToolbar: Die Toolbar ordnet ihre Child-Windows jetzt automatisch an, dadurch entfallen die Methoden Add() etc.
[SB] GuiToolbar: Die Größe der Toolbar im Floating-Modus kann nun mittels SetFloatingSize() frei eingestellt werden
[SB] Jedem Fenster wurde eine Liste seiner Child-Windows hinzugefügt, welche über GetChildWindow() abgefragt werden kann
[SB] Die Destruktoren von GuiWindow und abgeleiteten Klassen sind nun protected
[SB] Weitere Fehler in GuiListView, GuiListBox, GuiTreeView, GuiTabBar, GuiStatusBar behoben: Auch hier wurden Fenster
     mit delete gelöscht
[SB] Fehler in GuiSlider behoben: In der Funktion SetStyle() wurden die alten Buttons nicht korrekt mit Destroy()
     zerstört, sondern einfach mit delete gelöscht. Dadurch waren die Fenster im System noch vorhanden und es wurden
     somit Nachrichten an in der Gui nicht mehr bekannte Fenster geschickt
[SB] GuiWin32: Der Zeiger auf das GuiWindow wird jetzt als zusätzliche Daten beim System-Window gespeichert
[SB] GuiToolbar eingebaut: Die Toolbar kann entweder an einer Seite angedockt werden oder als frei positionierbarer
     Frame eingefügt werden (SetToolBarPos()). Es kann außerdem bestimmt werden, ob ein Mover angezeigt wird, durch den
     der User die Bar selbst positionieren kann (SetMovable()). Im Floating-Modus hat die Toolbar eine kleine Titelleiste
[SB] Fenster werden über OnUnDock() auch übers abdocken informiert
[SB] Änderung beim Docking: TryDocking() sucht eine geeignete Docking-Position heraus, jedoch wird das Docking erst
     beim Loslassen der Maustaste durch PerformDocking() ausgeführt, dadurch wird auch nur noch einmal OnDock()
     aufgerufen. Um das Docking aus dem Code heraus auszuführen, kann nun die Funktion Dock() verwendet werden
[SB] Das ContentWindow eines GuiFrames setzt jetzt als Standard seine Docking-Einstellungen so, daß Child Windows an
     seine Ränder angedock werden können
[SB] GuiFrame: Beim Verändern der Einstellungen (Größe der Titelleiste, Rahmen) wird das Content Window nun entsprechend
     angepaßt
[SB] GuiWindow: Neue virtuelle Funktion OnBoderChanged(), diese wird aufgerufen, wenn der BorderStyle des Fensters
     verändert wurde
[SB] GuiButton: Durch Übergabe von NULL als Parameter, können die Bilder eines Buttons nun wieder entfernt werden
[SB] Ein Frame besitzt nun automatisch einen Sizer, der jedoch über die Funktion SetResizable() ausgeschaltet werden
     kann. Das Vergrößern eines Fensters durch Klick auf den Rand wurde dafür ausgebaut
[SB] Neue Funktionen zum Setzen der Z-Position eines Fensters eingebaut (GuiWindow::SetZPos(), und neue Systemfunktion
     GuiSysWindow::SystemSetZPos())
[SB] Neues Control GuiMover eingebaut. Dieses kann verwendet werden, um ein parent window zu verschieben oder in der
     Größe zu ändern
[SB] GuiFrame: Es kann nun ein Icon in der Titelleiste angezeigt werden
[SB] GuiBitmap: Es kann jetzt auch NULL beim Laden eines Bildes übergeben werden, um kein Bild mehr anzuzeigen
[SB] Neue virtuelle Funktion OnDock() eingebaut, um das Fenster über das Docking zu informieren
[SB] GuiWindow: Neue Funktion Move(), welche das Fenster relativ zur jetzigen Position bewegt und dabei Docking zuläßt
     (SetPos() usw. führen dagegen kein Docking aus, damit die Fenster auch noch korrekt und zuverlässig positioniert
     werden können)
[SB] GuiWindow: PerformDocking() eingebaut, diese Funktion wird aufgerufen, um eine geeignete Docking-Position für das
     Fenster zu bestimmen (kann auch von der Applikation selbst aufgerufen werden)
[SB] Docking: Jedes Fenster kann nun seine Docking-Flags setzen, dadurch wird bestimmt, ob dieses Fenster an andere
     Fenster gedockt werden kann, und ob andere Fenster zum Docken an den angegebenen Rändern akzeptiert werden
     (entweder für benachbarte oder für Child-Windows). Zum Überprüfen der geeigneten Fenster werden zwei Listen in
     GuiSys aktualisiert, welche dann beim Bewegen von Fenster überprüft werden
[SB] GuiWin32Window: Beim Drücken eines Mousebuttons wird SetCapture() aufgerufen, um die Mausbewegung für dieses
     Fenster abzufangen, auch wenn diese das Fenster verläßt. Dadurch funktioniert das Verschieben eines Frames nun
     korrekt, auch wenn die Maus sehr schnell bewegt wird, ebenso wird das Bedienen von Slidern einfacher. Sollte das
     obligatorische Aufrufen von SetCapture() Probleme bereiten, muß dafür eine System-Funktion in GuiSysWindow()
     eingebaut werden
[CO] Neues Control: GuiTreeView
[CO] GuiWindow: Neue Funktionen: SetX() & SetY()
[CO] Neue Controls: GuiSplitter & GuiListView
[CO] GuiSlider: -/+ Buttons wiederholen nun bei gedrückter Maustaste den Befehl
[CO] Neues Control & : GuiSpinner
[CO] GuiGroupBox: Neues Style: Popup group box
[CO] GuiSysWindow & GuiWin32Window: Neue Funktion: DeactivateTimer()
[CO] GuiWindow: Neue Funktionen: SetWidth(), SetHeight(), DeactivateTimer()
[SB] GuiWindow: SetFocus() prüft nun, ob der Focus gesetzt oder weggenommen werden soll
[SB] GuiSys: Fehler in SetFocusWindow() behoben, wenn NULL übergeben wurde
[SB] GuiComboBox: Verwendet nun OnDeActivate(), um die Dropdown List wieder einzuklappen
[SB] Flag in der Methode GuiWindow::OnActivate() ausgetauscht: bMouseActivate wurde entfernt, dafür gibt bParentActivate
     an, ob das Fenster als Parent des wirklich aktiven Fenster mitaktiviert wurde (true), oder ob das Fenster selbst
     aktiviert wurde (false)
[SB] GuiSys::SetActiveWindow() eingebaut, diese Funktion muß nun vom Backend aufgerufen werden, um das aktuelle Fenster
     zu setzen. Damit wird das aktuelle Fenster nun von GuiSys selbst verwaltet, da dies bei Win32 nur unzureichend
     geschieht. Bei der Aktivierung eines Fensters werden alle seine Parentwindows ebenfalls aktiviert (bekommen aber
     mitgeteilt, daß sie nur als parents mitaktiviert wurden), ebenso werden alle wieder deaktiviert
[CO] GuiDialogs: Darin sind fürs erste die Temprären Dialoge welche später durch eigene ersetzt werden
[SB] Habe die Grafiken leicht angepaßt, da diese vorher verschoben wirkten (z.B. bei GuiSlider)
[CO] Neues Control: GuiTabBar
[SB] GuiWindow::OnTooltip() eingebaut, diese Funktion kann überladen werden, falls ein Fenster unterschiedliche Tooltips
     besitzt, ansonsten wird der für das Fenster gesetzte Tooltip-Text verwendet
[SB] Tooltip eingebaut, der Text kann per GuiWindow::SetTooltipText() für jedes Fenster eingestellt werden
[SB] Neue Systemfunktion GuiSys::SystemGetMousePos() eingebaut, um die aktuelle globale Mausposition zu erfragen
[CO] GuiCheckBox: Jede Check Box kann sich nun in einer Gruppe befinden wobei dort immer nur eines zur gleichen Zeit
     Markiert sein kann und die anderen Mitglieder automatisch demarktiert werden. Diese Gruppe selst ist eine einfache
     Liste welche automatisch gelöscht wird sobald das letzte Mitglied das Zeitliche segnet
[CO] Neues Control: GuiStatusBar -> Ist eine einfache Liste an Buttons was völlig ausreichen sollte da die Status Liste
     nur dazu dient einen Status darzustellen, hat hat aber trotzdem mehr Möglichkeiten als bei der alten
     Gui-Statusliste ;-)
[CO] GuiMenu verbessert
[CO] Neues Window: GuiInputBox
[CO] Neues Control: GuiMenu
[CO] GuiCommandProducer: Neue Funktion: RemoveAllCommandListeners()
[CO] GuiWindow: Neue Eigenschaft: GetActive() -> wie vorher nur bei GuiButton -> frägt ab ob die Mause gerade über
     diesem Fenster ist -> Neue Funktion: OnMouseEnter() wird aufgerufen wenn die Maus ein Fenster betritt -> Da diese
     Information häufiger verwendet wird sollten alle Fenster diese Active-Information haben
[CO] GuiComboBox: An Listener-Architektur angepasst
[SB] SendMessage-Methode wieder ausgebaut, da es nun eine Listener-Architektur gibt
[SB] GuiButton, GuiCheckBox, GuiEditbox implementieren nun einen CommandProducer
[SB] GuiCommandListener eingebaut, über diesen Listener können einfache Commands erzeugt werden (für kompliziertere
     Nachrichten könnten später andere Listener-Typen hinzugefügt werden, im Moment reicht dies jedoch aus, und ist
     außerdem kompatibel zur PLGui1)
[CO] Neues Control: GuiComboBox
[CO] GuiLogowindow: Text Nachricht wird nun dargestellt
[CO] GuiListBox: Wird eine Edit Box vearbeitet so erhält das entsprechende Item immer den neuen Korrekten Text
[CO] GuiMessageBox erweitert
[CO] GuiEditBox um Styles wie z.B. Text Zentrieren erweitert
[CO] GuiListBox: EditBoxes sind nun Transparent, desweiteren diverse andere Controns Transparent gestellt um Overdraw zu
     reduzieren was teils zu leichtem flackern beim neuzeichen führte
[CO] GuiColor so erweitert das Farben auch mit Werten zwischen 0-255 definiert werden können (so wird man diese meistens
     per Hand Definieren :)   -> IsTransparent() nur bei negativen Werten (da sonst kein Schwarz möglich)
[SB] GuiFrame hat nun Styles, über welche die Titlebar-Buttons gesetzt werden können
[SB] m_bActive wurd in m_bEnabled umbenannt. Dieser Name ist eindeutiger und schließt Verwechslungen aus, da bActive
     auch oft verwendet wird, um anzuzeigen daß sich die Maus in einem Fenster befindet
[SB] GuiSysWindow::SystemSetTitle() eingebaut, mit dieser Funktion wird dem System ein Title für das Fenster mitgeteilt
     (damit wird nun der Titel der Applikation in der Taskbar angezeigt)
[CO] Neues Control: GuiListBox
[CO] GuiCheckBox: Über den Konstuktor lassen sich die Standard Bilder einstellen (Check oder Round Button)
[SB] GuiLabel auf Basis von GuiEditBox eingebaut (das hört sich unlogisch an, doch zu einem Label Edit-Funktionalität
     hinzuzufügen würde mehr Auffwand bedeuten, als bei einer EditBox diese Funktionalität einfach auszuschalten)
[CO] GuiSlider um Trackbar-Style erweitert
[CO] PLTDynamicList in GuiTools kopiert
[CO] Neues Control: GuiGroupBox
[CO] GuiSysGraphics um GetTextHeight() erweitert -> Text angabe ist zwar nicht wirklich brauchbar, könnte es später aber
     einmal sein (zudem siehts so einheitlich aus :)
[CO] PLTString in GuiTools kopiert und diverse Klassen angepasst
[SB] GuiWindow::SetShowInTaskbar() eingebaut, zusammen mit der Systemfunktion GuiSysWindow::SystemSetShowInTaskbar().
     Hiermit wird kontrolliert, ob ein Fenster in der Taskleiste (falls vorhanden) angezeigt wird
[SB] GuiSys::SystemHasTaskbar() eingebaut, hierüber kann ermittelt werden, ob ein System eine Taskbar besitzt
[SB] OnDestroy() wird nun von GuiWindow::Destroy() aufgerufen
[SB] SetTopmost() funktioniert nun, dafür gibt es in GuiSysWindow eine weitere System-Funktion SystemSetTopmost()
[CO] Neues Control: GuiCheckBox
[CO] Neues Window: GuiMessageBox
[CO] GuiBitmap um Transparenz erweitert
[CO] GuiColor erweitert
[CO] Neues Window: GuiLogoWindow
[CO] Neues Control: GuiSlider
[SB] Minimieren und Maximieren des Frames eingebaut
[SB] Die Hintergrundfarbe der Fenster wird nun von GuiWindow selbst gezeichnet, nicht mehr vom OS. Dadurch läßt sich
     nun in GuiWindow die Hintergrundfarbe einstellen (inkl. -1 für Transparenz). Hierbei muß allerdings folgendes
     beachtet werden: Wird ein Fenster mit transparentem Hintergrund neu gezeichnet, so werden zuvor nicht automatisch
     die darunter liegenden Fenster neu angezeigt, daher kann es zu Fehlern in der Anzeige kommen. Aus diesem Grund ist
     die Hintergrundfarbe der Controls nicht automatisch transparent, sondern muß explizit gesetzt werden
[SB] Die Kontrollelemente in der Titelleiste von GuiFrame sind nun echte Buttons
[SB] ContentWindow implementiert und in GuiFrame verwendet
[SB] GuiButton wurde fertig gestellt, er ist auch als ToggleButton einsetzbar
[SB] Nachrichtenübermittlung eingebaut, damit senden die Buttons nun Nachrichten an ihr Parent-Window
[SB] GuiColor eingebaut und alle Klassen, welche Farben verwenden, umgeschrieben
[CO] Neues Window: GuiProgressWindow
[CO] Neues Control: GuiProgressBar
[SB] GuiSysWindow::SystemSetFocus() eingebaut, damit funktioniert der Keyboard Focus in der Win32 Implementierung nun
     auch wieder
[SB] GuiWindow::OnKeyPressed() eingebaut
[SB] Alte Win32 Relikte entfernt: unnötige Callback-Funktionen wurden gelöscht und die Parameter standardisiert
    (int statt WORD/DWORD)
[SB] Behandlung von MouseOverWindow und FocusWindow wurde in GuiSys eingebaut
[SB] Neue virtuelle Funktion: GuiWindow::OnMouseLeave()
[SB] GuiBitmap eingebaut
[SB] GuiButton eingebaut, dabei werden mehrere Styles unterstützt, so daß der Button auch für die Toolbar geeignet ist
[SB] GuiFrame wurde implementiert, diese Klasse bietet alles, was ein typisches Windows-Fenster auch hat: Titelleiste,
     Rahmen, Systembuttons. Verschieben und Vergrößern des Fensters wurde auch eingebaut
[SB] Mit GuiWindow wurde der erste Teil des plattform unabhängigen Teils der Gui implementiert
[SB] Win32 Implementierung des Backends ist fertig
[SB] Design des Backends abgeschlossen
[SB] Die PLGui wurde komplett neu geschrieben und baut nun auf einem minimalen Backend-System auf, welches Portierungen
     auf andere Plattformen erleichtert
[SB] Umstellung auf PLGui ist komplett, die alten Klassen wurden entfernt
[SB] Fehler in PLTGui entfernt: Die GUI-Listener sind selbständige Objekte (sogar meist statische Instanzen), welche
     sich nur bei der GUI anmelden, um Nachrichten über Veränderungen innerhalb der GUI zu erhalten. Diese Objekte
     dürfen deshalb nicht mit der Liste zusammen gelöscht werden ;-)
[CO] In PLTGui::ClearWidgets() wurden die Einträge doppelt gelöscht, einmal in der Funktion selbst und einmal beim
     Löschen der Liste welche ihre Elemente nochmals löschte. (verursachte den Crash beim beenden von SpaceTaxi) Man
     kann mittlerweile per Parameter einstellen ob die Elemente beim Löschen der Liste auch gelöchst werden sollen...
     das Löschen der Elemente beim Löschen der Liste ist der Normalfall da die Liste normalerweise komplett selbst für
     seine Einträge verantwortlich ist.
[CO] Gui -> Widgets haben nun eine Priorität damit man 'überlappen' besser kontrollieren kann
[CO] Neue Funktionen: PLTWindowManager -> GetUserColor() und SetUserColor() um Benutzer Farben zu bekommen oder zu setzen.
     Desweiteren werden diese Farbeinstellungen nun auch in plconfig.ini gespeichert damit die Grafiker ihre
     'MustHave'-Farben immer Griffbereit haben ;-)
[CO] Jedes PLTWindowBase hat nun einen individuellen Namen mit welchem es angesprochen werden kann. Dieser Name kann
     vom User verändert werden damit er leichter verschiedene Fenster verwalten kann.
[CO] Baute in PLTWindowManager zwei neue Funktionen ein: Message() zum öffnen eines Nachrichten Fensters und Question()
     um einen Frage Dialog zu öffnen
[SB] Habe einen Fehler in der Update Funktion des GUI behoben.  In bestimmten Situationen konnte es zum geschachtelten
     Durchlaufen der Widgetliste kommen (List::FindFirst), was zu einem undefinierten Verhalten führt
[CO] Behob Probleme mit der Programm Instanz im Fenstern Code (Programm Instanz muss nun übergeben werden)
[CO] überarbeitete den Window-Manager, passte die Fenster & Dialoge an... vieles wirst du aus deinem Gui kennen :)



>> 02.09.2003
[SB]
- Dialoge sind eingebaut (sowohl modale als auch nicht modale)
- Die Funktionalität der Gui wurde nochmal erweitert und abgerundet (Run(), ShowDialogModal())
- Alle Grundfunktionen der Gui sind nun denke ich implementiert, damit dürfte einem Einsatz der
  PLGui2 in der PixelLight Engine nichts mehr im Wege stehen. Einige Controls müssen noch erweitert
  werden, auch fehlen noch Ersatzdialoge für die Common Dialogs.
  Folgende Erweiterungen stehen später noch an: Backends für Linux und PL, Look&Feel, Beschreibungsdateien



>> 01.09.2003
[SB]
- Das Verhalten der Fenster ist nun komplett eingebaut (ZOrder, TopMost)
- Docking-Toolbars sind nun endlich funktionstüchtig (Das Docking kann aber auch bei jedem anderen Fenster verwendet werden)
- Die Grundfunktionalität scheint nun fast komplett eingebaut zu sein, es fehlen nur noch die Dialoge



>> 20.08.2003
[SB]
- Wir sind in den letzten Tagen gut vorangekommen, so daß die wichtigsten Controls bereits eingebaut sind.



>> 10.08.2003
[SB]
- Listener-Architektur eingebaut, um die strikte Objektstruktur nicht wieder durch Command-Messages aufzuweichen
- Das System dürfte nun beinahe vollständig sein



>> 09.08.2003
[SB]
- Struktur weiter verbessert und ausgebaut
- Weitere Controls hinzugefügt



>> 08.08.2003
[SB]
- Topmost-Windows funktionieren nun, dafür war eine weitere System-Funktion nötig
- Erste Controls hinzugefügt



>> 07.08.2003
[SB]
- So heute dürfte es endlich mal richtig voran gehen. Christian wird nun bei den Controls helfen,
  so daß die Gui schnell wieder einsatzfähig wird.
- GuiSys wurde um Behandlung von MouseOverWindow und FocusWindow erweitert
- Nachrichtenübermittlung eingebaut
- Minimieren, Maximieren von GuiFrame() eingebaut



>> 06.08.2003
[SB]
- Dies wird wohl der Tag der Gui-Controls werden :-)
  Mal sehen wie schnell ich vorankomme, eigentlich würde ich gerne heute Abend alle wichtigen
  Controls beisammen haben, so daß die Editoren bereits mit der neuen Gui laufen könnten...
- Na prima, 19:20 und noch zu nichts gekommen... was für ein Tag... *hmpf*
- GuiSysGraphics::DrawRect() hinzugefügt
- Und noch ne Störung, das darf doch echt nicht wahr sein... 21:15 und noch immer kaum was erledigt!
- GuiWindow::OnMouseLeave() eingebaut und in Win32Window implementiert
- GuiButton und GuiFrame reagieren nun auf OnMouseLeave()



>> 05.08.2003
[SB]
- Heute habe ich begonnen, die eigentliche Gui zu entwerfen. Da die Gui nun nicht mehr von
  Windows abhängig ist, können auch die Strukturen (also z.B. Hierarchie der Fenstertypen)
  wesentlich logischer aufgebaut werden
- GuiFrame wurde implementiert, diese Klasse bietet alles, was ein typisches Windows-Fenster
  auch hat: Titelleiste, Rahmen, Systembuttons. Verschieben und Vergrößern des Fensters wurde
  auch eingebaut
- GuiButton eingebaut, dabei werden mehrere Styles unterstützt, so daß der Button auch für die
  Toolbar geeignet ist
- GuiBitmap eingebaut



>> 04.08.2003
[SB]
- Alle Systemabhängigen Komponenten wurden entworfen (GuiSys, GuiSysWindow, GuiSysImage,
  GuiSysFont, GuiSysGraphics) und die Basisklassen implementiert
- Win32 Implementierungen aller GuiSys-Klassen ist abgeschlossen, so daß nun nur noch
  die abstrakte Gui auf dem "Rücken" der Sys-Klassen aufgebaut werden muß



>> 03.08.2003
[SB]
- Heute ist mir die Idee zur neuen PLGui gekommen, da die alte Implementierung einfach noch
  zu win32 lastig ist und daher später sehr schwer zu portieren sein wird. Ebenfalls negativ
  bei der Sache ist, daß wir zwei Guis haben, eine für die Windowsoberfläche und eine in
  der Engine selbst. Daher wird die PLGui2 so designed sein, daß sie nur noch auf einem
  winzigen Systemabhängigen backend basiert, während alles andere darauf aufsetzt. Damit wird
  die Gui extrem einfach zu portieren sein und kann auch als Gui innerhalb der Engine eingesetzt
  werden.
- Das Design des Systems ist weitgehend abgeschlossen und die Unterteilung vom systemabhängigen
  Backend und der aufgesetzten Gui wurde vorgenommen.
- Der erste Teil des Backends wurde mit GuiSysWindow eingebaut, dabei gibt es auch schon eine
  minimale win32 Implementierung (GuiWin32Window), so daß die Anzeige eines einfachen Fensters
  bereits möglich ist
