>> 08.12.2010
[CO]
- "InputManager::UpdateControl()": Bevor etwas in m_lstUpdatedControls eingefügt wird, sollte geprüft werden obs bereits drinnen ist
  (hatte hier beim Testen Situationen wo ein Control am Ende mehrmals drinnen war)
- Im Control-Destruktor wird die neue "InputManager::RemoveControl()"-Methode aufgerufen, hier wird sichergestellt das dieses nun gelöschte
  Control nicht mehr in m_lstUpdatedControls ist... und so auch nicht mehr in "InputManager::Update()" verwendet wird (hatte hier eine Situation
  wo's hier einen Crash gab)



>> 23.10.2010
[CO]
- Auf Stefans Wunsch hin "Axis::IsValueAbsolute()" in "Axis::IsValueRelative()" umbenannt
- "VirtualStandardController" um "Pan", "PanX", "PanY", "PanZ", "Rotate", "Zoom" und "ZoomAxis" erweitert



>> 22.10.2010
[CO]
- Über "Axis::IsValueAbsolute()" lässt sich ermitteln, ob der aktuelle Wert ("GetValue()") absolut oder relativ ist. Ich habe mich dabei
  für "IsValueAbsolute()" entschieden, da dadurch die Abfragen in konkreten Verwendungen minimal komfortabler sind als über "IsValueRelative()".
  ("wenn absolut" -> "TimeDiff einmultiplizieren").



>> 08.10.2010
[CO]
- External "WindowsDDK" (das mittlerweile "Windows Driver Kit (WDK)" heißt) entfernt. In PLInput wird "hid.dll" nun Dynamisch geladen + dynamisch
  die Funktionszeiger der paar verwendeten HID Funktionen ermittelt. Damit muss man nun also zum PixelLight übersetzen nicht mehr das gesamte
  gigantische WindowsDDK (> 600 MB!) herunterladen und installieren, nur weil man 9 Funktionen davon aufruft um mit HID kompatiblen Geräten
  kommunizieren zu können. (ca. 40 KB dieses WindowsDDK wurden verwendet...)



>> 08.09.2010
[CO]
- VirtualStandardController: Interaction-Controls "Pickup", "Throw", "IncreaseForce", "DecreaseForce" und "PushPull" hinzugefügt
  (verwendet in "PLPhysics::SNPhysicsMouseInteraction")



>> 30.09.2010
[CO]
- VirtualStandardController: "Jump"-Control hinzugefügt, ich denke das ist ebenfalls etwas recht allgemeines
- VirtualStandardController: "TransX"/"TransY" Achsen zuweisung der Space Mouse war vertauscht
- VirtualStandardController: So genau wie möglich Dokumentiert welche 3D-Achse welche Bedeutung hat... denn da kann man schonmal schnell
  durcheinander kommen :D



>> 15.08.2010
[SB]
- InputManager: Es gab hier einen Mutex-Deadlock, der durch das Hintereinanderschalten von Controls ausgelöst wurde.
  Die Reihenfolge ist eigentlich so:
  - Mutex->Lock
  - Durch die Liste von geänderten Controls iterieren und Events auslösen
  - Mutex->Unlock
  - Von allen Devices Update() aufrufen
    - Wenn ein Device änderungen zu vermelden hat, trägt es das Control in die Liste ein:
      - Mutex->Lock
      - Control in die Liste eintragen
      - Mutex->Unlock
  Der Mutex ist also dafür da, zu verhindern, dass an zwei unterschiedlichen Stellen gleichzeitig auf die Liste von Controls
  zugegriffen werden kann, was diese im Falle von Multithreading natürlich beschädigen kann.
  Im Falle von Verbundenen Controls, geht dies aber nicht auf, weil das Event vom Controls dann dazu führt, dass ein anderes Control
  geupdated, also in die Liste eingetragen wird, wodurch dann das zweite Mutex->Lock passiert, noch bevor das erste Mutex->Unlock aufgerufen
  wurde, an der Stelle bleibt das Programm dann natürlich stehen. Um das zu verhinden, musste ich nun leider erstmal lokal die Liste kopieren,
  damit das Mutex dann bereits wieder freigegeben werden kann, ohne dass gefahr besteht, dass zwei Threads gleichzeitig auf die Liste zugreifen
  könnten. Das ist zwar nicht sehr performant, hat aber hoffe ich keinen zu großen Impact (bitte mal ausprobieren/messen!)



>> 08.08.2010
[SB]
- VirtualStandardController: Standard-Controls für die typische Steuerung eines "Spielers" (sei das nun eine Figur
  oder eine Kamera) eingebaut. Es gibt also Tasten für alle Richtungen, und zusätzlich noch relative Achsen,
  damit man z.B. auch über Maus oder relativen Devices wie der SpaceMouse navigieren kann. Natürlich deckt
  dies lange nicht alle Möglichkeiten ab, das soll es aber auch gar nicht. Wenn man mehr oder andere Controls
  braucht (z.b. für einen Flugsimulator), so kann man sich seinen eigenen VirtualController erstellen und diesen
  dann an die zu kontrollierenden Objekte anhängen.
- Unterscheidung zwischen AbsAxis und RelAxis wieder aufgehoben, da das in der Praxis alles viel komplizierter Macht,
  als dass es wirklich nützen würde. Falls es später mal gebraucht wird, kann man z.B. ein Flag in Axis einbauen,
  das angibt, ob die Achse relativ oder absolut zu verstehen ist, aber in den allermeisten Fällen will man einfach
  nur den aktuellen Wert haben und behandelt absolute und relative Achsen sowieso identisch, so dass man auf
  zusätzlich nötige Fallunterscheidungen gerne verzichten kann.
- Connection: Skalierungsfaktor für Achsen eingebaut, damit man z.B. verschiedene Achsen miteinander verbinden
  kann und dabei auf einen gemeinsamen Wertebereich (z.B. von -1.0 bis 1.0) skalieren kann. Später sollte dieses
  System mittels Ableitungen von Connection und RTTI-Anbindung ausgebaut werden, damit man ganz unterschiedliche
  Operationen bei Verbindungen ausführen kann, vorläufig reicht aber eine reine Skalierung aus (z.B. um WiiMote,
  SpaceMouse und Mouse für virtuelle Devices nutzen zu können, denn die Wertebereiche sind hier ja völlig
  unterschiedlich).
- VirtualStandardController: Default-Verbindung mit allen bekannten Geräten eingebauten. Hier bräuchte es natürlich
  noch einiges an Feinabstimmung, damit das wirklich benutzbar ist, aber anhand des 2D-Demos kann man zeigen, dass
  zumindest schonmal alle Geräte (inkl. SpaceMouse und WiiMote) automatisch erkannt werden und auch gleich benutzbar
  sind, ohne dass man extra was dafür programmieren müßte. Die WiiMote-Sensoren werden allerdings nicht automatisch
  verbunden, denn dafür bräuchte es noch etwas mehr Logik, um aus den Beschleunigungsinformationen so etwas wie
  eine relative Drehbewegung zu machen. Das bleibt also eine Aufgabe, PLInput hier um vernünftige Connection-Klassen
  zu erweitern, die das automatisch übernehmen können.



>> 06.08.2010
[SB]
- Update() wird nun wieder von ausserhalb aufgerufen. Ein solcher Aufruf ist sowieso nötig, um die Input-Nachrichten
  im Main-Thread zu synchronisieren, von daher ist es denke ich unsinnig, zusätzlich noch die Update-Methode
  im Thread laufen zu lassen, wenn man hinterher doch noch eine (dann zweite) Update-Methode braucht, die von
  außen aufgerufen wird. In der Update-Methode werden nun also erst die Devices aktualisiert, hierbei veränderte
  Controls informieren aber nicht mehr direkt ihren Controller, sondern tragen sich beim Manager in eine Liste ein.
  Anschließend wird diese Liste ausgelesen und damit die Nachrichten über geänderte Controls versendet. Ein Mutex
  hilft dabei, dass andere Threads erst dann wieder in die Liste schreiben können, wenn das Auslesen beendet wurde.
- DeviceManager in InputManager umbenannt, da diese Klasse das gesamte Input-System verwaltet und nicht nur die
  Devices. Auch hoffe ich, dass man eher nach Input als nach Device suchen würde, wenn man den Einstiegspunkt von
  PLInput sucht :-)
 


>> 31.07.2010
[SB]
- VirtualController hinzugefügt. Diese Klasse soll als Basisklasse für alle virtuellen Input-Controller dienen
  und fügt nur eine virtuelle Methode hinzu, die dazu genutzt werden soll, die vorhandenen Devices abzufragen
  und sich zu ihnen zu verbinden. Die Basisklasse selbst ist allerdings leer und bietet auch keine Controls,
  daher muss die eigentliche Implementierung in abgeleiteten Klassen erfolgen (da die virtuellen Eingabegeräte
  je nach Anwendungsfall sehr unterschiedlich aussehen können, denke ich nicht, dass man hier eine Basis
  vorgeben sollte).
- VirtualStandardController: Ist das erste konkrete virtuelle Device und bietet die Standard-Controls, die wir
  bisher so brauchten. Für die Samples müsste das daher ausreichen und man sollte damit recht weit kommen können,
  für konkrete Applikationen oder Spiele sollte man allerdings sicherlich einen eigenen virtuellen Controller definieren.
- Controller: ConnectAll() implementiert. Hierbei werden alle Controls mit identischen Namen automatisch miteinander
  verbunden, bei Bedarf können auch auf beiden Seiten noch prefixes angegeben werden.
- VirtualStandardController: Tastatur- und Maus-Controls werden unverändert durchgereicht, da diese universell
  verwendet werden und mandas schlecht auf virtuelle Controls herunterbrechen kann, da man im Vorfeld nicht wissen
  kann, welche Funktionen ein Programm zur Verfügung stellt. Maus und Keyboard können also über diesen virtuellen
  Controller weiterhin direkt verwendet werden, allerdings sollte man wo immer es geht lieber eigene, virtuelle
  Controls definieren, da man ansonsten die Möglichkeit, Keys anders zu mappen, verhindert.



>> 30.07.2010
[SB]
- SpaceMouse: Wie bei allen anderen Devices, werden nun nur noch die Controls neu gesetzt, die sich auch wirklich
  geändert haben.
- DeviceManager: EventOnDetectDevices<bool> eingebaut, der beim Starten und beim Stoppen der Device-Detection
  ausgelöst wird. Dies könnte später beispielsweise genutzt werden, um dem User eine Info-Nachricht anzuzeigen,
  dass er jetzt z.B. den Detection-Mode seiner Bluetooth-Devices einschalten muss, damit die Geräte erkannt werden
  können.
- Control: IsInput() hinzugefügt, das zurückgibt, ob es sich um ein Input-Control (RelAxis, AbsAxis oder Button) handelt.
- Connection hinzugefügt, um Controls miteinander zu verbinden. Dabei wird darauf geachtet, dass nicht gleiche
  Controls oder gleiche Controller miteinander verbunden werden können, auch ist es nicht möglich, Controls von Devices
  als Ziel von Connections anzugeben, denn Devices geben nur Events von der Hardware weiter und sollten nicht gleichzeitig
  aus anderen Quellen gespeist werden können. Wenn man so etwas möchte, kann man immer noch einen virtuellen Controller
  "zwischenschalten".
- Controller: Interface für das Erzeugen und Verwalten von Connections hinzugefügt, im moment noch recht einfach, so
  dass einfach zwei Controls miteinander verbunden werden können. Später wird es hier noch etwas ausgefeiltere
  Methoden geben, die z.B. automatisiert Controls miteinander verbinden können (siehe das noch nicht implementierte
  ConnectAll).
- Connection: PassValue() und PassValueBackwards() hinzugefügt. Diese Methoden werten automatisch vom Controller
  aufgerufen, wenn ein Control mit einer Connection geändert wurde. Die Forward-Methode wird für normale Input-Controls
  verwendet, also z.B. Buttons oder Achsen: Diese werden in der "normalen" Richtung, also Input->Output gesendet.
  Bei Output-Controls wie LEDs werden die Werte aber in die andere Richtung gesendet, also Output->Input, da ja
  auch schon bei den Devices die "Richtung" der Werte anders herum ist (zum Device, statt vom Device wie üblich).
  Diese Methoden sind ausserdem virtuell, da abgeleitete Connections deren Funktionalität verändern müssen (hier
  kann dann z.B. eine Umwandlung von Werten stattfinden).
- Connections sind nun soweit funktionsfähig, das Sample wurde um einen kleinen Test erweitert. Hier ist bereits
  zu sehen, wie Devices mit einem virtuellen Controller verbunden werden können, und dann hinterher nur noch mit
  diesem virtuellen Controller gearbeitet wird. Hierbei können auch Controls mehrfach verbunden werden, so kann
  für 'A' entweder 'Space', 'Ctrl', Joystick-Button0, WiiMote-Button 'A' oder SpaceMouse-Button0 gedrückt werden.



>> 29.07.2010
[SB]
- Verzeichnisstruktur noch einmal leicht geändert: Die Devices liegen nun in Input/Devices, die Controls in Input/Controls.
  Das Verzeichnis Base wurde entfernt.
- Zwei neue Controls hinzugefügt: Effect und LED. Beides sind Output-Controls, also solche, welche nicht Eingaben des
  Gerätes lesen, sondern statt dessen schreibend auf das Gerät zugreifen. Effect bezieht sich z.B. auf die Rumble-Funktion
  von Gamepads oder anderen ForceFeedback-Effekten, und LED sollte eigentlich klar sein, bspw. hat die WiiMote 4 LEDs :-)
- Controller: Neue virtuelle Methode UpdateOutputControl() hinzugefügt, die aufgerufen wird, wenn ein Output-Control
  geändert wurde. Devices sollten diese Methode dann implementieren, um die geänderten Daten an das Gerät zu senden.
- HIDDevice: Neue Methoden SendOutputReport() und SendOutputReportData() erstellt, die alle aktuellen Output-Values
  auslesen und daraus einen OutputReport erstellen, der dann an das Gerät gesendet wird. Wie auch schon beim InputReport
  ist die virtuelle Methode SendOutputReportData() dabei für die systemspezifische Implementation da.
- Joystick: Rumble-Controls eingebaut und alte SetRumble()-Methode entfernt. Sofern ein Joystick oder Gamepad
  die Usages UsageSlowBlinkOnTime, UsageSlowBlinkOffTime, UsageFastBlinkOnTime und UsageFastBlinkOffTime
  unterstützt, sollten darüber die Rumble-Motoren angesteuert werden können. Wenn es nicht klappt, bitte mal schauen,
  ob in den Output-values vielleicht andere Usages vorhanden sind, die man ebenfalls noch unterstützen sollte.
- WiiMote: Controls für Rumble und LEDs eingebaut, alte Methoden entfernt.



>> 28.07.2010
[SB]
- Habe den Versuch, einen eigenen HID-InputReport-Parser zu implementieren, erstmal aufgegeben. Zwar sollte dies eigentlich
  nicht so schwer sein, da man im Prinzip nur alle Capabilities durchlaufen muss, deren Bitsizes ansehen muss und anhand
  ihres DataIndex müsste dann der korrekte Offset im InputReport-Buffer herauskommen. Komischer Weise scheinen einige
  Daten dann aber an falschen Stellen zu liegen, und auch die Byte-Order alleine kann das nicht erklären, da einige Indices
  in der einen Reihenfolge kommen, die weiteren dann aber in der anderen Reihenfolge. Da mir hier bislang die Lösung nicht
  klar ist, habe ich daher nun darauf umgestellt, die HID-Parser-Funktionen des Betriebssystems zu nutzen (im Moment
  wird HID ja sowieso nur unter Windows direkt verwendet).
- HIDCapability: Einige wichtige Datenfelder noch hinzugefügt. Ausserdem wird nun auch der aktuelle Wert in m_nValue
  gespeichert, dieser wird von der Parser-Funktion befüllt und kann dann von der Device-Klasse abgefragt werden.
- HIDDevice: Methode ParseInputReport() hinzugefügt, welche den erhaltenen InputReport-Buffer parsen und dadurch die
  aktuellen Werte herauslesen soll. Aufgrund der Schwierigkeiten, einen eigenen Parser zu schreiben, ruft diese Methode
  nun erstmal die virtuelle Methode ParseInputReportData() auf, welche im Backend unter Zuhilfenahme der zur Verfügung
  stehenden API-Funktionen implementiert wird.
- Joystick: Die drei zusätzlichen Achsen heißen nun RX, RY, RZ statt R, U, V, da dies offenbar so üblicher ist.
- HIDDeviceWindows: ParseInputReportData() implementiert, mithilfe der Windows-HID-API werden die Daten nun korrekt
  geparsed.
- Joystick: Die Joysticks werden nun mit dem HID-Backend endlich mit den richtigen Daten befüllt. Habe dies mit meinem
  Gamepad und meiner XBox360-Gitarre ausgetestet, und die Daten, die vom Device gelesen werden, sind nun genau die
  gleichen wie auch in der Systemsteuerung oder unter Linux :-D
- WiiMote: Es werden nun PLInput-Controls anstatt eines eigenen Interfaces verwendet, um auf alle Buttons und Werte der
  WiiMote zuzugreifen. Beschleunigungen wurden dabei als relative Achsen angelegt, da mir dies Analog zur Mausbewegung
  erscheint - solange eine Bewegung ausgeführt wird, ist ein Wert vorhanden, sobald die Bewegung aufhört, geht der
  Wert zurück, also ein relativer Wert. Die Orientation bzw. Rotation, die daraus errechnet wird, stellt dagegen
  eine absolute Achse dar.



>> 26.07.2010
[SB]
- Button: Neben IsHit() nun auch noch CheckHit() eingebaut, welches nur überprüft, ob eine Taste gedrückt
  worden ist, den Status aber danach *nicht* zurücksetzt. Normaler Weise sollte immer IsHit() verwendet werden,
  da der Hit-Status nur durch das Zurücksetzen auch einen Sinn ergibt, aber in einigen Situationen, z.B. wenn
  man den Hit-Status irgendwo spiegeln möchte, möchte man diesen tatsächlich nur abfragen, ohne ihn zu verändern.
- Button: Jedem Button kann nun noch ein char zugeordnet werden. Beim Keyboard werden hier die ASCII-Zeichen der
  entsprechenden Tasten verwendet, als Standard für alle andere Buttons wird '\0' verwendet, jedes andere Device kann
  dies aber auch nutzen, wenn man möchte. Über die neue Methode Controller::GetChar() können dann die Tastatureingaben
  als chars ausgelesen werden, wodurch sich das ungefähr so bedienen lässt wie früher bei der Konsolenprogrammierung
  (mit dem einzigen Unterschied, dass die Methode nicht blockiert, da dies in Echtzeitanwendungen wirklich wenig Sinn
  ergibt). Ich wollte diese Funktionalität ursprünglich nur in Keyboard einbauen, dann schien es mir aber ganz nett,
  dies prinzipiell bei jedem Device nutzen zu können, insbesondere wenn man die chars dann über virtuelle Geräte selber
  definiert. Dies ermöglicht in einigen Fällen vielleicht eine sehr einfache Bedienung von Buttons, und warum sollte das
  auf ein bestimmtes Gerät (Keyboard) beschränkt sein :-)



>> 25.07.2010
[SB]
- LinuxMouseDevice: Wie unter Windows werden jetzt nur noch Events übertragen, wenn sich die Werte wirklich
  geändert haben.
- LinuxEventDevice: Ich dummer Esel - der Aufruf blockierte beim Lesen des Event-Interfaces, wodurch natürlich auch alle anderen Update-Devices
  nicht mehr weiter funktionieren konnten. Die Datei wird nun mit nonblock-Flag geöffnet, wodurch das Problem erledigt ist.
- LinuxEventDevice: Die Werte von Achsen werden nun in einer Skala von -1.0 bis 1.0 zurückgegeben, wobei Maximal- und Minimalwerte dynamisch
  vom Device ausgelesen werden.
- DeviceManager: Log-Ausgaben beim Abfragen von Devices hinzugefügt.
- WiiMote: Wieder einmal unter Windows getestet, funktioniert offenbar auch noch. Sicherheitsabfrage wie bei Joystick
  hinzugefügt, für den Fall, dass das Backend vor dem Device selbst zerstört wurde.
- HIDDeviceWindows: Es werden nun asynchrone Aufrufe verwendet, um Daten zu lesen und zu schreiben, damit das Programm
  nicht blockiert, wenn von einem Device nicht gelesen oder geschrieben werden kann. Im Falle von Bluetooth-Devices
  gibt es offenbar einen sehr eigenartigen Status, wenn das Device bereits im System bekannt und angemeldet ist,
  jedoch nicht eingeschaltet aber auch nicht im Bluetooth-Manager deaktiviert ist. In diesem Falle wird das Gerät bei
  DetectDevices() erkannt, obwohl es ja eigentlich gar nicht vorhanden sein dürfte, das es z.B. ausgeschaltet ist, dann
  blockiert jedoch die erste Lese- oder Schreiboperation. Wenn das Gerät dagegen im Bluetooth-Manager deaktiviert wurde,
  oder Bluetooth insgesamt ausgeschaltet wurde, tritt diese Situation nicht auf. Um zu verhindern, dass das Programm
  beim Erkennen der Devices in dieser Situation hängen bleibt, werden nun also asynchrone Aufrufe verwendet, dadurch
  gibt das Programm in jedem Falle zurück, es kommt dann lediglich niemals ein OnRead() vom Device. Dass das Device
  trotzdem erkannt wird lässt sich hierbei nicht verhindern, es kann dann eben nicht verwendet werden bzw. reagiert
  nicht, steht aber trotzdem in der Liste der Devices. Ich halte dies für einen Fehler bzw. ein sehr eigenartiges
  Verhalten des Bluetooth-Stacks, denn ausgeschaltete Geräte dürften meiner Meinung nach gar nicht erkannt werden,
  selbst wenn sie bereits im System einmal angemeldet waren und daher bekannt sind.



>> 24.07.2010
[SB]
- LegacyJoystickDevice (Windows): Das Updaten des Joysticks wird nun in der normalen Update-Methode
  der Device-Implementation erledigt, die Spezialfunktion und der zusätzliche Update-Thread im Provider
  konnten daher entfernt werden.
- LegacyJoystickDevice überarbeitet und vereinfacht.
- DeviceManager: Die Update-Methode wird nun in einem eigenen Thread regelmäßig aufgerufen und ist damit
  unabhängig von der Main-Loop des Programmes. Hier muss zwar noch eine Methode gefunden werden, um das
  zu synchronisieren, aber es erscheint mir so besser, wenn dies einheitlich an einer zentralen Stelle
  stattfindet, als wenn die Update-Methode aus der Mainloop aufgerufen wird und gleichzeitig noch verschiedene
  Provider eigene Threads zum Updaten ihrer jeweiligen Devices erzeugen.
- Neue Basisklasse: UpdateDevice. Die Update()-Methode für Backends kommt nun erst in dieser Klasse hinein,
  die Basisklasse DeviceImpl hat keine Update()-Methode mehr. Die Idee hinter dieser Klasse ist, dass alle
  Backends, die davon ableiten, sich ungefähr in der gleichen Weise verhalten: In ihrer Update()-Methode
  fragen sie den Status des Gerätes ab, und setzen dann direkt die entsprechenden Werte vom Device. Ein
  Device, welches ein solches Backend unterstützt, muss dessen Update()-Methode regelmäßig (in der eigenen
  Update()-Methode) aufrufen. So bilden sich langsam Kategorien von Backends, und die Devices werden dann
  so implementiert, dass sie zumeist ein (manchmal aber auch mehrere) Typen von Backends unterstützen.
- RawInputDevice: Wenn eine Taste längere Zeit gehalten wurden, wurden mehrere Pressed-Events ausgesendet, obwohl
  die Taste nicht losgelassen wurde. Dies wurde nun behoben.
- RawInputDevice: Durch das Zurücksetzen der relativen Achsen auf 0, wurden ständig Control-Events ausgelöst.
  Darum prüfe ich nun, ob eine Achse einen Wert hat, und setze ihn nur dann zurück, wenn er nicht bereits auf
  0 stand. Dadurch wird nun nach jeder Bewegung der Maus einmal 0 gesendet, danach ist das Device still.
- LegacyJoystickDevice und RawInputDevice auf UpdateDevice umgestellt.
- LinuxMouseDevice, LinuxKeyboardDevice und LinuxEventDevice auf UpdateDevice umgestellt.
- Mouse und Joystick verwenden nun UpdateDevice als Backend, Hinweis im Kommentar zur Klasse hinzugefügt.
- EDeviceBackend hinzugefügt. Beim Device-Backend kann damit nun der Typus abgefragt werden, die Device sollten dies
  nutzen um zu überprüfen, dass das übergebene Backend von einem erwarteten und vom Device unterstützten Typus ist.
- Joystick ist nun das erste und bislang einzige Device, welches mit zwei unterschiedlichen Backends arbeiten
  kann, nämlich entweder UpdateDevice oder HIDDevice. Im Falle von HIDDevice wird das HID-Interface verwendet,
  um den Status des Joysticks abzufragen, im Falle von UpdateDevice wird Update() aufgerufen, das Backend ist dann
  dafür verantwortlich, den Joystick-Status entsprechend zu aktualisieren. Die abgeleiteten Joystick-Devices
  JoystickHID und JoystickLinux wurden nun entfernt, damit gibt es keine unschöne Verknüpfungen zwischen den
  Device- und Backend-Klassen mehr.
- SpaceMouse auf die Verwendung von HIDDevice umgestellt.
- WiiMote auf die Verwendung von ConnectionDevice umgestellt.



>> 23.07.2010
[SB]
- Bluetooth-Implementation für Linux ist wieder vollständig und lauffähig. Es wird erstmal direkt die libdbus
  verwendet, später wäre eine Abstraktion von DBUS in PixelLight nett, insbesondere weil sich das auch gut
  mit PLCore verbinden lassen müsste und damit eine sehr viel komfortablere Abstraktion bieten würde, als wenn
  man libdbus "per Hand" verwenden muss. Auch gibt es sicherlich noch weitere Anwendungen, die für uns interessante
  Interfaces über DBUS anbieten (z.B. das neue Tray-Icon unter KDE, aber auch viele Dienste für den Handy-Port etc.).
  Vorerst reicht es jedoch so, dbus direkt für ein bestimmtes Interface zu verwenden.
- WiiMote-Device: Testweise werden nun schonmal zwei "richtige" PLInput-Buttons definiert, damit das mit dem Sample
  30Input auszutesten ist, ob das Device richtig funktioniert (klappt unter Linux bereits).



>> 22.07.2010
[SB]
- Bluetooth-Implementation für Linux auf Basis von DBUS neu erstellt. Das Suchen und Abfragen von Geräten erfolgt
  jetzt über das DBUS-Interface von bluez, womit nicht mehr direkt gegen die bluez-Library gelinkt werden muss.
  Leider gibt es offenbar kein l2cap-Interface über DBUS, weshalb hier weiterhin die bisherige Methode über
  sockets und read/write verwendet wird. Dies benutzt jedoch nur standard Linux-Libs und erfordert auch nicht das
  linken gegen libbluez.
- ConnectionDevice: SetInputReportSize() und SetOutputReportSize() hinzugefügt. Je nach tatsächlichem Device
  kann damit von Aussen die Report-Size festgelegt werden, dies ist z.B. für die Wiimote mit Bluetooth notwendig,
  da ich keinen Weg gefunden habe, ob und wenn ja wie man die Reportsize von dem Device auslesen kann. Da diese
  aber bekannt ist, kann sie dann von außen gesetzt werden.



>> 20.07.2010
[SB]
- HID-Implementation 'libhid' im Linux-Port entfernt, da wir diese Lib leider nicht nutzen können.
- Leere Linux HID-Implementation eingefügt, momentan gibt es aber noch kein "richtiges" HID-Backend
  für Linux.
- Linux-Backend auf Basis des Input-Event-Systems von Linux (input.h) hinzugefügt. Dies ist ein an sich
  recht einfaches Input-System, welches automatisch vorhandene HID-Devices einbindet und auf eben dieses
  Event-System abbildet. Leider ist dieses System zwar im Hintergrund HID, bildet jedoch alles auf eigene
  Strukturen ab und bietet somit keinen direkten Zugriff auf die USB-HID-Datenstrukturen. Dadurch ist es
  leider nicht richtig möglich, dies als HID-Implementation zu realisieren, weshalb dies nun ein eigenes
  Backend geworden ist, und somit auch noch wieder eigene Device-Typen braucht, die mit diesem Backend
  arbeiten (siehe JoystickLinux). Im Moment werden alle Event-Devices abgefragt, und falls vorhanden und
  der Zugriff darauf möglich ist, werden diese dann als Joystick eingebunden. Leider weiß ich nicht, wie
  man den Typus eines Event-Devices abfragen kann, es gibt zwar Vendor und Product ID, aber kein Usage
  oder UsageType. Man müsste ausserdem noch testen, ob dies z.B. auch die SpaceMouse erkennt und wenn ja,
  ob diese bereits Buttons und Achsen zur Verfügung stellt, oder ob man mit der vorhandenen Implementation
  auf die gleiche Weise mit dem Device kommunizieren kann, wie es über USB-HID möglich ist. Wenn das geht,
  müsste die SpaceMouse-Klasse bereits mit diesem Backend laufen können, da das neue Backend aus diesem
  Grunde gleich von ConnectionDevice abgeleitet wurde.
- RawInputDevice: Auch MouseWheel wird nun zurückgesetzt, damit die Bewegung auch wieder aufhört.



>> 19.07.2010
[SB]
- JoystickHID auf neues HID-Interface umgestellt und überarbeitet.
- SpaceMouse auf neues HID-Interface umgestellt und überarbeitet.
- WiiMote auf neues HID-Interface umgestellt und überarbeitet.
- Bluetooth-Backends nach Backend/Bluetooth verschoben und an das neue Design angepasst. BTConnection wurde
  entfernt, dafür werden die systemspezifischen Implementationen nun von BTDevice abgeleitet, was seinerseits
  das allgemeine Interface aus ConnectionDevice implementiert. Das ganze ist eigentlich analog zu HID.
- Mouse, Keyboard und Joystick (Legacy und HID) funktionieren unter Windows nun wieder. Beim Deinitialisieren
  gibt es wieder einmal das Problem der Deinitialisierungsreihenfolge, wodurch die Singletons HID und RawInput
  u.U. früher deinitialisiert werden, als der DeviceManager, was dazu führt, dass die Backends früher gelöscht
  werden als die tatsächlichen Devices, die dann mit einem ungültigen Backend-Zeiger zurückbleiben. Dies sollte
  noch einmal überarbeitet werden, im Moment sollte das Problem aber eigentlich dadurch gelöst sein, dass sich
  das Backend bei der Device-Klasse austrägt, wenn es gelöscht wird. Auf Dauer wäre es aber besser, noch einmal
  die Verwaltung von Backends und Devices komplett zu überarbeiten.



>> 18.07.2010
[SB]
- HID-Backends nach Backend/HID verschoben und an das neue Design angepasst. HIDConnection wurde entfernt, diese
  Klasse diente zuvor dazu, eine "Direktverbindung" mit einem Device zu öffnen und ein Read/Write-Interface zur
  Verfügung zu stellen. Dies wird nun gleich direkt von HIDDevice übernommen. Ausserdem wird nun auch das neue
  Device-Backend-System verwendet, daher ist ConnectionDevice (früher RWDevice) nun eine ABleitung von DeviceImpl,
  davon abgeleitet wiederum sind HIDDevice und danach die systemspezifischen Backends. Dadurch sind nun keine
  Mehrfachvererbungen mehr nötig, entweder kann das Backend direkt auf das entsprechende Device zugreifen, oder
  das Device erwartet einen bestimmten Typus von Backend (z.B. ConnectionDevice) und arbeitet mit diesem. Somit
  kann es z.B. mehrere Implementationen von ConnectionDevice geben (HID und Bluetooth), die das gleiche Interface
  bedienen, die bisherige Fallunterscheidung ist daher nicht mehr nötig.



>> 17.07.2010
[SB]
- DeviceManager und Provider als Kopie der alten Klassen übernommen, hier wird es wohl nur sehr wenige Änderungen
  geben. Provider liegt nun in 'Backend', da hier die eigentliche Verwaltung konkreter Devices beginnt, und die
  jeweiligen Provider daher systemabhängig sind. Neben den Providern soll es zukünftig auch noch eine Art
  Device-Backend geben, welches ein konkretes Device(-Interface) darstellt (z.B. HID-Device, RawInput-Device,
  Bluetooth-Device o.ä.). Hier kann es nun zusätzliche abstrakte Basisklassen geben, damit z.B. ein logisches
  Device mit unterschiedlichen Backends arbeiten kann, wie z.B. WiiMote, welches dann auf einem abstrakten Interface
  arbeiten kann, während die konkrete Realisierung unter Windows mittels HID geschieht, unter Linux aber mittels
  Bluetooth.
- DeviceImpl hinzugefügt. Diese Basisklasse soll von konkreten Devices verwendet werden, um auf das jeweilige
  System-Backend zugreifen zu können. Beispielsweise würde KeyboardWindows ein Backend vom Typ 'RawInputDevice'
  verwenden, während z.B. WiiMote ein gemeinsames Backend verwenden würde, welches sowohl unter Linux als
  auch unter Windows (unterschiedlich) implementiert wird. Durch diese Entkoppelung wird hoffentlich die
  Ableitungslogik einfacher, da logische Devices und die im Backend verwendete Technologie nicht mehr
  gemeinsam abgebildet werden müssen.
- RawInput-Implementation auf das neue System umgestellt und nach Backend/Windows verschoben. Die Klasse RawInputHandler
  wird nun nicht mehr benötigt, statt dessen werden die Nachrichten nun direkt an das RawInputDevice gesendet,
  welches seinerseits nun von DeviceImpl abgeleitet worden ist. Da DeviceImpl und Device jeweils einen Zeiger
  aufeinander haben, kann somit direkt von RawInputDevice aus auf das logische Device zugegriffen werden und die
  entsprechenden Werte des Eingabegerätes gesetzt werden. Die Ableitung von MouseWindows und KeyboardWindows fallen
  damit auch raus und sind nicht mehr nötig.
- DeviceImpl hat nun auch eine Update()-Funktion, welche von Device aus aufgerufen wird. Damit können auch Backends
  das Update-Verhalten beeinflussen (z.B. müssen bei RawInput die Werte der Maus pro Frame zurückgesetzt werden).
- DeviceImpl: Flag m_bDelete hinzugefügt, das bestimmt, ob das DeviceImpl-Objekt automatisch gelöscht werden soll,
  wenn das dazugehörige Device gelöscht wird, oder ob das DeviceImpl an anderer Stelle verwaltet und gelöscht wird.
- Veraltete Windows Joystick-Implementation als ProviderLegacyJoystick und LegacyJoystickDevice in Backend/Windows
  wieder eingebaut.
- Linux-Backend für Mouse und Keyboard wieder eingebaut und an neues System angepasst.



>> 16.07.2010
[SB]
- Neue Basisklassen für die Controls eingebaut. Es gibt nun zunächst die Typen Button, Relative (axis) und
  Absolute (axis), womit 99% aller Anwendungsfälle zurechtkommen sollten. Controls melden sich bei ihrem
  jeweiligen Controller an, und können von dort aufgelistet und abgefragt werden.
- Controller-Interface vervollständigt. Es können nun alle Controls abgefragt werden, wahlweise auch nur
  einen bestimmten Typus von Controls. Die dafür notwendigen Listen werden nur dann befüllt, wenn sie überhaupt
  verwendet werden. Zusätzlich gibt es noch eine Hashmap, um auf Controls per Namen zugreifen zu können. Wenn
  ein Control sich ändert, informiert es seinen Controller, dieser schickt dann wiederum die notwendigen Events
  heraus, wenn er nicht selber gerade deaktiviert ist.
- Klasse Device als Ableitung von Controller eingebaut und Mouse und Joystick hinzugefügt. Zur Definition von
  Devices werden nun immer die Control-Klassen verwendet und nicht, wie bisher, noch zusätzliche Interface
  für konkrete Devices hinzugefügt (dies war bisher z.B. bei Keyboard und auch bei WiiMote der Fall). Zusätzliche
  Methoden sollten nur für spezielle zusätzliche Operationen oder Optionen hinzugefügt werden, bspw. um die
  Wiederholrate für ein Device einzustellen oder ähnliches.



>> 15.07.2010
[SB]
- Mit PLInput-Refactoring begonnen. Das Prinzip und grundlegende Design von PLInput ist soweit ok und wird nicht
  grundlegend geändert, es wird aber einige schon lange geplante Erweiterungen geben, auch soll das Backend-System
  noch einmal im überarbeitet und wenn möglich vereinfacht werden, so dass gleiche Device-Typen und unterschiedliche
  System-Implementationen davon besser abgebildet werden können.
- Neue Basisklasse Controller hinzugefügt. Dies wird die Basisklasse für sowohl reelle als auch virtuelle Devices, welche
  dann untereinander verbunden werden können. Dadurch werden die Eingaben in Zukunft nur noch mit virtuellen
  Eingabegeräten arbeiten, welche ihrerseits mit den reellen Devices verbunden sein werden. Neben dem Mappen von
  Controls beliebiger Devices auf virtuelle Controls, ermöglicht dies auch z.B. das Verknüpfen von virtuellen
  Controllern mit einem Render-Window, wobei z.B. der Controller automatisch deaktiviert werden kann, sobald das
  Window inaktiv wird. Dadurch sollten sich die alten Probleme lösen lassen, die wir mit unserem globalen Input-System
  bisher immer hatten, dass alle Eingaben wie z.B. Mouse-Events auch dann noch weiter aktiv bleiben, wenn man z.B.
  zu einem anderen Fenster oder einer anderen Applikation wechselt.



>> 08.07.2010
[SB]
- MouseLinux implementiert, analog zum Keyboard über XQueryPointer. Nun besteht noch das Problem, dass die Maus jetzt
  noch innerhalb der Fensters gefangen werden muss, wie es ja auch unter Windows schon der Fall ist.



>> 07.07.2010
[SB]
- ProviderLinux: Keyboard und Maus auch unter Linux hinzugefügt.
- KeyboardLinux implementiert, die Tastatureingaben werden global mittels XQueryKeyMap abgefragt, wodurch man nicht darauf angewiesen
  ist, Window-Nachrichten durchzureichen.



>> 03.08.2009
[CO]
- Mein SpacePilot zog in PixelLight irgendwie immer sehr unschön nach so das es dadurch sehr unhandlich war mit dem SpacePilot
  zu Navigieren da man sich wie Betrunken vorkam. Ich verfolgte per Debugger mal was da so alles intern passiert - und fand in
  "RWDevice::ReadThread()" ein "Sleep()" das diese verzögerung der Eingaben erklärt. Wenn ich dieses Sleep rausnehme geht alles
  wunderbar. Zumindestens für HID Geräte scheint dieses Sleep auch nicht nötig zu sein um die Systemlast zu senken wofür das
  glaub ich da ist. "ReadFile()" in "HIDConnectionWindows::Read()" blockt wenn keine weiteren Eingaben vorliegen. Wie das in
  "BTConnectionLinux::Read()" oder später anderen Fällen aussieht weis ich nicht. Habe das Sleep daher mal mit Kommentar versehen
  und auskommentiert - Stefan, wäre nett wenn du kurz drüberschaun könntest ob das auch ohne Sleep geht oder obs einen Grund gab
  warum man das benötigt.



>> 25.03.2009
[CO]
- "SpaceNavigator" in "SpaceMouse" umbenannt da Bezeichnung einer ganzen Palette gleichartiger Geräte



>> 14.03.2009
[CO]
- "SpaceNavigator": Die verschiedenen ProductID's hinzugefügt für ähnliche Produkte. (die Klasse sollte man wohl umbenennen...)
- "ProviderHID::QueryDevices()": Da ich mittlerweile stolzer Besitzer eines "SpacePilot" bin konnte ich das endlich mal selbst
  in Ruhe testen... allerdings tat sich bei mir in PixelLight erstmal nüschts. Stellte sich heraus das ich als PL-Device nicht
  "SpaceNavigator0" nutzen konnte sondern "SpaceNavigator3". Ich ging der Sache nach und fand die Problemstelle in
  "ProviderHID::QueryDevices()". Hier kann man leider ja nicht die ProductID vergleichen, warum auch immer bekomme ich 4
  Devices von "3Dconnexion" aufgelistet... was verwirrend ist da ich nur einen "SpacePilot" habe. :D
  Auf "http://www.3dconnexion.com/forum/viewtopic.php?p=4046#4046" wird geraten nicht die "ProductID" zu nutzen, was wir auch
  bereits nicht tun... aber neben "Vendor" sollte man "UsagePage" auf "HID_USAGE_PAGE_GENERIC" prüfen und "Usage" auf 8 hin.
  Machte das, und nun kann ich meinen "SpacePilot" wie (bis auf den Device-Namen :) erwartet über "SpaceNavigator0" nutzen.



>> 02.02.2009
[CO]
- 'RawInput'-Destruktor: Irgendwie hatte ich hier gerade das merkwürdige Verhalten das der Thread über 'Joint()'
  einfach nicht Terminieren wollte und sich dann natürlich die Anwendung nicht schloss - daher setzte ich ein Timeout.



>> 30.01.2009
[CO]
- DeviceManager: Im Destruktor werden nun erstmal direkt auch die anderen PLInput Singletons übern Jordan geschickt...
  leider machen Singletons bei bestimmten Projektarten schnell probleme und man kommt in Teufelsküche wenn man nicht
  sauber vor Programm Termination seinen selbst geholten Speicher wieder freigibt...



>> 08.01.2009
[SB]
- RawInput: Die Nachrichten für RawInput werden nun in einem separaten Thread abgefragt. Die Mausbewegungen werden dann
  summiert, damit alle relativen Bewegungen innerhalb eines Frames auch erfasst werden und nicht wie bisher bei geringen
  Frameraten viele Inputdaten verloren gehen. Nun muss jedoch pro Frame einmal eine Update-Methode aufgerufen werden,
  in der die relative Bewegung wieder zurückgesetzt wird. Dies muss letztlich in der Main-Loop aufgerufen werden, habe das
  erstmal in RenderApplication eingebaut.



>> 07.01.2009
[SB]
- Dateien etwas umsortiert, damit alles hoffentlich wieder etwas übersichtlicher wird. U.a. sind nun alle Devices, mit denen
  der Programmierer letztlich in Kontakt kommen soll, zusammen im Ordner "Devices" zu finden (bspw. Mouse, Joystick etc.).
  Zwar sind weitere Klassen hiervon abgeleitet, z.B. MouseWindows, MouseLinux etc., aber diese Klassen sollten für die
  *Verwendung* von PLInput nicht weiter betrachtet werden und sind nur für die Implementation interessant. Diese Klassen
  finden sich daher in den einzelnen Backend-Unterordnern (z.B. Windows, Linux, HID, etc.).
- DeviceHandler entfernt, da das bisher nur als Platzhalter drin war und noch nie verwendet wurde.



>> 15.12.2008
[SB]
- SpaceNavigator: Es sollte nur die VendorID geprüft werden und nicht die ProductID, damit auch andere Versionen des
  Eingabegerätes (SpacePilot, SpaceExplorer, ...) genutzt werden können.



>> 07.10.2008
[SB]
- SpaceNavigator: Da gabs ein signed/unsigned Problem mit den Achsen. Jetzt wird die Rotation im korrekten Intervall (-x, 0, +x) übergeben.



>> 24.08.2008
[CO]
- Wo sinnvoll 'Win32' zu 'Windows' gemacht da für 32 Bit als auch für 64 Bit



>> 30.05.2008
[CO]
- Keyboard: 'KeyClear', 'KeySelect', 'KeyExecute' und 'KeyHelp' "Dokumentiert". Nach viel "googeln" fand ich keine genaueren
  Infos zu diesen Tasten... alle schreiben eigentlich nur 'Clear' etc. als Kommentar. Ich denke mal das sind Tasten die
  nicht auf jeden Keyboad vorhanden sind oder 'überbleibsel aus vergangenen Tagen'. Nach herumprobieren konnte ich nur
  'KeyClear' über Numpad-5 erzeugen wenn das Numpad deaktiviert ist.



>> 10.05.2008
[CO]
- Button::SetPressed(): Die Abfrage wann 'Hit' auf 'true' gesetzt wird war irgendwie merkwürdig und machte es in z.B.
  'PLEngine::SNConsoleBase::ProcessKeyMessage()' unmöglich rauszubekommen ob eine Taste gedrückt wurde und jetzt im
  Augenblick immer noch gedrückt ist. ('hit' wird derzeit nicht 'automatisch' auf 'false' gesetzt sobald die Taste
  wieder losgelassen wird, darum muss man teils nach 'Hit' eine weitere Abfrage machen)
  'Hit' wird nun auf 'true' gesetzt wenn die Taste vorher 'nicht' gedrückt war, aber es 'nun ist'. Falls das nicht ok
  so ist müssen wir uns da nochmal zusammensetzen und schaun was man da noch machen kann.



>> 28.02.2008
[CO]
- KeyboardWin32: Bei "ProcessKeyboardData()" eine Sicherheitsabfrage auf NULL eingebaut, hatte hier bei
  'Keyboard::KeyPrintScreen' einen Crash. Baute bei ähnlichen Stellen wo das noch nicht der Fall war (auch GetAxis())
  ebenfalls solche Abfragen ein... sicher ist sicher ist sicher. *g*



>> 26.02.2008
[CO]
- JoystickWin32: Machte eine kleine Erweiterung für den Fall das kein 'POV' vorhanden ist wie das hier bei mir
  gerade der Fall ist. Nicht schön, aber es funktioniert.



>> 25.02.2008
[SB]
- Klasse HIDHandler in RWDevice.cpp umbenannt und nach src/ verschoben. Sie dient als Basisklasse für alle Devices,
  die direkt per Read/Write angesprochen werden. Im Konstruktor kann entweder ein HIDDevice oder ein BTDevice übergeben
  werden, dadurch wird eine entsprechende Connection erzeugt und verwendet.
- InputReport und OutputReport werden jetzt nicht mehr in RWDevice erzeugt sondern von jedem Device selbst. Da sich
  die eigentliche Größe der Puffer doch gerne mal von dem ausgelesenen Wert unterscheidet, ist es besser, wenn das
  vom Gerät selbst verwaltet wird.
- Mußte eine Merkwürdige Fallunterscheidung in WiiMote einbauen: Unter Windows funktioniert es nur, wenn man immer
  einen ganzen OutputReport von 22 Byte sendet, auch wenn der aktuellen Befehl weniger Bytes braucht. Unter Linux ist
  es genau umgekehrt, da bekomme ich Fehler, wenn ich mehr sende als für den aktuellen Befehl notwendig. Daher überprüfe
  ich nun in WiiMote, ob Bluetooth verwendet wird oder nicht, und sende jenachdem mehr oder weniger vom Puffer.
- Mußte noch etwas an den OpenFile-Einstellungen herumspielen, da HID Geräte ansonsten in größeren Applikationen plötzlich
  nicht mehr anzusprechen waren. Hoffe, das geht jetzt so.
- Ganz einfache WiiMote-Steuerung als Test in PLSample2DGame eingebaut.



>> 24.02.2008
[SB]
- Design von HID und RawInput vereinheitlicht: Die Devices werden als direkte Instanzen in einer Liste gespeichert,
  dienen aber nur als Informationsobjekte, nicht zur Kommunikation mit dem Gerät. Die eigentlichen Instanzen können
  sich daher immer ändern (de facto nach jedem DetectDevice), es sollten also keine Zeiger darauf gespeichert werden.
  Beim Zugriff auf ein Gerät wird immer eine Referenz auf das Device übergeben, um z.B. auf den Namen oder das
  Device-Handle zuzugreifen.
- Neue Klasse HIDConnection mit Plattform-spezifischen Implementationen hinzugefügt. Diese Klasse wird jetzt von
  HIDHandler für die eigentliche Kommunikation mit dem Gerät verwendet, wodurch die unschöne Lösung, void-Pointer
  als Handles an die Plattform-Implementation zu übergeben, nicht mehr nötig ist. Dadurch, dass die eigentliche
  Kommunikation nun über die Schnittstelle HIDConnection läuft, läßt sich dies im nächsten Schritt weiter abstrahieren.
- Da wie gesagt die HID-Implementation(en) unter Linux noch etwas unfertig daherkommen, ist es zur Zeit nicht so richtig
  möglich, eine WiiMote einfach über HID anzusprechen. Statt dessen muss man zur Zeit unter Linux leider noch direkt
  über Bluetooth kommunizieren, um die WiiMote anzusprechen. Das ist sehr schade, weil damit natürlich auch mein
  ganzes Design, diese Klasse einfach auf HID aufzusetzen, unter Linux nicht greift ;-)
  Es gibt daher nun noch ein weitere Input-Backend zur Kommunikation mit Geräten über Bluetooth. Dieses implementiere
  ich aber erstmal nur für Linux, da man ja Bluetooth-Eingabegeräte über Windows gleich über HID ansprechen kann und
  somit eigentlich keine Notwendigkeit besteht, direkt per Bluetooth zu kommunizieren.
- Der Klasse HIDHandler kann nun beim Erstellen entweder wie bisher ein HIDDevice übergeben werden, oder aber ein
  BTDevice. Je nachdem, wie die Klasse instanziiert wird, wird dann entweder eine HIDConnection oder eine BTConnection
  verwendet, um mit dem Gerät zu kommunizieren. Ab da ist wieder alles gleich, so dass sich z.B. an der Implementation
  für die WiiMote nichts ändert.
- Neuer Provider: ProviderBluetooth. Dieser sucht mittels des Bluetooth-Backends nach WiiMotes und initialisiert diese
  dann mit einem BTDevice.



>> 20.02.2008
[SB]
- Nochmal einige Klassen verschoben und umbenannt. Die meisten Klassen liegen nun direkt im Source-Ordner,
  nur die Controls sowie die zugrunde liegenden Interfaces (HID und RawInput) haben einen Extraordner. So finde
  ich das deutlich übersichtlicher, da alle zusammengehörigen Dinge jetzt auch beisammen liegen (z.B. alle
  Joystick-Implementation).



>> 19.02.2008
[SB]
- Abstraktion von HID über eine weitere Implementationsklasse HIDImpl. Das muss leider sein, da jedes System
  eine andere HID-API besitzt. Wenn wir also auf HID zugreifen wollen, müssen wir dies für jedes System entsprechend
  implementieren, nur so ist es möglich, dass hinterher z.B. eine JoystickHID-Implementation nur noch auf unsere
  HID-Klasse zugreift, und wir dafür dort nicht noch einmal zwischen Linux/Windows unterscheiden müssen.
- HID unter Linux ist leider noch lange nicht so ausgereift, wie ich dachte. Zur Zeit gibt es das gleich in mehreren
  Geschmacksrichtungen, die natürlich alle so ihre Tücken haben. Zunächst einmal gibt es HIDDEV, welches vom Kernel
  bereitgestellt wird und entsprechend eigentlich die erste Wahl sein sollte. Darüber kann man auf HID-Devices zugreifen,
  welche über spezielle Device-Nodes vorhanden sein sollten (/dev/usb/hiddevX oder /dev/hiddevX). Leider ist dies
  auf meinem Ubuntu-System nicht der Fall, obwohl die entsprechenden Optionen im Kernel enthalten zu sein scheinen.
  Und mit anderen Device-Nodes lassen sich die Geräte auch nicht korrekt mit HID ansprechen. Man könnte das System sicherlich
  so hinbekommen, dass die Nodes da sind, aber das hilft wenig, weil es ja auf einem "normalen" Ubuntu laufen soll, ohne dass
  der User erst in udev oder sonstwo herumkonfigurieren muss. Auf anderen Linuxes dürfte diese Methode aber so funktionieren,
  denn da sind die Devices meist vorhanden - z.B. auf dem PLServer sind sie da :-)
  Darum kommen wir zu Option 2: libHID. Diese Lib spricht direkt USB und implementiert darauf das HID-Protokoll selbst, deswegen
  benötigt sie keine HID-Unterstützung im Kernel. Leider hat das ganze aber einen anderen Haken: Der Kernel erkennt die Devices
  automatisch und lädt einen entsprechenden Treiber für das jeweilige Gerät, sofern er einen dafür hat. Beispielsweise Joysticks
  werden automatisch über JOYDEV angesprochen und eine entsprechende Node /dev/jsN angelegt. Damit hat aber der Kernel exclusiven
  Zugriff auf dieses Device, somit kann ich dieses Gerät über libHID nicht mehr ansprechen. Darum muß man über libhid alle Devices,
  auf die man Zugriff haben will, erstmal vom Kernel trennen - und das geht natürlich nur, wenn man root-Rechte besitzt. Die Methode
  über lidhid funktioniert also nur, wenn man das PL-Programm als root startet, oder wenn man nur Geräte benutzt, die vom Kernel
  nicht in Anspruch genommen werden (oder z.B. selbst in seinem System das Laden des Joysticktreibers verhindert).
  Aus diesen Gründen werde ich einfach versuchen, beide Methoden zu implementieren. Als erstes wird dann versucht, die HIDDEV-Funktion nutzen,
  wenn das Programm dann feststellt, dass es leider keine HIDDEV-Nodes auf dem System gibt, wird lidhid als Fallback verwendet.
- HID-Implementation für Windows eingebaut: HIDWin32
- HID-Implementation für Linux eingebaut: HIDLibHid



>> 17.02.2008
[SB]
- Neue Rubrik 'HID': Hierüber kann auf alle USB-HID Geräte zugegriffen werden. Das ist ein generelles Protokoll für
  USB-Eingabegeräte, wodurch keine speziellen Treiber für einzelne Geräte mehr nötig sind. Was wir hierüber implementieren,
  müßte also auch unter Linux genau so laufen (sobald der HID-Manager unter Linux läuft), und man kann auf Unterscheidungen
  zwischen den Systemen verzichten (z.B. für Joysticks).
- RawInput und HID im Aufbau so verändert, dass die Devices nur noch reine Datenobjekte sind, die Informationen über ein
  Device herausgeben. Der eigentlich Zugriff wird dann über Handler vorgenommen. Das macht das Enumerieren von Devices
  einfacher, so dass die komplizierte Logik für das Auffinden/Hinzufügen/Entfernen von Devices jetzt nur noch im Device-Manager
  stattzufinden braucht. 
- WiiMote implementiert. Es kann auf alle Buttons, LEDs, Rumble, die Beschleunigungssensoren sowie den Infrarotsensor
  zugegriffen werden. Unterstützte Extensions: Nunchuk, Classic-Controller ist noch auskommentiert, da ich den nicht habe
  und daher nicht testen kann. Jetzt fehlt eigentlich nur noch das Abspielen von Sound (ja, auf diesem Controller kann man
  Sound abspielen),   dafür habe ich auch bereits die nötigen Infos, sehe aber gerade keinen Grund dafür, das zu implementieren.
- SpaceNavigator implementiert - Translation und Rotation können ausgelesen werden. Da ich das auch auf Basis von HID
  implementiert habe, wird dies mit der alten seriellen Space Mouse nicht funktionieren. Ich habe zwar auch Code dafür,
  die Space Mouse über die dafür mitgelieferten Treiber-DLL anzusprechen, werde das aber im Moment nicht implementieren,
  wenn wir nicht wirklich eine Verwendung dafür haben.
- Habe jetzt 2 Tage damit verbracht, Joysticks über HID anzusprechen. Das alte Joystick-API von Windows ist nun doppelt
  veraltet (erst DirectInput und nun HID), und sollte daher eigentlich nicht mehr benutzt werden. Allerdings muß ich
  leider feststellen, dass das alles nicht so einfach ist. Ich kann mein eigenes Gamepad problemlos ansprechen, jedoch
  ist es eine ganz andere Geschichte, das für *beliebige* Joysticks zu implementieren. Zwar listet das Device penibel
  auf, was für Controls es so besitzt und wie es diese zurückliefert, aber diese Informationen genau zu analysieren und
  dann den Input zu parsen, ist ziemlich aufwendig. Beispielsweise sind die Werte nicht unbedingt an einem Byte ausgerichtet,
  ein Device kann also z.B. 4 Bit für eine spezielle Achse senden, danach 8 Bit für Buttons, dann die X-Achse oder ähnliches.
  Daher mache ich daran jetzt erstmal nicht weiter, hierfür sollten wir uns einen vernünftigen HID-Parser suchen (da habe ich
  einige Projekte gefunden), oder das doch anders über Systemfunktionen implementieren.
  Testweise habe ich jedoch die Implementation für mein Gamepad drin gelassen - wenn man einmal für ein Device weiß, wie
  dessen Daten aufgebaut sind, ist es sehr einfach, das anzusprechen. Daher kann ich bei meinem Gamepad auch die Rumble-Motoren
  ansprechen, was über die alte Joystick-API natürlich nicht geht :-)



>> 11.02.2008
[CO]
- Ging das neue Projekt zum Einarbeiten genauer durch und veränderte ein paar kleinigkeiten die mir ins Auge vielen.
  Sieht alles sehr Interessant aus. :D



>> 01.02.2008
[SB]
- RawInput: Es gibt nun zwei virtuelle Devices für "Keyboard" und "Mouse", die jeweils alle entsprechenden Geräte
  zusammen repräsentieren. Damit kann das Verhalten hergestellt werden, das vom normalen Windows-Maustreiber her bekannt
  ist (z.B. beim Laptop werden alle Bewegungen von Touchpad und USB-Maus auf den gleichen Maus-Cursor übertragen.).
  Diese virtuellen Geräte werden standardmäßig verwendet. Falls jemand explizit nur ein bestimmtes Gerät ansprechen will,
  kann er dies über GetDevice("Mouse0") usw. tun.
- Kleines Problem bei der Mauseingabe festgestellt: Da es kein "No-Mouse-Movement"-Event gibt, bleibt der letzte Wert
  der Mausbewegung im jeweiligen Axis-Objekt stehen. Da in der Update-Routine nun aber ständig der Wert gepollt wird,
  hört die Bewegung nicht auf sondern geht immer weiter (da ja deltaX != 0). Dies vernünftig zu lösen ist schwierig, da
  der Wert ja erst dann zurückgesetzt werden darf, nachdem er gelesen wurde (und falls mehrere lesen, geht es gar nicht).
  Im Moment setze ich daher den Wert von DeltaX, DeltaY und DeltaWheel nach der entsprechenden Get()-Methode zurück.
  Sobald wir nicht mehr pollen, sondern auf Events umgestellt haben, wird das Problem verschwinden, denn dann wird eben
  die Bewegungsroutine auch nur noch dann aufgerufen, wenn wirklich eine Mausnachricht aufgetreten ist, und nicht mehr einmal
  pro Update.
- DetectDevices() mit bReset=true noch etwas überarbeitet, nun müßten eigentlich alle devices neu erkannt und neue Objekte
  dafür in die Liste eingetragen werden. Eventuell sollte man das ganze später nochmal überarbeiten und vereinfachen,
  ich denke ich habe hier teilweise zu kompliziert gedacht :-)



>> 30.01.2008
[SB]
- Neues Input-System implementiert :-)
- Zur Zeit werden die Devices direkt verwendet - das soll später aber anders werden. Anstatt direkt auf Device
  zuzugreifen, soll dieser Zugriff dann über Handler laufen, die z.B. noch Dinge unterschiedlich konfigurieren
  können (z.B. die Sensitivität bei der Maus). Außerdem sollen diese Handler dann aktiviert oder deaktiviert werden
  können, später kann dann ein Fenster entsprechend den Input für seinen Szenengraphen so komplett deaktivieren
  und später wieder aktivieren. Das ist die bessere Lösung als früher, wo wir pro Frame ständig den Zeiger auf
  den aktuellen Input veränderten. 
- PLSample2DGame habe ich kurzzeitig als Test für PLInput mißbraucht - die Kanone kann nun mit Tastatur, Maus,
  Gamepad oder Joystick gespielt werden. Zum Testen bitte auf die Standard-Devices achten (DeviceManager::GetMouse()/GetKeyboard()),
  und evtl. umändern (z.B. "Keyboard0", "Mouse0").
