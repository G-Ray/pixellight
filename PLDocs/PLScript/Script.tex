\chapter{Script}




\section{Overview}
Because Lua is shipped with the official PixelLight SDK, this script language will be used within the examples. Please note that the PixelLight script API is script language independent. In fact, there's not even such a PixelLight script API. Everything that is connected to the RTTI of PixelLight can be accessed through script languages as long as the script backend has support for RTTI objects.

Within the PLCore documentation, there a lot of inside detail information on how the RTTI works. The script support itself is implemented within PLCore because scripting is heavily using PLCore features like the RTTI. Therefore adding script bindings or using RTTI objects within scripts is fairly straightforward and don't require the writing of thousands of proxy/wrapper classes exposing C++ functionality to script languages.

Certain non-RTTI parts of PixelLight are exposed to script languages through the loose plugin \emph{PLScriptBindings}. Please note that within PixelLight, scripting is completely optional, not mandatory - unlike some other engines out there were one is only able to use scripting. So, you can use scripting, but you are not forced to do so.

In general, the abstract script interface of PixelLight supports the following script features:
\begin{itemize}
\item{Global variables (with namespace support)}
\item{Global functions, C++ calls script and script calls C++ (with namespace support)}
\item{RTTI objects}
\end{itemize}

The access to RTTI objects makes the script support quite powerful and universal. You're able to access properties (constant RTTI class information), (variables within an object), methods (functions within an object), signals (aka events) and slots (aka event handlers).

Supported primitive data types are: \begin{quote}bool, float, double, int8, int16, int32, int64, uint8, uint16, uint32, uint64, PLCore::Object*, PLCore::Object\&\end{quote}

Please note that not each script language/API may make such a detailed data type distinction. Because strings are fundamental within scripts, PLGeneral::String is supported as well. But if you're a 100\% script programmer, without writing own new C++ components, the mentioned information is probably already too technically.

In general, the script support of PixelLight can be subdivided into the two following use-cases:
\begin{itemize}
\item{A C++ component is using an own script instance in a highly specialized way. The script scene node modifier is a good example for this. Such a script scene node modifier is is attached to a scene node and is adding logic trough a script.}
\item{A scripted stand-alone application, meaning that the complete application logic is implemented within for instance Lua and can be executed by PLViewer or custom applications. This doesn't mean that it's 100\% script only because the more complex stuff will probably done by used C++ components, but the wires are tied up by a script.}
\end{itemize}




\section{Namespaces}
\label{Script_Namespaces}
When a project is growing, one may run out of decent names or name conflicts happen by accident. Even if you're just starting a project and don't think that you'll end up with much source code you should consider to use namespaces right from the beginning. That's the reason why this section comes even before introducing for instance global variables.

Modern high-level computer languages support the concept of namespaces which, when used in the proper way, can help a developer with the naming task. An even bigger benefit in using namespaces is, that elements are grouped together. An editor may for example just look for global variables inside a namespace called \emph{PublicVariables} and make them visible and editable through a GUI while other internal script variables will be hidden. This way it's not required to \emph{extend} already existing, maybe even normed script languages like JavaScript (ECMA-262), by own constructs like a \emph{public}-modifier to denote that a script variable should be accessible to the outside world. Please note that this was just an example, within the PixelLight core there's nothing like \emph{PublicVariables} fixed build in.

While on the first look several script languages have no namespace support, they have so on the second look or they can at least be emulated. Let's take Lua as an example. Lua is a really compact language and many important features are missing within the core of the language... but on a deeper look they can be realized by using Lua's powerful and universal table concept. This is also true for namespaces.

When searching the internet for information how to do namespaces in Lua one often finds examples like seen in source~code~\ref{Code:GlobalVariablesWithinANamespace1}.
\begin{lstlisting}[float=htb,label=Code:GlobalVariablesWithinANamespace1,caption={Global variables within a namespace (1)}]
-- Create the "PublicVariables"-namespace
PublicVariables = {}
-- Create the variable "Health" within
-- the "PublicVariables"-namespace
PublicVariables.Health	= 42
-- Create the variable "Gold" within
-- the "PublicVariables"-namespace
PublicVariables.Gold	= 21
\end{lstlisting}
By writing \emph{PublicVariables = \{\}}, a new global variable named \emph{PublicVariables} is created and an empty table \emph{\{\}} is assigned to it. The name \emph{PublicVariables} is now addressing a Lua table. By writing \emph{PublicVariables.Health = 42} the table \emph{PublicVariables} gets a new entry with the key \emph{Health} and the value \emph{42}.

Personally, I don't like the style used in source~code~\ref{Code:GlobalVariablesWithinANamespace1}, it looks complicated. The result of source~code~\ref{Code:GlobalVariablesWithinANamespace2} is the same, but in my personal opinion it's more readable and reminds me at e.g. C++.
\begin{lstlisting}[float=htb,label=Code:GlobalVariablesWithinANamespace2,caption={Global variables within a namespace (2)}]
-- Create the "PublicVariables"-namespace
PublicVariables = {
	-- Create the variable "Health" within
	-- the "PublicVariables"-namespace
	Health	= 42,
	-- Create the variable "Gold" within
	-- the "PublicVariables"-namespace
	Gold	= 21,
}
\end{lstlisting}

When writing a script, it's probably a good idea to use such a \emph{public}-namespace to mark that those script content should be visible to e.g. an editor while other stuff is for internal purposes only. I hope you got the idea why using namespaces, even in scripts, is a good thing.




\section{Global variables}
There's nothing fancy about global variables, so this section is quite handy. When using Lua, just assign somewhere within your script, as seen in source~code~\ref{Code:GlobalVariables}, a value to a name and et voila, you've created a new global variable\footnote{Lua is loosely typed, the type of a variable depends on the value assigned to it and can be changed everytime by just assigning another value with another type to it}.
\begin{lstlisting}[float=htb,label=Code:GlobalVariables,caption={Global variables}]
halfTheTruth = 21
\end{lstlisting}




\section{Global functions}
[TODO]



source~code~\ref{Code:GlobalFunctions}
\begin{lstlisting}[float=htb,label=Code:GlobalFunctions,caption={Global functions}]
\end{lstlisting}




\section{Object-oriented programming (OOP)}
First at all, please note that this section has nothing to do with PixelLight RTTI objects which are explained in section~\ref{Script_RTTIObjects}.

Let's directly jump into the topic. The OOP Lua skeleton shown in source~code~\ref{Code:OOPSkeleton} has proofen to be useful.
\begin{lstlisting}[label=Code:OOPSkeleton,caption={Object-oriented programming (OOP) Lua skeleton}]
--[-------------------------------------------------------]
--[ Includes                                              ]
--[-------------------------------------------------------]
-- Include another Lua script
require("FilenameOfAnotherLuaScript")


--[-------------------------------------------------------]
--[ Classes                                               ]
--[-------------------------------------------------------]
--@brief
--  My Lua class
MyClass = {


	--[-------------------------------------------------------]
	--[ Public definitions                                    ]
	--[-------------------------------------------------------]
	--@brief
	--   Interaction mode
	Mode = {
		WALK = 0,	-- Walk mode
		FREE = 1,	-- Free mode
	},


	--@brief
	--  The default constructor - In Lua a static method
	new = function()


		--[-------------------------------------------------------]
		--[ Private class attributes                              ]
		--[-------------------------------------------------------]
		-- A private class attribute -> Emulates the C++ "this"-pointer by using a Lua table
		local this	= {}
		-- The current interaction mode
		local _mode	= Interaction.Mode.WALK


		--[-------------------------------------------------------]
		--[ Private class methods                                 ]
		--[-------------------------------------------------------]
		--@brief
		--  Very secret stuff is happening in this private method
		local function MyPrivateMethod()
			-- ...
		end


		--[-------------------------------------------------------]
		--[ Public class methods                                  ]
		--[-------------------------------------------------------]
		--@brief
		--  A public method
		function this.MyPublicMethod()
			-- ...
		end


		--[-------------------------------------------------------]
		--[ Public class constructor implementation               ]
		--[-------------------------------------------------------]
		-- ...


		-- Return the created class instance
		return this
	end


}
\end{lstlisting}
A new instance of this class can be created by writing \emph{myClassInstance = MyClass.new()} and methods can be used by writing \emph{myClassInstance.MyPublicMethod()}.

Wait a moment, the class definition within source~code~\ref{Code:OOPSkeleton} just looks like a namespace as described within \ref{Script_Namespaces}... and hey, Lua doesn't have OOP support at all!

That's true, Lua has no build in OOP support, but that's no reason to don't use OOP. It's possible to realize OOP by using, yes your guess was right, tables. Even information hiding is possible.

At this point you may possibly ask yourself: \begin{quote}''Why use OOP at all within a script? Shouldn't make a script language make the life of a programmer much easier? Why can't we just use variables and functions and be happy?''\end{quote} The answer is short: No one is forcing you to use OOP. If you're unformfortable or unfamiliar with OOP and don't want to get into the topic, then don't. If your scripted application gets bigger and you want a powerful tool to write well structured, reusable script code without a totally flooded global space due to tousends of global variables and functions, use the mentioned OOP approach. Personally, I wouldn't want to work without OOP because I'am a lazy person.




\section{RTTI objects}
\label{Script_RTTIObjects}
RTTI objects is were the scripting gets really interessting because it's possible to direcly access and manipulate PixelLight RTTI objects by using a script.


\subsection{Properties}
[TODO]
properties (constant RTTI class information)


\subsection{Attributes}
[TODO]
attributes (variables within an object)


\subsection{Methods}
[TODO]
methods (functions within an object)


\subsection{Signals}
[TODO]
signals (aka events)

There are two fixed build in script functions for signals:
\begin{itemize}
\item{Connect}
\item{Disconnect}
\end{itemize}




\subsection{Slots}
[TODO]
slots (aka event handlers)