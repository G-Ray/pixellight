\chapter{Script}




\section{Overview}
Because Lua is shipped with the official PixelLight SDK, this script language will be used within the examples. Please note that the PixelLight script API is script language independent. In fact, there's not even such a PixelLight script API. Everything that is connected to the RTTI of PixelLight can be accessed through script languages as long as the script backend has support for RTTI objects.

Within the PLCore documentation, there a lot of inside detail information on how the RTTI works. The script support itself is implemented within PLCore because scripting is heavily using PLCore features like the RTTI. Therefore adding script bindings or using RTTI objects within scripts is fairly straightforward and don't require the writing of thousands of proxy/wrapper classes exposing C++ functionality to script languages.

Certain non-RTTI parts of PixelLight are exposed to script languages through the loose plugin \emph{PLScriptBindings}. Please note that within PixelLight, scripting is completely optional, not mandatory - unlike some other engines out there were one is only able to use scripting. So, you can use scripting, but you are not forced to do so.

In general, the abstract script interface of PixelLight supports the following script features:
\begin{itemize}
\item{Global variables (with namespace support)}
\item{Global functions, C++ calls script and script calls C++ (with namespace support)}
\item{RTTI objects}
\end{itemize}

The access to RTTI objects makes the script support quite powerful and universal. You're able to access properties (constant RTTI class information), (variables within an object), methods (functions within an object), signals (aka events) and slots (aka event handlers).

Supported primitive data types are: \begin{quote}bool, float, double, int8, int16, int32, int64, uint8, uint16, uint32, uint64, PLCore::Object*, PLCore::Object\&\end{quote}

Please note that not each script language/API may make such a detailed data type distinction. Because strings are fundamental within scripts, PLGeneral::String is supported as well. But if you're a 100\% script programmer, without writing own new C++ components, the mentioned information is probably already too technically.

In general, the script support of PixelLight can be subdivided into the two following use-cases:
\begin{itemize}
\item{A C++ component is using an own script instance in a highly specialized way. The script scene node modifier is a good example for this. Such a script scene node modifier is is attached to a scene node and is adding logic trough a script.}
\item{A scripted stand-alone application, meaning that the complete application logic is implemented within for instance Lua and can be executed by PLViewer or custom applications. This doesn't mean that it's 100\% script only because the more complex stuff will probably done by used C++ components, but the wires are tied up by a script.}
\end{itemize}




\section{Namespaces}
\label{Script_Namespaces}
When a project is growing, one may run out of decent names or name conflicts happen by accident. Even if you're just starting a project and don't think that you'll end up with much source code you should consider to use namespaces right from the beginning. That's the reason why this section comes even before introducing for instance global variables.

Modern high-level computer languages support the concept of namespaces which, when used in the proper way, can help a developer with the naming task. An even bigger benefit in using namespaces is, that elements are grouped together. An editor may for example just look for global variables inside a namespace called \emph{PublicVariables} and make them visible and editable through a GUI while other internal script variables will be hidden. This way it's not required to \emph{extend} already existing, maybe even normed script languages like JavaScript (ECMA-262), by own constructs like a \emph{public}-modifier to denote that a script variable should be accessible to the outside world. Please note that this was just an example, within the PixelLight core there's nothing like \emph{PublicVariables} fixed build in.

While on the first look several script languages have no namespace support, they have so on the second look or they can at least be emulated. Let's take Lua as an example. Lua is a really compact language and many important features are missing within the core of the language... but on a deeper look they can be realized by using Lua's powerful and universal table concept. This is also true for namespaces.

When searching the internet for information how to do namespaces in Lua one often finds examples like seen in source~code~\ref{Code:GlobalVariablesWithinANamespace1}.
\begin{lstlisting}[float=htb,label=Code:GlobalVariablesWithinANamespace1,caption={Global variables within a namespace (1)}]
-- Create the "PublicVariables"-namespace
PublicVariables = {}
-- Create the variable "Health" within
-- the "PublicVariables"-namespace
PublicVariables.Health	= 42
-- Create the variable "Gold" within
-- the "PublicVariables"-namespace
PublicVariables.Gold	= 21
\end{lstlisting}
By writing \emph{PublicVariables = \{\}}, a new global variable named \emph{PublicVariables} is created and an empty table \emph{\{\}} is assigned to it. The name \emph{PublicVariables} is now addressing a Lua table. By writing \emph{PublicVariables.Health = 42} the table \emph{PublicVariables} gets a new entry with the key \emph{Health} and the value \emph{42}.

Personally, I don't like the style used in source~code~\ref{Code:GlobalVariablesWithinANamespace1}, it looks complicated. The result of source~code~\ref{Code:GlobalVariablesWithinANamespace2} is the same, but in my personal opinion it's more readable and reminds me at e.g. C++.
\begin{lstlisting}[float=htb,label=Code:GlobalVariablesWithinANamespace2,caption={Global variables within a namespace (2)}]
-- Create the "PublicVariables"-namespace
PublicVariables = {
	-- Create the variable "Health" within
	-- the "PublicVariables"-namespace
	Health	= 42,
	-- Create the variable "Gold" within
	-- the "PublicVariables"-namespace
	Gold	= 21,
}
\end{lstlisting}

When writing a script, it's probably a good idea to use such a \emph{public}-namespace to mark that those script content should be visible to e.g. an editor while other stuff is for internal purposes only. The Lua script language does also have the concept of local variables by writing the keyword \emph{local} in front of the variable declaration (see section~\ref{Script_GlobalVariables} for details). Local variables are invisible to the C++ side, so, they can also be used to realize script internal variables.

I hope you got the idea why using namespaces, even in scripts, is a good thing.




\section{Global variables}
\label{Script_GlobalVariables}
There's nothing fancy about global variables, so this section is quite handy. When using Lua, just assign somewhere within your script, as seen in source~code~\ref{Code:GlobalVariables}, a value to a name and et voila, you've created a new global variable\footnote{Lua is loosely typed, the type of a variable depends on the value assigned to it and can be changed everytime by just assigning another value with another type to it}.
\begin{lstlisting}[float=htb,label=Code:GlobalVariables,caption={Global variables}]
-- Create the global variable "Health"
Health = 42
-- Create the global variable "Gold"
Gold = 21
\end{lstlisting}

Lua does also have the concept of local variables by writing the keyword \emph{local} in front of the variable declaration as seen within source~code~\ref{Code:LocalVariables}.
\begin{lstlisting}[float=htb,label=Code:LocalVariables,caption={Local variables}]
-- Create the global variable "Health"
Health = 42
-- Create the local variable "Gold"
local Gold = 21
\end{lstlisting}
From the C++ side, it's possible to interact with global variables while local variables can not be seen. So, while the C++ side can access your global variable \emph{Health}, it can't access your local variable \emph{Gold}.

\paragraph{Global variables added by the C++ host}
The C++ side is also able to create new, or to delete existing global variables. Whether or not this is in general useful is up to you. PixelLight components using scripts dynamically add a global variable named \emph{this} pointing back to the script calling RTTI object. If you want to know more about the global \emph{this} variable, have a look into section~\ref{Script_RTTIObjects}.





\section{Global functions}
\label{Script_GlobalFunctions}
As soon as your script grows over a hand full of source code lines, the need for function arises. Within Lua, global functions look as seen in source~code~\ref{Code:GlobalFunctions}.
\begin{lstlisting}[float=htb,label=Code:GlobalFunctions,caption={Global functions}]
function MyFunction()
	-- ... do some fancy stuff...
end
\end{lstlisting}
The global function \emph{MyFunction} can then be called by writing \emph{MyFunction()}.

From the C++ side, it's possible to interact with global function. Such global functions are usually used as script entry points and typical names for such global functions used as entry points are \emph{OnInit}, \emph{OnUpdate} and \emph{OnDeInit} which are called after as script has been loaded, when a script should perform an update step and shortly before a script is going to die. Please note that this was only an example of the naming convention used within PixelLight. Within the script system there are no such fixed build in names and you're free to choose your own entry point names. But in general, it makes the life easier to always use the same function names for the same purpose.


\paragraph{Global functions added by the C++ host}
Beside writing own global functions directly within the script, the C++ side is able to add global function during runtime to expose stuff written in C++ to the script. This allows a script to communicate with it's C++ host. In general, global functions added by C++ should be kept to a bare minimum because they introduct script initialization cost and also trash the global script namespace, altough there's namespace support to reduce the propabiliy of name conflicts. A far more advanced, universal and powerful way of exposing C++ stuff to the script is by using RTTI objects as discussed in section~\ref{Script_RTTIObjects}. Within the Lua script backend, the RTTI object approach is not adding script initialization cost.


\paragraph{Functions used as callbacks}
Just calling global function directly is not the only possible way to use them. Global functions can also be used as slots, meaning that when the signal they are connected with is emitted, the global function is called. Please note that this is also true for local functions, local functions can be used as slots as well. See section~\ref{Script_RTTIObjects_Signals} for information about signals and section~\ref{Script_RTTIObjects_Slots} for details about slots.

As seen within the following source~code~\ref{Code:VariableWithAFunctionAsValue}, within Lua it's also possible to use a function as a value of a variable.
\begin{lstlisting}[float=htb,label=Code:VariableWithAFunctionAsValue,caption={Variable with a function as value}]
function MyFunction()
	-- ... do some fancy stuff...
end
myVariable = MyFunction
\end{lstlisting}
Therefore, a function can also be used as callback, name it \emph{slot} if you want. This way, a function pointer can be passed around within your script which can become really handy. Imagine that there's a movie script which accepts such a function pointer as parameter. As soon as the movie playback has been finished this given function is called. The script which is using the movie script can then react on this signal/event and change for instance into an interactive mode. Source~code~\ref{Code:FunctionAsCallback} summes this up.
\begin{lstlisting}[float=htb,label=Code:FunctionAsCallback,caption={Function as callback}]
function MyCallbackFunction()
	-- ... do some fancy stuff...
end

function MyMovie(callbackFunction)
	-- ... do some fancy stuff...

	-- Movie playback has been finished
	if callbackFunction ~= nil then
		callbackFunction()
	end
end

-- Playback a movie
MyMovie(MyCallbackFunction)
\end{lstlisting}




\section{Object-oriented programming (OOP)}
First at all, please note that this section has nothing to do with PixelLight RTTI objects which are explained in section~\ref{Script_RTTIObjects}.

Let's directly jump into the topic. The OOP Lua skeleton shown in source~code~\ref{Code:OOPSkeleton} has proofen to be useful.
\begin{lstlisting}[label=Code:OOPSkeleton,caption={Object-oriented programming (OOP) Lua skeleton}]
--[-------------------------------------------------------]
--[ Includes                                              ]
--[-------------------------------------------------------]
-- Include another Lua script
require("FilenameOfAnotherLuaScript")


--[-------------------------------------------------------]
--[ Classes                                               ]
--[-------------------------------------------------------]
--@brief
--  My Lua class
MyClass = {


	--[-------------------------------------------------------]
	--[ Public definitions                                    ]
	--[-------------------------------------------------------]
	--@brief
	--   Interaction mode
	Mode = {
		WALK = 0,	-- Walk mode
		FREE = 1,	-- Free mode
	},


	--@brief
	--  The default constructor - In Lua a static method
	new = function()


		--[-------------------------------------------------------]
		--[ Private class attributes                              ]
		--[-------------------------------------------------------]
		-- A private class attribute -> Emulates the C++ "this"-pointer by using a Lua table
		local this	= {}
		-- The current interaction mode
		local _mode	= Interaction.Mode.WALK


		--[-------------------------------------------------------]
		--[ Private class methods                                 ]
		--[-------------------------------------------------------]
		--@brief
		--  Very secret stuff is happening in this private method
		local function MyPrivateMethod()
			-- ... do some fancy stuff...
		end


		--[-------------------------------------------------------]
		--[ Public class methods                                  ]
		--[-------------------------------------------------------]
		--@brief
		--  A public method
		function this.MyPublicMethod()
			-- ... do some fancy stuff...
		end


		--[-------------------------------------------------------]
		--[ Public class constructor implementation               ]
		--[-------------------------------------------------------]
		-- ... do some fancy stuff...


		-- Return the created class instance
		return this
	end


}
\end{lstlisting}
A new instance of this class can be created by writing \emph{myClassInstance = MyClass.new()} and methods can be used by writing \emph{myClassInstance.MyPublicMethod()}.

Wait a moment, the class definition within source~code~\ref{Code:OOPSkeleton} just looks like a namespace as described within \ref{Script_Namespaces}... and hey, Lua doesn't have OOP support at all!

That's true, Lua has no build in OOP support, but that's no reason to don't use OOP. It's possible to realize OOP by using, yes your guess was right, tables. Even information hiding is possible.

At this point you may possibly ask yourself: \begin{quote}''Why use OOP at all within a script? Shouldn't make a script language make the life of a programmer much easier? Why can't we just use variables and functions and be happy?''\end{quote} The answer is short: No one is forcing you to use OOP. If you're unformfortable or unfamiliar with OOP and don't want to get into the topic, then don't. If your scripted application gets bigger and you want a powerful tool to write well structured, reusable script code without a totally flooded global space due to tousends of global variables and functions, use the mentioned OOP approach. Personally, I wouldn't want to work without OOP because I'am a lazy person.




\section{RTTI objects}
\label{Script_RTTIObjects}
RTTI objects is were the scripting gets really interessting because it's possible to direcly access and manipulate PixelLight RTTI objects by using a script. Within the Lua script backend, RTTI objects are realized by using the \emph{user data} feature of Lua. Whenever Lua is not able to resolve for instance a function call, this request is redirected into the script backend implementation which is then accessing the RTTI system of PixelLight.

\paragraph{this}
PixelLight components using scripts dynamically add a global variable named \emph{this} pointing back to the script calling RTTI object. Of course, the type of the RTTI object depends on the use-case. For example when running a scripted stand-alone application by using \emph{PLViewer}, \emph{this} points to an instance of the \emph{PLEngine::ScriptApplication} RTTI class. Another example would be the script scene node modifier called \emph{PLScriptBindings::SNMScript} where \emph{this} points to an instance of \emph{PLScriptBindings::SNMScript}. All RTTI objects are derived from the base class \emph{PLCore::Object} and therefore share a common featue set. To check the RTTI object type just write within a Lua script \emph{myRTTIObject:IsInstanceOf("PLEngine::ScriptApplication")} in order to figure out whether the RTTI object you currently dealing with is an instance of \emph{PLEngine::ScriptApplication}. In case you've wondered why it's called \emph{this} and not \emph{self} as it's commonly named in Lua scripts: The answer is that PixelLight is using a generic script language independent script interface. Components like \emph{PLEngine::ScriptApplication} or \emph{PLScriptBindings::SNMScript} don't use e.g. Lua directly, they're only using the generic script language independent script interface. Not every script language is using \emph{self} to identify \emph{this instance}. PixelLight itself is writtin in C++, so the name \emph{this} was obviously a better choice then \emph{self} becaues this way, there are not to many different names descriping one and the same concept.


\subsection{Properties}
[TODO]
properties (constant RTTI class information)


\subsection{Attributes}
[TODO]
attributes (variables within an object)


\subsection{Methods}
[TODO]
methods (functions within an object)


\subsection{Signals}
\label{Script_RTTIObjects_Signals}
[TODO]
signals (aka events)

Within a script, signals can be connected to an RTTI object slot or to a global function (section~\ref{Script_GlobalFunctions} for details) with then is used as a script slot.

There are two fixed build in script functions for signals:
\begin{itemize}
\item{Connect}
\item{Disconnect}
\end{itemize}




\subsection{Slots}
\label{Script_RTTIObjects_Slots}
[TODO]
slots (aka event handlers)