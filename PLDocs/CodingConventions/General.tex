\chapter{General}




\section{Foreword}
This documentation can't describe everything - because then you would spend more time in reading and rereading this document instead of actual programming. In here, we especially mention things that are important to us. The rest should be pretty self explanatory and it should be possible to \emph{find out} other style conventions by self. We strongly recommend you to spend time in writing clean code yourself to support the \emph{work flow}! It's not important HOW FAST you wrote the code, it's important that this code is well designed, well commented and cleanly written because you may use this code for a loonng time.\footnote{Belief us, at the time of writing we're working already 8 years on PixelLight and are always happy when there's no need to touch code again because it's just fine the way it is}




\section{Keep it simple!}
The world is complicated enough - if there are multiple solutions, prefer the simplest over the most complicated one! This way, the chances are high that other will understand the solution as well as you when looking at the code some years later.




\section{Encoding}
We work with multiple operation systems so we have to take into account \emph{how} text files are saved. All \emph{Diary}, \emph{Readme}, \emph{Todo} and \emph{Plan} text files saved as "Unicode (UTF-8 with signature) - Codepage 65001". All other text files like code or make files saved in classic \emph{ANSI}.




\section{Names}
In general, names of classes, functions, variables and so on must have human readable names. The name has to tell as much as possible about the usage - if the user can guess correctly the usage of for example a variable by just looking at it's name, the name is perfect.

General rules:

\begin{itemize}
\item A single character as name for local (only local!) control variables like \emph{i} within a for-loop is acceptable as long as there are not to much of those at once (else use reasonable names to avoid confusion!)
\item Short cuts should be avoided whenever possible because they may leads to confusion\footnote{True story: When using \emph{Rot} as short cut for \emph{Rotation}, we once had the situation that a German speaking programmer asked confused what the color \emph{Rot} should do inside the scene node... in German, \emph{Rot} is the word for \emph{red}...} (NO stuff like \emph{stricmp()}!)
\item If there's a \emph{commonly used} name for something, just this name instead of creating a totally new one
\item Avoid long names, if there's an expressive shorter name it's the preferred one... but keep the short cut rule in mind!
\end{itemize}

Classes, structures and so on have a upper case letter at the beginning. Example:

\begin{lstlisting}[caption=Name convention]
class Player {
};
struct Info {
};
\end{lstlisting}




\section{Prefix}
Because the readability of code is extremely important when working in a team and/or using code from others, one of our goals was to make the PixelLight code as readable and well structured as possible. We are using a name style convention.

Variable prefixes for standard types:

\begin{lstlisting}[caption=Variable prefixes for standard types]
Type               Prefix    Example
bool               b         bool bActive

(n for all none standard floating point types)
int                n         int  nNumber
char               n         char nCharacter
long               n         long nHuge

float              f
double             d

(Character arrays -> strings)
char[]             sz        char szName[64]
char*              psz       char *pszName

(Pointers)
*                  p         Player *pPlayer

(References)
&                  -         char &nTest = nTest2;

struct instance    s         Info sPlayer (struct Info)

class instance     c         Player cPlayer (class Player)
\end{lstlisting}

General variable prefix for class variables:
m\_ (m for member)\\
Example: char *m\_pszName\\

Variable prefixes for PixelLight types:

\begin{lstlisting}[caption=Variable prefixes for PixelLight types]
Type               Prefix    Example
String             s         String sName

Container          lst       List lstNames

Map                map       HashMap mapNames

VectorX            v         Vector3 vPosition
(X for dimension: 2, 3 or 4)

MatrixXxX          m         Matrix4x4 mRotation
(X for dimension: 3 or 4)

Quaternion         q         Quaternion qRotation

ColorX             c         Color3 cColor (same as class)
(X for dimension: 3 or 4)
\end{lstlisting}




\section{Postfix}
We recommend you to use the PixelLight name convention and marking debug versions with a \emph{D} at the end of the filename. Example: \emph{MyPlugins.dll} = release version, \emph{MyPluginsD.dll} = debug version.




\section{Namespaces}
PixelLight is using multiple namespaces, one for each sub-project. If you want to use for instance the string class which is defined in PLGeneral you need to do this:

\begin{lstlisting}[caption=Explicit namespace]
PLGeneral::String sMyString;
\end{lstlisting}

Or this:

\begin{lstlisting}[caption=Using namespace]
using namespace PLGeneral;
...
String sMyString;
\end{lstlisting}

Try to avoid using \emph{using namespace} too often or this will result in name conflicts which you then have to resolve by hand by adding for instance \emph{PLGeneral::}. We recommend to NEVER use \emph{using namespace} within header files!




\section{Events and signals}
As soon as an event is inside a class, we refer to it as \emph{signal}. As such, the prefix \emph{Event} like within \emph{EventKeyDown} is used outside classes while prefix \emph{Signal} like within \emph{SignalKeyDown} is used inside classes.




\section{Event handlers and slots}
Within our name convention for event handlers and RTTI slot names, there's a \emph{On} within for example \emph{OnMyEvent} indicating that this is a handler/slot method. The other part of the name consists of the name of the event/signal - for \emph{OnMyEvent} this would be an event/signal with the name \emph{MyEvent}.




\section{Dynamic parameters}
When dynamic parameters are used and the name of the parameters inside a string is irrelevant, as this is the case for \emph{PLCore::Params::FromString}, the parameters are named using \emph{Param<x>} were x starts with $0$ (example: \emph{Param0=1 Param1=''Hello''}).  




\section{Reuseability and adding new stuff}
Before you add new classes, functions an so on - check first whether there's already something similar within PixelLight. If there's something you can already use directly, use it instead of writing new stuff. If there's something quite similar, have a more detailed look at it and contact your team colleagues to discuss whether a refactoring is possible and reasonable to update and/or to enhance existing stuff.

Reuseability is one of the most important concepts when creating frameworks like PixelLight... and reuseability does NOT mean that it's possible to copy'n'past it and then hacking around for a certain project! Reuseability means that it's possible to directly reuse, to share, something between multiple projects in a quite universal way without the need to enhance and hack around constantly!




\section{Const correctness}
Define functions, variables etc. whenever possible to be constant. By giving the compiler this hint, it may be possible to use special optimizations or uncover bugs within the implementation.

There's one situation were we do not use \emph{const} - when dealing with function parameters because

\begin{lstlisting}[caption=Function parameters]
void MyFunction(int nVariable1, int nVariable2);
\end{lstlisting}

is inside headers better readable than

\begin{lstlisting}[caption=Constant function parameters]
void MyFunction(const int nVariable1, const int nVariable2);
\end{lstlisting}

In this situation, the readability is more important for us. This rule does not apply for pointer or reference parameters like

\begin{lstlisting}[caption=Constant function pointer/reference parameter]
void MyFunction(const String &sVariable);
\end{lstlisting}

because the user should be able to see whether or not a function is going to manipulate the parameter variable!
