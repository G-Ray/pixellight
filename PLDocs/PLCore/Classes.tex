\chapter{Classes, Modules And Plugins}
\label{Chapter:ClassesModulesAndPlugins}



\section{Classes}
\paragraph{Defining A New Class}
A RTTI class is always derived from \emph{PLCore::Object} either directly or by deriving from another RTTI class which is usually done within header files. The next step is to tell the RTTI about the class, this can be done by using the macros \emph{pl\_class} to initiate the RTTI class definition and \emph{pl\_class\_end} to conclude the RTTI class definition inside the C++ class. While \emph{pl\_class\_end} is parameterless, \emph{pl\_class} takes multiple parameters. The first parameter defines whether or not the RTTI class is currently exported or imported, more on this shortly. While the second macro parameter is the class name without namespace, the third parameter is the namespace the class is in as string - this way, the RTTI is able to know in which namespace the class is in. As fourth parameter you need to specify the class your new class is derived from, the namespace of this base class must also be provided - even if your new class is within the same namespace. The most basic RTTI class one can derive from is \emph{PLCore::Object}. The RTTI class definition is finished by a description of the class, by doing so, one can figure out through the RTTI what this class should be good for. Source~code~\ref{Code:RTTIClassDefinitionWithoutNamespace} shows how a basic RTTI class can be defined without a namespace, and source~code~\ref{Code:RTTIClassDefinitionWithNamespace} shows the same with namespace. More on namespaces will follow shortly.
\begin{lstlisting}[float=htb,label=Code:RTTIClassDefinitionWithoutNamespace,caption={Defining a new RTTI class without namespace}]
#include <PLCore/Base/Object.h>
class MyClass : public PLCore::Object {
	pl_class(MY_RTTI_EXPORT, MyClass, "", PLCore::Object, "Description of my RTTI class")
		pl_constructor_0(MyConstructor, "Default constructor", "")
	pl_class_end
};
\end{lstlisting}
\begin{lstlisting}[float=htb,label=Code:RTTIClassDefinitionWithNamespace,caption={Defining a new RTTI class with namespace}]
#include <PLCore/Base/Object.h>
namespace MyNamespace {
	class MyClass : public PLCore::Object {
		pl_class(MY_RTTI_EXPORT, MyClass, "MyNamespace", PLCore::Object, "Description of my RTTI class")
			pl_constructor_0(MyConstructor, "Default constructor", "")
		pl_class_end
	};
} // MyNamespace
\end{lstlisting}
Don't forget to define a constructor if you intent to instantiate the class. In the shown example, a default constructor was defined by using the \emph{pl\_constructor\_0} macro.  The zero the end of this macro means, that this constructor doesn't have any parameters - that's exactly what a default constructor is about. If there's no RTTI class constructor, you've defined an abstract class and it's not possible to create an instance of this class using the RTTI. Right now, we don't go into the details of this macro - for more information about RTTI class constructors, please have a look at section~\ref{ClassMembers:Constructor}. Because namespaces are quite important, especially for more extensive projects, we're referring from now on to the defined RTTI class \emph{MyNamespace::MyClass}.

The last thing do to is to implement the RTTI class using the \emph{pl\_implement\_class} macro. This is usually not done within the header but within the source code file as seen within source~code~\ref{Code:RTTIClassImplementation}.
\begin{lstlisting}[float=htb,label=Code:RTTIClassImplementation,caption={Implementing a new RTTI class}]
namespace MyNamespace {
	pl_implement_class(MyClass)
} // MyNamespace
\end{lstlisting}
If you forget to use \emph{pl\_implement\_class}, your class will not be available through the RTTI. Now you've defined your very own RTTI class that is ready to be used.

You should always ensure that the information given to \emph{pl\_class} is correct, check twice if necessary. If the base class defined within \emph{pl\_class} is not correct, the RTTI may be able to detect this - an compiler error is the result. For example \begin{quote}pl\_class(MY\_RTTI\_EXPORT, MyClass, "", MyClass, "Description of my RTTI class")\end{quote} results in a compiler error like \begin{quote}'initializing' : cannot convert from\\'PLCore::CheckBaseClassBool<Condition,Class,Base>::Error::\\ERROR\_Not\_A\_Base\_Class' to 'PLCore::CompileTimeError<false>'\end{quote}. This is a build in safety net - but we can't guarantee that this safety net is able to detect each and every possible error combination.


\paragraph{RTTI Class Export}
As promised within the RTTI class definition introduction, this paragraph describes the first parameter of the \emph{pl\_class} macro and it's background. Source~code~\ref{Code:RTTIClassDefinitionWithNamespace} defined a RTTI class by using \begin{quote}pl\_class(MY\_RTTI\_EXPORT, MyClass, "", PLCore::Object, "Description of my RTTI class")\end{quote}. In the shown example, \emph{MY\_RTTI\_EXPORT} is just a project dependent definition which is either $0$ or $1$. This is quite similar to the usual export and import you're using to export for example class methods so they can be used by other projects linked against your library. Usually, there's a main header file per project, in this main header file you define for example the project macros for export and import - in this file there may be something like the code shown within source~code~\ref{Code:RTTIClassExportDefinition}.
\begin{lstlisting}[float=htb,label=Code:RTTIClassExportDefinition,caption={RTTI class export definition}]
#ifdef MY_EXPORTS
	// To export RTTI elements
	#define MY_RTTI_EXPORT 1
#else
	// To import RTTI elements
	#define MY_RTTI_EXPORT 0
#endif
\end{lstlisting}
This means that if the \emph{MY\_EXPORTS} definition is set within the preprocessor definitions, the own project is currently compiled and therefore exports have to be performed. When using the compiled library, \emph{MY\_EXPORTS} is not set resulting in an import of previously exported features. For a complete example how such a project main header can look like, have a look into \emph{PLCore.h} which includes for example \emph{PLCoreWindows.h} if the project is currently compiled for the \emph{Microsoft Windows} platform.

When creating a project and you know that this project is only used as a dynamically loaded plugin and other developers don't have the header files of your project to access your shared library directly, you can use the \emph{pl\_rtti\_export} definition instead of defining an own one like \emph{MY\_RTTI\_EXPORT}. In practice this will look like \begin{quote}pl\_class(pl\_rtti\_export, MyClass, "", PLCore::Object, "Description of my RTTI class")\end{quote}.


\paragraph{Namespaces}
A RTTI class can be within no, one or multiple namespaces. The class interfaces offers methods to request the complete class name including namespace or just components like the class name without namespace. Source~code~\ref{Code:RTTIClassNamespaces} shows how a RTTI class within namespaces can be defined.
\begin{lstlisting}[float=htb,label=Code:RTTIClassNamespaces,caption={Using namespaces within the RTTI}]
#include <PLCore/Base/Object.h>
namespace MyNamespace1 {
namespace MyNamespace2 {
class MyClass : public PLCore::Object {
	pl_class(MY_RTTI_EXPORT, MyClass, "MyNamespace1::MyNamespace2", PLCore::Object, "RTTI class within namespaces")
		pl_constructor_0(MyConstructor, "Default constructor", "")
	pl_class_end
};
} // MyNamespace2
} // MyNamespace1
\end{lstlisting}
Please note that it's not required that the RTTI namespace the class is in is exactly the same as the real C++ namespace, but it's strongly recommended that the RTTI namespace matches the C++ namespace to avoid confusion.


\paragraph{Multiple Inheritance}
Multiple inheritance for RTTI classes is not supported. This would increase the complexity of the RTTI design and would lead to fault-prone situations as they also appear when using C++ in general. It's recommended to use for example the \emph{composite design pattern} instead.


\paragraph{Creating An Instance Of A RTTI Class}
In order to create an instance of a RTTI class, you first need to request the class description. This can be done using the method \emph{PLCore::ClassManager::GetClass} and a given class name including the namespace the class is in. If the requested class can't be found, for example because the class is within a currently not loaded plugin, a null pointer is returned. So, it's strongly recommended to always check for a null pointer in here. After you've received the RTTI class description, you're able to use the method \emph{PLCore::Class::Create} to create an instance of this class. This instantiation may fail if there's no, or no proper constructor within the class, so, you may want to check for a null pointer, too. Within the source~code~\ref{Code:RTTICreateClassInstance}, you can see the described process.
\begin{lstlisting}[float=htb,label=Code:RTTICreateClassInstance,caption={Creating an instance of a RTTI class}]
// Get RTTI class description
const PLCore::Class *pMyClass = PLCore::ClassManager::GetInstance()->GetClass("MyNamespace::MyClass");
if (pMyClass != nullptr) {
	// Create an instance of the RTTI class
	PLCore::Object *pMyObject = pMyClass->Create();
	if (pMyObject != nullptr) {
		// Cast the pointer to MyNamespace::MyClass
		MyNamespace::MyClass *pMyClassInstance = (MyNamespace::MyClass*)pMyObject;
	}
}
\end{lstlisting}
After you've created an instance of the class, it's usually safe to cast to the concrete class type, in this case \emph{MyNamespace::MyClass}. The object is destroyed by using the classic \emph{delete} of C++.

Sometimes it's important to ensure that a class is derived from a certain base class. For example, when adding a new scene node instance to a scene graph, it's strongly recommended that you ensure that the given RTTI class is really derived from the scene node base class - else an ugly accident may occur. Such a check can be performed by using the \emph{PLCore::Class:IsDerivedFrom} method as shown within source~code~\ref{Code:RTTIIsDerivedFrom}.
\begin{lstlisting}[float=htb,label=Code:RTTIIsDerivedFrom,caption={Ensure that a class is derived from a certain base class}]
// Get RTTI class description
const PLCore::Class *pMyClass = PLCore::ClassManager::GetInstance()->GetClass("MyNamespace::MyClass");
if (pMyClass != nullptr && pMyClass->IsDerivedFrom("MyBaseClass")) {
	// ... create an instance of the RTTI class and so on...
}
\end{lstlisting}
If you're just using the code parts presented in this chapter, the \emph{PLCore::Class:IsDerivedFrom} test within the example will fail because \emph{MyNamespace::MyClass} is not derived from \emph{MyBaseClass}.


\paragraph{Enumerating RTTI Classes}
The method \emph{PLCore::ClassManager::GetClasses} is the central RTTI class enumeration method. By using this method, one can for example request a list of all RTTI classes which are derived from another RTTI class. The method has several parameters which are used to control which RTTI classes will land within the filled RTTI class list. The source~code~\ref{Code:EnumeratingRTTIClasses} shows this method in action.
\begin{lstlisting}[float=htb,label=Code:EnumeratingRTTIClasses,caption={Enumerating RTTI classes}]
// Get all classes derived from PLCore::Object
PLGeneral::List<const PLCore::Class*> lstClasses;
PLCore::ClassManager::GetInstance()->GetClasses(lstClasses, "PLCore::Object", PLCore::NonRecursive, PLCore::NoBase, PLCore::IncludeAbstract);

// Iterate through the found classes
PLGeneral::Iterator<const PLCore::Class*> cIterator = lstClasses.GetIterator();
while (cIterator.HasNext()) {
	// Get the class
	const PLCore::Class *pClass = cIterator.Next();

	// ...
}
\end{lstlisting}
Within this example, a list of all classes derived from \emph{PLCore::Object} will be returned. Because \emph{PLCore::NonRecursive} was used, only classes directly derived from the given base class will be enumerated. The base class \emph{PLCore::Object} itself will not be within the resulting RTTI class list because the option \emph{PLCore::NoBase} was set. Due the use of the \emph{PLCore::IncludeAbstract} option, only RTTI classes which can be instanced will be listed - this means that within the resulting list, there will be no abstract classes.




\section{Modules And Plugins}
\paragraph{Defining A New Module}
A RTTI module is a unit like for example an executable or a shared library that contains RTTI content. There can only be one RTTI module per executable or a shared library. A module can either be a plugin or not. The term plugin means in this case that a module is not explicitly linked to the executable or to a used shared library and therefore not loaded automatically by the operation system on start-up. A RTTI module is defined by using RTTI macros as seen within source~code~\ref{Code:RTTIModuleDefinition}.
\begin{lstlisting}[float=htb,label=Code:RTTIModuleDefinition,caption={Defining a new RTTI module}]
#include <PLCore/ModuleMain.h>
pl_module("MyModule")
	pl_module_vendor("Copyright (C) 2002-2011 by Me")
	pl_module_license("LGPL")
	pl_module_description("Description of my module")
pl_module_end
\end{lstlisting}
It's recommended to do this within our main file so that you always have a fixed place were you put your module definitions in. Please note that this module definition is optional for your executable, even if you don't do it, you're still able to access your RTTI classes defined within the executable. But in general, we strongly recommend to always use the described module definition and at least provide the module information shown within the shown source~code~\ref{Code:RTTIModuleDefinition}. Module information in the form of strings can be provided by using the following macros:
\begin{itemize}
\item \textbf{pl\_module\_vendor} Information about the author of the module
\item \textbf{pl\_module\_license} Information about the license the module is using
\item \textbf{pl\_module\_description} A short description of the module
\item \textbf{pl\_module\_version} Version information, the version format is up to you
\item \textbf{pl\_module\_active} Defines the default active state of the project, if nothing is defined, a module will be active by default. Only relevant for plugins, if a plugin is deactivated, it's not loaded when using the PLCore plugin features.
\item \textbf{pl\_module\_dependencies\_\textless platform\textgreater\_\textless mode\textgreater} Enumeration of the external shared libraries this module depends on. This information is only for the user and it will not be used internally. \emph{\textless platform\textgreater} can be for example \emph{win32} or \emph{win64} describing dependencies for a \SI{32}{\bit} or \SI{64}{\bit} version of \emph{Microsoft Windows}. \emph{\textless mode\textgreater} can be \emph{release} or \emph{debug} for a release or debug version of the module.
\end{itemize}


\paragraph{Plugins}
PixelLight ships with dozens of plugins. Plugins are dynamically linked libraries of code that extend the capabilities of PixelLight and your application and handled within the RTTI system as simple modules. As mentioned before, there are two types of modules, executable or shared library. While source~code~\ref{Code:RTTIModuleDefinition} defines an executable module, source~code~\ref{Code:RTTIModulePluginDefinition} defines a shared library - or short: A plugin.
\begin{lstlisting}[float=htb,label=Code:RTTIModulePluginDefinition,caption={Defining a new RTTI module plugin}]
#include <PLCore/ModuleMain.h>
pl_module_plugin("MyPlugin")
	pl_module_vendor("Copyright (C) 2002-2011 by Me")
	pl_module_license("LGPL")
	pl_module_description("Description of my plugin")
pl_module_end
\end{lstlisting}
As you can see, the only difference within the definition is the usage of \emph{pl\_module\_plugin} instead of \emph{pl\_module}. While the module definition is optional for the executable, it's required for shared libraries. If \emph{pl\_module\_plugin} wasn't used, the RTTI features defined within the shared libraries can't be used.

The PixelLight plugin system, which comes with the RTTI for free, is one of the the most important part of the PixelLight SDK because many PixeLight components are just such plugins. Not only objects like actors or lights are plugins, even things like a load screen can be a plugin! You will spend the most time in programming different plugins. Therefore the framework offers a huge amount of RTTI functions for all the necessary tasks. Further each RTTI class has a set of exported attributes which can be manipulated from outside. Through the plugin system, components are not limited to a single project. You can also write shared libraries in which your scene nodes classes are. Scene nodes are a good sample to show how plugins will increase your reuseability. Using this technique it's possible to develop different scene nodes like particle groups one time and then be able to use them in each other project by copying the written shared library into the project folder instead of coping the source codes. The framework will automatically detect this scene node plugin and will be able to use this scene node classes. This also offers you a real-time edit meaning you can manipulate scene nodes while the application is running! Also the editors take advantage of this system because you are able to see how the scene node looks when changing different attributes \ldots it enables e.g. quite comfortable particle group tweaking. Sometimes it's the best to program project relevant plugins direct in your project. (exe for Microsoft Windows) But note that you are NOT able to access this plugin classes outside your application.

The shared library of each plugin comes with a \emph{plugin}-file, a XML file which contains general informations about the plugin. Methods like \emph{PLCore::ClassManager::ScanPlugins} will just look for those files, and will not touch the shared libraries directly. This has the advantage that shared libraries are only loaded if they are referenced within an activated \emph{plugin}-file. This XML files can, and should be created automatically by using the \emph{PLProject} tool which is a part of the PixelLight SDK. This tool will look through the source codes of your projects and search for, for example \emph{pl\_module} RTTI macros. Usually this tool should be launched automatically when you compile your program, by using this approach it's ensured that the \emph{plugin}-file is always up-to-date. When using \emph{Microsoft Visual Studio 2010}, \emph{PLProject} can be launched within a so called \emph{Post-Build-Event} by using for instance the command line option
\begin{verbatim}
..\Runtime\PLProject.exe . --output-path Bin\Plugins --write-plugin
\end{verbatim}
The resulting XML file may look like
\begin{verbatim}
<?xml version="1.0" ?>
<Plugin Version="1" PixelLightVersion="PixelLight 0.9.4-R1">
  <Active>1</Active>
  <Name>MyPlugin</Name>
  <Version>1.0</Version>
  <Vendor>Copyright (C) 2002-2011 by Me</Vendor>
  <License>LGPL</License>
  <Description>Description of my plugin</Description>
  <Platform Name="Win32">
    <Library Type="Release">TheOtherOne.dll</Library>
    <Library Type="Debug">TheOtherOneD.dll</Library>
  </Platform>
</Plugin>
\end{verbatim}

As source~code~\ref{Code:RTTIScanPlugins} shows, it's quite simple to scan for RTTI plugins and adding them to the running system. After this step, they are ready to be used.
\begin{lstlisting}[float=htb,label=Code:RTTIScanPlugins,caption={Scanning for RTTI plugins to add}]
PLGeneral::String sDirectory = PLGeneral::System::GetInstance()->GetCurrentDir() + "/MyPlugins";
PLCore::ClassManager::GetInstance()->ScanPlugins(sDirectory);
\end{lstlisting}


\paragraph{Class Name Conflicts}
Multiple classes within different modules, but with the same class name - don't do this. The RTTI will register all classes correctly, but then, it's not possible to access all those classes with the same name by using for example \emph{PLCore::ClassManager::GetClass}. That's one of the reasons why you should always work with namespaces, this will reduce the probability that this name conflict situation will arise. It there's a RTTI class name conflict, the class manager will write a warning into the log like
\begin{quote}[Warning]: Class 'MyClass' [module 'MyFirstModule']: Name conflict with already registered class 'MyClass' [module 'MySecondModule']\end{quote}.


\paragraph{Accessing The Current Module}
To access the current executed module you can use the macro \emph{pl\_current\_module\_id} ( just a short cut for \emph{PLCore::ModuleID<int>::GetModuleID} to request the ID of this module. This module ID can then be used to request a pointer to this module by using \emph{PLCore::ClassManager::GetModule}. The following source~code~\ref{Code:CurrentDirectoryToCurrentModuleDirectory} shows how this can be used to set the current directory to the one the current module is in.
\begin{lstlisting}[label=Code:CurrentDirectoryToCurrentModuleDirectory,caption={Setting the current directory to the one the current module is in}]
// Includes
#include <PLGeneral/File/Url.h>
#include <PLGeneral/System/System.h>
#include <PLCore/Base/Rtti.h>
#include <PLCore/Base/Module.h>
#include <PLCore/Base/ClassManager.h>

// ...

// Get the ID of the current module
const PLGeneral::uint32 nModuleID = pl_current_module_id();

// Get RTTI module instance
const PLCore::Module *pModule = PLCore::ClassManager::GetInstance()->GetModule(nModuleID);
if (pModule != nullptr) {
	// Get the absolute filename of the module [TODO] Currently an empty string is returned
	const PLGeneral::String sAbsModuleFilename = pModule->GetFilename();

	// Get the absolute filename of the directory the module is in
	const PLGeneral::String sAbsModuleDirectory = PLGeneral::Url(sAbsModuleFilename).CutFilename();

	// Use the module directory as the current directory
	PLGeneral::System::GetInstance()->SetCurrentDir(sAbsModuleDirectory);
}
\end{lstlisting}




\section{Class Members}
The RTTI class consists of the fundamental components, variables, functions, events and event handler, described within the introduction - but with a terminology that fit's to the class context.



\subsection{Attribute}
In C++, variables inside a class are called \emph{attribute}, for the RTTI, we're using the same terminology.


\paragraph{Overview Of RTTI Class Attributes}
Within this paragraph, just a short first overview of RTTI class attribute should be provided so you can make your first steps without reading the whole section. The topic about class members is more extensive, therefore, details are discussed after this preview. Let's jump directly into a code sample without so much introduction. Have a look at source~code~\ref{Code:RTTIClassWithAttributes}.
\begin{lstlisting}[float=htb,label=Code:RTTIClassWithAttributes,caption={Defining a new RTTI class with attributes}]
// Class definition of MyClass
#include <PLCore/Base/Object.h>
class MyClass : public PLCore::Object {

	// RTTI interface
	pl_class(MY_RTTI_EXPORT, MyClass, "", PLCore::Object, "Description")
		pl_constructor_0(MyConstructor, "Default constructor", "")
		pl_attribute(MyInt, int, 10, ReadWrite, DirectValue, "Simple integer", "")
		pl_attribute(MyFloat, float, 3.1415f, ReadOnly, DirectValue, "PI", "")
	pl_class_end

	// Default constructor
	public:
		MyClass() : MyInt(this), MyFloat(this) {}

};

// MyClass RTTI implementation (not done within headers)
pl_implement_class(MyClass)
\end{lstlisting}
This code sample defines a RTTI class with the name \emph{MyClass} that is within no namespace. A default constructor is provided by using \emph{pl\_constructor\_0}, as a result, it's possible to instance the class without any parameters. By using the RTTI macro \emph{pl\_attribute} two attributes are added to the class. The first attribute has the name \emph{MyInt} and is an integer with a default value of \emph{10}. This attribute can be read and written (\emph{ReadWrite} setting) directly without the need to use special methods, just like if they were normal primitive public C++ attributes - this is implied by the \emph{DirectValue} setting. The last two parameters provide a description of the attribute and some additional optional attribute annotation - have a look at appendix~\ref{Appendix:RTTIAnnotations} for more information about annotations. The second attribute, \emph{MyFloat}, is a floating point attribute and is defined as read-only, any attempt to change this attribute will fail. The primitive data type attributes are actually objects and their constructor needs a pointer back to their owner object. In the example, this is done within the default constructor by using \emph{MyInt(this)} and \emph{MyFloat(this)}.

Now that you have a RTTI class with attributes, you're able to instantiate the class and access their attributes as shown within source~code~\ref{Code:RTTIUsingClassAttributes}.
\begin{lstlisting}[label=Code:RTTIUsingClassAttributes,caption={Using RTTI class attributes}]
// Get RTTI class description
const PLCore::Class *pMyClass = PLCore::ClassManager::GetInstance()->GetClass("MyClass");
if (pMyClass != nullptr) {
	// Create an instance of the RTTI class
	MyClass *pMyObject = (MyClass*)pMyClass->Create();
	if (pMyObject != nullptr) {
		// Get the current attribute value, nCurrentValue has now the value 10
		int nCurrentValue = pMyObject->MyInt;

		// Is MyInt currently set to it's default value?
		bool bIsDefaultBefore = pMyObject->MyInt.IsDefault();

		// Set a new attribute value, MyInt has now the value 42
		pMyObject->MyInt = 42;

		// Is MyInt currently set to it's default value?
		bool bIsDefaultAfter = pMyObject->MyInt.IsDefault();

		// Read back the current MyInt value, should be 42 now
		nCurrentValue = pMyObject->MyInt;

		// Try to set a read-only attribute...
		pMyObject->MyFloat = 42.0f;

		// ... MyFloat still has the value 3.1415
		float fCurrentValue = pMyObject->MyFloat;

		// Cleanup
		delete pMyObject;
	}
}
\end{lstlisting}
As mentioned before, the RTTI class attributes are actually objects - even if they can be used as if they were primitive data types. Therefore, methods from, for example the attribute \emph{MyInt}, can be called to check for instance whether or not the attribute has currently the defined default value. In the example above, this default value could be requested by using \begin{quote}int nDefaultValue = pMyObject->MyInt.Default();\end{quote} or by using \begin{quote}PLGeneral::String sDefaultValue = pMyObject->MyInt.GetDefault();\end{quote} to get the default value as generic string.

Although \emph{MyInt} can nearly be used as if it were just an usual primitive C++ data type, writing something like \begin{quote}pMyObject->MyInt += 42;\end{quote} would result in a compiler error like \begin{quote}error C2676: binary '+=' : 'MyClass::MyInt\_Attr' does not define this operator or a conversion to a type acceptable to the predefined operator\end{quote} because operators like \emph{+=} are not implemented within \emph{PLCore::DynVar}. If you want to write the previously shown, write \begin{quote}pMyObject->MyInt = pMyObject->MyInt + 42;\end{quote} instead. Another practical solution would be, to get the value by using for example \begin{quote}int nValue = pMyObject->MyInt;\end{quote}, then working on in this case \emph{nValue} and if your done writing down the result by using for instance \begin{quote}pMyObject->MyInt = nValue;\end{quote}.

A copy of the actual C++ variable can be received through the method \emph{PLCore::DynVar::Get} and set by using \emph{PLCore::DynVar::Set}. For example \begin{quote}int nValue = pMyObject->MyInt.Get();\end{quote} gives you a copy of the real integer instance. This way you can still access data types, even if \emph{PLCore::DynVar} provides no access to it because it's for example an user defined RTTI data type as presented within appendix~\ref{Appendix:UserDefinedRTTIDataType}. Please note that the mentioned getter method returns a copy, not a reference to the actual internal C++ variable instance. As a result, when changing the returned variable by using for example \begin{quote}pMyObject->MyInt.Get() = 5;\end{quote}, the actual \emph{MyInt} content is not changed and instead the compiler will probably output an error like \begin{quote}error C2106: '=' : left operand must be l-value\end{quote}. Another invalid use case of \emph{PLCore::DynVar::Get} would be \begin{quote}const int \&GetMyIntReference() { return MyInt.Get(); }\end{quote} - the compiler will probably output a warning like \begin{quote}warning C4172: returning address of local variable or temporary\end{quote} because the copy of the variable received by \emph{MyInt.Get()} is a local one which is stored on the C++ runtime stack, and returning a reference or a pointer to a local variable is definitely no good idea. Have a look into the \emph{PLCore::DynVar} header to see the functionality you can use. You've probably got the idea how to work with RTTI classes and attributes.


\paragraph{Directly Accessing Attributes}
The previous paragraph already showed how attributes of a RTTI class can be used as if they where just primitive C data types. One big advantage, which makes the usage of RTTI class attributes quite powerful is, that attributes can also be accessed by just using their name as string. This form of direct access is provided by the method \emph{PLCore::Object::SetAttribute}, the counterpart of \emph{PLCore::Object::GetAttribute} which returns a \emph{PLCore::DynVar} pointer to the requested attribute. A list of all available attributes can be received by using the \emph{PLCore::Object::GetAttributes} method. To set attribute values by using an attribute name is quite simple, so just jump into the source~code~\ref{Code:RTTIUsingClassAttributesWithGetAttribute} to show how this works in practice.
\begin{lstlisting}[float=htb,label=Code:RTTIUsingClassAttributesWithGetAttribute,caption={Using RTTI class attributes with the PLCore::Object::SetAttribute method}]
// Get RTTI class description
const PLCore::Class *pMyClass = PLCore::ClassManager::GetInstance()->GetClass("MyClass");
if (pMyClass != nullptr) {
	// Create an instance of the RTTI class
	MyClass *pMyObject = (MyClass*)pMyClass->Create();
	if (pMyObject != nullptr) {
		// Set MyInt to 42
		pMyObject->SetAttribute("MyInt", "42");

		// Set MyInt to 24
		pMyObject->SetAttribute("MyInt", &PLCore::Var<int>(24));

		// Cleanup
		delete pMyObject;
	}
}
\end{lstlisting}
Within the example, the first usage of \emph{PLCore::Object::SetAttribute} not only specified the attribute by using a string, the attribute value to set was also provided by just a simple string. While it may be quite generic to set attribute values by using strings, this introduces also risks because someone may call \begin{quote}pMyObject->SetAttribute("MyInt", "Bob");\end{quote} which is just wrong and you can be sure that the referred integer attribute is not set to the string value ''Bob''. The second usage of \emph{PLCore::Object::SetAttribute} gave the method the attribute value in form of a \emph{PLCore::DynVar}\footnote{\emph{PLCore::Var} is derived from \emph{PLCore::DynVar}} instance. Internally, if the given value type doesn't match the real attribute type, the value is converted as well - this automatic conversion may produce the desired result or not.

The default value of an attribute can be received by using \emph{PLCore::Object::GetAttribute} which returns a \emph{PLCore::DynVar} pointer to the requested attribute, and then
calling the \emph{PLCore::DynVar::GetDefault} method. Because at this abstraction level the attribute type is not known to the compiler, this method will return the default value as string. By using \emph{PLCore::Object::SetAttributeDefault} an attribute given by it's name can be set to it's default value in a comfortable way. If all attributes should be set to their default values at once, the \emph{PLCore::Object::SetDefaultValues} method will do the job.


\paragraph{Accessing Attributes By Using Getter And Setter Methods}
Within the introduction paragraph at the beginning of this section, the option \emph{DirectValue} was used as parameter of the RTTI macro \emph{pl\_attribute} - this enabled unrestricted C++ like public access to the attribute. Sometimes, it's desired to restrict the access to attributes or to be informed when the attribute is going to be read or written to. An example for read notification would be the usage of an \emph{lazy evaluation} scheme, that means that before a correct value can be returned, the internal value may need to be recalculated first as soon as it's accessed. The same example can be applied to write notification - if an attribute has been changed from outside, other implementation internal values may need an immediate or delayed update, too. A reason for restricting the write access may be, that some value settings may not be valid. For instance, if an object is part of a collection of objects, and every of this objects is required to have an unique name, the setter method may check whether or not the new name, the object should be set to, is already used by another object of the collection. Further, if the situation occurs that in the described example there's a name conflict, the setter method may manipulate the new name to set in order to make it conflict free, or reject the new name completely. As a result, if an attribute was defined with the option \emph{GetSet}, a read access to the attribute may not return the same value you just set the attribute to. Actually, it's even not guaranteed that either the getter nor the setter method will do anything, because it's completely implementation dependent what this implemented methods really do. This means that your attribute, defined with the option \emph{GetSet}, doesn't refer directly to a real attribute but only to a getter and a setter C++ method. If you've defined an attribute with the name \emph{MyInt} of type \emph{int} and the option \emph{GetSet}, there must be a getter C++ method with the name \emph{GetMyInt} returning an \emph{int}, and a setter C++ method with the name \emph{SetMyInt} accepting a \emph{int} as parameter. Whether or not, for example the setter method looks like \begin{quote}void SetMyInt(int nValue);\end{quote} or \begin{quote}void SetMyInt(const int \&nValue);\end{quote} or even \begin{quote}bool SetMyInt(const int \&nValue);\end{quote} is up to you. Read and write requests on the attribute will be redirected into these C++ methods. The C++ methods can be \emph{public}, \emph{protected} or \emph{private}. For the RTTI, this doesn't make any difference - but we recommend to make this methods always \emph{public} because through the RTTI, they are public accessible anyway. Whether or not this C++ methods are defined as constant, is up to you and has no direct influence on the RTTI. The getter and setter C++ methods can be virtual as well, which can be helpful as well.

The third parameter of the \emph{pl\_attribute} RTTI macro representing the default value, and the fourth parameter representing the access mode still have an effect when using the option \emph{GetSet}. When using \emph{PLCore::Object::IsDefault}, the getter method is called internally to compare the \emph{current value} with the defined \emph{default value}. When the attribute was defined as read-only by using \emph{ReadOnly}, the setter method is never called.

Source~code~\ref{Code:RTTIGetSetAttributeDefinition} shows the told in practice.
\begin{lstlisting}[label=Code:RTTIGetSetAttributeDefinition,caption={Defining an RTTI class attribute using getter and setter methods}]
// Class definition of MyClass
#include <PLCore/Base/Object.h>
class MyClass : public PLCore::Object {

	// RTTI interface
	pl_class(MY_RTTI_EXPORT, MyClass, "", PLCore::Object, "Description")
		pl_constructor_0(MyConstructor, "Default constructor", "")
		pl_attribute(MyInt, int, 42, ReadWrite, GetSet, "Simple integer", "")
	pl_class_end

	// Public methods
	public:
		MyClass() : MyInt(this), m_nMyInt(10) {}
		int GetMyInt() const { return m_nMyInt; }
		void SetMyInt(int nValue) { m_nMyInt = nValue; };

	// Private data
	private:
		int m_nMyInt;

};

// MyClass RTTI implementation (not done within headers)
pl_implement_class(MyClass)
\end{lstlisting}
The usage of getter and setter methods has no real benefits in here, but it's good for demonstrating the concept. When comparing source~code~\ref{Code:RTTIUsingClassAttributes} accessing an \emph{DirectValue} attribute with source~code~\ref{Code:RTTIGetSetAttributeUsage} accessing an \emph{GetSet} attribute, you will notice that when accessing a RTTI class attribute through the RTTI, there's no difference between the \emph{DirectValue} and \emph{GetSet} option. The user of the class doesn't care about the implementation details of the class and doesn't have to.
\begin{lstlisting}[label=Code:RTTIGetSetAttributeUsage,caption={Accessing an RTTI class attribute using getter and setter methods}]
// Get RTTI class description
const PLCore::Class *pMyClass = PLCore::ClassManager::GetInstance()->GetClass("MyClass");
if (pMyClass != nullptr) {
	// Create an instance of the RTTI class
	MyClass *pMyObject = (MyClass*)pMyClass->Create();
	if (pMyObject != nullptr) {
		// Get the current attribute value, nCurrentValue has now the value 10
		int nCurrentValue = pMyObject->MyInt;

		// Is MyInt currently set to it's default value?
		bool bIsDefaultBefore = pMyObject->MyInt.IsDefault();

		// Set a new attribute value, MyInt has now the value 42
		pMyObject->MyInt = 42;

		// Is MyInt currently set to it's default value? Is 'true'.
		bool bIsDefaultAfter = pMyObject->MyInt.IsDefault();

		// Read back the current MyInt value, should be 42 now
		nCurrentValue = pMyObject->MyInt;

		// Cleanup
		delete pMyObject;
	}
}
\end{lstlisting}

If you read source~code~\ref{Code:RTTIGetSetAttributeDefinition} carefully, you may have noticed that the internal variable \emph{m\_nMyInt} was initialized within the initialization list of the C++ constructor with the value $10$ - but within \emph{pl\_attribute} the default value of \emph{MyInt}, which in this example works as a wrapper for \emph{m\_nMyInt}, was set to the default value $42$. Well, this is no typing error, but an indented artificial construction to show you the following: \begin{quote}int nCurrentValue = pMyObject->MyInt;\end{quote} returned the value $10$! This means, when an instance of a RTTI class is created, and the attribute has the storage type \emph{GetSet}, the RTTI attribute is not initialized with the default value specified within \emph{pl\_attribute}. Still, this defined default value can be requested and used through for example \begin{quote}bool bIsDefaultAfter = pMyObject->MyInt.IsDefault();\end{quote}. What's the background? Is this a bug? An ugly RTTI design issue or just sloppiness within the RTTI implementation? It's nothing of those, it's indented behaviour and well thought out.

When using the RTTI storage type \emph{GetSet}, actually as mentioned before, there's no direct C++ attribute that could be set to a certain default value. The RTTI attribute using \emph{GetSet} can only be seen as a potential wrapper for an internal C++ attribute. But even this is no implementation requirement - the used C++ getter and setter methods may internally do anything totally else which may not even involve a C++ attribute! Likewise, this means that \emph{initializing} an \emph{GetSet} RTTI attribute with the defined default value would mean, that the defined C++ setter method would be called during C++ class construction. During C++ class construction the class is not yet finally constructed and certain parts may still be within an uninitialized, and therefore undefined state. As a result, calling the C++ setter method of the \emph{GetSet} RTTI attribute during this phase would be irresponsible because this may lead quickly to nasty situations resulting in an ugly crash due not yet initialized C++ class attributes. A situation we don't want to bring our PixelLight users into. If you internally use C++ attributes, you should, as usual, take care that those attributes are initialized correctly within your C++ class constructor - in this use case, the PixelLight RTTI can't be responsible for this for the explained reasons.

Of course, the presented source~code~\ref{Code:RTTIGetSetAttributeDefinition} should not be used as a reference how to deal with attribute default values. In general, even if the C++ setter method of the \emph{GetSet} RTTI attribute is not called during initialization with the defined RTTI attribute default value, we strongly recommended to use one and same default value within \emph{pl\_attribute} and the internal C++ attribute, if there's one. Everything else would only lead to confusion and would be error prone.


\paragraph{Overwriting Attributes Within Derived Classes}
Sometimes it's useful to be able to overwrite attributes from base classes within derived classes - for example to add even more enumeration values or to change the default value of an attribute. Therefore, beside \emph{DirectValue} and \emph{GetSet}, there's also a \emph{ModifyAttr} which denotes that this attribute is an overwritten version of an attribute of the base class. Source~code~\ref{Code:RTTIAttributeOverwrite} shows how \emph{ModifyAttr} is used.
\begin{lstlisting}[label=Code:RTTIAttributeOverwrite,caption={Overwriting RTTI attributes in derived classes}]
// Class definition of MyClass
#include <PLCore/Base/Object.h>
class MyClass : public PLCore::Object {

	// RTTI interface
	pl_class(MY_RTTI_EXPORT, MyClass, "", PLCore::Object, "Description")
		pl_constructor_0(MyConstructor, "Default constructor", "")
		pl_attribute(MyFloat, float, 3.1415f, ReadWrite, DirectValue, "PI", "")
	pl_class_end

	// Default constructor
	public:
		MyClass() : MyFloat(this) {}

};
class MyDerivedClass : public MyClass {

	// RTTI interface
	pl_class(MY_RTTI_EXPORT, MyDerivedClass, "", MyClass, "Description")
		pl_constructor_0(MyConstructor, "Default constructor", "")
		// Overwritten MyClass attribute
		pl_attribute(MyFloat, float, 2.71828f, ReadWrite, ModifyAttr, "Euler number", "")
	pl_class_end

	// Default constructor
	public:
		MyDerivedClass() : MyFloat(this) {}

};

// MyClass RTTI implementation (not done within headers)
pl_implement_class(MyClass)
pl_implement_class(MyDerivedClass)
\end{lstlisting}
The defined classes can then be used as seen within source~code~\ref{Code:RTTIAttributeOverwriteUsage}.
\begin{lstlisting}[label=Code:RTTIAttributeOverwriteUsage,caption={Using overwritten RTTI attributes}]
const PLCore::Class *pMyClass = PLCore::ClassManager::GetInstance()->GetClass("MyClass");
const PLCore::Class *pMyDerivedClass = PLCore::ClassManager::GetInstance()->GetClass("MyDerivedClass");
if (pMyClass != nullptr && pMyDerivedClass != nullptr) {
	// Create an instance of the RTTI class MyClass
	MyClass *pMyObject = (MyClass*)pMyClass->Create();
	if (pMyObject != nullptr) {
		// fValue has now the value 3.1415
		float fValue = pMyObject->MyFloat;
		// Cleanup
		delete pMyObject;
	}
	// Create an instance of the RTTI class MyDerivedClass
	MyDerivedClass *pMyDerivedObject = (MyDerivedClass*)pMyDerivedClass->Create();
	if (pMyDerivedObject != nullptr) {
		// fValue has now the value 2.71828
		float fValue = pMyDerivedObject->MyFloat;
		// Value from base class: fValue has still the value 2.71828
		fValue = ((MyClass*)pMyDerivedObject)->MyFloat;
		// Default value from base class: fValue has now the value 3.1415
		fValue = ((MyClass*)pMyDerivedObject)->MyFloat.GetDefault().GetFloat();
		// Default value from class: fValue has now the value 2.71828
		fValue = pMyDerivedObject->MyFloat.GetDefault().GetFloat();
		// Generic default value: fValue has now the value 3.1415
		fValue = pMyDerivedObject->GetAttribute("MyFloat")->GetDefault().GetFloat();
		// Generic default value: fValue still has the value 3.1415
		fValue = ((MyClass*)pMyDerivedObject)->GetAttribute("MyFloat")->GetDefault().GetFloat();
		// Cleanup
		delete pMyDerivedObject;
	}
}
\end{lstlisting}

When overwriting an attribute, take care that the overwritten attribute has the same core properties as the attribute of the base class, or unexpected behaviour may occur. Something like \begin{quote}pl\_attribute(MyFloat, float, 3.1415f, ReadWrite, DirectValue, "PI", "")\end{quote} within the base class, but \begin{quote}pl\_attribute(MyFloat, int, 42, ReadWrite, DirectValue, "PI", "")\end{quote} within the overwritten attribute would be just wrong. Also changing the allowed access is no good idea. If within the base class there's a \emph{MyClass::MyFloat} defined as \emph{ReadOnly}, and within your derived class there's a \emph{MyDerivedClass::MyFloat} defined as \emph{ReadWrite} - just don't overwrite attributes marked with \emph{ReadOnly}.

Using \emph{ModifyAttr} to overwrite \emph{GetSet} attributes is possible, too. In this case, the \emph{GetSet} methods should be virtual within the base class to get the expected behaviour and the getter and setter methods can be specialized correctly. Within PixelLight itself, we're usually don't use \emph{ModifyAttr} to overwrite \emph{GetSet} attributes - instead we just define overwritten attributes by using \emph{GetSet} as well. This way we avoid issues which arise when using \emph{ModifyAttr} to overwrite an \emph{GetSet} attribute. \emph{ModifyAttr} also changes the default value - but \emph{GetSet} attributes internally don't really have default values because they are in fact just methods and no typical C++ attributes. When overwriting for example \begin{quote}pl\_attribute(Flags, pl\_flag\_type(EFlags), 0, ReadWrite, GetSet, "Flags", "")\end{quote} from the base class by using \begin{quote}pl\_attribute(Flags, pl\_flag\_type(EExtendedFlags), 0, ReadWrite, GetSet, "Flags", "") \end{quote} within the derived class, there are usually no problems, especially when the used methods are virtual.


\paragraph{Attribute Serialization}
From time to time it's required to backup all object attribute values at once, to restore them later. An obvious use case for this would be, if the current program state should be saved so it can later be restored by loading saved settings. In the literature, this is often called \emph{serialization} and the RTTI can greatly help you with this task. How such a serialization is done for many RTTI class instances is in no interest of the RTTI, and therefore it's out of the scope of this description.

One way to realize serialization would be the direct use of \emph{PLCore::Object::GetAttributes} to iterate over all available attributes and then saving or loading each single attribute by hand. While this may be required for certain tasks, for instance if the values should be stored in a special binary form, usually it's more comfortable to directly use the methods provided by \emph{PLCore::Object}. You have the option to get and set the attribute values by using strings or by using XML, the last is usually the way you will go for more advanced applications.

By using \emph{PLCore::Object::GetValues} you can receive a string containing all attributes with their current values. Whether or not you want to have attributes which currently have their default value, is up to you. Usually it's best to just request a string with attributes which are not set to their default value - this is also the default behaviour of \emph{PLCore::Object::GetValues} and \emph{PLCore::Object::GetValuesXml} if you call the methods without any parameters. By using the method \emph{PLCore::Object::SetValues}, all attributes the given string mentions are set to the requested values. All other RTTI object attributes the string doesn't refer to, will keep their current state. This means that when you want to ensure that all RTTI object attributes have known values, you first need to reset all attributes to their default values by using \emph{PLCore::Object::SetDefaultValues}, and then setting the changed attributes.

How the RTTI object attributes serialization by using strings works in practice is shown within source~code~\ref{Code:RTTIAttributeSerializationString}.
\begin{lstlisting}[label=Code:RTTIAttributeSerializationString,caption={RTTI object attributes serialization by using strings}]
// Get RTTI class description
const PLCore::Class *pMyClass = PLCore::ClassManager::GetInstance()->GetClass("MyClass");
if (pMyClass != nullptr) {
	// Create an instance of the RTTI class
	MyClass *pMyObject = (MyClass*)pMyClass->Create();
	if (pMyObject != nullptr) {
		PLGeneral::String sValues;

		// Get the values of all attributes as string, but only
		// the attributes which are currently not set to their
		// default value -> sValues is an empty string
		sValues = pMyObject->GetValues(PLCore::NoDefault);

		// Get the values of all attributes as string
		// sValues has the content "MyInt="10" MyFloat="3.1415""
		sValues = pMyObject->GetValues(PLCore::WithDefault);

		// Set new attribute values, MyInt has now the value 42
		// while MyFloat is not changed
		pMyObject->SetValues("MyInt=42");

		// Get the values of all attributes as string, but only
		// the attributes which are currently not set to their
		// default value - sValues has the content "MyInt="42""
		sValues = pMyObject->GetValues(PLCore::NoDefault);

		// Cleanup
		delete pMyObject;
	}
}
\end{lstlisting}

As mentioned before, \emph{PLCore::Object} comes with XML support. The methods \emph{PLCore::Object::GetValuesXml} and \emph{PLCore::Object::SetValuesXml} are the counterparts of \emph{PLCore::Object::GetValues} and \emph{PLCore::Object::SetValues}, the behaviour stays the same as seen within source~code~\ref{Code:RTTIAttributeSerializationXML}.
\begin{lstlisting}[label=Code:RTTIAttributeSerializationXML,caption={RTTI object attributes serialization by using XML}]
// Get RTTI class description
const PLCore::Class *pMyClass = PLCore::ClassManager::GetInstance()->GetClass("MyClass");
if (pMyClass != nullptr) {
	// Create an instance of the RTTI class
	MyClass *pMyObject = (MyClass*)pMyClass->Create();
	if (pMyObject != nullptr) {
		// Get the values of all attributes as XML
		PLGeneral::XmlElement cXmlElement("MyElement");
		pMyObject->GetValuesXml(cXmlElement, PLCore::WithDefault);

		// nMyIntValue has the value 10
		int nMyIntValue = cXmlElement.GetAttribute("MyInt").GetInt();

		// Set the values of all attributes by using XML
		cXmlElement.SetAttribute("MyInt", "42");
		pMyObject->SetValuesXml(cXmlElement);

		// nMyIntValue has the value 42
		nMyIntValue = pMyObject->MyInt;

		// fMyFloatValue has the value 3.1415
		float fMyFloatValue = pMyObject->MyFloat;

		// Cleanup
		delete pMyObject;
	}
}
\end{lstlisting}



\subsection{Enumeration And Flag Attributes}
\label{ClassMembers:EnumerationAndFlagAttributes}
There are two, in some way, special RTTI data types: Enumerations and flags. You may already know enumerations from, for example the C++ \emph{enum} - the RTTI enumeration data type is nearly the same. This data type is quite useful if there are well defined values a variable can be set to. Flags are a derivation of an enumeration data type and internally, they are the same for the RTTI. Because, in practice, this two data types are quite handy, the RTTI offers special features to use those two data types as comfortable as possible. Although the usage of RTTI enumeration and flag is not that complex, this section will discuss the topic in detail because there are many possible variations which may help you within certain situations.


\paragraph{Enumerations}
The C++ \emph{enum} is a quite nice feature which is best used whenever it suggests itself. By using enumerations, one can work with human readable names instead up cryptic numbers which don't tell what they are good for. Another important argument for the use of enumerations is: If the concrete value, the enumeration value represents, was changed for any reason, there's no need to update the hole code by replacing the old number through the new one. As a result, additions, removals or direct value changes of enumerations are less error prone - which is a good thing. Because, for the mentioned reasons, C++ \emph{enum} is an quite important feature to us, the RTTI also provides build in support for enumeration data types.

RTTI enumeration data types can, and should use C++ \emph{enum} values. By doing so, one just defines C++ \emph{enum} values as usual, and then tells the RTTI to use those values - you only define the values once at one place. Although it's possible to use RTTI enumeration data types without an C++ \emph{enum} equivalent, we don't recommend this because it may lead to poor readable source code.

RTTI enumeration data types can be defined inside namespaces and classes or outside. We strongly recommend to make the RTTI enumeration definitions at the same place as the C++ \emph{enum} counterpart, this way one can keep an overview on what's going on. The definition of an RTTI enumeration starts with the \emph{pl\_enum} RTTI macro, and ends with the \emph{pl\_enum\_end} macro. The \emph{pl\_enum} macro requires as parameter the name of the RTTI enumeration, we recommend to use the same name as the one used for the C++ \emph{enum}, although this is no requirement. Internally, the primitive data type of RTTI enumeration data types is usually \emph{int}. The individual possible enumeration values are defined by using the \emph{pl\_enum\_value} macro between \emph{pl\_enum} and \emph{pl\_enum\_end}. The \emph{pl\_enum\_value} macro takes as first parameter the enumeration value, this can be any valid value of the used data type, like \emph{int}, but as mentioned before it's best to directly use values of the C++ \emph{enum}. The second enumeration value parameter is a description of the value, this description may be quite useful to others - so write a satisfactory description and not poor ones as can be seen within the following source code examples. Within source~code~\ref{Code:DefineRTTIEnum} the explained is used in practice.
\begin{lstlisting}[float=htb,label=Code:DefineRTTIEnum,caption={Defining a new RTTI enumeration}]
// C++ enumeration
enum MyEnum {MyZero, MyOne};

// RTTI enumeration counterpart of the C++ enumeration
pl_enum(MyEnum)
	pl_enum_value(MyZero, "My value description 0")
	pl_enum_value(MyOne, "My value description 1")
pl_enum_end
\end{lstlisting}
The RTTI enumeration \emph{MyEnum} can then be used like other RTTI data types as shown within source~code~\ref{Code:RTTIClassWithEnumAttribute}.
\begin{lstlisting}[label=Code:RTTIClassWithEnumAttribute,caption={Defining a new RTTI class with an enumeration attribute}]
// Class definition of MyClass
#include <PLCore/Base/Object.h>
class MyClass : public PLCore::Object {

	// RTTI interface
	pl_class(MY_RTTI_EXPORT, MyClass, "", PLCore::Object, "Description")
		pl_constructor_0(MyConstructor, "Default constructor", "")
		pl_attribute(MyEnumNumber, pl_enum_type(MyEnum), MyOne, ReadWrite, DirectValue, "My enumeration number", "")
	pl_class_end

	// Default constructor
	public:
		MyClass() : MyEnumNumber(this) {}

};

// MyClass RTTI implementation (not done within headers)
pl_implement_class(MyClass)
\end{lstlisting}
The attribute type \emph{pl\_enum\_type(MyEnum)} is using a RTTI macro which is really required in here. This macro must also be used when accessing the RTTI enumeration type directly, for example to figure out the number of enumeration values by using \begin{quote}int nNumber = pl\_enum\_type(MyEnum)::GetNumOfEnumValues();\end{quote}.

As demonstrated within source~code~\ref{Code:RTTIClassWithEnumAttributeUsage}, when using an RTTI enumeration attribute, there's no difference to other RTTI attributes.
\begin{lstlisting}[label=Code:RTTIClassWithEnumAttributeUsage,caption={Using a RTTI class with an enumeration attribute}]
// Get RTTI class description
const PLCore::Class *pMyClass = PLCore::ClassManager::GetInstance()->GetClass("MyClass");
if (pMyClass != nullptr) {
	// Create an instance of the RTTI class
	MyClass *pMyObject = (MyClass*)pMyClass->Create();
	if (pMyObject != nullptr) {
		// nValue has now the value 1
		int nValue = pMyObject->MyEnumNumber;

		// Set MyEnumNumber to MyZero
		pMyObject->MyEnumNumber = MyZero;

		// nValue has now the value 0
		nValue = pMyObject->MyEnumNumber;

		// Set MyEnumNumber to MyOne
		pMyObject->SetAttribute("MyEnumNumber", "MyOne");

		// nValue has now the value 1
		nValue = pMyObject->MyEnumNumber;

		// Cleanup
		delete pMyObject;
	}
}
\end{lstlisting}
Please note that an RTTI enumeration is not just limited to the defined enumerations values, \begin{quote}pMyObject->MyEnumNumber = 5;\end{quote} would also work. This is no bug, or a poor RTTI implementation, it's indented behaviour to not artificially limit the usage of enumeration attributes. This is the same as when using a C++ \emph{enum} like \begin{quote}MyEnum nValue = (MyEnum)5;\end{quote}, which works, too\footnote{Although this wouldn't be a picture book usage of C++ \emph{enum}}.


\paragraph{Enumerations And Namespaces/Classes}
RTTI enumerations can also be within namespaces and classes as shown within source~code~\ref{Code:DefineRTTIEnumNamespaceTogether}.
\begin{lstlisting}[float=htb,label=Code:DefineRTTIEnumNamespaceTogether,caption={Defining a new RTTI enumeration within a namespace}]
namespace MyNamespace {
	// C++ enumeration
	enum MyEnum {MyZero, MyOne};

	// RTTI enumeration counterpart of the C++ enumeration
	pl_enum(MyEnum)
		pl_enum_value(MyZero, "My value description 0")
		pl_enum_value(MyOne, "My value description 1")
	pl_enum_end
} // MyNamespace
\end{lstlisting}
Source~code~\ref{Code:DefineRTTIEnumNamespace} shows how RTTI enumerations outside namspaces are defined while the C++ \emph{enum} counterpart is within a namespace.
\begin{lstlisting}[float=htb,label=Code:DefineRTTIEnumNamespace,caption={Defining a new RTTI enumeration with ugly mixed namespaces}]
// C++ enumeration
namespace MyNamespace {
	enum MyEnum {MyZero, MyOne};
} // MyNamespace

// RTTI enumeration counterpart of the C++ enumeration
pl_enum(MyEnum)
	pl_enum_value(MyNamespace::MyZero, "My value description 0")
	pl_enum_value(MyNamespace::MyOne, "My value description 1")
pl_enum_end
\end{lstlisting}
Although this is technically possible, don't do that because it may lead to confusion. Source~code~\ref{Code:DefineRTTIEnumMultipleNamespace} shows how RTTI enumerations inside multiple namespaces are defined correctly.
\begin{lstlisting}[label=Code:DefineRTTIEnumMultipleNamespace,caption={Defining a new RTTI enumeration within multiple namespaces}]
namespace MyNamespace1 {
	namespace MyNamespace2 {
		// C++ enumeration
		enum MyEnum {MyZero, MyOne};

		// RTTI enumeration counterpart of the C++ enumeration
		pl_enum(MyEnum)
			pl_enum_value(MyZero, "My value description 0")
			pl_enum_value(MyOne, "My value description 1")
		pl_enum_end
	} // MyNamespace2
} // MyNamespace1
\end{lstlisting}
In this case, the definition of the RTTI class attribute would look like \begin{quote}pl\_attribute(MyEnumNumber, pl\_enum\_type(MyNamespace1::MyNamespace2::MyEnum), MyNamespace1::MyNamespace2::MyOne, ReadWrite, DirectValue, "My enumeration number", "")\end{quote}. Because an C++ \emph{enum} can also be within a C++ class, source~code~\ref{Code:DefineRTTIEnumClass} shows an example how this situation is handled.
\begin{lstlisting}[label=Code:DefineRTTIEnumClass,caption={Defining a new RTTI enumeration using a C++ enum inside a class}]
class MyOtherClass {

	public:
		// C++ class with C++ enumeration
		enum MyEnum {MyZero, MyOne};

		// RTTI enumeration counterpart of the C++ enumeration
		pl_enum(MyEnum)
			pl_enum_value(MyZero, "My value description 0")
			pl_enum_value(MyOne, "My value description 1")
		pl_enum_end

};
\end{lstlisting}
As can be seen, when using the RTTI, this situation is the same as when using namespaces. When using an RTTI enumeration with a namespace/class, the usage of an RTTI enumeration attribute stays the same. This means that \begin{quote}pMyObject->SetAttribute("MyEnumNumber", "MyOne");\end{quote} from one of the source code samples above is still using \emph{"MyOne"} and not \emph{"MyNamespace::MyOne"}. Another approach wouldn't be that comfortable within the daily use of the RTTI system. It should be mentioned that it's also possible to have a C++ \emph{enum} used as RTTI enumeration directly used as RTTI attribute inside one and the same class - this is shown within source~code~\ref{Code:DefineRTTIEnumClassTogether}.
\begin{lstlisting}[label=Code:DefineRTTIEnumClassTogether,caption={Defining and using a new RTTI enumeration inside one and the same class}]
// Class definition of MyClass
#include <PLCore/Base/Object.h>
class MyClass : public PLCore::Object {

	// Public data types
	public:
		// C++ class with C++ enumeration
		enum MyEnum {MyZero, MyOne};

		// RTTI enumeration counterpart of the C++ enumeration
		pl_enum(MyEnum)
			pl_enum_value(MyZero, "My value description 0")
			pl_enum_value(MyOne, "My value description 1")
		pl_enum_end

	// RTTI interface
	pl_class(MY_RTTI_EXPORT, MyClass, "", PLCore::Object, "Description")
		pl_constructor_0(MyConstructor, "Default constructor", "")
		pl_attribute(MyEnumNumber, pl_enum_type(MyEnum), MyOne, ReadWrite, DirectValue, "My enumeration number", "")
	pl_class_end

	// Default constructor
	public:
		MyClass() : MyEnumNumber(this) {}

};

// MyClass RTTI implementation (not done within headers)
pl_implement_class(MyClass)
\end{lstlisting}


\paragraph{Extending Enumerations}
RTTI classes may need to add further enumeration values to the one of the base class because they provide additional features. This can be done by using the \emph{pl\_enum\_base} RTTI macro between \emph{pl\_enum} and \emph{pl\_enum\_end}. The macro \emph{pl\_enum\_base}, will add all enumeration values from the RTTI enumeration given as parameter. We recommend to use \emph{pl\_enum\_base} right after \emph{pl\_enum} and before the definition of further enumeration values using for instance \emph{pl\_enum\_value}. This can be seen as a kind of inheritance between RTTI enumerations - even a form of multi inheritance is supported and it's possible to use multiple \emph{pl\_enum\_base}, although this may not improve the readability. Please take care that enumerations given to \emph{pl\_enum\_base} have other values than the one of the current enumeration - else enumeration value conflicts may arise, the compiler will not report them to you. So, use this feature wisely and if it doesn't provide you with benefits, try to avoid using it for the sake of readabliltiy. Source~code~\ref{Code:DefineRTTIExtendingEnumerations} shows how the described is used in practice.
\begin{lstlisting}[label=Code:DefineRTTIExtendingEnumerations,caption={Defining an extended RTTI enumeration}]
// C++ enumerations
enum MyEnum {MyZero, MyOne};
enum MyExtendedEnum {MyTwo=2, MyThree};

// RTTI enumerations counterpart of the C++ enumerations
pl_enum(MyEnum)
	pl_enum_value(MyZero, "My value description 0")
	pl_enum_value(MyOne, "My value description 1")
pl_enum_end
pl_enum(MyExtendedEnum)
	pl_enum_base(MyEnum)
	pl_enum_value(MyTwo, "My value description 2")
	pl_enum_value(MyThree, "My value description 3")
pl_enum_end
\end{lstlisting}
The new RTTI enumeration \emph{MyExtendedEnum} can than be used just like every other RTTI enumeration.


\paragraph{Enumerations Which Differ From Classic C++ Enumerations}
While the C++ \emph{enum} can only deal with integer data types, the RTTI enumeration can also work for example with floating point data types. In such a case, the RTTI macros \emph{pl\_enum\_direct} and \emph{pl\_enum\_value\_direct} can be used instead of \emph{pl\_enum} and \emph{pl\_enum\_value} so the enumeration values can be specified directly. The first parameter of the \emph{pl\_enum\_direct} macro is the name of the RTTI enumeration, we recommend to use the same name as the one used for the C++ \emph{enum}, although this is no requirement. The second parameter of the macro is the primitive data type the enumeration should use. Usually \emph{int} will do the job, but as seen within source~code~\ref{Code:DefineRTTIEnumerationsFloat}, you are free to choose otherwise.
\begin{lstlisting}[label=Code:DefineRTTIEnumerationsFloat,caption={Defining RTTI enumerations which differ from classic C++ enumerations}]
// Define enum in RTTI
pl_enum_direct(FamousNumbers, float)
	pl_enum_value_direct(Zero, 0.0f, "Ask a mathematician whether zero is a number (if you want some fun)")
	pl_enum_value_direct(Pi, 3.1415f, "Also known as Archimedes Constant")
	pl_enum_value_direct(e, 2.71828f, "Euler number")
	pl_enum_value_direct(TheTruth, 42, "Answer to the Ultimate Question of Life, the Universe, and Everything")
	pl_enum_value_direct(HalfTheTruth, 21, "21 is just half the truth")
pl_enum_end
\end{lstlisting}
The defined RTTI enumeration can then be used just like a traditional enumeration.


\paragraph{Flags}
A special case of an enumeration data type is the flags data type. As you may already now, by using flags is possible to get and set single bits of, for example an integer data type. Instead of using tons of boolean variables and wasting memory and lines of codes to provide interfaces for each and every variable, it's possible to put many \emph{true/false} states into one variable by accessing the single bits of a variable directly. As mentioned before, internally at a technical level, enumeration and flag data types are the same for the RTTI. Therefore we'll only discuss the additions of flags and especially their usage. When using the \emph{pl\_enum} RTTI macro, for enumerations, usually \emph{int} will do the job, but flags a data types like \emph{PLGeneral::uint32} would be the better choice because then, you know exactly how many bits are available - even if you currently writing an \SI{64}{\bit} application. In normal situations, 32 flags are enough and as a result, you normally don't care whether or not the flags are in fact stored as \emph{int} which can be \SI{32}{\bit} or \SI{64}{\bit}, or whether the number of bits is well defined by using for example \emph{PLGeneral::uint32} as data type. Within source~code~\ref{Code:DefineRTTIFlagsClass} you can see how to define RTTI flags and using them within a class as RTTI attribute.
\begin{lstlisting}[label=Code:DefineRTTIFlagsClass,caption={Defining new RTTI flags and a RTTI class using them}]
// C++ enumeration used as flags
enum MyFlags {MyFirstFlag=1<<0, MySecondFlag=1<<1};

// RTTI enumeration counterpart of the C++ enumeration
pl_enum(MyFlags)
	pl_enum_value(MyFirstFlag, "My value description 0")
	pl_enum_value(MySecondFlag, "My value description 1")
pl_enum_end

// Class definition of MyClass
#include <PLCore/Base/Object.h>
class MyClass : public PLCore::Object {

	// RTTI interface
	pl_class(MY_RTTI_EXPORT, MyClass, "", PLCore::Object, "Description")
		pl_constructor_0(MyConstructor, "Default constructor", "")
		pl_attribute(MyFlagsNumber, pl_flag_type(MyFlags), MyFirstFlag|MySecondFlag, ReadWrite, DirectValue, "My flags number", "")
	pl_class_end

	// Default constructor
	public:
		MyClass() : MyFlagsNumber(this) {}

};

// MyClass RTTI implementation (not done within headers)
pl_implement_class(MyClass)
\end{lstlisting}
When adding an RTTI class attribute by using the \emph{pl\_attribute} macro, you may have noticed that \emph{pl\_flag\_type} instead of \emph{pl\_enum\_type} is used. The rest is the same as for RTTI enumerations. \emph{MyFirstFlag=1<<0} using bit shift is the same as writing \emph{MyFirstFlag=2}, it's up to you what you're using - but take into account that as you add more and more flags, your number becomes bigger and bigger. At the end \emph{1<<17} may be better readable than \emph{131072} and being less error prone. Further, when writing \emph{1<<17} the used bit is directly visible - bit $17$ in this case when we're starting counting at $0$, which a programmer usually does. When using RTTI flags, there's nothing fancy about them - they are used in the same way as they're used within C++. Instead of going into detail of all the different flag usages, we just present you source~code~\ref{Code:DefineRTTIFlagsClassUsage}.
\begin{lstlisting}[label=Code:DefineRTTIFlagsClassUsage,caption={Using a RTTI class with an flag attribute}]
// Get RTTI class description
const PLCore::Class *pMyClass = PLCore::ClassManager::GetInstance()->GetClass("MyClass");
if (pMyClass != nullptr) {
	// Create an instance of the RTTI class
	MyClass *pMyObject = (MyClass*)pMyClass->Create();
	if (pMyObject != nullptr) {
		// bFirstFlagSet has now the value true
		bool bFirstFlagSet = (pMyObject->MyFlagsNumber & MyFirstFlag) != 0;
		// bSecondFlagSet has now the value true
		bool bSecondFlagSet = (pMyObject->MyFlagsNumber & MySecondFlag) != 0;
		// Just set MyFirstFlag
		pMyObject->MyFlagsNumber = MyFirstFlag;
		// bFirstFlagSet has now the value true
		bFirstFlagSet = (pMyObject->MyFlagsNumber & MyFirstFlag) != 0;
		// bSecondFlagSet has now the value false
		bSecondFlagSet = (pMyObject->MyFlagsNumber & MySecondFlag) != 0;
		// Set MyFirstFlag and MySecondFlag
		pMyObject->SetAttribute("MyFlagsNumber", "MyFirstFlag|MySecondFlag");
		// bFirstFlagSet has now the value true
		bFirstFlagSet = (pMyObject->MyFlagsNumber & MyFirstFlag) != 0;
		// bSecondFlagSet has now the value true
		bSecondFlagSet = (pMyObject->MyFlagsNumber & MySecondFlag) != 0;
		// sValue is now "MyFirstFlag|MyFlagsNumber"
		PLGeneral::String sValue = pMyObject->GetAttribute("MyFlagsNumber")->GetString();
		// bFirstFlagSet has now the value true
		bFirstFlagSet = sValue.IsSubstring("MyFirstFlag");
		// bSecondFlagSet has now the value true
		bSecondFlagSet = sValue.IsSubstring("MySecondFlag");
		// Get flags as integer value, nValue is 3
		int nValue = pMyObject->GetAttribute("MyFlagsNumber")->GetInt();
		// bFirstFlagSet has now the value true
		bFirstFlagSet = (nValue & MyFirstFlag) != 0;
		// bSecondFlagSet has now the value true
		bSecondFlagSet = (nValue & MySecondFlag) != 0;
		// Just set MySecondFlag
		pMyObject->SetAttribute("MyFlagsNumber", "MySecondFlag");
		// sValue is now "MySecondFlag"
		sValue = pMyObject->GetAttribute("MyFlagsNumber")->GetString();
		// Cleanup
		delete pMyObject;
	}
}
\end{lstlisting}


\paragraph{Dynamic Usage Of Enumerations And Flags}
As seen in source code examples before, enumerations and flags can be used dynamically through for instance \emph{PLCore::Object::GetAttribute} and \emph{PLCore::Object::SetAttribute} by using strings, too. This way, you don't need to have the C++ headers the RTTI enumerations are defined in.

By using for example \emph{PLCore::Object::GetAttribute} is possible to get an instance to \emph{PLCore::DynVar} which can also be used to request more information about the variable. To do so, just call \emph{PLCore::DynVar::GetType} and you'll receive an \emph{PLCore::DynTypeInfo} instance. The \emph{PLCore::DynTypeInfo} interface offers methods for dealing with enumeration data types. Whether or not a data type is an enumeration can be figured out by using the \emph{PLCore::DynTypeInfo::IsEnumType} method. If \emph{PLCore::DynTypeInfo::IsFlagType} returns \emph{true}, you know this is a flag data type. If it's an enumeration data type, a list of all known values as a string representation can be requested by using the \emph{PLCore::DynTypeInfo::GetEnumValues} method. If you already have an enumeration value as string, the concrete value this enumeration represents can be figured out by using \emph{PLCore::DynTypeInfo::GetEnumValue} - this is a string, too. If you have absolutely no clue what an enumeration value is good for, call the \emph{PLCore::DynTypeInfo::GetEnumDescription} method to get a, hopefully human readable, description of the enumeration value. Please note that this will only return a satisfactory description if the author if the RTTI enumeration value wrote such a description. Source~code~\ref{Code:RTTIDynamicUsageOfDynTypeInfoForEnumerationInformation} shows how to use \emph{PLCore::DynTypeInfo} to get additional enumeration information.
\begin{lstlisting}[label=Code:RTTIDynamicUsageOfDynTypeInfoForEnumerationInformation,caption={Dynamic usage of \emph{PLCore::DynTypeInfo} for enumeration information}]
// Get RTTI class description
const PLCore::Class *pMyClass = PLCore::ClassManager::GetInstance()->GetClass("MyClass");
if (pMyClass != nullptr) {
	// Create an instance of the RTTI class
	MyClass *pMyObject = (MyClass*)pMyClass->Create();
	if (pMyObject != nullptr) {
		// Get the DynVar instance of MyEnumNumber and check
		// whether or not it's really an enumation
		PLCore::DynVar *pDynVar = pMyObject->GetAttribute("MyEnumNumber");
		if (pDynVar != nullptr && pDynVar->GetType().IsEnumType()) {
			// Get the list of all enumeration values
			const PLGeneral::List<PLGeneral::String> &lstEnums = pDynVar->GetType().GetEnumValues();
			for (PLGeneral::uint32 i=0; i<lstEnums.GetNumOfElements(); i++) {
				// Get the name of the enumeration value
				PLGeneral::String sEnum  = lstEnums[i];

				// Get the value of the enumation value
				PLGeneral::String sValue = pDynVar->GetType().GetEnumValue(sEnum);

				// Get the description of the enumation value
				PLGeneral::String sDescription = pDynVar->GetType().GetEnumDescription(sEnum);

				// ...
			}
		}

		// Cleanup
		delete pMyObject;
	}
}
\end{lstlisting}



\subsection{Method}
\label{ClassMembers:Method}
In C++, functions inside a class are called \emph{method}, for the RTTI, we're using the same terminology. A list of all RTTI class methods can be requested by using \emph{PLCore::Class::GetMethods}. The RTTI class methods are defined between the macros \emph{pl\_class} and \emph{pl\_class\_end} using the \emph{pl\_method\_x} macro, were $x$ stands for a number between $0$ and $15$. (inclusive) This number defines the number of method parameters, \emph{pl\_method\_0} means that this method doesn't have any parameters. Usually you don't have methods with more than 15 parameters, if you have, you should reconsider your design. The total number of macro parameters depends on the number of C++ method parameters. In general, the first parameter of this macro is the name of the method, this name must match the name of the C++ method. The name is used to reference the method within methods like \emph{PLCore::Class::GetMethod}. Please note that it's not possible to create multiple RTTI class methods with the same name, but with a different signature. The RTTI class method names need to be unique inside a RTTI class (names over multiple derived classes is another story). The name is followed by the type of the return value, for example \emph{pl\_ret\_type(void)} if the method doesn't return a value. Next, there are $x$ parameters, the types of these parameters depend on the types of the original C++ method. After this individual parameters, a description string and an annotation string conclude the method definition. If you make any errors while defining a RTTI method, for example there's no C++ method with the given signature, don't panic, the compiler will yell at you so you will be politely informed about the mismatch. The C++ methods can be \emph{public}, \emph{protected} or \emph{private}. For the RTTI, this doesn't make any difference - but we recommend to make this methods always \emph{public} because through the RTTI, they are public accessible anyway. This C++ methods for RTTI class methods should not be defined as constant.

Source~code~\ref{Code:RTTIMethods} shows the definition of a class that comes with three different methods.
\begin{lstlisting}[label=Code:RTTIMethods,caption={Definition of RTTI class methods with parameters}]
// Class definition of MyClass
#include <PLCore/Base/Object.h>
class MyClass : public PLCore::Object {

	// RTTI interface
	pl_class(MY_RTTI_EXPORT, MyClass, "", PLCore::Object, "Description of my RTTI class")
		pl_constructor_0(MyConstructor, "Default constructor", "")
		pl_method_0(MyMethod, pl_ret_type(void), "My method", "")
		pl_method_1(MyMethodParameter, pl_ret_type(void), int, "My method with given parameter", "")
		pl_method_2(MyMethodParameters, bool, int, float, "My method with given parameters and return value", "")
	pl_class_end

	public:
		MyClass() : MethodMyMethod(this), MethodMyMethodParameter(this), MethodMyMethodParameters(this) {}
		void MyMethod() {}
		void MyMethodParameter(int nFirst) {}
		bool MyMethodParameters(int nFirst, float fSecond) { return true; }

};

// MyClass RTTI implementation
pl_implement_class(MyClass)
\end{lstlisting}
Like the RTTI class attributes, the RTTI class methods are actually objects and their constructor needs a pointer back to their owner object. In the shown example, this is done within the default constructor by using \emph{MethodMyMethod(this)}, \emph{MethodMyMethodParameter(this)} and \emph{MethodMyMethodParameters(this)}. As you can see, a \emph{``Method``} was added automatically to the method object name and for example the method name \emph{MyMethod} was changed into \emph{MethodMyMethod}. If this wouldn't be done, there would occur a name conflict when using the C++ methods. When using for instance \begin{quote}PLCore::DynFunc *pDynFunc = pMyObject->GetMethod(``MyMethod``);\end{quote}, the method name is unchanged.

The following source~code~\ref{Code:CppLikeRTTIClassMethodUsage} shows how this RTTI class methods can be used by directly accessing the RTTI class method objects as if they were just usual C++ methods.
\begin{lstlisting}[label=Code:CppLikeRTTIClassMethodUsage,caption={Accessing RTTI class method objects as if they were just usual C++ methods}]
// Get RTTI class description
const PLCore::Class *pMyClass = PLCore::ClassManager::GetInstance()->GetClass("MyClass");
if (pMyClass != nullptr) {
	// Create an instance of the RTTI class
	MyClass *pMyObject = (MyClass*)pMyClass->Create();

	// Call a parameterless method of the RTTI class which doesn't return anything
	pMyObject->MethodMyMethod();

	// Call a method with one parameter of the RTTI class which doesn't return anything
	pMyObject->MyMethodParameter(42);

	// Call a method with two parameters of the RTTI class returning a boolean value
	bool bResult = pMyObject->MyMethodParameters(42, 3.1415f);

	// Cleanup
	delete pMyObject;
}
\end{lstlisting}
If the shown usage would be the only possible usage of the RTTI class methods, this all would be much effort without any benefits. As already exposed, RTTI class methods can also be accessed by using the generic \emph{PLCore::Class::GetMethod} method and the RTTI class method name as string parameter. If all went fine and there's a RTTI class method with the given name, you now have a pointer to an \emph{PLCore::DynFunc} instance. If there's no RTTI class method with the given name, a null pointer will be returned - therefore it's recommended to check whether or not the returned pointer is valid. After you received a valid generic dynamic function pointer, use \emph{PLCore::DynFunc::Call} to call the method as seen within source~code~\ref{Code:DynamicRTTIClassMethodUsage}.
\begin{lstlisting}[label=Code:DynamicRTTIClassMethodUsage,caption={Dynamically calling RTTI class methods}]
// Get RTTI class description
const PLCore::Class *pMyClass = PLCore::ClassManager::GetInstance()->GetClass("MyClass");
if (pMyClass != nullptr) {
	// Create an instance of the RTTI class
	PLCore::Object *pMyObject = pMyClass->Create();

	// Get a pointer to a RTTI class method
	PLCore::DynFunc *pDynFunc = pMyObject->GetMethod("MyMethodParameter");
	if (pDynFunc != nullptr) {
		// Dynamic RTTI class method call
		pDynFunc->Call("Param0=42");

		// Dynamic typed RTTI class method call
		pDynFunc->Call(PLCore::Params<void, int>(42));
	}

	// Get a pointer to a RTTI class method with a return value
	pDynFunc = pMyObject->GetMethod("MyMethodParameters");
	if (pDynFunc != nullptr) {
		// Dynamic typed RTTI class method call with a return value
		PLCore::Params<bool, int, float> cParams(42, 3.1415f);
		pDynFunc->Call(cParams);
		bool bResult = cParams.Return;
	}

	// Cleanup
	delete pMyObject;
}
\end{lstlisting}
As you can see at the \begin{quote}pDynFunc->Call(''Param0=42'');\end{quote} example, when calling a method by using just a string, there must by any argument name followed by an equal symbol in front of each single argument value. In here, this argument name is totally free to choose (yes, you may also name it \emph{Bob} if you wish), but the order of the arguments must match the one of the called method. The only reason for this approach is to make the parsing of the given argument string saver. If the given arguments don't match the RTTI class method signature, for example because they have the wrong type, the method call is just ignored. This means this whole process is type safe. Please note, when using just a string to call a RTTI class method as shown within \begin{quote}pDynFunc->Call(''Param0=42'');\end{quote}, it's not possible to catch the returned value. If you're using the feature rich \emph{PLCore::Params} template instead of the shown string short cut, it's also possible to catch the return value as already shown within part \ref{Functions:DynamicParameters}.

Be careful when using RTTI methods which take one or more references as parameter. Have a look into appendix~\ref{Appendix:CommonPitfalls:RTTIMethodStringReferenceParameter} to get an idea what kind of problems may arise.


\paragraph{Constructor}
\label{ClassMembers:Constructor}
As you probably know, a constructor is a special case of a method - a method which is called when the object is created and doesn't have any return value. As such, it will not be listed within \emph{PLCore::Class::GetMethods}. A list of all class constructors can be requested by using the method \emph{PLCore::Class::GetConstructors}. If a RTTI class has no constructors at all, it's not possible to instantiate it by using the RTTI. This is also called an abstract class which can only be used as base class for other classes. Because RTTI constructors are defined in a similar way as RTTI methods are defined, the following description is nearly the same as the one for methods. By using this approach, it should be easier to see were methods and constructors are similar, and were they differ.

The RTTI class constructors are defined between the macros \emph{pl\_class} and \emph{pl\_class\_end} using the \emph{pl\_constructor\_x} macro, were $x$ stands for a number between $0$ and $15$. (inclusive) This number defines the number of constructor parameters, \emph{pl\_constructor\_0} means that this constructor doesn't have any parameters - this is the default constructor. Usually you don't have constructors with more than 15 parameters, if you have, you should reconsider your design. The total number of macro parameters depends on the number of C++ constructor parameters. In general, the first parameter of this macro is the name of the constructor. Unlike the RTTI name of methods, it's up to you to choose an adequate name. This name is used to reference the constructor within methods like \emph{PLCore::Class::GetConstructor}. Please note that it's not possible to create multiple RTTI class constructors with the same name, but with a different signature - although this is exactly the way it's done within C++. The RTTI class constructor names need to be unique inside a RTTI class (names over multiple derived classes is another story) Now there's a difference to the definition of methods - constructors have no user defined return value type, this type is automatically always \emph{PLCore::Object*} and therefore it mustn't be specified. The constructor name is followed by $x$ parameters, the types of these parameters depend on the types of the original C++ constructor. After this individual parameters, a description string and an annotation string conclude the constructor definition. If you make any errors while defining a RTTI constructor, for example there's no C++ constructor with the given signature, don't panic, the compiler will yell at you so you will be politely informed about the mismatch. In contrast to methods, the C++ constructor the RTTI class constructor is referring must be \emph{public}.

Source~code~\ref{Code:RTTIConstructors} shows the definition of a class that comes with different three constructors.
\begin{lstlisting}[label=Code:RTTIConstructors,caption={RTTI class constructors with parameters}]
// Class definition of MyClass
#include <PLCore/Base/Object.h>
class MyClass : public PLCore::Object {

	// RTTI interface
	pl_class(MY_RTTI_EXPORT, MyClass, "", PLCore::Object, "Description of my RTTI class")
		pl_constructor_0(MyConstructor, "Default constructor", "")
		pl_constructor_1(MyConstructorParameter, int, "Create with given parameter", "")
		pl_constructor_2(MyConstructorParameters, int, float, "Create with two parameters", "")
	pl_class_end

	// Public methods
	public:
		MyClass() {}
		MyClass(int nFirst) {}
		MyClass(int nFirst, float fSecond) {}

};

// MyClass RTTI implementation
pl_implement_class(MyClass)
\end{lstlisting}
You may have noticed that the RTTI class constructors doesn't need to be initialized by using for example \emph{MyConstructor(this)} within a C++ constructor, as this is required for RTTI class attributes and RTTI class methods. The instance of the class can be created by using one of the offered \emph{PLCore::Class::Create} methods as shown within source~code~\ref{Code:RTTIClassInstantiationWithParameters}.
\begin{lstlisting}[label=Code:RTTIClassInstantiationWithParameters,caption={RTTI class instantiation with parameters}]
// Get RTTI class description
const PLCore::Class *pMyClass = PLCore::ClassManager::GetInstance()->GetClass("MyClass");
if (pMyClass != nullptr) {
	// Create an instance of the RTTI class by using the default constructor
	MyClass *pMyObject0 = (MyClass*)pMyClass->Create();

	// Create an instance of the RTTI class by using a constructor with one parameter
	MyClass *pMyObject1 = (MyClass*)pMyClass->Create(PLCore::Params<PLCore::Object*, int>(42));

	// Create an instance of the RTTI class by using a constructor with two parameters
	MyClass *pMyObject2 = (MyClass*)pMyClass->Create(PLCore::Params<PLCore::Object*, int, float>(42, 3.1415f));

	// ...
}
\end{lstlisting}
Unlike constructors in C++, it's not possible to call RTTI class constructors like usual methods by using for example \emph{pMyObject0->MyConstructor}. The compiler will tell you in this case, that \emph{MyConstructor} is not a member of \emph{MyClass} (the object \emph{pMyObject0} is an instance of this class). Within the RTTI, constructors are really only involved within the automatic creation of an class instance without the need to use the C++ \emph{new} which would require that you have all C++ headers of all the classes - which is usually not the case and not wanted when using completely dynamic plugins by using for example shared libraries. The RTTI is not meant to be a complete replacement for the C++ class inheritance or a complete extension of the C++ programming language, it's just meant to enable flexible and extensible dynamic runtime access to classes and their members in a more flexible way as this is possible by using just C++ given native features.



\subsection{Signal}
At this point, you should already be familiar with the concept of events and event handlers, if not, please read the chapter~\ref{Chapter:EventsAndEventHandlers} first. A signal is an event within an object, this is the terminology we're using in PixelLight. This means that even if an event inside a class is not connected to the RTTI, we still speak from a signal when we talk about an event within a class or an object.

A list of all RTTI class signals can be requested by using \emph{PLCore::Class::GetSignals}. The RTTI class signals are defined between the macros \emph{pl\_class} and \emph{pl\_class\_end} using the \emph{pl\_signal\_x} macro, were $x$ stands for a number between $0$ and $15$. (inclusive) This number defines the number of signal parameters, \emph{pl\_signal\_0} means that this signal doesn't have any parameters. Usually you don't have signals with more than 15 parameters, if you have, you should reconsider your design. In general, the first parameter of this macro is the name of the signal, it's up to you to choose an adequate name. This name is used to reference the signal within methods like \emph{PLCore::Class::GetSignal}. Please note that it's not possible to create multiple RTTI class signals with the same name, but with a different signature. The RTTI class signal names need to be unique inside a RTTI class (names over multiple derived classes is another story). The signal name is followed by $x$ parameters, the types of these parameters are up to you. After this individual parameters, a description string and an annotation string conclude the signal definition.

Source~code~\ref{Code:RTTISignalDefinition} shows the definition of a class that comes with two signals, one with, the other without any parameters.
\begin{lstlisting}[label=Code:RTTISignalDefinition,caption={Defining a RTTI class with signals}]
// Class definition of MyClass
#include <PLCore/Base/Object.h>
class MyClass : public PLCore::Object {

	// RTTI interface
	pl_class(MY_RTTI_EXPORT, MyClass, "", PLCore::Object, "Description of my RTTI class")
		pl_constructor_0(MyConstructor, "Default constructor", "")
		pl_signal_0(MySignal, "My signal", "")
		pl_signal_1(MySignalParameter, int, "My signal with given parameter", "")
	pl_class_end

	// Public methods
	public:
		MyClass() : MySignal(this), MySignalParameter(this) {}

};

// MyClass RTTI implementation
pl_implement_class(MyClass)
\end{lstlisting}
Like the RTTI class attributes and the RTTI class methods, the RTTI class signals are actually objects and their constructor needs a pointer back to their owner object. In the shown example, this is done within the default constructor by using \emph{MySignal(this)} and \emph{MySignalParameter(this)}. As you can see, there's nothing fancy about signals - as mentioned before, they are just events inside an object and the \emph{pl\_signal\_x} macro is more or less just for a more comfortable definition. As a result, the signals example source~code~\ref{Code:RTTISignalUsage} doesn't show any difference to the usage of blank events.
\begin{lstlisting}[label=Code:RTTISignalUsage,caption={Using signals of a RTTI class}]
// This static function will be called if the MySignal signal is emitted
void MyFunction() {
}

// This static function will be called if the MySignalParameter signal is emitted
void MyFunctionParameter(int nValue) {
}

// ...

// Get RTTI class description
const PLCore::Class *pMyClass = PLCore::ClassManager::GetInstance()->GetClass("MyClass");
if (pMyClass != nullptr) {
	// Create an instance of the RTTI class
	MyClass *pMyObject = (MyClass*)pMyClass->Create();

	// Create event handlers which will be connected to signals
	PLCore::EventHandler<> cMyEventHandler(MyFunction);
	PLCore::EventHandler<int> cMyEventHandlerParameter(MyFunctionParameter);

	// Connect one of the event handler with the MySignal signal, the other with MySignalParameter
	pMyObject->MySignal.Connect(&cMyEventHandler);
	pMyObject->MySignalParameter.Connect(&cMyEventHandlerParameter);

	// Emit the MySignal signal, MyFunction will be called
	pMyObject->MySignal();

	// Emit the MySignalParameter signal, MyFunctionParameter will be called
	pMyObject->MySignalParameter(42);

	// Cleanup
	delete pMyObject;
}
\end{lstlisting}
OK, we lied before when telling that there's nothing fancy about signals in contrast to events. As you may remember, RTTI class attributes and methods can also be accessed by using their name as string, this is the same for signals. As a result, it's possible to use signals without the need to have the header of the class the signal is in as shown within source~code~\ref{Code:RTTIDynamicSignalUsage}.
\begin{lstlisting}[label=Code:RTTIDynamicSignalUsage,caption={Using signals of a RTTI class dynamically}]
// This static function will be called if the MySignal signal is emitted
void MyFunction() {
}

// This static function will be called if the MySignalParameter signal is emitted
void MyFunctionParameter(int nValue) {
}

// ...

// Get RTTI class description
const PLCore::Class *pMyClass = PLCore::ClassManager::GetInstance()->GetClass("MyClass");
if (pMyClass != nullptr) {
	// Create an instance of the RTTI class
	PLCore::Object *pMyObject = pMyClass->Create();

	// Create event handlers which will be connected to signals
	PLCore::EventHandler<> cMyEventHandler(MyFunction);
	PLCore::EventHandler<int> cMyEventHandlerParameter(MyFunctionParameter);

	// Connect one of the event handler with the MySignal signal, the other with MySignalParameter
	PLCore::DynEvent *pMySignal = pMyObject->GetSignal("MySignal");
	if (pMySignal != nullptr)
		pMySignal->Connect(&cMyEventHandler);
	PLCore::DynEvent *pMySignalParameter = pMyObject->GetSignal("MySignalParameter");
	if (pMySignalParameter != nullptr)
		pMySignalParameter->Connect(&cMyEventHandlerParameter);

	// Emit the MySignal signal, MyFunction will be called
	if (pMySignal != nullptr)
		pMySignal->Emit(PLCore::Params<void>());

	// Emit the MySignalParameter signal, MyFunctionParameter will be called
	if (pMySignalParameter != nullptr)
		pMySignalParameter->Emit(PLCore::Params<void, int>(42));

	// Cleanup
	delete pMyObject;
}
\end{lstlisting}



\subsection{Slot}
At this point, you should already be familiar with the concept of events and event handlers, if not, please read the chapter~\ref{Chapter:EventsAndEventHandlers} first. A slot is an event handler within an object, this is the terminology we're using in PixelLight. A RTTI class slot is quite similar to a RTTI class method, except that a slot has never a return value. As a result, the following description is quite similar to the one of RTTI class methods.

A list of all RTTI class slots can be requested by using \emph{PLCore::Class::GetSlots}. The RTTI class slots are defined between the macros \emph{pl\_class} and \emph{pl\_class\_end} using the \emph{pl\_slot\_x} macro, were $x$ stands for a number between $0$ and $15$. (inclusive) This number defines the number of slot parameters, \emph{pl\_slot\_0} means that this slot doesn't have any parameters. Usually you don't have slots with more than 15 parameters, if you have, you should reconsider your design. The total number of macro parameters depends on the number of C++ method parameters which will catch the event while the C++ method signature depends on the signature of the event this method should catch. In general, the first parameter of this macro is the name of the slot, this name must match the name of the C++ method which will catch the event. The name is used to reference the slot within methods like \emph{PLCore::Class::GetSlot}. Please note that it's not possible to create multiple RTTI class slots with the same name, but with a different signature. The RTTI class slot names need to be unique inside a RTTI class (names over multiple derived classes is another story). Slots don't return a value, so no return value type has to be specified. Next, there are $x$ parameters, the types of these parameters depend on the types of the C++ method which will catch the event. After this individual parameters, a description string and an annotation string conclude the slot definition. If you make any errors while defining a RTTI slot, for example there's no C++ method with the given signature, don't panic, the compiler will yell at you so you will be politely informed about the mismatch. The C++ methods for slots can be \emph{public}, \emph{protected} or \emph{private}. For the RTTI, this doesn't make any difference - but we recommend to make this C++ methods always \emph{public} because through the RTTI, they are public accessible anyway. This C++ methods for RTTI class slots should not be defined as constant.

Source~code~\ref{Code:RTTISlots} shows the definition of a class that comes with two different slots.
\begin{lstlisting}[label=Code:RTTISlots,caption={Definition of RTTI class slots with parameters}]
// Class definition of MyClass
#include <PLCore/Base/Object.h>
class MyClass : public PLCore::Object {

	// RTTI interface
	pl_class(MY_RTTI_EXPORT, MyClass, "", PLCore::Object, "Description of my RTTI class")
		pl_constructor_0(MyConstructor, "Default constructor", "")
		pl_slot_0(OnMyEvent, "My slot", "")
		pl_slot_1(OnMyEventParameter, int, "My slot with given parameter", "")
	pl_class_end

	// Public methods
	public:
		MyClass() : SlotOnMyEvent(this), SlotOnMyEventParameter(this) {}
		void OnMyEvent() {}
		void OnMyEventParameter(int nValue) {}

};

// MyClass RTTI implementation
pl_implement_class(MyClass)
\end{lstlisting}
The RTTI slot names in the examples are using a name convention we're using within PixelLight and our other projects - it's up to to whether you adopt this convention, you can also make your one naming conventions. Within our name convention for RTTI slot names, there's a \emph{On} within for example \emph{OnMyEvent} indicating that this is a slot method. The other part of the name consists of the name of the event/signal - for \emph{OnMyEvent} this would be an event/signal with the name \emph{MyEvent}. Like the RTTI class attributes, methods and signals, the RTTI class slots are actually objects and their constructor needs a pointer back to their owner object. In the shown example, this is done within the default constructor by using \emph{SlotOnMyEvent(this)} and \emph{SlotOnMyEventParameter(this)}. As you can see, a \emph{``Slot``} was added automatically to the slot object name and for example the slot name \emph{OnMyEvent} was changed into \emph{SlotOnMyEvent}. If this wouldn't be done, there would occur a name conflict when using the C++ methods. When using for instance \emph{pMyObject->GetSlot(``OnMyEvent``)}, the slot name is unchanged. As you can see, this approach is the same as the one used for the RTTI class methods.

The following source~code~\ref{Code:RTTISlotsUsage} shows how this RTTI class slots can be used by directly accessing the RTTI class slots.
\begin{lstlisting}[label=Code:RTTISlotsUsage,caption={RTTI class slots usage}]
// Get RTTI class description
const PLCore::Class *pMyClass = PLCore::ClassManager::GetInstance()->GetClass("MyClass");
if (pMyClass != nullptr) {
	// Create an instance of the RTTI class
	MyClass *pMyObject = (MyClass*)pMyClass->Create();

	// Create events
	PLCore::Event<> cMyEvent;
	PLCore::Event<int> cMyEventParameter;

	// Connect one of the slots with the cMyEvent event, the other with cMyEventParameter
	cMyEvent.Connect(&pMyObject->SlotOnMyEvent);
	cMyEventParameter.Connect(&pMyObject->SlotOnMyEventParameter);

	// Emit the cMyEvent event, MyClass::OnMyEvent will be called
	cMyEvent();

	// Emit the cMyEventParameter event, MyClass::OnMyEventParameter will be called
	cMyEventParameter(42);

	// Cleanup
	delete pMyObject;
}
\end{lstlisting}
If the shown usage would be the only possible usage of the RTTI class slots, this all would be much effort without any benefits. As already exposed, RTTI class slots can also be accessed by using the generic \emph{PLCore::Class::GetSlot} method and the RTTI class slot name as string parameter. If all went fine and there's a RTTI class slot with the given name, you now have a pointer to an generic \emph{PLCore::EventHandlerDesc} instance. If there's no RTTI class slot with the given name, a null pointer will be returned - therefore in certain situations, you may want to check whether or not the returned pointer is valid. After you received a slot pointer, you're able to use it as shown within source~code~\ref{Code:DynamicRTTISlotsUsage}.
\begin{lstlisting}[label=Code:DynamicRTTISlotsUsage,caption={Dynamic RTTI class slots usage}]
// Get RTTI class description
const PLCore::Class *pMyClass = PLCore::ClassManager::GetInstance()->GetClass("MyClass");
if (pMyClass != nullptr) {
	// Create an instance of the RTTI class
	PLCore::Object *pMyObject = pMyClass->Create();

	// Create events
	PLCore::Event<> cMyEvent;
	PLCore::Event<int> cMyEventParameter;

	// Connect one of the slots with the cMyEvent event, the other with cMyEventParameter
	cMyEvent.Connect(pMyObject->GetSlot("OnMyEvent"));
	cMyEventParameter.Connect(pMyObject->GetSlot("OnMyEventParameter"));

	// Emit the cMyEvent event, MyClass::OnMyEvent will be called
	cMyEvent();

	// Emit the cMyEventParameter event, MyClass::OnMyEventParameter will be called
	cMyEventParameter(42);

	// Cleanup
	delete pMyObject;
}
\end{lstlisting}
As you can see, this example is nearly identical to source~code~\ref{Code:RTTISlotsUsage}, the only difference is that for instance \emph{pMyObject->GetSlot(''OnMyEvent'')} is used to receive a pointer to a slot. Because signals are just events within objects, and a slots are just event handlers within an objects, slots can also be connected to signals \ldots \begin{quote}pMyObject0->GetSignal(''MySignal'')->Connect(pMyObject1->GetSlot(''OnMySignal''));\end{quote}. If the signature of \emph{MySignal} and \emph{OnMySignal} doesn't match, nothing will happen.



\subsection{Properties}
Each RTTI class can transport additional information in the form of properties. A property is a name/value pair of strings that can contain any kind of string based information. The usage of properties becomes quite handy when, for instance, it's required to make the file formats, a class can deal with, public in a general way without the need to create a  special interface.

Please note that during runtime, this properties can't be changed - they are not meant for dynamic program information. As a result, the properties are independent from RTTI class instances - the objects. A hash map containing this properties can be requested by using the method \emph{PLCore::Class::GetProperties}. The RTTI class properties are defined between the macros \emph{pl\_class} and \emph{pl\_class\_end} using the \emph{pl\_properties} macro to initiate the definition of properties and the \emph{pl\_properties\_end} macro to conclude the properties definition. Single properties are defined within this two mentioned property macros by using the \emph{pl\_property} macro. The first macro parameter is the name of the property while the second macro parameter is the value of the property. Both parameters are simple strings which have no special build in RTTI meaning and therefore can be chosen freely.

Source~code~\ref{Code:RTTIClassPropertiesDefinition} shows how a basic RTTI class with properties can be defined.
\begin{lstlisting}[float=htb,label=Code:RTTIClassPropertiesDefinition,caption={Defining a new RTTI class with properties}]
#include <PLCore/Base/Object.h>
class MyClass : public PLCore::Object {
	pl_class(MY_RTTI_EXPORT, MyClass, "", PLCore::Object, "Description of my RTTI class")
		pl_constructor_0(MyConstructor, "Default constructor", "")
		pl_properties
			pl_property("MyFirstProperty",  "FirstValue")
			pl_property("MySecondProperty", "SecondValue")
		pl_properties_end
	pl_class_end
};
\end{lstlisting}

As shown within source~code~\ref{Code:RTTIClassPropertiesUsage}, the usage of RTTI class properties is a quite simple task.
\begin{lstlisting}[float=htb,label=Code:RTTIClassPropertiesUsage,caption={Accessing RTTI class properties}]
// Get RTTI class description
const PLCore::Class *pMyClass = PLCore::ClassManager::GetInstance()->GetClass("MyClass");
if (pMyClass != nullptr) {
	// Query the value of the "MyFirstProperty" property, "sFirst" has now the value "FirstValue"
	PLGeneral::String sFirst = pMyClass->GetProperties().Get("MyFirstProperty");

	// Query the value of the "MySecondProperty" property, "sSecond" has now the value "SecondValue"
	PLGeneral::String sSecond = pMyClass->GetProperties().Get("MySecondProperty");
}
\end{lstlisting}
A RTTI class can overwrite inherited properties from it's base classes. In this case, the hash map entry within the derived class is just replace by a new entry. Because the RTTI class properties are accessed by using a \emph{PLGeneral::HashMap} template instance, all hash map operations can be used. The following source~code~\ref{Code:RTTIClassPropertiesIteration} shows how to iterate over all RTTI class properties.
\begin{lstlisting}[float=htb,label=Code:RTTIClassPropertiesIteration,caption={Iterating over all RTTI class properties}]
// Get RTTI class description
const PLCore::Class *pMyClass = PLCore::ClassManager::GetInstance()->GetClass("MyClass");
if (pMyClass != nullptr) {
	// Iterate over all RTTI class properties
	PLGeneral::Iterator<PLGeneral::String> cIterator = pMyClass->GetProperties().GetKeyIterator();
	while (cIterator.HasNext()) {
		// Get the value of the current property
		PLGeneral::String sValue = pMyClass->GetProperties().Get(cIterator.Next());
	}
}
\end{lstlisting}
