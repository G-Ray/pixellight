>> 18.12.2010
[CO]
- "PLGeneralWindows.h": If "_MSC_VER" (VisualStudio) or "_WCHAR_T_DEFINED" is not defined, "wctype.h" will be included for
  "wchar_t". Now PLGeneral can be used within for example QtCreator at once.
- Added a static adapter class within PLGeneral for mapping Qt strings to PixelLight strings and vice versa



>> 17.12.2010
[CO]
- Added unicode support to "FileLinux", "FileSearchLinux", "ConsoleLinux", "DynLibLinux", "SystemLinux", "FileStdStream", "Log",
  "ConsoleWindows" and "Process"



/*********************************************************\
 *  The entries below are in german only
\*********************************************************/



>> 04.12.2010
[CO]
- Beim über die Codes "schweifen" (hin und wieder passiert mir soetwas unbeabsichtigt *g*) vielen mir in der String Klasse ein
  paar Stellen wie z.B. "if (pszFormat && strlen(pszFormat))" auf. Sinn ist hier eigentlich nur rauszufinden ob direkt das erste
  Zeichen im String eine terminierende Null ist - die String länge braucht man hier gar nicht. Änderte diese Stellen daher in
  "if (pszFormat && pszFormat[0] != '\0')" - spart einen Funktionsaufruf und ändert die komplexität hier von n zu 1 da nicht mehr
  im String nach '\0' gesucht werden muss. Interessant das mir das noch nicht vorher ins Auge gestochen ist. *g*



>> 29.11.2010
[CO]
- "Stopwatch::Stop()"-Bugfix: Wenn die Stopuhr gerade nicht läuft, und man "Stop()" aufruft sollte natürlich "0" als gemessene
  Zeit zurückgegeben werden...
-> Die im Tagebucheintrag vom "30.10.2010" angesprochenen String Optimierungen angepackt...
- StringBuffer: "Append()" hinzugefügt, wenn immer möglich wird in der String-Implementation nun "Append()" verwendet da dessen
  Implementation einfacher gehalten ist (wodurch Optimierungen und bessere Performance leichter zu realisieren sind)
- StringBuffer um "m_nMaxLength"-Variable erweitert, damit ist es nun möglich, dass ein String Buffer intern größer ist als der
  tatsächlich gespeicherte String. Hintergrund ist, das Speichermanagement teuer ist und derzeit die String Klasse für ein paar
  Dinge performancemäßig leider unbrauchbar ist. Da wir meist nur ASCII nutzen, konzentriere ich mich erstmal auf Optimierungen
  für ASCII Strings - aufgrund des Umfangs der String Klasse, wird es sicherlich nen bischn dauern bis alles etwas flotter geht.
  Oft werden mehrere Strings konkateniert, hier zeigte die String Klasse performance mäßig deutliche schwächen. Sinnfreies aber
  einfaches Beispiel:
    String sString;
    for (int i=0; i<100000; i++)
      sString += 'a';
  Vor dem Beginn der Performance optimierungen dauerte das im Release Modus unglaubliche 2995 ms. Nach dem einbauen von "Append()"
  noch 2757 ms, und sobald bei "Append()" intern Speicher für zukünfige Zeichen reserviert und dann genutzt wurde nur noch
  47 ms. Das zeigt denke ich, dass es Sinnvoll ist diese Optimierung weiterzuverfolgen da es doch schon ein deutlicher Unterschied ist -
  gerade bei großen Datenmengen! (der Code wird dadurch aber leider nicht einfacher oder gar weniger :/)
- StringBufferManager hinzugefügt. Zukünftig sollten StringBuffer-Instanzen nur noch hierüber erfragt, und sobald nicht mehr benötigt
  hierhin zurückgegeben werden. Sobald man einen StringBuffer benötigt, fragt man einfach den StringBufferManager nach einer StringBuffer
  Instanz die eine bestimmte String länge halten kann... es obliegt dann dem StringBufferManager zu entscheiden ob man einen Buffer
  mit GENAU der länge zurückbekommt, oder einen Buffer der *mehr* halten kann. Es ist ebenfalls dem StringBufferManager überlassen ob
  er gerade nicht benötigte StringBuffer Instanzen buffert statt sofort zu löschen, um dann diese wiederverwenden zu können um dynamisches
  Speicher anlegen/freigeben zu reduzieren. Durch den StringBufferManager wurde hier und da die Implementation der String Klasse etwas einfacher. :D
  Die StringBuffer-Klasse hat eine statische Instanz von StringBufferManager und StringBufferManager speichert gerade nicht benötigte
  StringBuffer Instanzen zwischen - das ist momentan eher noch Experimentiell und sicherlich definitiv nicht optimal (u.a. weil die statische initialisierungs
  und deinitialisierungs Reihenfolge ja nicht festgelegt werden kann), läuft aber bereits halbwechs ordentlich und reduziert das dynamische anlegen
  und freigeben von Speicher zur Laufzeit.
-> Uff, das waren nun fast 14 Stunden am Stück mit Strings jonglieren, aber ich denke es ist schonmal besser als vorher, vorallem wurde die Implementation
   an einigen Stellen deutlich überschauberer. Das mit Strings intern mehr Speicher geben + StringBufferManager wollte ich nun schon seit Jahren mal
   ausprobieren... und da mir wiedermal aufviel wie laaaam die String Klasse stellenweise ist/war, hatte ich mich nun endlich einfach mal drangesetzt und
   es durchgezogen. Ich merke hier bei mir nun eine allgemeine leichte Performance verbesserung... wie gehofft. :D
   Morgen mal noch etwas weitertesten, aber bisher siehts so aus als ob sich durch das interne String-Refactoring (das Interface nach Außen hin hat sich
   nicht verändert!) keine total üblen Bugs eingeschlichen hätten die sofort alles zum Crashen bringen.



>> 14.11.2010
[SB]
- String::Format(): Hier gab es einen Bug, da nicht darauf geachtet wurde, dass laut Dokumentation die Funktion
  _vscprintf (und alle anderen Funktionen dieser Art) das Handle für die Argumentenliste "zerstört". Daher muss
  nach dem Aufruf von _vscprintf die Argumentenliste beendet und dann wieder neu geöffnet werden. Unter 32 Bit Linux
  sowie unter Windows gab es hier niemals irgendwelche Probleme, aber unter 64 Bit Linux stürzte das ganze hier auf
  mysteriöse Art und Weise ab. Wäre schon nett, wenn solche Dinge dann vielleicht nicht nur irgendwo in der Doku versteckt
  wären, sondern auch verlässlich abstürzen würden, damit sowas nicht völlig unentdeckt bleiben kann ;-)
  Zu diesem Fehler: http://bytes.com/topic/c/answers/572931-segmentation-fault-vsnprintf-lib64-tls-libc-so-6-a



>> 04.11.2010
[SB]
- XmlAttribute: Die Funktion sscanf_s ist eine Microsoft-Erweiterung und daher
  unter anderen Systemen nicht vorhanden. Habe das daher erstmal in sscanf()
  umgewandelt, vielleicht könnte man hier natürlich auch eine von unseren
  bereits vorhandenen Varianten verwenden, um Strings in Zahlen zu konvertieren?
  Die String-Klasse hat soetwas ja schon, alleine schon daher würde ich daher
  empfehlen, in Zukunft möglichst auf low-level String-Funktionen zu verzichten.



>> 30.10.2010
[CO]
- Wie mit Stefan besprochen: TinyXML Abhängigkeit entfernt. Das hatten wir nun bereits seit etlichen Jahren angedacht... TinyXML ist zwar
  wirklich super, aber unsere eigenen Ansprüche verändern sich über die Zeit so das immer mehr Änderungen in TinyXML nötig wurden um es in
  PL noch richtig nutzen zu können. Die XML Wrapper Schicht an sich war auch noch nie sooo toll da diese Overhead hinzufügte. Nachdem Stefan
  nun probleme beim Einladen großer XML Dateien hatte, entschlossen wir uns dazu, die TinyXML Abhängigkeit nun zu entfernen um mehr Kontrolle
  über die XML Implementation zu haben und z.B. einfacher Problemen nachgehen zu können. Der Kern des XML Parsers basiert auf TinyXML damit ich
  nicht ganz bei 0 anfangen musste und auf einen über viele Jahre hinweg ausgereiften XML Parser aufbauen kann, ich denke das die Implementation
  auf Dauer allerdings immer weiter von TinyXML abdriften wird.
  Das war nun zwar ca. 2 Tage Arbeiten an Grundlagen-Klassen, aber ich denke es hat sich gelohnt da unsere grundliegenste Komponente nun von
  einer externen lib weniger Abhängt was das Cross-Compiling etwas einfacher macht. Die erzeugte PLGeneral dll ist bei mir um 10 KB kleiner geworden
  da weniger Redundanter Code vorhanden ist (mehrere String Klassen etc. da jede lib das nochmal selbst implementiert).
  -> Weis noch nicht ob Unicode XML Dateien schon korrekt funktionieren, da müsste man etwas testen und gegebenenfalls ausbessern
  -> Das XML Laden (XmlDocument::Load) ist im Augenblick etwas langsamer als vorher da unsere String Klasse bei z.B. "sMyString +=" immer einen internen
     neuen String erzeugt... hier sollte man wohl demnächst kleinere Optimierungen machen so das der interne String immer etwas mehr Speicher belegt
     als eigentlich nötig ist, was dann aber ein performanteres anhängen von weiteren Zeichen oder kurzen Strings ermöglicht.
  -> Am XML Interface hat sich zwar nicht wirklich was großartig verändert, unter der Haupe gabs allerdings einiges an Änderungen... darum wäre es gut
     wenn jemand das nochmal kritisch durchgeht (auch z.B. die Copy-Operatoren) und testet.



>> 24.10.2010
[SB]
- Time: Wenn man Zeiten als String abspeichert, möchte man diese manchmal auch gerne wieder einlesen. Da das Format
  hier ja sehr strikt ist, dürfte dies auch ohne weiteres möglich sein, daher habe ich FromString() so implementiert,
  dass es die von ToString() ausgegebenen Time-Strings parsen kann und somit Zeiten auch als Strings übergeben
  werden können.



>> 11.10.2010
[CO]
- String: < und > Operatoren für ASCII waren fehlerhaft Implementiert. StringBuffer::IsLessThan() und StringBuffer::IsGreaterThan()
  wurden, warum auch immer, mit einer String länge von 0 aufgerufen... interessant das dies bisher noch nicht aufgefallen war, und das
  obwohl die String-Tests die umfangreichsten aller Tests sind. :/ (ok, die ASCII, UTF8 und Unicode kombinationsmöglichkeiten machen
  es nicht einfacher das möglichst Wasserdicht zu testen)



>> 20.09.2010
[SB]
- HttpServer: Methoden zum Senden von Daten nach HttpServerConnection verschoben, wo sie auch hingehören.
  Eine Server-Klasse sollten eigentlich nur Connections verwalten, die eigentliche Kommunikation
  zwischen zwei Hosts passiert aber immer in einer Connection, daher sollte die Funktionalität dieser
  Kommunikation auch dort definiert werden. Dies macht auch die Verwendung und den Zugriff auf eine Connection
  einfacher, ansonsten gibt es immer Probleme mit der Sichtbarkeit und der Vererbung von der Server-Klasse.



>> 16.09.2010
[CO]
- "PLGeneralWindows.h" um MinGW Support erweitert



>> 22.08.2010
[CO]
- Huch, die "FileWindows::CopyTo"-Implementation war fehlerhaft, die Windows Funktion "CopyFile" erwartet als zweiten Parameter,
  die Ziel URL inklusive Dateiname, übergeben wurde allerdings URL ohne Dateiname...
- "FileLinux::CopyTo" war noch nicht implementiert... selbst nach längeren Suchen konnte ich allerdings keine c-Funktion für Dateien
  kopieren finden, per Hand eine neue Datei erzeugen und dann die Daten selbst umkopieren war mir etwas zu doof...
  die jetztige Implementation über "system" ist allerdings genauso doof :/ (aber wenigstens läufts)



>> 09.08.2010
[CO]
- "UTF8Tools::GetNumOfStringBytes" um "nCount" erweitert
- "StringBufferUTF8::LastIndexOf(const char szString[]..." war fehlerhaft implementiert, daher erstmal eine funktionierende
  Lösung eingebaut, die allerdings sicherlich nicht die Effizienteste ist
- "StringBufferUTF8::GetSubstring" implementiert
-> Nun geht "Url(sFilename).GetExtension()" wenn "sFilename" ein UTF8-String ist
- "String::Compare" & "String::CompareNoCase" & "String::Insert" um UTF8 Support erweitert
- "FileWindows::Open(" um Unicode-Support erweitert
- UTF8Tools Warnungen beseitigt wo ich halbwechs sicher bin das die Beseitigung keine Seiteneffekte hat



>> 04.08.2010
[SB]
- System: GetDataDirName() hinzugefügt. Diese Methode wandelt den übergebenen Namen für das Unterverzeichnis im
  User-Data-Dir in ein für das OS typisches Format um. Aus "PixelLight" wird dann unter Linux ".pixellight", unter
  Windows wird der Name nicht verändert und bleibt bei "PixelLight".



>> 03.08.2010
[SB]
- System: GetCurrentDir() gibt das aktuelle Verzeichnis nun im Native-Format zurück statt wie bisher im URL-Format.
- System: Zusätzlich zu GetUserHomeDir() gibt es nun auch noch GetUserDataDir(). Hier wird das Verzeichnis zurückgegeben,
  in das die Konfiguration der Applikation geschrieben werden soll. Unter Linux sind Home- und Data-Dir identisch,
  unter Windows wird hier der Ordner "Anwendungsdaten" im Home-Verzeichnis zurückgegeben.



>> 02.08.2010
[SB]
- SystemLinux: GetProgramName() implementiert, so dass nun genauso wie unter Windows der absolute Pfad zur Bin-Datei
  zurückgegeben wird, gleichgültig von wo das Programm aufgerufen wurde. Der in args[0] übergebene Pfad ist leider
  relativ zur aktuellen Position und hilft daher nicht wirklich weiter, wenn es darum geht, den Pfad zu extrahieren
  um dann z.B. relativ dazu Datenpfade herausfinden zu können. Mittels der PID kann aber der absolute Pfad einer
  Applikation relativ leicht abgefragt werden. Dafür wurde nun SetProgramName() entfernt, da dies nur eine Notlösung
  war, damit den Wert aus arg[0] übergeben zu können.
- SystemLinux: GetUserHomeDir() scheint richtig zu funktionieren, daher eingebaut und TODO entfernt.
- System: GetProgramName() in GetExecutableFilename() umbenannt, da dies wesentlich eindeutiger ist.
- Log: ConsoleOutputActive in Verbose umbenannt. "Keep it simple" darf ruhig auch mal auf Namen angewendet werden :-)
- Log: Kommentare etwas überarbeitet.



>> 01.08.2010
[SB]
- Eigene Versionsnummer von PLGeneral entfernt.



>> 24.07.2010
[SB]
- ConsoleLinux: Wenn Dateibefehle verwendet werden, um auf die Konsole zu schreiben, sollte der Dateipuffer immer geleert werden, damit die
  Ausgabe sofort erfolgt. Habe daher hier fflush(stdout) hinzugefügt.



>> 17.07.2010
[CO]
- "XmlNode::GetNextSiblingElement" & "XmlNode::GetFirstChildElement": Rückgabetyp sollte XmlElement und nicht XmlNode sein



>> 15.07.2010
[CO]
- Bugfix in verschiedenen Projekten: Verwendung von XmlNode GetFirstChild/IterateChildren war Fehlerhaft da oft auf XmlElement
  gecasted wurde ohne vorher zu prüfen ob es überhaupt XmlElement ist, im Falle von XmlComment bekam man so dann einen Crash



>> 07.07.2010
[CO]
- "String::GetUInt32()": Statt "atol" wird nun "strtoul" verwendet da sich scheinbar das Verhalten von "atol"
  unter Linux/Windows unterscheidet und z.B. unter Linux das umwandeln in uint32 nicht klappte wenn die Zahlen
  zu groß waren



>> 06.07.2010
[SB]
- Bug in FileLinux::IsFile() behoben.



>> 27.05.2010
[CO]
- Log liegt wieder in PLGeneral. Diesmal allerdings in einem eigenen "Log" Verzeichnis und nicht ans RTTI angeschlossen.
  "LogFormaterConsole" entfernt, das Log kann auf Wunsch nun direkt in die Standard OS Konsole schreiben.



>> 25.05.2010
[SB]
- String::GetUInt64(): _wtoi64 gibt es leider unter Linux nicht. Habe da nun statt dessen wcstoumax() verwendet,
  welches hoffentlich die richtige Funktion dafür ist. Leider gibt es die wiederum unter Windows nicht, jedenfalls
  konnte ich das nicht finden, obwohl es eigentlich zum ISO-Standard gehören sollte, und musste darum hier leider
  eine Fallunterscheidung einbauen.



>> 24.05.2010
[CO]
- Bugfix: "ElementManager<AType>::SetElementName": Umbenannte Elemente sollten nur in m_mapElements eingefügt werden, wenn
  diese kurz zurvor ausgetragen wurden



>> 23.05.2010
[CO]
- Da der Typ "handle" als "unsigned int" definiert ist, ist es unter 64 Bit übersetzt, 64 Bit statt 32 Bit groß.
  "INVALID_HANDLE" wird daher nun 32/64 Bit abhängig definiert. (scheinbar nur für Windows nötig)



>> 22.05.2010
[CO]
- String Klasse um Operatoren für uint32 und uint64 erweitert. Unter Windows nutzte ich dafür die Erweiterungen "I32"
  und "I64", unter Linux einfach nur "u" und "llu" - habe im Code für Linux als Kommentar alternativen eingefügt die
  man eventuell noch testen könnte.



>> 20.05.2010
[CO]
- Das alte RTTI aus PLGeneral entfernt... manohman, das waren 2 verdammt heftige Wochen. Im großen und ganzen läuft nun alles
  wieder, natürlich steht nun noch weiteres Bugfixing an bis alles wieder so rund läuft wie vor der großen Umstellung. Interessant
  ist, dass es am Ende nun wirklich 2 Wochen Arbeit waren, so wie am Anfang pi*daumen geschätzt. *g*



>> 17.05.2010
[CO]
- PixelLight ist nun soweit auf das neue RTTI umgestellt, nun folgen nur noch Aufräumarbeiten & Bugfixing
- "Log" von PLGeneral nach PLCore verschoben



>> 07.05.2010
[CO]
- "Chunk" und "Localization" samt dazugehörigen Klassen von PLGeneral nach PLCore verschoben da hier RTTI Funktionalität
  benötigt wird die zukünftig erst ab PLCore zur Verfügung steht. Habe das erstmal in einem "Tools"-Unterordner gelassen.
- "Loader"/"Loadable" von PLGeneral nach PLCore verschoben
- "Resource" von PLGeneral nach PLCore verschoben



>> 21.03.2010
[SB]
- HttpClient: Fehler bei der HTTP-Authentification behoben: Benutzername und Passwort wurden falsch übermittelt, wodurch
  eine Anmeldung natürlich nicht möglich war. Ausserdem wird nun auch das HTTP-Verb "DELETE" unterstützt.



>> 14.03.2010
[CO]
- "Config", "ConfigLoader" und "ConfigLoaderPL" nach PLCore ins Application-Verzeichnis verschoben (siehe PLCore-Tagebuch
  für mehr Informationen)



>> 19.01.2010
[SB]
- ThreadLinux: Wie es aussieht, ist die Thread-Implementation unter Linux noch so gut wie unbrauchbar. Leider kenne ich
  mich mit dem Threading ja auch so gut wie nicht aus, und müsste mich da nun enorm einarbeiten, um das irgendwie brauchbar
  zu machen. Die schlimmsten Fehler habe ich nun aber erstmal korrigiert bzw. umgangen:
  - pthread_kill(m_nThreadID, SIGKILL) ist *nicht* geeignet, um einen Thread zu beenden. Das Signal beendet immer den
    gesamten Prozess, auch wenn es an einen bestimmten Thread eines Prozesses gesendet wird. Daher wurde nun bei uns jedes
    Mal das gesamte Programm beendet, wenn nur ein Thread oder z.B. ein Timer beendet werden sollte. Zum Beenden eines
    Threads verwende ich nun pthread_cancel(). Diese Fehler hat natürlich dazu geführt, dass das Programm ständig "abstürzte",
    nun macht das alles schon einen deutlich stabileren Eindruck unter Linux :-)
  - Es gibt keinen timed-join Befehl in pthreads, also einen Befehl der bis zu einem bestimmten Timeout darauf wartet, dass
    ein Thread beendet wurde. Statt dessen hatte ich hier bisher einfach join verwendet, also ohne Timeout zu warten, was dann
    aber zu einem Einfrieren der Applikation führt, wenn sich ein Thread nicht freiwillig beendet. Daher lasse ich diese
    Funktion nun erst einmal komplett fehlschlagen, damit das zumindest nicht mehr passieren kann, hier müsste dann eine
    timed-join Operation implementiert werden, wofür ich auch schon ein Beispiel gefunden habe.



>> 30.11.2009
[SB]
- Neue und umfangreiche HTTP-Implementation erstellt. Dies umfasst sowohl einen HTTP-Client, als auch einen minimalen
  Http-Server. Der Client ist um einiges umfangreicher als die alte HttpHandle-Klasse und kann HTTP/1.0 sowie HTTP/1.1.
  Damit ist auch die "Download fortsetzen"-Funktion möglich, bzw. das auslesen beliebiger Teile einer Datei, sofern der
  Server das zulässt, was die Verwendung der File-Klassen und Seek() einfacher und vor allem deutlich schneller machen
  sollte. Auch ist die Klasse ansonsten umfangreicher, z.B. werden alle HTTP-Fehlercodes verstanden und können entsprechend
  abgefragt werden etc. Daneben gibt es noch einen sehr minimalistischen HTTP-Server, der dazu verwendet werden kann, aus
  einem Programm heraus z.B. eine kleine Weboberfläche zur Verfügung zu stellen. Die Server-Klasse ist dabei eine reine
  Basisklasse, die HTTP-Anfragen entgegennimmt und weiterleitet, von sich aus aber erstmal nur eine statische Seite
  anzeigt. Die eigentliche Funktionalität muss also in der abgeleiteten Klasse implementiert werden, z.B. was für
  Seiten auf welche URLs hin generiert werden sollen. Auch ist dies kein HTTP-Server in dem Sinne, dass er Dateien von
  der Festplatte lesen und auf HTTP bereitstellen würde, da der Anwendungsfall eher auf dynamisch generierte Web-Applikationen
  abzielt (z.B. als Weboberfläche für einen Spiele-Server). Allerdings wäre es recht einfach, dies in einer abgeleiteten
  Klasse zu implementieren :-)



>> 29.11.2009
[SB]
- Time: Die Monate werden nun von 1 an gezählt, statt wie bisher von 0. Es ist einfach völlig unintuitiv, wenn nur die
  Monate ungewohnt bei 0 anfangen, der Rest aber wie gewohnt von 1 an gezählt wird. Habe das nun daher verändert und hoffe,
  dass ich alle Verwendungen in PL entsprechend korrekt angepasst habe (-1 entfernt wo nötig und +1 hinzugefügt wo nötig).
  Allerdings wurde die Time-Klasse zum Glück bisher nicht so häufig verwendet, es dürften also wohl nicht allzu viele
  mögliche Fehlerstellen jetzt vorhanden sein.



>> 25.10.2009
[SB]
- Base64-Funktion nach Tools verschoben, da man diese Funktion später noch einmal brauchen könnte.



>> 24.10.2009
[SB]
- Connection: Mir ist gerade aufgefallen, dass es nicht unbedingt immer erwünscht ist, dass eine Connection automatisch alle
  Daten ausliest, die man ihr zuschicken will. Beispielsweise bei einem HTTP-Client würde man wohl erst den Header lesen,
  und dann entscheiden, ob man die Daten ausliest oder nicht (könnten ja auch große Dateien sein). Aus diesem Grund kann
  nun per Option eingestellt werden, ob eine Connection automatisch alles liest, was ihr geschickt wird, oder ob dies
  manuell aufgerufen werden muss. Dafür die Option EReceiveMode sowie die Methoden Receive() und ReadLine() eingebaut.
  ReadLine liest Text-Daten vom Stream und gibt diese Zeilenweise zurück. Dabei wird das EOL-Zeichen nicht automatisch gelöscht,
  da dies in manchen Kontexten wichtig ist, dies muss daher ebenfalls manuell geschehen. Ebenso wird nun beim Senden von
  Strings (Send()) nicht mehr automatisch CRLF angehängt, da dies auch nicht immer erwünscht ist. Für Zeilenenden ist nun
  also die jeweilige Anwendung selbst verantwortlich.
- Buffer: Einige Fehler behoben. Beim zeilenweisen Auslesen werden nun sowohl CRLF als auch nur LF als Zeilenenden akzeptiert.
  Zusätzliche Methode GetData() eingebaut, damit man auch auf den Inhalt des Buffers zugreifen kann.



>> 23.10.2009
[SB]
- Network: Habe die Basisklassen aus PLNetwork nach PLGeneral verschoben und noch einmal gründlich überarbeitet.
  Es scheint mir sinnvoll, diese Basisklassen bereits in PLGeneral zu haben, denn mit Sockets alleine zu arbeiten
  ist ziemlich mühsam und nicht sinnvoll, deswegen sollten immer diese Basisklassen verwendet werden, wenn es darum
  geht, Netzwerkfunktionalität einzubauen. Daher ergab die Trennung hier nicht viel Sinn, und eine weitere Bibliothek
  zu verwenden stellt immer eine zusätzliche Hürde dar, daher ist es besser, diese Klassen gleich in PLGeneral verfügbar
  zu haben. Die Netzwerk-Basisklassen bieten selber nur ein minimales Framework um Socket herum an, und durch die
  Überarbeitung wurde auch alles noch einmal deutlich schlanker und eleganter, so dass letztlich nur 5 zusätzliche
  Klassen herausgekommen sind, die PLGeneral daher auch nicht unnötig aufblähen sollten :-)



>> 22.10.2009
[SB]
- String: Neue Methode RemoveLineEndings() eingebaut, die Markierungen für das Zeilenende ("\r" oder "\r\n") am
  Endes des Strings löscht. Das ist insbesondere dann wichtig, wenn in einem Netzwerkprotokoll die Zeilenenden
  entscheidend sind und daher Strings nicht gleich "bereinigt" werden sollten.



>> 20.10.2009
[SB]
- Time: Neue Methode GetDaysPerMonth() spendiert, um die Anzahl an Tagen in einem Monat abzufragen.



>> 18.10.2009
[SB]
- Habe meine alte Klasse 'HMLTParser' vom letzten Jahr wieder ausgegraben und reaktiviert :-) Diese Klasse hatte ich
  geschrieben, damit man eine HTML-Datei parsen und als Ergebnis einen XML-Syntaxbaum herausbekommen kann. Zwar hatte
  ich dann die gesamte HTML-Anwendungsidee verworfen und in dem Zusammenhang auch den Parser wieder gelöscht, aber
  da ich nun wieder einmal merke, wie praktisch es ab und zu wäre, HTML-Dateien einlesen zu können, habe ich die
  Klasse nun wiederhergestellt und noch ein wenig erweitert sowie ein paar Fehler behoben. Der Parser selbst sollte
  nun relativ robust sein, allerdings besteht natürlich immer noch keine Garantie dafür, dass er in der Lage ist, eine
  beliebige HTML-Seite fehlerfrei einzulesen. Dafür ist der HTML-Syntax viel zu unübersichtlich und es gibt zu viele Arten
  von Erweiterungen über eingebettete Scripte etc. Nun werden allerdings Kommentare und einige andere Tags von vornherein
  ignoriert, daher dürften einiger Maßen wohlformatierte Seiten jetzt eigentlich problemlos eingelesen werden können. Also
  falls man mal in irgendeinem Zusammenhang HTML-Seiten einlesen bzw. parsen muss, gibt es dafür nun eine Klasse, die man
  als Basis dafür verwenden kann.



>> 16.10.2009
[SB]
- FileObject und Url: Methoden für den Zugriff auf URLs überarbeitet. GetUrl_() in GetUrl() umbenannt, da denke ich die
  Verwendung und Bedeutung dieser Methode inzwischen klar festgelegt ist. In FileObject alle "Abkürzungen" entfernt,
  um direkt auf den Dateinamen zuzugreifen, es muss nun also immer GetUrl() verwendet werden und von dort aus weitere
  Methoden, um die URL als String zu erhalten. Ich bin mittlerweile ein Freund davon, keine unnötigen doppelten Funktionen
  irgendwo einzubauen, sondern lieber klar nur eine Möglichkeit zur Verfügung zu stellen. Das sieht zwar manchmal nicht so
  hübsch aus, ist dafür aber verständlicher und leichter nachzuvollziehen. Schließlich GetWindow(), GetLinux() etc. wieder
  in GetWindowsPath(), GetLinuxPath() etc. umbenannt, denn der Name sollte schon irgendwie darauf hindeuten, was dort
  zurückgegeben wird (auch wenn "Path" nicht ganz korrekt ist, aber hier fehlt es halt an einem eindeutigen Überbegriff für
  Pfade, URLs etc.).



>> 06.08.2009
[CO]
- "uint32" wird nun mit "__int32" definiert, das gleiche gilt für alle ähnlichen Typen
- "HashFunction" & "CompareFunction" um 64 Bit Datentypen erweitert... ansonnsten gibts Probleme wenn man in einer
  HashMap als Schlüssel z.B. "UINT_PTR" unter 64 Bit nutzen will, dann weis der Compiler nicht was er nehmen soll



>> 02.08.2009
[CO]
- "RegEx": Neue Funktion: "WildcardToRegEx()": Wandelt einen gebenen String mit Wildcard in einen String mit Regulären
  Ausdruck um
- "Map": "GetKeyIterator()", "GetConstKeyIterator()", "GetEndKeyIterator()" & "GetConstEndKeyIterator()" hinzugefügt
  damit man bei "Map" ebenfalls durch die Schlüssel iterieren kann
- "HashMapKeyIterator" & "SimpleMapKeyIterator" hinzugefügt



>> 10.05.2009
[CO]
- "ZipHandle::ReadCurrentFileInfo()": Autsch, hier hatten wir ein übles Speicherleck wenn "m_cCurFile.m_nSizeFilename"
  0 war... denn hier muss noch ein Zeichen für \0 angehängt werden. Die String Klasse übernimmt dann die Kontrolle
  über den Speicher, bekommt aber die Original Speicherlänge ohne +1 und denkt sich dann "hopala, leerer String!"
  und übernimmt dann natürlich nicht die Speicherkontrolle da der Speicher ja scheinbar leer ist. Und dann müllt
  sich der Speicher langsam mit Herrenlosen frühlich frei herumschwirrenden 1 Bytes voll.
- "ClassManager::LoadPlugin()" sollte auch mehrmals aufgerufen werden können ohne das es bereits vorhandene
  Module erneut hinzufügt, baute daher einen entsprechenden Test ein.



>> 07.05.2009
[CO]
- "BinaryHeap", "BinominalHeap" und "FibonacciHeap" hatten Fehler so das der Compiler einem kryptische Fehler nur
   so um die Ohren schlug wenn man versuchte den "Comparer" durch einen eigenen zu ersetzen



>> 01.05.2009
[CO]
- "Bitset"-Konstruktor: Beseitigte eine Inkonsistenz zu "Array" und "Resize()": Die Standardeinstellungen von
  "bAdded" und "bInit" sind nun identisch. "Bitset" wird bis jetzt zum Glück sehr selten eingesetzt so das es
  nur wenige Stellen waren die einer Prüfung bedurften. (Änderung dieser Art sind ja immer sehr heikel :/)
- "Bitset" um superkomplexe "Reset()"-Funktion die es ebenfalls auch in "Array" gibt erweitert... setzt einfach
  die aktuelle Anzahl an Elementen auf null so das es einem "Clear()" gleichkommt, aber deutlich schneller ist da
  der angelegte Speicher erhalten bleibt. (hin und wieder sehr praktisch soetwas :)



>> 26.04.2009
[CO]
- "SystemWindows::GetOS()" erkennt nun auch Windows 7



>> 22.04.2009
[CO]
- Änderte einige Methoden der String-Klasse minimal so das die heute von Stefan festgestellten unschönheiten beseitigt sind



>> 22.04.2009
[SB]
- RegEx: Workaround eingebaut, da String::Copy() mit der Länge 0 den gesamten String zurückgibt anstelle der leeren Strings ("").
  Ich denke dies sollten wir dringend überarbeiten, denn dieses Verhalten ergibt zwar Sinn, wenn man 0 nur als Defaultwert,
  sprich als "nicht angegeben" betrachtet, verhindert aber, dass man den Wert 0 als tatsächliche Länge eines Substrings angeben
  kann. Und dies führt zu einem sehr ungewöhnlichen Verhalten, denn wenn ich z.B. alle Prefixes alles Strings mit sowas wie
  for (int i=3; i>=0; i--) sPrefix = sString.GetSubstring(0, i); abfrage, würde ich wohl eher ["abc", "ab", "a", ""] erwarten
  als ["abc", "ab", "a", "abc"] (siehe Test99).



>> 22.04.2009
[CO]
- "File": Neue Funktion: "GetMemoryBuffer()": Falls die Datei "im Speicher liegt" kann man sich hiermit direkt einen Zeiger auf
  den Speicher geben lassen. Ist zwar irgendwie "unschön" aber "praktisch" da man dadurch in einigen Fällen die Performance
  in Anwendungen verbessern kann... denn wenn man "weis" das eine Datei bereits komplett im Speicher liegt und man die Datei im
  Speicher braucht um diese mit anderen Funktionen weiterzuverarbeiten - dann muss man nun nicht mehr einen "Zwischenbuffer"
  erzeugen, die ganze Datei "einlesen", Arbeit erledigen und "Zwischenbuffer" wieder freigeben... sondern man nutzt direkt
  den bereits die bereits im Speicher liegende Datei. :D



>> 15.04.2009
[CO]
- Spendierte der "File"-Klasse einen weiteren Konstruktor dem man einen Buffer übergeben kann... was hin und wieder
  ziemlich praktisch ist da "Dateien" dann nicht zwanghaft direkt von der Festplatte kommen müssen.
- "Base::SetVars()": In meinem Regulären Ausdruck war noch ein böser Fehler drinnen so das beim Wert ' am Ende stehen konnte...
  generell hab ich hier noch etwas Probleme mit " und ' richtig erkennen und habe das momentan etwas umständlich gelöst -
  Stefan... falls du ne Idee hast wie man das alles zusammen in einem netten Ausdruck vereinen könnte... :D



>> 12.04.2009
[SB]
- System: Exit() hinzugefügt, um die Applikation sofort beenden zu können. Dies ist natürlich nur ein Wrapper für die jeweilige Systemfunktion.



>> 11.04.2009
[SB]
- CommandLine erweitert, um möglichst viele der üblichen Kommandozeilen-Optionen abzudecken. Ich hoffe mal, mit dieser
  aufgebohrten Klasse kommt man weit genug und kann auch komplizierte Kommandozeilen-Optionen definieren, damit man da
  möglichst nicht ständig wieder einen eigenen Parser schreiben muss. Es gäbe natürlich noch viel mehr Möglichkeiten, aber
  alles abzudecken wäre wirklich zu kompliziert und daher nicht mehr sinnvoll. Auch ist zu beachten, dass diese Klasse nun
  zwar vieles erlaubt, aber nicht alles auch auf Plausibilität prüft (z.B. beim Festlegen von benötigten und optionalen
  Parametern). Hier muss der Programmierer also noch selber darauf achten, dass er nicht unsinnige oder wiedersprüchliche
  Angaben macht. Die Änderungen im Detail:
  - Es gibt nun drei Typen von Optionen: Flags, Parameter und Argumente.
  - Ein Flag besteht nur aus einer Option (z.B. '-a' oder '--optiona') ohne weiterem Argument dahinter und
    kann einen kurzen sowie einen langen Namen haben.
  - Ein Parameter besteht aus einer Option und einem Argument dahinter (z.B. '-n <name>' oder '--name <name>').
    Die Möglichkeit, dass dieses Argument optional ist, besteht *nicht* (ich finde aber auch nicht, dass man das braucht).
  - Ein Argument wird ohne ohne Option davor angegeben (z.B. "app.exe <name>"). Hierbei werden die registrierten Argumente
    der Reihe nach durchgezählt, das erste angegebene Argument entspricht dem ersten in der Liste usw. Alle weiteren
    übergebenen Argumente werden in einer zusätzlichen Liste gespeichert und können über GetAdditionalArgument() abgefragt
	werden.
  - Alle Optionen können nun einen logischen Namen bekommen, z.B. "Name" für "-n" oder "--name". Das macht das Abfragen
    der Optionen einfacher und erlaubt es auch, die Flags später zu verändern aber den logischen Namen dabei beizubehalten,
    wodurch man weniger im Code ändern muss. Bei Parametern wird dieser Logische Name auch in der Hilfe mit angezeigt
    (z.B. --name <name>).
  - Optionen können nun zusätzlich noch als "Required" definiert werden. In diesem Fall wird es als Fehler gewertet, wenn
    die jeweilige Option beim Starten des Programmes nicht angegeben wurde, weshalb dann das Programm nicht gestartet und
	statt dessen der Hilfetext ausgegeben wird.   
  - CommandLine::ShowHelp() an die Änderungen angepasst und erweitert. Alle Parameter werden geordnet angezeigt, unterteilt
    in Argumente und Optionen. Habe mich dabei an möglichst übliche Darstellungen gehalten, z.B. steht <arg> für ein
    benötigtes Argument, [arg] für ein optionales. Am Anfang wird eine kurze Zusammenfassung (Synopsis) ausgegeben, hierbei
    wird auch der Dateiname des Programmes mit ausgegeben.



>> 10.04.2009
[CO]
- "Loader::OpenFile()"-Implementation etwas geändert so das weniger "File::IsFile()" aufrufe gemacht werden
 (langsam da Datei zugriff)
- "RegEx" etwas optimiert: "m_lstGroups" ist nun ein "Array", dadurch kann man von der schnellen "Reset"-Methode
  profitieren
- "Base::SetVars()" arbeitet nun mit Regulären Ausdrücken statt mit dem Tokenizer... und ist laut meinen intensiven
  Benchmarks die ich momentan betreibe sogar deutlich flotter. ("246 ms" statt "356 ms" Ladezeit in einem Projekt
  mit größerer Szene :)
  "static RegEx ..." mag zwar nicht Thread-Safe sein, aber das ist PixelLight in seiner Gesammtheit derzeit ohnehin
  nicht und das Beschleunigt die Sache. (ohne "static" beim Projekt von oben "280 ms"... und hier kommts wirklich
  knadenlos auf jede Millisekunde an :/)



>> 08.04.2009
[CO]
- Da das RTTI so grundliegend ist und sehr intensiv genutzt wird machte ich ein paar vorsichtige Optimierungen um
  soviel Performance wie möglich rauszuholen. (muss leider sein :/) Die Änderungen hab ich einige male durchdacht
  und genau geprüft damit ich blos nix klaput mache... Stefan, bitte zur Sicherheit auch nochmal überfliegen.
- "ClassManager::RegisterClass()": Das langsame durchgehen der 'm_lstClasses'-Liste ob die Klasse schon
   Registriert ist kann man sich sparen, 'm_mapClasses'-Test reicht völlig... + der Listen-Test brachte in
   meinen Tests immer das gleiche Ergebniss (nicht in Liste)
- "Class::HasBaseClass()": Hier braucht man keine Klassen-Namen vergleichen sondern kann direkt Klassen-Zeiger
   vergleichen, in der "String"-Variante wird der Test direkt Implementiert um einen Funktionsaufruf zu sparen
- "Base::IsInstanceOf()": Hier braucht man keine Klassen-Namen vergleichen sondern kann direkt Klassen-Zeiger
   vergleichen, in der "String"-Variante wird der Test direkt Implementiert um einen Funktionsaufruf zu sparen



>> 05.04.2009
[CO]
- "Tokenizer::StreamIsString()" nach "BufferedReader::IsString()" verschoben, dadurch kann man ein internes
  'GetSubstring()' nur für String vergleichen vermeiden (... performance...)
- "Tokenizer::StreamRead()": "m_nPosition++" aus der Schleife gezogen und zu "m_nPosition += nCount" gemacht
- "Tokenizer": "EndOfLine"-Definition für "\n" hinzugefügt damit man statt 'm_sEndTag = "\n"' einfach
  "m_sEndTag = EndOfLine" schreiben kann was um einiges Effizienter ist da keine dynamische Speicherbehandlung :D
- "String": Das zuweisen von "char" oder "wchar_t", sprich einzelnen Zeichen optimiert so das wenn die Situation
  es zulässt man keine dynamische Speicherbehandlung braucht
- "String": "GetChar()", "GetWideChar()", "GetInt()", "GetLong()", "GetFloat()" und "GetDouble()" Implementation
  überarbeitet damit so effizient wie möglich (keine xxx Funktionsaufrufe etc.)
- "StringBufferUnicode" & "StringBufferUnicode" & "StringBufferUTF8": Entfernte die "GetString()"-Methode da im
  grunde nur ein Umweg (= balast) in einem String-System das 'sehr eng verdrahtet' ist



>> 27.03.2009
[CO]
- "Bitset": Neue Funktion: "GetNumOfSetBits()": Gibt die Anzahl der auf "true" gesetzten Bits zurück



>> 25.03.2009
[CO]
- "Loader::OpenFile()" muss es natürlich auch erlaubt sein Dateien beim Speichern neu zu erzeugen, hm, merkwürdig das dies
  bis jetzt noch nicht aufgefallen war...
- "Loader::OpenFile()" sollte natürlich auch ohne eingetragene "Basis Pfade" funktionieren, tat es aber bis jetzt nicht



>> 11.02.2009
[CO]
- Bitset: 'GetNumOfIntegers()' & 'GetIntegers()' hinzugefügt damit man an die interne Datenrepräsentation rankommt...
  was hin und wieder hilfreich sein kann...



>> 06.02.2009
[CO]
- 'DynLib': Neue Funktion 'GetAbsPath()' -> Gib den absoluten Pfad der geladenen Dynamischen Bibliothek zurück



>> 30.01.2009
[CO]
- 'Singleton': 'DestroyInstance()'-Funktion hinzugefügt mit der man manuell die Zerstörung der Singleton-Instanz
  'befehlen' kann. Da das Singleton normalerweise erst 'gaanz am Ende automatisch' zerstört wird kann es zu
  problemen kommen wenn man eine Anwendung schreibt die in eine andere Eingebettet ist... + so kann man nie die
  von VC angebotenen Speicherleck Tests nutzen da dann immer angemeckert wird es gäbe ein Speicherleck da die
  Singletons erst nach dem Test freigegeben werden. Auf dauer sollten wir versuchen soweit möglich komplett auf
  Singletons zu verzichten... (einfach weil man nicht wirklich Kontrolle über erzeugung und löschung hat :/)



>> 26.01.2009
[SB]
- ChunkLoaderPL: Fehler behoben, wodurch sich das Projekt unter Linux nicht mehr übersetzen ließ.
  Statische Member einer Klasse müssen *immer* in einer .cpp Datei definiert werden, da diese als
  Symbol exportiert werden. Nur im Header einfügen reicht nicht aus, da dann ein "undefined external
  symbol"-Fehler ausgelöst wird, wenn von ausserhalb der Projektes versucht wird, auf dieses Symbol
  zuzugreifen. Also bitte bei statischen Members immer eine Definition in einer .cpp Datei hinzufügen
  (einzige Ausnahme sind Templates, da der Compiler das hier automatisch macht), oder statt dessen enums
  verwenden.



>> 25.01.2009
[CO]
- 'GetHexValue()' aus einem von Stefans Projekten nach 'ParseTools::ParseHexValue()' verschoben da man das durchaus öfters mal brauchen kann



>> 22.01.2009
[CO]
- 'Chunk'-Klasse hinzugefügt die z.b. zum speichern von Keyframes genutzt werden kann



>> 14.01.2009
[SB]
- FileLinux: Die Klammerung war hier falsch, weshalb Verzeichnisse nicht mehr richtig erkannt wurden. Darum funktionierte PLProject nicht
  mehr richtig. Habe hier gleich die Fehlermeldungen ein wenig erweitert. Keine Ahnung, warum das noch nicht früher aufgefallen ist ...



>> 01.01.2009
[CO]
- 'Timing::CheckUpdate()': Hier kann man nun optional einen Parameter übergeben der im Falle eines FPS Limits zurückgibt wie lange man noch
  warten muss bis es Zeit für das nächste Update ist. So kann man direkt diesen Wert für 'Sleep' nutzen anstatt '1'.
- 'Timing::Update()': FPS Limit wird nun auch ausgeführt wenn gerade 'freezed' aktiv ist



>> 29.11.2008
[CO]
- Var: 'GetFlagsFromString()' & 'GetStringFromFlags()' public gemacht da man diese Funktionalität auch von außen brauchen kann
- Da wir überall 'PL_VAR_FLAGS' als 'uint32' handhaben stellte ich die paar Stellen die 'int' nutzten hier auch auf 'uint32' um... macht nicht
  wirklich einen unterschied da beides 32 Bit, aber so ists konsequent. :D



>> 28.09.2008
[SB]
- CmdLineParser durch die neu implementierten Klassen CommandLine und CommandLineOption ersetzt. Das Prinzip bleibt zwar
  das gleiche, die Schnittstelle von CommandLine entspricht jedoch mehr unserem üblichen PL-Style als dies bei CmdLineParser
  der Fall war. So können bspw. die einzelnen Optionen über die Methoden AddOption und AddFlag hinzugefügt werden, anstatt wie
  bisher alles in einen recht kryptischen String zu packen, der erst einmal geparsed werden musste. Optionen, die sowohl einen
  kurzen als auch einen langen Namen haben, gehören nun auch direkt zusammen. Zusätzlich wird noch eine Beschreibung zu jeder
  Option gespeichert, was dazu benutzt wird, um automatisch einen Hilfetext auszugeben, in dem alle vorhandenen Optionen
  aufgezählt werden. In Verbindung mit dem Application-Framework können damit nun sehr einfach Kommandozeilenoptionen
  verwaltet werden, was ingesamt einen sehr guten Eindruck machen sollte, wenn jede PL-Applikation solche Standardfunktionen
  schon bietet, ohne das der Programmierer sich groß darum kümmern muss. 



>> 24.08.2008
[CO]
- System: GetPlatform() gibt wieder 'Win32' oder 'Win64' zurück statt 'Windows' da hier eine feinere Unterscheidung z.B. beim Plugins laden
  hilfreich ist. Unter Linux wird derzeit wie gehabt 'Linux' zurückgegeben, ob wir hier dann auch 32/64 Bit unterscheidungen brauchen müssen
  wir uns später mal genauer anschaun.



>> 23.08.2008
[CO]
- Wo sinnvoll 'Win32' zu 'Windows' gemacht da für 32 Bit als auch für 64 Bit



>> 22.08.2008
[CO]
- Der 64 Bit Support von PLGeneral funktioniert nun. CMake Dateien schau ich mir als nächstes an + ein paar Dinge müsste man
  wohl umbenennen damit es 'Sauber' ist. 'SystemWin32' z.B. zu 'SystemWindows' da es für 'Win32' und 'Win64' nutzbar ist. :D



>> 21.08.2008
[CO]
- Fing an mich mit 64-Bit Support auseinander zu setzen. 'WIN64' wird zusätzlich als Precompiler Definition hinzugefügt.
  Bei zumindestens schonmal einer Stelle, und zwar in SystemWin32::GetCPUMhz() muss man nun mit 'WIN64' eine Fallunterscheidung machen.



>> 20.08.2008
[SB]
- HTMLParser wieder entfernt, da mir das alles nicht robust genug ist. Um Texte anzuzeigen, wird nun ein eigenes
  XML-Format verwendet, da muss man nicht die ganzen HTML-Probleme mit sich herumschleppen und das war auch relativ
  schnell und einfach implementiert. Für "echtes" HTML kann man dann evtl. später auf vernünftige Bibliotheken setzen.



>> 12.08.2008
[CO]
- Ich entschloss mich dazu die "SimpleList"-Implementation noch ein Stück radikaler zu machen... und hier auch keine virtuellen Funktionen
  einzusetzen so das nochmal 4 Byte für die Virtuelle-Tabelle wegfallen. Eine leere "SimpleList" Instanz ist nun also nur noch 4 Byte groß.
  "Iterable" und "Container" Funktionen sind wie gehabt da und lassen sich genauso nutzen, auch sind weiterhin Funktionen drinnen die
  Daten von "Container" übernehmen können - nur kann man "SimpleList" nicht mehr auf "Container" oder gar "Iterable" casten. Da Sinn
  und Zweck dieser Implementation jedoch ist "so Speichereffizient wie irgend möglich sein", kann man das denke ich rechtfertigen
  das diese Klasse etwas aus der "Container"-Reihe tanzt.
- Die internen Daten von "SimpleList" sind nun von außen Zugreifbar für maximale Optimierungs möglichkeiten. Das ist zwar sehr unschön
  und Riskant - aber diese Klasse sollte man eh nur nutzen wenn man genau weis was man will und warum. Die Vorteile überwiegen hier
  wie man in PLCore::Event sehen kann die Nachteile finde ich.



>> 11.08.2008
[CO]
- Bugfix: Directory::CreateRecursive(): Hier muss auf jedenfall noch 'GetRoot()' (zur Sicherheit fügte ich auch noch 'GetProtocol()' ein)
  beim Pfad vorne eingefügt werden - sonst kann es schnell zu Problemen kommen wenn ein absoluter Pfad übergeben wurde. Viel mir
  gerade im 3ds Max Scene Exporter auf als 'neben' den gewünschten Verzeichnissen auch noch 'sollten nicht da sein'-Verzeichnisse
  erzeugt wurden.



>> 10.08.2008
[CO]
- "SimpleList" angelegt. Da "List" einige Daten speichert um diverse Operationen zu beschleunigen, aber in ein paar Situationen
  man diese Operationen nicht braucht und lieber eine 'super Speicherschonende' Liste hätte gibts nun "SimpleList". Startpunkt
  war "List" das ich schrittweise Umformte:
  - 'm_nNumOfElements' raus
  - 'm_pLastElement' raus
  - 'ListElement::pPreviousElement' raus
  -> dadurch ist SimpleList 8 Byte wenn leer im gegensatz zu "List" 16 Byte leer.



>> 09.08.2008
[CO]
- "PLGeneralStat.vcproj": Gib seine Objekt-Dateien nun in ein eigenes Build-Verzeichniss aus. Ich hatte in letzter Zeit ständig
  Linker fehler beim übersetzen - jetzt weis ich auch warum. :D
- MODULE_LICENSE() hinzugefügt für die Angabe der Lizenz. Mir war es wichtig das diese Information allerdings auch direkt im Modul
  Abrufbar ist - z.B. damit man über ein Plugin-GUI dann das dort auch bequem sehen kann.
- In Funktionen wie z.B. "ModuleID<T>::SetModuleName()" war der 'Überlaufschutz' nicht korrekt Implementiert, so müsste das nun
  korrekt sein



>> 08.08.2008
[CO]
- Loadable::Reload(): Funktionierte unter umständen nicht korrekt da direkt eine Referenz auf einen 'internen' String übergeben
  wurde der während des Ladevorgangs verändert werden kann - und schon klappte das Neuladen nicht mehr. (altbekanntes "Problem" :)



>> 23.07.2008
[CO]
- Neue System-Funktion: 'GetUserHomeDir()' liefert das 'Home Directory' des aktuellen Benutzers zurück - dort kann/sollte
  man dann immer Dinge wie Konfigurationen, Screenshots etc. speichern so das dort wo das eigentliche Programm gespeichert
  ist NICHTS dynamisches gespeichert wird. Das ist unter Unix scheinbar so gängig + unter Vista wird da wie es aussieht
  auch Wert drauf gelegt... jedenfalls muss man dort dann erst Verzeichnissattibute ändern bevor Logs etc. im Programm
  Verzeichniss geschrieben werden können...
  -> PLGeneral ist dadurch nun auch von 'Userenv.lib' Abhängig, das sollte aber kein Problem sein. Man hätte sicherlich
     auch irgendwie in der Registry herumfummeln können, was aber nicht ganz so prall sein soll - dann lieber gleich
     Funktionen die das OS dafür bereitstellt nutzen. :D
  -> Linux Implementation 'müsste so passen', aber da ich es nicht testen konnte ist es Auskommentiert.



>> 21.07.2008
[SB]
- HTMLParser implementiert. Diese Klasse liest eine HTML-Datei ein und erzeugt daraus ein XML-Dokument. Besonders robust ist
  der Parser sicherlich nicht, allerdings habe ich versucht, viele typische Fehler in HTML-Dateien (z.B. falsch geschlossene Tags
  oder gemischter HTML und XML-Syntax) zu berücksichtigen, so dass die Datei dennoch eingelesen werden kann. Die Klasse ist
  aber ein reiner Parser und beinhaltet keinerlei HTML-Semantik (was heißt, dass semantische Regeln, wie z.B. <li> kann nur in
  Listen vorkommen oder <tr> nur in Tabellen, nicht überprüft werden können). 



>> 18.07.2008
[CO]
- ClassManager::LoadPlugin(): Um Format Versions Informationen erweitert ('plugin'-Dateien)



>> 10.07.2008
[CO]
- ConfigLoaderPL & LocalizationLoaderPL: Um Format Versions Informationen erweitert



>> 09.07.2008
[CO]
- LoadableManagerLoaderPL: Um Format Versions Informationen erweitert. So wird es Zukünftig dann in all unseren XML Formaten gehandhabt.
- Loader: Ein paar 'Standard Strings' hinzugefügt



>> 08.07.2008
[SB]
- Statische Version von PLGeneral hinzugefügt. Ich denke, PLGeneral und evtl. später noch PLGui sollten erstmal als statische
  Bibliotheken ausreichen, damit man kleine Tools auch ohne Abhängigkeit von der PixelLight-Runtime schreiben kann (gerade
  auch wichtig für unsere internen Tools).



>> 22.06.2008
[CO]
- System Klasse um 'GetCurrentThread()' erweitert - das nutzen wir in verschiedenen Vorlesungen des öfteren mal und kann ganz hilfreich sein.
  Rauszufinden wie man diese Funktion intern realisieren kann war allerdings etwas - knifflig. Leider scheint es weder bei Windows
  noch bei Linux möglich zu sein an die Funktions Parameter zu kommen die man einem Thread beim erzeugen gegeben hat. Daher muss man
  das leider etwas umständlicher anpacken um an die PixelLight Thread Instanz des aktuellen Threads zu kommen:
  - Unter Windows lässt sich das mit 'Thread Local Storage' (TLS) realsieren, bis auf die unschöne Globale Variable ganz ok würd ich sagen
  - Unter Linux kann man dafür denke ich 'pthread_getspecific()' nutzen (fand das zuerst, und schaute dann obs unter Windows etwas
    ähnliches gibt :)
  Ich habe das direkt mal in 'PLPhysics::WorldThread' ausprobiert, klappt ganz wunderbar. :D
  Sobald die Linux Variante Implementiert ist würde ich gerne 'System::Sleep()' wieder nach 'Thread::Sleep()' verschieben da es für mich
  einfach dorthin gehört und man es in 'neuen Sprachen' wie Java oder C# ebenfalls in der Thread Klasse findet was ich sehr nett finde. Zwar
  ist 'System::GetInstance()->Sleep(100)' 'kompakter' zu schreiben als 'System::GetInstance()->GetCurrentThread()->Sleep(100)', aber irgendwie
  ist das einfach eine Thread Verwaltungs Funktion die für mich nix in der 'allgemeinen System'-Klasse zu suchen hat, auch wenn man diese auf
  dem aktuell laufenden Thread ausführt. Bei Zeiten würde ich dann auch noch gerne eine 'Thread::Yield()'-Funktion hinzufügen damit wir die
  meisten gängigen Thread Funktionen haben.
- Threads können nun auch einen von Menschen lesbaren Namen haben, gerade beim Debugging oder Thread Experimenten ist das sehr hilfreich
- Neue System Funktion: 'Yield()' -> veranlasst im Normallfall den aktuellen Thread den Prozessor aus der Hand zu geben, ebenfalls eine gängige
  Funktion. Habe das erstmal in die System Klasse eingebaut da dort auch die 'Sleep()'-Funktion ist. Hier müssten wir uns wie gesagt nochmals
  überlegen ob wir das wirklich in der System Klasse lassen wollen oder nicht lieber in die Thread Klasse schieben damit die Thread Dinge
  beisammen sind... auch wenn diese Funktionen auf den 'aktuell laufenden Thread' arbeiten und nicht auf die Thread Instanz was ein klein wenig
  verwirrt, aber das ist auch bei Java und C# so. (im aktuellen Semester habe ich wie gesagt sehr viele Vorlesungen die sich mit Threads in
  verschiedensten Sprachen befassen :) Wir müssen uns das nicht sofort nochmal anguckn ob wir das in der System Klasse haben wollen oder das so
  machen wie es mittlerweile viele API's handhaben und das den "Umstieg auf PixelLight" etwas einfacher machen könnte. :)



>> 01.06.2008
[SB]
- RTTI: Es war immer noch ein Fehler beim Registrieren von Klassen vorhanden. Wenn die Liste der auf ihre Basisklassen
  wartenden Klassen durchgegangen wird, muß die Suche neugestartet werden, damit alle abgeleiteten Klassen auch initialisiert
  werden können. Hier war ein saublöder fehler drin, wodurch die Klassen meistens nicht initialisiert wurden.
  Aus irgend einem Grund ist die Reihenfolge der Initialisierungen unter VC anscheinend ziemlich optimal, so dass dieser
  Fehler da nicht wirklich aufgefallen ist - solange die Klassen in der richtigen Reihenfolge initialisiert werden
  (z.B. erst SceneNode, dann SceneContainer, dann SCPhysics) funktioniert ja alles korrekt. Beim Übersetzen mittels
  CMake ist die Reihenfolge, in der compiliert und gelinkt wird, jedoch eine andere, deswegen fiel der Bug hier ins Gewicht
  und beim Ausführen konnten Klassen nicht gefunden werden, da diese nicht richtig am RTTI angemeldet wurden.
  Ich habe jetzt keine Probleme mehr feststellen können, auch wenn ich mit CMake das Übersetzen starte, funktionieren hinterher
  alle Samples korrekt und das dubiose Problem, dass z.B. "SceneNode" nicht gefunden wird, ist nicht mehr vorhanden. Ich hoffe
  mal, dass dies auch meine Probleme unter Linux löst (dort wurden die Loader nicht gefunden, dürfte ziemlich sicher das
  gleiche Problem gewesen sein). 
- RTTI: Da es sehr blöd ist, das RTTI zu debuggen, wenn es aus irgend einem Grund nicht richtig funktioniert, und man hier
  auch nicht einfach ins Log schreiben kann, da dies ebenfalls schon ein funktionierendes RTTI voraussetzt, habe ich ein neues
  Makro eingebaut, um das RTTI zu debuggen. Normaler Weise ist das deaktiviert, wenn man es aber aktiviert, werden RTTI-Aktivitäten
  mit einfachen stdio-Methoden in einer festgelegten Datei (C:\rtti.txt) geloggt. Das dürfte es etwas vereinfachen, Problemen
  mit dem RTTI auf die Schliche zu kommen.



>> 22.05.2008
[CO]
- 'Informer' und 'Listener' Templates entfernt da wir zukünftig wie von Stefan vorgeschlagen auf das 'Event'-Konzept setzen das ich mittlerweile
  auch sehr nett finde. Diese zwei Templates wurden nur von 'SceneNode' und 'SceneQuery' innerhalb von 'PLEngine' verwendet, hier werden nun
  'Events' genutzt.



>> 16.05.2008
[CO]
- Wie besprochen liegen System Konsolen Funktionen nun in einer eigenen Klasse die man über 'System::GerInstance().GetConsole()' bekommt
- XML-Klassen: Interessant. Mir viel gerade als ich Stefans Änderungen durchschaute zum ersten mal das 'XmlDocument::SetTabSize()' beim speichern
  überhaupt keine Auswirkung hat da intern immer direkt "    " geschrieben wird. Als ich in den TinyXML Codes nachschaute sah ich das die
  das ebenfalls vergessen haben... oder es warum auch immer gewollt ist. Bei uns ist das jedenfalls nicht gewollt da ich keinen Grund finden
  kann warum die 'XmlDocument::SetTabSize()'-Einstellung ignoriert werden sollte. Darum ging ich die Funktionen die speichern nochmal durch
  und korrigierte das + nutzte '' anstatt "" wo nur ein Zeichen genutzt wird. (die String Klasse kann damit etwas Effizienter arbeiten :)
- XmlNode::GetDocument(): Auch hier war noch ein fieser Bug drinnen. Wow, Respekt, dieses Kerlchen hat sich aber ziemlich lange tapfer im
  Code halten können. *g*



>> 17.04.2008
[CO]
- SystemWin32::GetCurrentDir(): Gab das Verzeichniss 'Native' zurück. Da in der Dokumentation nix steht und in Programmen normalerweise
  wenn immer möglich nicht mit 'Native' gearbeitet werden sollte änderte ich das. Dies merkte ich durch 'LoadableType::GetRelativeFilePath()'
  das nicht mehr korrekt ging da alle Basis-Pfade im LoadableManager ein Protokoll vorne haben, aber das von 'System::GetCurrentDir()'
  keines hatte was hier nicht wirklich hilfreich ist. :D
- 'LoadableType::GetRelativeFilePath()': Da 'SystemWin32::GetCurrentDir() & CO' am Ende keinen Slash haben musste hier nun an einer Stelle
  '+1' eingefügt werden. Nun arbeitet diese Funktion wieder korrekt.



>> 05.04.2008
[SB]
- PLMain so umgeändert, dass man nun immer den Dateinamen und die Parameter übergeben bekommt. Das wird so auch
  an die Application-Klasse weitergegeben, so ist das einheitlich und man braucht sich nicht mehr zu fragen, ob
  Parameter[0] jetzt der Dateiname ist oder der erste Parameter. Damit dies unter allen System vernünftig funktioniert,
  waren noch ein paar Anpassungen nötig. Man könnte nun überlegen, die Funktion GetProgramName() aus System herauszunehmen,
  damit man das nicht doppelt hat. Natürlich könnte man das dann nur noch nutzen, wenn man auch die Application-Klasse
  nutzt (was man allerdings tun sollte, da es nur Vorteile bringt).



>> 05.04.2008
[CO]
- ThreadLinux: Speichert intern das vom Benutzer gesetzte 'PriorityClass' und 'Priority' damit sich das rein von den Rückgabewerten
  her wie unter Windows verhält. Linux selbst hat eine Funktion Namens 'pthread_setschedparam' zum setzen der Thread Priorität - allerdings
  ist 'SCHED_OTHER' als Default-Strategie gesetzt und in dem Fall sind keine Thread Prioritäten zulässig da dies komplett der Kernel
  übernimmt. Damit hat sich das mit den Thread Prioritäten unter Linux also erledigt.



>> 05.03.2008
[SB]
- Mußte die Verwendung des Null-Objektes noch etwas verändern: In (Standard-)C++ ist es nicht erlaubt, statische Member
  über Objekte anzusprechen. So etwas wie m_lstObjects->Null geht also nicht, es muß List<Object>::Null heißen. Leider
  scheint Visual C++ immer noch nicht standardkonform zu sein, da es hier keinerlei Fehler oder Warnungen gab. Für den
  gcc dagegen ist m_lstObjects->Null ganz einfach unbekannt. Habe alles angepaßt und hoffe, dass es nun so unter beiden
  Compilern funktioniert.



>> 05.03.2008
[CO]
- Wie besprochen geben nun die Container Referenzen statt Zeiger zurück... die Klassen waren schnell verändert, das hatte
  ich gestern bereits fertig -  alle Projekte entsprechend anzupassen war allerdings 'etwas' mehr Aufwand der sich allerdings
  definitiv gelohnt hat. Stellen wo Zeiger genutzt werden müssten unproblematisch sein da soetwas wie 'if (!...)' oder nur
  'if (...)' weiterhin klappt. Sollte allerdings in den Containern ohne Zeiger gespeichert sein, so können diese Abfragen
  teils immer noch übersetzt werden - aber das was abgefragt wird ist dann nicht mehr ob das zurück bekommene Element gültig
  ist, sondern dann wird direkt der Wert dieses Elements getestet. Bei soetwas wie 'int' gespeichert meckert das dann natürlich
  der Compiler nicht an - das kann ganz böse nach hinten losgehen. Eine solche Stelle fand ich bereits, aber um 'alle' zu finden
  müssen wir überall wo Container genutzt werden ohne Zeiger nochmal suchen und durchschauen. :/
  Bin schon schwer gespannt was ich so alles übersehen habe... entweder findet es Stefan oder die Zeit. *g*



>> 03.03.2008
[SB]
- Neuer PLGeneral-Datentyp 'handle'. Es ist irgendwie blöd, ständig auf uint32 casten zu müssen oder gleich
  void-Pointer zu übergeben, wenn es um System-Handles geht. Meistens sind diese auf einem System immer vom
  gleichen Datentyp, bei Windows wird HANDLE (DWORD) verwendet, bei Linux ist es meistens int. Daher definiere
  ich das nun in einem PLGeneral-Datentyp 'handle', der für alle Systemhandles verwendet werden soll. Ebenfalls
  wird auch INVALID_HANDLE je nach System für ungültige Handles definiert. Dieser Datentyp sollte nicht häufig
  Verwendung finden, aber manchmal braucht man eben auch die Möglichkeit, über unsere Datentypen wieder an
  System-Handles heranzukommen. Das können wir nun über diesen Datentyp machen, anstatt das völlig undefiniert
  zu lassen oder für verschiedene Situationen unterschiedliche Datentypen zu definieren (wie früher MODULE_HANDLE).
- FileStdStream erweitert: Es kann nun entweder ein beliebiger Stream-Pointer übergeben werden (FILE*),
  oder ein File-Handle des jeweiligen Systems (int unter Linux, HANDLE unter Windows). Falls ein File-Handle
  übergeben wird, muß hinterher die Datei noch geöffnet werden, wobei die bekannten Flags (Read/Write/Text/etc.)
  verwendet werden können. Im Falle eines FILE*-Pointers müssen die Access-Flags, die verwendet wurden um die Datei
  zu öffnen, mit übergeben werden. Somit ist es möglich, eine beliebige bereits geöffnete oder sonstwie zurückgegebene
  Datei trotzdem über unseren File-Wrapper anzusprechen. Die Standard-Streams (in/out/err) sind da nur ein Beispiel,
  es können jetzt aber auch beliebige andere Dateien oder Pipes so verwendet werden.
- Statt void* wird nun FILE* übergeben, da dieser Datentyp feststeht und sich auch nicht je nach System unterscheidet.

  Da dadurch jetzt leider schon in File <stdio.h> benötigt wird, habe ich die FILE-Vordefinition in eine eigene
  Headerdatei ausgelagert, wo nach Windows und Linux unterschieden wird. Damit wird <stdio.h> wirklich nur da
  eingebunden, wo es unbedingt nötig ist, ohne die Includes überall mit #ifdef's zu verunstalten :-)
- File: Konstruktoren zum Öffnen schon vorhanderer Streams/FileHandles via FileStdStream eingebaut bzw.
  öffentlich gemacht.
- File: IsOpen() hinzugefügt
- Überall Writeable durch Writable ersetzt. Es scheint zwar beides richtig zu sein, aber writable ist mir irgendwie
  geläufiger - und in meinem Dictionary ist diese Variante fettgedruckt :-)
- Neue Klasse Pipe eingebaut, über die System-Pipes (named und unnamed) erstellt und angesprochen werden können.
- Neue Klasse Process eingebaut, die benutzt werden kann, um externe Prozesse zu starten. Dabei kann die
  Ein- und Ausgabe umgeleitet werden und hinterher über unsere File-Klasse ausgelesen/geschrieben werden. Das ist
  eine Funktionalität, die man immer mal wieder braucht, und die mit OS-Funktionen ein absoluter Krampf ist. Darum
  möchte ich gerne PLGeneral soweit vollständig haben, dass man alles sowas schön einfach und komfortabel damit machen
  kann :-)



>> 02.03.2008
[CO]
- Änderte in den Container-Klassen 'AType' zu 'ValueType' damit das hier überall gleich geschrieben ist und somit
  Doxygen bei z.B. dem Iterator eine 'komplette' Klassenhierarchie zeigt und nicht nur die 'Container' Klassen
- Bugfix: Directory::CreateRecursive(): Trotz meiner bei der Implementation merkwürdigerweise erfolgreichen Tests
  (eventuell nicht sonderliche pralle Test Situation erzeugt :) war die Implementation noch nicht ganz ok... Stefan
  hatte ja schon die korrekte Funktionsweise angezweifelt, so 'müsste' es nun aber klappen.



>> 29.02.2008
[CO]
- "ConstIterator" hinzugefügt, bin mir allerdings nicht sicher ob das den 'Todo'-Punkt
  "Const_Iterator (currently we can't return some lists)" korrekt behandelt. Hoffentlich geht das so halbwechs,
  währe heftig wenn wir nochmal komplette Iterator Implementationen für 'const' schreiben müssten. :/
  Wenn das passt, wäre es sicherlich ne gute Idee bei 'Iterable::GetIterator()' und 'Iterable::GetEndIterator()'
  das 'const' hinten heraus zunehmen + die möglichkeit einen Iterator einem ConstIterator zuzuweisen.
  (anderst herum natürlich nicht *g*)



>> 28.02.2008
[CO]
Alle Projekte:
- Nahm wie besprochen überall dort wo 'inline' genutzt wird die Export Makros heraus. (siehe Eintrag 24.02.2008
  von Stefan) Damit man an diesen Stellen sehen kann das es absicht ist das hier kein Export Makro ist habe ich
  dort dann jeweils 'inline' reingeschrieben. (ist also nix 'funktionales', sondern als Hilfe/Gedächtnissstütze
  gedacht)
PLGeneral:
- 'SubString' und 'Sub-String' in 'Substring' umbenannt da man diese Schreibweise heute am häufigsten antrifft
- String::String(const utf8 *pnValue) muss natürlich raus da der Compiler hier nicht zwischen den zwei entsprechenden
  Konstruktoren unterscheiden kann (dank Default Einstellungen sieht das dann für ihn gleich aus :)
- String: "String operator +(utf8 nValue) const;" macht natürlich nicht wirklich viel Sinn da dies eigentlich immer
  ein 'Array von utf8' ist, nahm es heraus. Das gleiche bei "String::operator +=(utf8 nValue)" und
  "friend String operator +(utf8 nValue, const String &sString)" und "GetUTF8Char()" und "Replace(utf8 nOld, utf8 nNew)".
  "SetCharacter()" mit UTF8 braucht natürlich einen Zeiger.
- Bugfix: "String(const utf8 *pszString, bool bCopy, uint32 nLength, uint32 nNumOfBytes)": "UTF8Tools::GetNumOfCharacters()"
  sollte man natürlich auch die Anzahl der Bytes mitgeben...
- "Functions.cpp": "HashFunction::Hash(const String &sKey)": Hier sollten Fallunterscheidungen für die verschiedenen
  Formate gemacht werden... das könnte allerdings schnell zu problemen führen wenn man Formate mischt und sich dann
  wundert wieso man 'bei doch eigentlich scheinbar gleichem String' unterschiedliche Schlüssel bekommt. Das sollte
  man sich also dann eventuell nochmal genauer anschaun.
- RegEx: 'Mode' zu etwas universelleren Flags gemacht in denen 'Match' und 'Encoding' gespeichert wird, so braucht
  man für 'Encoding' keine weiteren Parameter. Setzt man kein spezielles 'Encoding'-Flag, so wird das interne
  String Format (ASCII oder UTF8) des übergebenen Ausdrucks verwendet. 'Subject' bei 'Match()' wird in dieses
  interne RegEx Format 'gezwängt'. 'Meistens' macht man sich über 'Encoding' keine Gedanken und nutzt nur ASCII,
  in dem Fall kann man das auch hier wie gehabt als Benutzer ignorieren. :D
  UTF8 Support in RegEx Implementation eingebaut, allerdings funktioniert das noch nicht richtig da u.a.
  "UTF8Tools::Unescape()" noch Probleme mit soetwas wie "\\s*(\\w+)\\s*" hat was es dann zu z.B. "s*(w+)s*" umformt +
  einige entsprechenden Funktionen in der String-Klasse noch nicht richtig Implementiert sind. Aber der Anfang wäre
  gemacht, taste wir uns also mal voran bis das alles korrekt auch mit UTF8 läuft...



>> 27.02.2008
[SB]
- Linux-Implementationen der Konsolen- und Memoryfunktionen getestet und wo nötig angepasst. Die Datei /proc/meminfo
  sieht bei mir völlig anders aus als offenbar in dem Beispiel, da sollte man sich also offenbar nicht drauf verlassen,
  dass der x-te Wert das und das bedeutet. Deswegen Parse ich nun nach den entsprechenden Strings. Worauf ich mich allerdings
  verlasse ist, dass der Wert immer in Kilobyte angegeben ist - hoffe, das ist auch so, ansonsten müsste man auch noch nach
  "kB|MB|B" parsen.
- System::ConsolePrint hinzugefügt, damit alle Konsolenfunktionen beisammen sind und man nicht nur, um eine kleine
  Konsolenausgabe tätigen zu können, auch noch File einbinden muss. So wird die Funktion auch gefunden, ansonsten würde
  man sich wohl wundern, dass zwar alle möglichen Konsolenfunktionen in System zu finden sind, nur ein simples Print fehlt.



>> 27.02.2008
[CO]
- Bugfix: "XmlBase::XmlBase(void *pData)", "((XmlBase*)m_pData)"... autsch, das sollte natürlich
  "((TiXmlBase*)m_pData)" heißen, muss irgendwann einmal durcheinander gekommen sein... gab natürlich ein
  Speicherleck + ein Test wie 'GetFirstChild() == GetLastChild()' um zu sehen obs nur ein Kind gibt ging natürlich
  nicht da jedesmal ein anderer PL XML Knoten zurückgegeben wurde.
- Iteratoren: Überarbeitete die Implementation nochmal so das Iteratoren beliebig 'kopiert' werden können. Intern
  wird ähnlich wie bei bei den Strings gearbeitet - Implementationen werden gemeinsam genutzt so lange das möglich
  ist und erst wenn sich etwas ändert muss 'geklont' werden. Ansonnsten hätte man einen ziemlichen Overhead in der
  'Standard Anwendung' z.B. "Iterator<int> cIterator = lstMyList.GetIterator()" da intern dann mehrmals dynamisch
  Speicher angelegt und wieder freigegeben werden müsste.
- Neue Funktion: System::SetConsoleCursorPosition(): Wie von Stefan gewünscht eine Funktion zum setzen des
  Konsolen Cursors. Fügte auch 'GetConsoleCursorPosition()' hinzu damit das vollständig ist.
  Die Linux Implementationen von 'ClearConsoleScreen() & SetConsoleCursorPosition()' müsste man noch testen - hab
  hier mal den Weg über ANSI Sequenzen gewählt, diese Lösung findet man im Internet recht häufig. Für
  'GetConsoleCursorPosition()' konnte ich auch nach längerem Suchen keine einfache akzeptable Lösung finden.
- SystemWin32: 'GetComputerName()' und 'GetUserName()' ermitteln den nötigen Speicher nun automatisch passend.
  'GetProgramName()' hat leider weiterhin eine 'feste' größe die ich allerdings von '1024' auf 'MAX_PATH' setzte
  da ich für 'GetModuleFileName()' nix finden konnte das einem zurück gibt wieviel Speicher man denn nun eigentlich
  wirklich braucht.
- System-Klasse um einige Funktionen erweitert über die man Informationen über den Speicher bekommen kann. Dies dürfte
  praktisch für Resource Manager sein da diese solche Informationen nutzen können um rauszufinden wann es sinnvoll
  ist etwas länger nicht mehr genutzte Resourcen über Bord zu werfen. Diese Funktionen 'könnte' man auch in
  'MemoryManager' halten, allerdings passt es doch am Ende etwas besser in die 'System'-Klasse. Habe in der
  'MemoryManager'-Klasse allerdings ein kleines Kommentar eingefügt falls jemand dort zuerst nach diesen Funktionen
  suchen sollte. Die Windows Implementation ist 'sehr' einfach, bei der Linux Implementation ist es ein 'wenig'
  mehr (wie irgendwie fast immer...) aber immer noch im bereich des erträglichen. Den Linux Code müsste man noch
  testen ob das so korrekt läuft.
  Da es recht viele Funktionen für Speicher Informationen sind überlegte ich zuerst ob man diese Informationen nicht
  besser gesammelt in einer Struktur speichert, entschloss mich dann aber dagegen da es über Funktionen irgendwie
  'schöner' zu nutzen ist.



>> 26.02.2008
[CO]
- CmdLineParser::CmdArrayToString(): "int argc, const char **argv"-Parameter zu "const Array<String> &lstArray"
  gemacht... das ist universeller so herum. Ansonnsten hätte man etwas für 'wchar_t' und 'utf8' hinzufügen müssen...
  "#include <string.h>" hinterherwink *g*



>> 24.02.2008
[SB]
- Seit den letzten Änderungen ließ sich die Engine bei mir unter Windows nicht mehr compilieren, da es beim
  Linken unresolved references auf Tools::FloatToUInt32 und Tools::UInt32ToFloat gab. Das Problem konnte
  durch das Entfernen von PLGENERAL_API vor diesen Funktionen behoben werden. Ich nehme an, dass das
  deswegen erst jetzt auftritt, weil in PLGeneral nun der Header selbst nicht mehr eingebunden wird und
  der Compiler diese Funktionen daher nicht mehr sieht und somit auch nicht compilieren und exportieren kann.
  Da die Funktionen als inline deklariert sind, sollte hier aber sowieso nichts export werden, sondern erst
  beim Einbinden durch den Compiler an die entsprechende Stelle eingesetzt werden. Damit da nichts durcheinander
  kommt (und das inline dadurch nutzlos wird), sollte bei Inline-Funktionen also künftig kein Export-Makro
  mehr verwendet werden.



>> 23.02.2008
[CO]
- PLMain(): 'MODULE_HANDLE hModule' ersatzlos heraus genommen da wir selbst es noch nirgends verwendet haben
  und ich im Augenblick auch nicht wüsste wofür wir das noch brauchen - zumal es dies unter Linux scheinbar
  erst gar nicht gibt. Sollte ein Windows Nutzer es mal für etwas spezielles brauchen, muss er einfach die
  entsprechende Windows Funktion nutzen um an den Module/Instanz-Handle zu kommen... in dem Fall macht er dann
  eh etwas Platform spezifisches. :D
  "PLGeneralLinuxIncludes.h" könnte man nun herausnehmen da komplett leer.
- Habe in PLMain() 'lstArgs' zu 'lstArguments' gemacht, 'args' ist zwar 'geläufig'... aber das muss hier nicht
  sein diese zwanghafte Abkürzung. Wird eh nur selten genutzt und daher ist "Schreibaufwand" kein Argument,
  lesbarkeit aber schon. :D
- ParseIntegerArray(), ParseFloatArray(), ParseDoubleArray(), GetFlagsFromString() und GetStringFromFlags() von
  der 'Tools'-Klasse in eine neue 'ParseTools'-Klasse verschoben die sich im 'String'-Ordner befindet
- 'Tools::FlipRB3()'-Funktion in 'PLGraphics::Color3' verschoben + dieses Funktion heißt dort nun 'SwapRB'
- 'Tools::FlipRB4()'-Funktion in 'PLGraphics::Color4' verschoben + dieses Funktion heißt dort nun 'SwapRB'
- Ein paar Copy-Operators und Copy-Constructors hinzugefügt
- Ein paar Copy-Operators und Copy-Constructors entfernt da unnötig, sprich, die automatische erzeugten sind
  völlig ausreichend. Klassen: Version, Time



>> 18.02.2008
[CO]
- Directory::CreateRecursive() Implementation nochmal überarbeitet so das nur Url-Funktionen genutzt werden



>> 17.02.2008
[SB]
- PLGeneral läßt sich nun wieder unter Linux übersetzen. Und manchmal frage ich mich wirklich, wozu ich
  Dinge dokumentiere ...
  Aus FileWin32.h:
    // Hmmmpf, not nice. But better than to include <stdio.h>, and as it must only work on Windows, it might be ok :-)
    struct _iobuf;
   typedef struct _iobuf FILE;
  Hier habe ich doch explizit geschrieben, dass dieser Hack *nur unter Windows* funktionieren wird. Deswegen steht
  da auch "as it must only work on Windows". Und darum war auch im Linux-Header entsprechend <stdio.h> eingebunden,
  weil das da nunmal leider nicht so geht (evtl. kann man es dort anders vordefinieren, aber da die Header da zig
  if's und defines enthalten, wird dies wohl auf jedem System anders aussehen). Und nun wird einfach dieser Kommentar
  kopiert, "Windows" durch "Linux" ersetzt und geglaubt, so ginge das.
  Entschuldigung, aber sowas verstehe ich einfach nicht. Kann man nicht bitte mal vor dem Ändern davon ausgehen, dass
  andere Programmierer (ich, in diesem Falle) sich auch etwas *dabei denken*, was sie schreiben, und es somit wohl einen
  *Grund* hat, wenn die Forward-Declaration zwar im Windows-Header drin ist, aber im Linux Header nicht? Und wenn man dann
  trotzdem meint, dass das alles Quatsch ist und man das ändern muss, dann *muss* man das bitte auch unter Linux übersetzen
  und dort ausprobieren, und nicht einfach davon ausgehen, dass das schon gehen wird (insbesondere dann, wenn ich im Kommentar
  extra darauf hingewiesen habe, dass dies so nur unter Windows geht).
- Var.cpp: Habe ebenfalls die Änderung mit PLGeneralLinuxWrapper.h wieder rückgängig machen müssen, da es eben
  '_atoi64' unter Linux leider nicht gibt. Wo die Information herkommen soll, dass es diese Funktion unter Linux
  nun auch in stdlib.h geben 'müsste', ist mir schleierhaft, eine Suche per Google gibt jedenfalls nur zig mal die
  Information, dass es das unter Linux eben nicht gibt. Vielleicht könnten wir das nun einfach mal so lassen, und
  nicht in einem halben Jahr wieder behaupten, dass es nun gehen müsste, ohne auszutesten, dass das auch wirklich so ist.



>> 17.02.2008
[CO]
- LogFormaterConsole: Nutzt wieder 'printf' direkt anstatt 'File::StandardOutput' da es ansonnsten dank der statischen
  De-initialisierungs Reihenfolge in PLSampleChat einen Crash beim beenden geben kann :/



>> 16.02.2008
[CO]
- File: ESeek andere Werte vergeben damit diese mit SEEK_CUR, SEEK_END, SEEK_SET aus 'stdio.h' zusammenpassen, das ist sicherlich
  eine gute Sache... in z.B. 'PLSoundFMOD/SoundManagerFMOD.cpp' musste man extra 'stdio.h' einbinden 'nur' um an diese Definitionen
  zu kommen was ich irgendwie dämlich fand. ("Mit Kanonen auf Spatzen schießen")
- Var.cpp: Nahm den speziellen Linux Include '#include "PLGeneral/PLGeneralLinuxWrapper.h"' heraus, auch dort 'müsste' '_atoi64'
  in 'stdlib.h' definiert sein
- System: Neue Funktion: GetConsoleCharacter(): Liest ein einziges Zeichen von der Konsole, für die Linux Fassung musste ich mal
  wieder Code 'aus dem Internet' nehmen... das so einfache Dinge so kompliert und nicht Plattform unabhängig sein müssen. *gruml*
  Wie üblich wieder ausführlich dazu geschrieben woher das kommt.
- System: Neue Funktion: ClearConsoleScreen(): 'Löscht' den Inhalt der Konsole, ebenfalls etwas sehr praktisches... aber auch wieder
  etwas das obwohl so Grundliegend, nicht wirklich so einfach ist daher auch hier wieder 'gefundener Code' sammt woher er kommt...
- FileHttp genauso wie die anderen File Implementationen alles private gemacht da man da von außen nicht mehr rankommen können sollte
  (es sprichts nichts dagegen, oder?)
- SystemWin32::GetEnvironmentVariable(): Nahm das [TODO] heraus und erweiterte das Kommentar 'etwas' damit man nachvollziehen kann
  warum das so 'merkwürdig' aussieht... das ist eine reine Optimierung. (nicht Performance 'kritisch', aber wenns möglich ist...)
  Würde man nur "GetEnvironmentVariableW(sName.GetUnicode(), NULL, 0)" schreiben, müsste 'sName' intern zwanghaft in Unicode
  konvertiert werden auch wenn das überhaupt nicht nötig ist da ASCII gegeben ist und eine solche Umgebungs Variable nicht
  existiert, existiert diese muss dann natürlich konvertiert werden da wir nicht vorher feststellen können ob für den Wert
  ASCII reicht oder nicht. (würd ich also gerne so lassen auch wenns 'Erbsenzählerei' ist, das zeigt das man da mit liebe
  fürs Detail rangeht :)
- Directory::CreateRecursive() Implementiert. Weis nicht ob das mit "System::GetInstance()->GetCurrentDir()" so prall ist, wüsste
  aber im Augenblick nicht wie man das anderst machen sollte, auf jedenfall funktioniert es recht gut.
- 'Directory.h': "PLGeneral/File/FileSearch.h" durch 'Forward declaration' ersetzt. Ich erwähne es da ich mir gerade nicht sicher
  bin ob das so absicht war oder nicht. (Regel sollte sein 'Forward declaration' wo geht, das hält die Compile dauer + das neu
  Compilieren bei Header Änderungen schön niedrig was die Produktivität steigert, bei der Sache bin ich wirklich stark hinterher
  da es sich wirklich auszahlt *g*)



>> 15.02.2008
[CO]
- Klassen im 'Container'-Ordner nochmal durchgeschaut (hauptsächlich nur Zeilen umbrüche)
- Heap & Map und Implementierungen um Copy-Operator und Copy-Constructor erweitert, auch wenn diese erstmal nicht Implementiert
  und daher private sind. Diese Operationen sind nicht ganz ohne... man könnte zwar einen Iterator nutzen, aber dann hätte man
  nur 'Werte' aber ohne die dazu gehörenden 'Schlüssel' - da muss ich mir noch etwas Einfallen lassen.
  Aber so ist's schonmal besser als überhaupt nix drinnen zu haben... dadurch viel sofort ein Bug im 'FileAccess' Copy-Constructor
  auf der bereits eifrig den nicht vorhandenen HashMap Copy-Constructor nutzte. :/
- SimpleMap: Speziellen Copy-Operator hinzugefügt, im grunde würde der automatische reichen wie beim automatischen Copy-Constructor,
  aber der Rückgabewert sollte hier ein universelles 'Map' sein
- HashMap: Speziellen Copy-Constructor und Copy-Operator hinzugefügt, wird bereits von 'FileAccess' verwendet
- File: "Standard Stream"-Dateien, nächster Anlauf nach Stefans Idee - klappt denke ich so recht gut und ist überschaubar.
  Habe dies als File Implementation Namens 'FileStdStream' realisiert damit das sauber Implementiert ist und es nicht zu viele
  Sonderfälle gibt die man ständig Abfragen muss.
- System: GetTime(), GetMilliseconds() und GetMicroseconds() Funktionen runter zu Sleep() verschoben damit Funktionen mit gleichen
  oder zumindestens sehr ähnlichen Jobs 'räumlich' beisammen sind
- System: Neue Funktion: IsConsoleKeyHit(): '_kbhit()' Funktion die bei Konsolen Anwendungen recht praktisch sein kann. PLSoundTest
  nutzt diese Funktion bereits. Dort wurde bisher 'im Internet gefundener' Code direkt verwendet - forschte etwas nach woher dieser
  Code stammte und es stellte sich heraus das dieser Code auf flipcode (es ruhe in Frieden) veröffentlicht wurde und recht bekannt
  ist. Fügte beim Linux Port ausführliche Copyright Informationen hinzu. (nutzen 'müsste' man es können)



>> 14.02.2008
[CO]
- SystemLinux::GetCurrentDir(): Ist nun nicht mehr auf 'MAXPATHLEN' beschränkt sondern ist Dynamisch
- Ging die System und XML Klassen nochmal ganz genau durch und fügte wo nötig Copy-Constructor und Copy-Operator
  hinzu. In z.B. 'DynLibLinux' ist dies jedoch nicht wirklich nötig da der User da nicht rankommt. (oder sollen wir
  hier dann trotzdem soetwas hinzufügen?)
  Schaute auch das jede Anweisung in einer eigenen Zeile steht - das machts einfacher wenn man mal einen Break-Point
  setzen will auch wenn das die Anzahl der Zeilen etwas aufbläht, die Vorteile überwiegen.
- File-Klassen nochmal genau durchgeschaut
- FileSearchImpl: 'm_pSearch' herausgenommen (bin mir zu 99% sicher das dies noch ein alter Überbleibsel war :)
- FileSearch: Copy-Operator hinzugefügt... hier erwähne ich es da es etwas umfangreicher ist, auch im Copy-Constructor
  änderte ich eine kleinigkeit. (sah etwas merkwürdig aus, funktionell natürlich kein Unterschied)
- FileObject: Destruktor virtuell gemacht
- FileAccess: 'NullEntry' zu einer öffentlichen Klassenvariable gemacht damit man von außen testen kann ob das als Ergebniss
  zurück kam + FileAccess braucht weniger Speicher (das erste Argument war ausschlag geben *g*)
- SocketAddress: "SocketAddress::SocketAddress(const String &sHost, uint32 nPort)" auskommentieren Code entfernt, schien mir
  wirklich 'tot' zu sein (sprich Nutzlos :)
- 'CmdLineParser' vom 'Tools'- in den 'String'-Ordner verschoben da es dort viel besser reinpasst, ist ja nur ein einfaches
  String Parsing. (also würde ich wohl auch genau in diesem Ordner danach suchen :)
  Wollte auch zuerst die 'Localization'-Klassen in den 'String'-Ordner verschieben da diese ebenfalls 'nur' dazu da sind um
  einen String von einer Sprache in eine andere zu bringen... aber da diese Klassen bereits das Loadable-System nutzen das
  zukünftig wie es aussieht in PLCore liegen wird, wird das Localization-System wohl auch mit in PLCore wandern müssen. Bei
  Zeiten sollten wir mal für das Localization-System ein Loader Plugin schreiben das die Sprachen/Übersetzungen aus einer
  Datenbank ausliest. *g*



>> 13.02.2008
[CO]
- File: Um "Standard Stream"-Dateien erweitert... das bot sich direkt an das "Dinge auf Konsole ausgeben"  hierüber zu
  realisieren anstatt seperate Funktionen z.B. in die System-Klasse zu stecken. (könnten wir natürlich immer noch, aber ich denke
  das ist erstmal unnötig) Intern ist das sowieso so realisiert + damit kommen andere Dinge wie man im Punkt unten sehen kann
  'for free'... hat also durchaus seine Vorzüge. *g*
  Erweiterte dafür "EAccess" in der File Klasse damit das ohne große Änderungen ins Interface passt. In "File::Open()",
  "FileWin32::Open()" und "FileWin32::Linux()" musste etwas Code eingefügt werden - Stefan, schau dir das bitte genau an, nicht
  das diese Änderung überhaupt nicht ins Konzept passt und alles durcheinander bringt. Hatte mir schon überlegt ob eine extra
  "StandardStream"-Datei Implementation angebracht wäre... aber irgendwie war mir das dann mit Kanonen auf Spatzen geschossen.
- "Print()"-Funktion aus den XML Klassen genommen da sich dies nun über eine "Standard Stream"-Datei realisieren lässt.
  In der PLBaseTest Funktion "XmlTest::Test()" kann man sehen wie das Schreiben 'in die Konsole' darüber zu realisieren ist.
- XmlDocument: "LoadFile()" und "SaveFile()" Funktionen in "Load()" und "Save()" umbenannt damit das konsistent zu den anderen
  Funktionen ist.



>> 12.02.2008
[CO]
- Iteratoren wie besprochen umgeschrieben so das diese problemlos immer auf dem Stack liegen können damit man kein 'delete' mehr
  nutzen muss was man ja leider schnell mal vergisst. Alle Projekte entsprechend angepasst und darauf geachtet das die Iteratoren
  immer im kleinst möglichen Bereich genutzt werden damit so wenig wie möglich schief gehen kann. Dafür habe ich hier und da auch
  extra Blöcke hinzugefügt was ich allerdings nicht 'schlimm' finde da es für mehr 'Sicherheit' sorgt, (Thematik veränderung der
  Datenstruktur auf die der Iterator gerade arbeitet) das ersetzt praktisch das 'delete'. :)
  Im Iterator Copy-Constructor ist momentan noch ein kleiner Hack drinnen der den konstanten Parameter auf nicht Konstant umbiegt
  damit dort die Iterator Implementation zurück gesetzt werden kann - macht man den Parameter nicht Konstant erhält man tonnenweise
  Compiler Warnungen... momentan weis ich noch nicht wie man das anderst lösen könnte. (bei nicht konstant kann man ein Temporäres
  Objekt ändern das der Compiler nicht mag da Seiteneffekte möglich)
  Aber die Bedienung der Iteratoren ist so nun auf jedenfall 'deutlich' Eleganter und weniger Speicherleck anfällig. :D



>> 09.02.2008
[CO]
Gelaber:
- Nachdem ich gestern meine letzte Prüfung im total überfüllten 3'ten Semester geschrieben habe kann ich nun
  ENDLICH wieder mehr an PL machen. Am 17.03.2008 gehts dann weiter mit dem 4'ten Semester das hoffentlich nicht
  mehr so heftig wird wie das aktuelle. Bis dahin nur noch PL und daher wieder mehr Tagebuch Einträge meinerseits. :D
Alle Projekte:
- Auf Visual Studio 2008 umgestellt damit man 'relativ problemlos' auch unter Vista arbeiten kann ohne erstmal
  die Entwicklungsumgebung mit x Vista-Patches vollzudröhnen die dann doch nicht gehen (zumindestens bei mir nicht)
- In den 'sln'-Dateien hat sich nix groß geändert, nur die Versionsnummer:
      Microsoft Visual Studio Solution File, Format Version 9.00
      # Visual Studio 2005
  wurde zu
      Microsoft Visual Studio Solution File, Format Version 10.00
      # Visual Studio 2008
  In den 'vcproj'-Dateien hat sich zum Glück auch nicht wirklich viel verändert. In "<VisualStudioProject"
      Version="8,00" wurde zu Version="9,00"
  und
      TargetFrameworkVersion="131072"
  kam neu hinzu.
-     <Tool
          Name="VCWebDeploymentTool"
      />
  Wurde automatisch entfernt da "Web deployment to the local IIS server is no longer supported", für was auch
  immer das gut war, nicht mehr unterstützt wird - wir werden es sicher nicht vermissen. *g*
- Bei "<Tool Name="VCLinkerTool"" gibts zwei neue Optionen die automatisch hinzugefügt wurden:
      RandomizedBaseAddress="1"
      DataExecutionPrevention="0"
- "Data Execution Prevention (DEP)" auf "Image is compatible with DEP (/NXCOMPAT)" gestellt, das ist eine gute Sache
  und sollte bei uns keine Probleme geben (konnte jedenfalls keine feststellen)
- Folgende Warnung erschien nun öfters mal:
      "Command line warning D9035 : option 'Wp64' has been deprecated and will be removed in a future release"
  Da diese Meldung leider wie es aussieht nicht Deaktivierbar ist und das 'etwas' störrend ist deaktivierte
  ich "/Wp64 (Detect 64-Bit Portability Issues)". 64 Bit Compilieren ist momentan bei uns kein Thema... und falls
  man das doch mal ausprobieren will muss sich einer von uns erstmal ein 64 Bit Windows Installieren (zum Testen)
  + den 64 Bit VC Compiler. (sehe momentan aber keinen Grund das zu tun, gibt wichtigeres momentan :)
- Ging die Projekt-Abhängigkeiten (Menu bar -> Project -> Project Build Order... -> Dependencies)
  nochmal durch und korrigierte wo nötig. Damit geht das komplett Übersetzen wieder beim ersten mal sauber durch
  ohne das Fehlermeldungen kommen das z.B. 'PLGeneral.lib' nicht gefunden werden konnte da z.B. PLNetwork vorher
  'fertig wurde' mit dem Übersetzen. (Multi-Threading sei dank *g*)
- "LINK : warning LNK4224: /OPT:NOWIN98 is no longer supported;  ignored" -> "Optimize for Windows98"
  auf Default gesetzt... das Unterstützen wir eh nicht. (selbst MS hat mittlerweie den Support dafür
  fallen gelassen)
PLGeneral:
- "LIBCMT,MSVCRT" zu den zu ignorierenden Bibliotheken hinzugefügt um Linker Warnungen zu beseitigen
- "PLGeneralWin32Includes.h": WINVER und _WIN32_WINNT werden, falls bereits Definiert, 'undefiniert' - ansonnsten
  bekam ich hier unter Vista mit VC 2008 Warnungen
- TinyXML: Neuste Version 2.5.3 (intern steht bereits 2.5.4) aus dem Repository genommen und mit VC 2005 übersetzt.
  "TiXmlBase::PutString()" wurde mittlerweile in "TiXmlBase::EncodeString()" umbenannt und öffentlich gemacht - darum
  haben wir nun nur noch 3 anstatt 4 eigene Änderungen in TinyXML. :D
  Für Linux und VC7 müsste man das noch übersetzen.



>> 04.02.2008
[SB]
WOW. Mit den C++ Templates kann man echt viele tolle Dinge machen - man muß nur aufpassen, auf dem Weg dahin
nicht Amok zu laufen ;-)
- Habe meinen ersten Test von Funktionsobjekten entfernt und durch eine neue Implementation ersetzt. Es ist jetzt
  nicht mehr nötig, die Anzahl der Parameter beim Template mit anzugeben - das merkt das Template nun von selbst.
  Auch kann man jetzt die Klasse Functor direkt verwenden, und der einfach einen beliebigen gültigen Zeiger
  auf eine Funktion hineingeben - egal ob statisch oder Memberfunktion einer Klasse. Beispiel:
  Functor<int, int> cFunc(TestFunction);
  Functor<int, int> cFunc(&Class::TestMethod, &cObject);
  int nRes = cFunc(10);
  Dank vieler verrückter Template-Tricks müßte das ganze Typensicher sein - man kann die Klasse also nicht austricksen
  und z.B. einen Zeiger auf ein Objekt falschen Typs hineingeben oder aus einem int(int) ein int(float) machen.
  Es war jetzt auch nicht mehr nötig, noch Makros zu verwenden - das ganze geht komplett nur mit Templates. Allerdings
  steht zur Zeit noch der Test aus, ob auch alle Compiler die wir verwenden das ganze mögen (VC8 mag es jedenfalls).
  Da der ganze Template-Mechanismus beim Compilieren abläuft braucht übrigens auch keine Angst zu entstehen, dass das
  ganze ein zu großer Overhead wäre und daher die Performance beeinträchtigen könnte. Die ganzen Hilfsklassen sind nur
  dafür da, damit der Compiler die richtigen Typen zur richtigen Zeit findet, da sie aber weder Daten beinhalten noch
  jemals Instanzen davon erzeugt werden, bleibt davon zur Laufzeit nichts mehr übrig :-) Das ganze reduziert sich
  dann auf das Dereferenzieren zweier Pointer :-) 



>> 22.01.2008
[CO]
Alle Projekte:
- Überall den Style der Konstruktor Initialisierer-Liste wie vor geraumer Zeit besprochen angepasst



>> 22.01.2008
[CO]
- ClassManager::LoadPlugin(): Hier hatte sich ein Fehler eingeschlichen so das manche Plugins nicht gefunden
  werden konnten. Man kann innerhalb der '.plugin'-Datei auch absolute dll-Pfade nutzen, z.b. zu Testzwecken -
  ansonnsten sind die dll's IMMER relativ zum Verzeichniss in dem sich die '.plugin'-Datei befindet.



>> 19.01.2008
[CO]
- Fügte wie von Stefan gewünscht eine 'Set'-Funktion zur 'Map'-Klasse + deren Implementationen hinzu. Lies die 'Add'
  und 'Remove' Funktionen jedoch drinnen da ich finde das diese durchaus ihre Existenzberechtigung haben. (sonst hätten
  wir wohl schon vvviiiiel früher die 'Set'-Funktion eingebaut :)
  Z.B. kann man über 'Add' mehrmals den gleichen Schlüssel einfügen, das verhält sich im Grunde dann wie ein 'Stack' +
  'Replace' ersetzt wirklich nur einen Wert wenn dieser bereits in der Map war, ansonnsten wird nix gemacht.
- PLMain: Unicode-Support für die Kommandozeilen-Parameter hinzugefügt, für Linux könnte ich nix spezielles finden...



>> 18.01.2008
[CO]
Alle Projekte:
- Überall "Predefinitions" durch "Forward declarations" ersetzt
- Ein paar unnötige Includes entfernt ("Include-Sparsamkeit" ist mir extrem wichtig :)
- "uint32 HashFunction::Hash(const char szKey[])" und "uint32 HashFunction::Hash(const String &sKey)":
  Variable 'g' in die Schleife gezogen + die Zuweisung in der Abfrage entfernt
- Alle 'doxyfile'-Dateien an die 'Doc'-Ordner verschiebung angepasst
- "Config/" in Dateinamen beim Laden/Speichern von Konfigurationen entfernt, das regelt das Loadable System
  intern selbst wo diese Dateien standardmäßig landen
PLGeneral:
- Bugfix: Fand gerade den Grund dafür das es z.B. beim laden der Szene 'PhysicsPlayground.scene' Crashte:
  "FileWin32::Open()": Hier konnte es eine Situation geben in der 'szMode' nicht Initialisiert wurde. In dieser
  kombination muss 'ungültig' zurück gegeben werden. ("FileLinux" natürlich das gleiche)
    (!(nAccess & File::FileWrite) && !(nAccess & File::FileCreate) && !(nAccess & File::FileAppend))
- Bugfix: "FileWin32::Open()": Bei folgender Kombination klappte das noch nicht wie erwartet:
    (nAccess & File::FileWrite) && !(nAccess & File::FileCreate) && !(nAccess & File::FileAppend)
  Wenn man nicht "FileRead" gesetzt hatte gab die Funktion 'ungültig' zurück obwohl eine Datei bereits
  existierte in die man hätte schreiben können. Daher wird hier nun erstmal geprüft ob die Datei bereits
  vorhanden ist, wenn ja kann man den "w"-Modus nutzen, ansonnsten wird 'ungültig' zurückgegeben.
  ("FileLinux" natürlich das gleiche)
- "File::Open(uint32 nAccess = 0)" zu "File::Open(uint32 nAccess)" gemacht da '0' eine ungültige Flag-Kombination ist
- Loader::OpenFile(): Muss Dateien auch korrekt erzeugen können beim Speichern, das müsste so nun hoffentlich
  passen... nach den oberen Änderungen konnte ich keine Probleme mehr feststellen
- LoadableManagerLoaderPL: 'FileSystemSettings' entfernt und 'BaseDirectories' nach 'LoadableManagerSettings'
  verschoben
- "Loader::OpenFile()": Kennt nun 'nur' noch Basis Verzeichnisse, also kein '-1 = das aktuelle Verzeichniss'... dies
  war höchst Problematisch da dies nicht mit den 'Prioritäten' der Basis Verzeichnisse zusammen passte. War etwas im
  aktuellen Verzeichniss, also standardmäßig wo das Programm selbst liegt, wurde diese Datei 'immer' genommen, auch
  wenn man z.B. im Falle des Scene Viewers dem Verzeichniss in dem die aktuelle Szene liegt die höchste Priorität geben
  wollte damit 'zuallererst' geschaut wird ob die gesuchte Datei dort liegt.
- LoadableManager: "", also ein leerer String ist nun ebenfalls ein gültiger Basis-Pfad und steht für das
  'aktuelle Verzeichniss'
- LoadableManager:SetBaseDirPriority(): Bei den URL-Umstellungen hatte sich hier ein kleiner Fehler eingeschlichen
  so das die Prioritäten nicht korrekt geändert wurden



>> 14.01.2008
[SB]
- Beim Lesen aus Archiven mit dem Flag FileMemBuf gab es Probleme, weil die Zeilenenden auch dann konvertiert wurden,
  wenn die Datei als Binary geöffnet wurde. Nachdem ich dieses Problem behoben hatte, scheinen auch wieder alle Daten
  richtig geladen zu werden :-)
- Habe das Flag FileBinary komplett gelöscht, da dieses nur Probleme machte. Generell werden Dateien im Binärmodus geöffnet,
  wenn dies nicht gewünscht ist, muss FileText angegeben werden.
- Registry-Klasse in einen eigenen Ordner verschoben.
- Url::Collapse: Hier gab es einige Probleme, wenn ein ".." am Ende des Pfades stand. Diese sind nun hoffentlich behoben ...
- Änderungen aus dem Rewrite-Branch in den Trunk übertragen. Gab so weit ich sehen kann keinerlei Probleme - die einzige
  Datei mit einem Conflict war "Diary.txt" :-))



>> 13.01.2008
[CO]
- Ein paar Mini-Änderungen an der "Registry"-Klasse



>> 12.01.2008
[SB]
- Wrapper für die Registry hinzugefügt. Ich möchte einfach *nirgendwo* mehr direkt auf die Windows-API zugreifen müssen,
  da das immer total nervt und meist extrem unübersichtlich ist. Auch muß man dann ja meist wieder direkt mit irgendwelchen
  String-Buffern hantieren, Speicher allozieren etc. *brrr*. Die Klasse Registry bietet also Zugriff auf die Windows-Registry
  und wrappt einfach die API-Funktionen in eine hübsche Klasse. Später könnte man das evtl. noch erweitern, um auch auf andere
  Registry-Systeme zugreifen zu können (z.B. Gnome hat ja auch so etwas). Allerdings würden dann natürlich auch die ganzen Pfade
  darin vollkommen anders aussehen, das muß man also mal sehen, ob das überhaupt sinnvoll wäre. In jedem Fall kann man nun auch
  über die Registry-Klasse abfragen, ob überhaupt eine Registry auf dem System vorhanden ist, falls nein kann man dann auf andere
  Methoden zurückgreifen und sich so ein #ifdef sparen :-)



>> 11.01.2008
[SB]
- Einige kleinere Fehler in RegEx behoben.



>> 10.01.2008
[SB]
- Neue Toolklasse Version eingebaut. Diese speichert die Versionsnummer eines Projektes und kann diese z.B. als
  String ausgeben. Auch können Versionsnummern miteinander verglichen werden. Dies soll später verwendet werden,
  um die Versionen der einzelnen Komponenten zu verwalten.



>> 21.12.2007
[SB]
- Neue Klasse RegEx zum Parsen regulärer Ausdrücke eingebaut. Diese sollten wir verwenden, um uns ansonsten schnell
  kompliziert werdende Parsing-Aufgaben zu erleichtern. Ich denke, dass wir damit an manchen Stellen das Parsen
  von Text deutlich vereinfachen können, z.B. für Vektoren, Listen usw. (a b c) . Der Tokenizer ist zwar recht leistungsfähig,
  aber selbst damit ist es immer noch sehr aufwendig, so etwas zu parsen, und die entsprechenden Stellen werden meist
  sehr groß und sind schwer zu lesen. Reguläre Ausdrücke dürften hier weiterhelfen und sind sowieso an vielen Stellen sehr
  nützlich :-) Das ganze benutzt den Perl-Syntax für reguläre Ausdrücke und darf noch kräftig erweitert werden, im Moment
  können nur einfache Vergleiche ausgeführt werden. Die Klasse ist ein Wrapper für die PCRE Library (Perl Compatible
  Regular Expressions), die unter einer BSD-Lizenz steht.
- SearchFilterRegEx: Neuer Suchfilter zum Suchen mit regulären Ausdrücken.



>> 15.12.2007
[CO]
- Loadable System Änderung vom 08.12.2007 im Main-Branch wieder rückgängig gemacht da nicht alles wieder ging wie vorher
  und Stefan das im seperaten Branch komplett überarbeitet. So haben wir zumindestens wieder eine voll lauffähige Version.



>> 09.12.2007
[SB]
- Einige Unklarheiten beseitig, die beim Umstellen auf das neue FS deutlich wurden.
- Url: Die Methoden zum Zurückgeben der URL etwas umsortiert und umbenannt, damit deren Verwendung verständlicher wird.
  Man sollte eigentlich immer Url::GetNative() verwenden, denn dies gibt den Pfad im nativen Format zurück, sofern dies
  ein lokaler Pfad ist, ansonsten als URL, wenn es sich z.B. um http:// handelt. Das scheint mir der natürlichste Weg zu
  sein, weil der Pfad für den User "normal" angezeigt wird, und nur dann z.B. ein Protokoll hinzugefügt wird, wenn das
  auch wirklich nötig ist. GetUrl() dagegen gibt in jedem Fall file:// heraus, was man aber normaler Weise nicht haben
  möchte und auch nicht braucht. Als Faustregel würde ich daher sagen:
  - Zur Übergabe von URLs (z.B. zum Laden/Speichern): GetUrl()
  - Zur Ausgabe von URLs an den Benutzer: GetNative()
- Url: Zugriff auf die einzelnen Teile einer Url etwas verändert und Funktionen für die häufigsten Zugriffsformen
  hinzugefügt (z.B. nur Pfad oder Dateiname ohne Endung) 
- FileObject, File, Directory: GetUrl() gibt *immer* eine URL ohne "/" am Ende zurück. Dies ist wichtig zu wissen, denn
  dann kann man z.B. ohne Bedenken cDir.GetUrl() + "/filename.txt" schreiben, ohne noch selbst auf "/" testen zu müssen.
  Einzige Besonderheit: Beim Mounten von ZIP-Dateien muß das "/" angegeben werden, damit das FS überhaupt weiß, dass diese
  ZIP-Datei als Verzeichnis angesprochen werden soll und nicht einfach die Datei geöffnet werden soll. Das ändert aber nichts
  an der Regel, dass GetUrl() auch in diesem Fall ohne "/" zurückgegeben wird!
- FileObject: Erweiterte die Funktionen zum Zugriff auf die URL, damit man die häufig benötigten Funktionen direkt zur
  Hand hat und nicht ständig Url's dafür erzeugen muss. Die Funktionen sind analog zur Url-Klasse und wrappen diese:
  GetUrl() gibt nun das Url-Objekt zurück, damit dieses nicht unnötig neu erzeugt werden muß
  GetPathUrl() gibt die Url als String zurück
  GetPathNative() gibt den Native-Path als String zurück
  GetPathWindows() gibt den Windows-Path als String zurück
  GetPathUnix() gibt den Unix-Path als String zurück
  GetFilename() gibt nur den Dateinamen zurück
- Threads etwas umgebaut und GetMainThread() in System eingebaut.
- File: FileBinary und FileText vertauscht, damit ist FileBinary nun wieder der Standard.
- Die Engine auf das neue FS umgestellt. Dabei sind mir einige Stellen aufgefallen, die noch deutlich überarbeitet werden
  sollten, z.B. werden noch viel zu Oft irgendwelche Dateipfade auseinandergebröselt, hier sollte zumindest versucht werden,
  das möglichst transparent nur an einer Stelle zu tun. Manche Dateitypen suchen dann wieder selbst die Basispfade durch
  oder geben einen festen Pfad vor (z.B. "data/sounds"), das sollte auf jeden Fall raus. Viele Dinge habe ich nur blind
  umstellen können und fürchte, dass das nicht mehr richtig funktionieren wird. Dies war aber schlecht anders möglich, da
  mir teilweise die Funktionsweise der entsprechenden Funktion nicht wirklich klar wurde und ein komplettes Neuschreiben
  on-the-fly zu aufwendig wäre.
- Es läßt sich nun wieder alles compilieren, allerdings funktionieren die Loader noch nicht wieder richtig, weshalb viele
  Dateien noch nicht gefunden werden können. Als nächstes werde ich daher die für später geplanten Arbeiten vorziehen und
  das Config- und das Loader-System überarbeiten. Es dürfte sinnvoller sein, dies nun gleich neu zu machen, als erstmal
  das alte wieder mühselig zum Laufen zu bringen um es dann hinterher doch noch neu zu schreiben.



>> 08.12.2007
[SB]
- PLGeneral/System überarbeitet: Globale Manager entfernt, direkte Instanzen der Klassen sind jetzt möglich und
  Impl-Klassen nach dem gleichen Pattern wie in File überarbeitet.
- Folgendes Pattern für Implementationsklassen soll nun überall möglichst identisch verwendet werden:
  - Eine plattformunabhängige Klasse besitzt einen Zeiger auf eine (versteckte) Implementationsklasse
  - Diese wird im Konstruktor (oder evtl. erst später, wie in FileObject) erzeugt, aber innerhalb dieser Klasse
  - Die Implementationsklasse besitzt keinen Zeiger zurück auf die plattformunabhängige Klasse!
  - Das gesamte Interface der Implementationsklasse sollte protected sein, auch die virtuellen Funktionen.
  - Mittels friend darf die plattformunabhängige Klasse darauf zugreifen.
  - Konkrete Implementation werden abgeleitet, auch diese mit protected-interface.



>> 08.12.2007
[CO]
- Base Path Dinge von FileSystem in LoadableManager verschoben. Ist noch nicht wirklich Prall realsiert, sollte so aber
  erstmal reichen. Nachdem das überarbeitet FS drinnen ist sollte man sich das hier nochmal anschaun.



>> 05.12.2007
[SB]
- Map: Auf die Values einer Map kann nun auch nicht-const zugegriffen werden. Dies ist nützlich, wenn es sich um abstrakte
  Datentypen (z.B. Klassen) handelt, von denen man nur ein Attribut ändern möchte und nicht das gesamte Objekt per
  Replace austauschen möchte. 
- SearchFilter implementiert. Beim Auflisten von Dateien wird über die Klasse SearchFilter getestet, ob der gefundene
  Dateiname dem Filter entspricht. Als Standard wird ein WildCard-Filter verwendet, es können aber auch individuelle
  Filter implementiert werden.
- GetCurrentDirectory und SetCurrentDirectory in PLGeneral::System implementiert.



>> 04.12.2007
[SB]
- HttpHandle und ZipHandle: Beide Klassen besitzen nun nur noch einen leeren Konstruktor und öffnen zunächst keine
  Datei bzw. Verbindung. Dafür gibt es nun jeweils eine Funktion Open(). 
- Habe mal etwas mit den Ideen herumgespielt, wie man beim FS den Zugriff auf z.B. passwortgeschützte Inhalte
  realisieren könnte. Die bisherige Methode, Open(Name, Passwort) gefällt mir aus folgenden Gründen nicht:
  - Die Signatur von Open wird um einen Parameter erweitert, den vermutlich die meisten User zunächst nicht verstehen
  - Es wird nur von einem Passwort ausgegangen, in vielen Fällen kann es aber noch mehr Parameter geben
    (Username/Passwort, Crypto-Keys u.v.m.)
  - Wenn man z.B. eine Datei "http://www.pixellight.org/test.zip/dir/test.txt" laden möchte, kann man an verschiedenen Stellen
    einen Zugriffsschutz haben, z.B. einmal für den http-server (username/passwort), und dann noch einmal für die Zip-Datei.
    Mit dieser Lösung ist es aber nicht möglich, mehrere Passwörter zu übergeben, ausserdem vermittelt Open(Name, Passwort)
    in diesem Falle den Eindruck, dass das Passwort für test.txt benötigt wird, was aber gar nicht der Fall ist.
  Es sollte also die Möglichkeit geben, mehrere Authentifizierungsdaten gleichzeitig anzugeben, falls die Dateisysteme wie
  im obigen Beispiel verschachtelt sind. Ausserdem wäre es nett, noch weitere Daten übergeben zu können, z.B. dass bestimmte
  Zugriffsflags verwendet / nicht verwendet werden sollen (z.B.: Zip-File nicht memory-buffered öffnen), oder weitere
  unbestimmte Informationen (annotation like).
- FileAccess implementiert, dies soll so funktionieren wie oben angegeben. Kleines Beispiel:
  FileAccess sAccess;
  sAccess["www.pixel-light.de"].SetAuth("username", "password");                // Username und Passwort für HTTP
  sAccess["http://www.pixellight.org/test.zip"].SetPassword("password");        // Passwort für die ZIP-Datei
  sAccess["http://www.pixellight.org/test.zip"].SetFlags(File_::FileMemBuf, 0); // ZIP-Datei ohne FileMemBuf öffnen
  File cFile("http://www.pixellight.org/test.zip/dir/test.txt", sAccess);
  Etwas problematisch ist es zur Zeit noch die Frage, welcher Name für welche Zugriffsoptionen verwendet werden soll.
  FileZip sucht nach dem exakten Namen der Zip-Datei, also z.B. "http://www.pixellight.org/test.zip",
  FileHttp sucht dagegen nach der Domain, also z.B. "http://www.pixel-light.de". Gerade im Falle von HTTP ist das schwierig,
  da man ja nicht genau weiss, wo auf dem Server der Passwortschutz eingerichtet ist.
- FileAccess um bCaseSensitive erweitert. Dies wird von FileZip ausgelesen, somit kann man bestimmen, ob eine Zip-Datei
  case-sensitive behandelt werden soll oder nicht. Standardwert ist jetzt 'true', da wir dies anderswo auch meist so behandeln!
- Ebenfalls prüft FileZip nun, ob ein Wert für FileMemBuf angegeben wurde. Ist dies der Fall, wird dieses Flag übernommen,
  damit kann also das automatische Buffern von Zip-Dateien ausgeschaltet werden. Das Prinzip der Flags in FileAccess funktioniert
  so: Alle Flags, die in FlagsMask angegeben werden, gelten als "gesetzt" (egal ob 1 oder 0). Deren Wert wird dann in FlagsValue
  bestimmt. Beispiel: (Mask = Read | MemBuf, Value = Read) bedeutet, dass Read = 1 gewünscht ist und MemBuf = 0. Alle anderen
  Werte sind nicht weiter bestimmt. Allerdings sind die ganzen Angaben in FileAccess nur "Wünsche", die berücksichtigt werden
  können aber nicht müssen. Im Moment wird also nur bei Zip-Dateien auf MemBuf geachtet, alle anderen Flags werden ignoriert.
  Man kann dies also nciht nutzen, um z.B. eine Zip-Datei auch zum Schreiben zu öffnen oder ähnliches.
- Mir ist aufgefallen, dass man auf die Values einer HashMaps nur noch als const zugreifen kann, man also die Werte später
  nicht mehr ändern kann. Gerade beim FileAccess brauche ich aber auch die Möglichkeit, die Objekte später noch zu ändern.
  Habe das daher erst einmal eingehackt, Christian sag bitte mal bescheid ob das so ok ist oder ob ich das anders lösen
  sollte.



>> 03.12.2007
[SB]
- HttpHandle: Beim Lesen von Daten über das Netz kann es häufig vorkommen, dass noch nicht genügend Daten im Stream
  vorhanden sind, in dem Fall gibt Socket.Read() einfach so viel zurück, wie bereits vorhanden ist, auch wenn dies
  weniger ist als angefordert. Dies ist so ok und sollte denke ich auch nicht geändert werden, wenn man mit Sockets
  arbeitet muss man dies einfach einplanen. Beim Arbeiten mit Dateien wird jedoch davon ausgegangen, dass Read() genau
  so viel liest wie angefordert, wenn weniger gelesen wird, ist dies ein Fehler. Daher habe ich dies in HttpHandle::Read()
  so geändert, dass so lange immer wieder vom Socket gelesen wird, bis die gewünschte Datenmenge erreicht wurde, es
  kann also hier nicht mehr vorkommen, dass zu wenig gelesen wird. Bei grossen Dateien könnte dies also einen Moment
  lang dauern :-) 
- HttpHandle: Fehler behoben, es muss die gesamte URL übermittelt werden, damit ein Webserver, der mehrere Domains hostet
  (wie bei uns) weiß, welche gemeint ist.
- HttpHandle: Es wird nun auch Http-Auth (Basic) unterstützt, damit kann also per Username und Passwort auf geschützte
  Webseiten zugegriffen werden.
- Memory buffered files implementiert: Wird eine Datei mit dem Flag FileMemBuf geöffnet, so wird der gesamte Inhalt der
  Datei eingelesen und im Speicher behalten, alle weiteren Lesezugriffe finden dann nur noch auf diese Buffer statt.
  Ich habe mich für die Bezeichnung "Memory Buffered" entschieden, da "Memory Mapped" viele unterschiedliche Bedeutungen
  hat (z.B. auf OS-Ebene, um mittels gemappter Dateien IPC zu betreiben), da scheint mir "Memory Buffered" eindeutiger
  und daher leichter verständlich. Der Buffer und der Zugriff darauf befindet sich in der Klasse File, und kann nur zum
  Lesen verwendet werden.
- ZipHandle: Das Zip-File wird nun mittel FileMemBuf geladen. Hier sollten wir uns noch überlegen, ob man das evtl. von
  der Dateigröße abhängig machen sollte, oder irgendwie eine Möglichkeit geben sollte, dies wenn gewünscht zu deaktivieren.



>> 02.12.2007
[SB]
- Habe die Basisklassen von PLNetwork nach PLGeneral/Network verschoben, da Sockets und Netzwerkkommunikation eigentlich
  zu den System-Basisklassen gehören. Alles weitere, also die Struktur der Netzwerkkommunikation in PL, wird wie geplant
  in PLNetwork implementiert werden, die Basisklassen können jedoch auch an anderen Stellen nützlich sein. 
- Netzwerk-Basisklassen überarbeitet und wo möglich vereinfacht.
- HTTP-Client hinzugefügt. Analog zu den ZIP-Dateien gibt es eine Klasse HttpHandle, die benutzt werden kann, um eine
  HTTP-Verbindung mit einem Server aufzumachen und Dateien zu übertragen. Diese Klasse kann bislang nur das nötigste, also
  nur das Übertragen einer Datei per HTTP/1.0 sowie das auslesen der wichtigsten Header-Informationen. Alles andere kann
  später erweitert werden.
- HTTP-Implementation für das FS hinzugefügt. Damit kann per HTTP auf Dateien aus dem Netzwerk zugegriffen werden, was ich mir
  sehr nützlich vorstelle, um z.B. News von der Webseite zu laden (oder auch Updates). Dank der Schachtelung ist natürlich auch
  etwas wie "http://www.pixellight.org/test.zip/test.txt" möglich, was auch gut funktioniert, allerdings nicht zu empfehlen ist :-)
- Linux-Implementation für das FS hinzugefügt.
- Generische Funktionen für das Kopieren und Verschieben von Dateien hinzugefügt. Zunächst wird versucht, die systemspezifische
  Implementation für die entsprechende Funktion zu verwenden, wenn dies fehlschlägt, wird es mit der generischen Variante
  versucht: Wenn man z.B. eine Datei aus einer Zip-Datei irgendwo hin kopieren möchte, wird dies mit der Systemfunktion
  natürlich nicht gehen. Das Herunterladen einer Datei aus dem Netz kann man nun also z.B. so erledigen:
    File("http://www.pixellight.org/test.zip").Copy("C:\\test.zip")



>> 01.12.2007
[SB]
- Funktionalität von ZipHandle vervollständigt.
- FileZip und FileSearchZip unter Verwendung von ZipHandle wieder implementiert und getestet. Das Verhalten je nach
  Lesemodus (Binary oder Text) an die Systemfunktionen angepasst.
- Beim Öffnen einer Datei wird die Implementationsklasse automatisch ermittelt: Entweder mittels des Protokolls,
  oder durch Suche nach ".zip/" oder ".pak/" im Dateinamen. Dadurch muß eine Zip-Datei als Verzeichnis so geöffnet
  werden: Directory("test.zip/"), da "test.zip" an sich auch eine valide Datei wäre. Innerhalb der Zip-Datei sind aber
  z.B. "test.zip/test" und "test.zip/test/" identisch.
- Eine Problematik beim Verwenden von Zip-Dateien: Mir ist aufgefallen, dass in einer Zip-Datei nicht unbedingt alle
  Unterverzeichnisse auch aufgelistet werden. Wenn ich unter Windows direkt oder mit TugZip eine Zip-Datei packe, gibt es
  z.B. die Einträge "test/dir1/test1.txt" und "test/dir1/test2.txt", aber weder "test/dir1/" noch "test/". Je nachdem,
  welches Programm man verwendet, ist dies mal so und mal so, aber offensichtlich kann man sich nicht darauf verlassen,
  dass alle Verzeichnisse auch direkt aufgelistet werden. Dieses Problem in den Zip-Klassen zu lösen wäre denke ich etwas
  aufwendig, da man die Pfade auseinandernehmen und eine eigene Liste erstellen müßte, anstatt einfach nur alle Einträge
  in der Zip-Datei durchzugehen. Später sollte man dies wohl tun, damit es keine Probleme mit "schlechten" Zip-Dateien gibt,
  im Moment würde ich aber einfach darauf achten, dass die Zip-Dateien vernünftig sind - zip unter Linux trägt beispielsweise
  alles korrekt ein :-)



>> 21.11.2007
[SB]
- Übertragen der Zip-Implementation begonnen.
- Neue Klasse ZipHandle erstellt, welche auf einer Zip-Datei arbeitet. Vereinigt die Funktionalität von StreamZip und IteratorZip,
  denn diese getrennten Klassen arbeiteten letztlich beide auf dem File-Handle von DirectoryZip, was ich sehr undurchschaubar
  finde. Weitere Zip-Funktionalität war auch noch innerhalb von DirectoryZip und FileZip verstreut, das wurde ebenfalls in diese
  Klasse übertragen. ZipHandle besitzt nun selber den File-Handle für die Zip-Datei und soll als generelles Interface dienen, um
  den Inhalt der Zip-Datei aufzuzählen und anschliessend z.B. auf den Anfang einer Datei zu springen und diese auszulesen.
- Neue eingebettete Klasse ZipHandle::ZipEntry hinzugefügt. Diese Klasse enthält die Informationen zu einem Eintrag
  innerhalb der Zip-Datei. Damit sind diese Informationen nicht mehr direkt in ZipHandle (übersichtlicher), außerdem kann so
  leichter eine Liste von Zip-Entrys erstellt werden, was man z.B. innerhalb der FS-Abkapselung machen könnte, um den Zugriff
  auf das Directory schneller zu machen. 
- Da die verteilten Zip-Funktionen recht verwirrend waren, bin ich mir nicht 100% sicher, ob ich alles richtig übertragen habe.
  Christian: Bitte schau nochmal genau drüber und teste wenn möglich ZipHandle etwas, ob noch alles richtig funktioniert.
- ZipHandle überarbeitet und versucht, das Interface sowie die Variablennamen verständlicher zu machen. Diese Klasse soll für
  sich alleine genommen schon leicht verwendet werden können, um auf eine Zip-Datei zuzugreifen und diese auszulesen. Die weitere
  Abstraktion über FileZip und FileSearchZip dient dann nur noch dazu, Zip-Files auch transparent über das FS-Interface nutzen
  zu können. Es soll aber auch ganz ohne gehen, die gesamte Zip-Funktionalität soll also in ZipHandle vorhanden sein.  
- Kleinen Test implementiert, der den Zugriff auf Zip-Dateien nur über ZipHandle demonstriert testet. Konnte bisher keine Fehler
  feststellen, das Verzeichnis eines Zip-Files sowie der Inhalt der enthaltenen Dateien werden mir korrekt angezeigt. 



>> 20.11.2007
[SB]
- Basisklassen und Win32-Implementation für das Dateisystem sind weitgehend vollständig (bis auf Suchfilter).
  Das Klassenlayout wurde stark vereinfacht und gleichzeitig teilweise erweitert, so ist das Erstellen, Löschen,
  Umbenennen, Verschieben usw. nun direkt über ein File- oder Directory-Objekt möglich. Dabei gibt es nun auch
  ein Muster, welches wir sonst selten haben: Gleichnamige Funktionen in abgeleiteten Klassen, die *nicht* virtuell
  sind. File::Create erstellt eine neue Datei, während Directory::Create ein Verzeichnis erstellt. In der Basisklasse
  gibt es diese Funktion nicht, daher dürfte dies kein Problem darstellen, und über das verwendete Interface legt
  der Programmierer deutlich fest, was von beidem er tun möchte, das ganze scheint mir so also auch am intuitivsten zu sein.
- Mittels Assign kann das Datei-Objekt auf einen neuen Dateinamen gelenkt werden. Dabei werden automatisch vorher
  geöffnete Dateien geschlossen, das Objekt "zeigt" also dann auf eine andere Datei (diese muß nicht mal vorhanden sein).
  Beispielsweise kann so eine Datei oder ein Verzeichnis angelegt werden: Directory("test").Create();
- Dateiflags vervollständigt und in hoffentlich üblicherer Weise verwendet (z.B. gibt es nun neben FileWrite auch FileRead,
  ebenso gibt es FileBinary und FileText).
- Die Url-Klasse wird nur noch intern eingesetzt, im Interface werden dagegen nur noch Strings übergeben. Ansonsten müßte
  man ständig Methoden doppelt machen, obwohl der User wohl meist sowieso Strings übergeben wird. Ausserdem sollte Url
  sowieso so selten wie möglich eingesetzt werden, um unnötiges Parsen des Dateinamens zu verhindern.



>> 19.11.2007
[SB]
- Klasse Url überarbeitet und vereinfacht. Ein Pfad wird nun *immer* intern in URL-Form gespeichert, d.h. mit Protokoll
  und mit '/' als Trennzeichen. Beim Umwandeln werden auch nicht mehr unterschiedliche Url-Instanzen kopiert, sondern
  direkt die Strings wie gewollt umgewandelt. Dies scheint mir am einfachsten und ist in der Benutzung konsistent, da
  es keine Unterschiede mehr geben kann, in welcher Form verschiedene Url-Instanzen ihre Werte vorliegen haben. Im allgemeinen
  möchte man eine Url meist im einheitlichen Url-Format angeben, dieser Zugriff ist daher auch immer der schnellste, da nur
  ein String zurückgegeben werden muss. Will man dagegen in ein spezielles Format umwandeln, ist dies etwas aufwendiger, dafür
  macht man dies meist nur einmal (z.B. beim Erzeugen einer FileWin32-Instanz). Da diese dann nur als String und nicht mehr
  als Url gespeichert wird, entfällt dafür aber auch der Overhead, noch einmal die umgewandelte Url in ihre Bestandteile
  zu zerlegen.
- FileObject: Die URL eines jeden Objektes wird jetzt immer ohne ein abschließendes '/' gespeichert. Damit ist der Dateiname
  eines FileObject immer korrekt, und man kann sich sicher sein, wie dieser verwendet werden muß (z.B. kann der Suchpfad
  eines Verzeichnisses jetzt immer korrekt durch Hinzufügen von /*.* erzeugt werden). Eine URL kann aber weiterhin Pfade
  speichern, die mit / enden, da dies für eine URL von Bedeutung sein kann.



>> 13.11.2007
[SB]
- Rewrite des Dateisystems begonnen.
- Globale Klasse FileSystem entfernt.
- Die Klassen FileObject, File und Directory bleiben von der Funktionsweise sehr ähnlich, werden nun aber direkt verwendet,
  müssen also nicht mehr dynamisch erzeugt werden und beinhalten auch keine virtuellen Funktionen mehr.
- Die systemspezifischen Implementationen werden von der Klasse FileImpl abgeleitet und kapsel sowohl die Datei- also auch
  die Verzeichnisoperationen ab. Ein FileObject erzeugt eine Instanz einer von FileImpl abgeleiteten Klasse und verwendet
  diese.
- Das Auflisten/Suchen von Dateien wird wie bisher über eine eigene Klasse gehandhabt, wobei SearchHandle in FileSearch
  umbenannt wurde. Diese Klasse verwendet ebenfalls das Backend-Schema, zu einer Instanz von FileSearch gehört daher
  immer eine systemspezifische Implementation welche von FileSearchImpl abgeleitet ist.
- Alle Dateifunktionen sollen über die Klassen FileObject/File/Directory zu verwenden sein, z.B. auch das Erstellen
  neuer Dateien oder Verzeichnisse ebenso wie das Löschen. Dies sollte einfacher zu verwenden sein als vorher, wo manche
  Funktionen nur über das globale Filesystem-Interface ausgeführt werden konnten.



>> 12.11.2007
[SB]
- Rewrite begonnen. Ziel ist es, die Basisklassen deutlich zu vereinfachen und zu verschlanken, wobei folgende Ziele
  verfolgt werden:
  * Alle Klassen sollten möglichst direkt instanziiert werden können, damit es dem Programmierer frei steht, ob er eine
    Klasse direkt verwendet oder dynamisch erzeugt, was auch eine effizientere Nutzung ermöglicht. Es sollte daher nicht mehr,
  wie bisher, eine dynamische Erzeugung von Objekten erzwungen werden, da dies auch die Problematik der späteren
  Speicherfreigabe beinhaltet und generell komplizierter in der Verwendung ist.
  * Möglichst keine globalen Manager mehr, welche alle Instanzen einer oder mehrerer Klassen verwalten. Dies ist zwar manchmal
    sinnvoll (z.B. für Ressourcenmanager), aber oftmal auch komplett unnötig (z.B. Dateisystem, Systemklassen allgemein).
  * Die Basisklassen sollten möglichst schlank sein, also direkt möglichst einfach zu verwenden sein und dabei möglichst
    wenig Overhead erzeugen. Dies bedeutet vor allem, dass die Basisklassen vom RTTI unabhängig sein sollen und
    daher deutlich von den RTTI Klassen getrennt werden, diese arbeiten dann auf einer höheren Ebene über den Basisklassen.     
- Ausserdem werde ich versuchen, folgende Konventionen einzuhalten:
  * Keine Verschachtelung mehr von Unterverzeichnissen, da dies eher wieder unübersichtlicher wird als übersichtlicher. Also
    wird es z.B. nur noch das Verzeichnis FileSystem geben, darin jedoch keine weiteren Unverzeichnisse für Zip, Win32, Linux etc.    
  * Das Backend-Prinzip wird konsequent umgesetzt, also überall dort, wo es Systemspezifische Implementationen gibt, wird
    es nach aussen eine Systemunabhängige Klasse geben, welche die Details über eine systemspezifische Implementationsklasse
    abkapselt (1:1-Beziehung). Dieses Vorgehen bringt am wenigsten Probleme mit sich und ist sehr flexibel und ist daher besser,
  als z.B. direkt die Systemspezifischen Klassen abzuleiten (zumal dies nicht damit vereinbar ist, die Klasse direkt zu
  instanziieren).



>> 23.10.2007
[SB]
- Definition von _CRT_SECURE_NO_DEPRECATE in CMakeLists.txt hinzugefügt. Dabei ist mir aufgefallen, dass im VC-Projekt
  diese Definition nicht auf die übliche Weise unter "Präprozessordefinitionen" hinzugefügt wird, sondern per
  "zusätzliche Optionen" der Kommandozeile. Habe das mal geändert, da ich keinen Grund sehe das hier anders zu machen
  als bei den sonstigen Definitionen und man so nur unnötig suchen muss.



>> 20.10.2007
[SB]
- zlib.dll auch aus den Installationsanweisungen in der CMake-Datei entfernt.



>> 19.10.2007
[CO]
- zlib wird im VC8 Projekt nun genauso wie in der CMake-Datei statisch eingebunden. 'zlib.dll' aus dem Runtime-Ordner gelöscht.



>> 13.10.2007
[CO]
Alle Projekte:
- Einige 'const' eingefügt
- Einige '#define' entfernt
- Ein paar Absätze eingefügt



>> 07.10.2007
[CO]
Alle Projekte:
- Einige 'const' eingefügt um dem Compiler das Leben etwas einfacher zu machen und möglichen unerwünschten Manipulationen
  vorzubeugen
- Dort wo es problemlos möglich war machte ich beim Speichern das zu speichernde Objekt Konstant. Bei ein paar Loadern wie z.B.
  Mesh Loadern ist dies leider nicht möglich da Index Buffer beim Lock verändert werden.
PLGeneral:
- String(const Variant &cVariant) entfernt da überflüssig, da nutzt man lieber Variant::GetString() :D
- Variant: Entfernte alle 'char*'-Funktionen da intern sowieso als 'String' gespeichert wird und man es daher gleich auch
  so übergeben kann ohne das es einen wirklichen Unterschied macht. Die 'GetString()'-Funktion erzeugt nun auch gleich den
  String und gibt diesen zurück ohne das dieser eventuell in 'm_sString' gespeichert wird... das macht die Sache zwar langsamer
  wenn öfters diese Funktion hintereinander aufgerufen wird - allerdings hat diese Funktion wirklich konstant zu sein.
- Parameters::GetParams() entfernt da dies einen Iterator zurückgab über den man die Variablen hätte verändern können +
  diese Funktion wurde nirgends verwendet.



>> 17.09.2007
[CO]
- Nahm das aktuelle Experimentelle Error System heraus da dies erstmal wohl nicht weiterverfolgt wird. Hab dafür im
  lab-Repository ein entsprechendes Projekt mit diesem System angelegt.
- Entfernte nach Rücksprache mit Stefan 'PLBool'. Wir wollten zwar das noch solange drinnen lassen bis die Sache wie/ob
  wir ein 'Error System' implementieren geklärt ist - allerdings ist es nicht abzusehen ob/wann das gemacht wird. Darum
  kommt das nun raus damit die Codes nicht mehr ganz so unfertig/höchst Experimentell wirken. Sollte man dann irgendwann
  ein 'Error System' haben, müsste man eh nochmal alles im Detail durchgehen.
  Das war nun zwar wieder einiges an Fleißarbeit, aber so isses wieder viel besser da übersichtlicher + weniger Overhead...
  die einzelnen dll's sind gleich um ein paar KB (eine davon sogar um 30! :) kleiner geworden. *g*



>> 15.09.2007
[CO]
- XML-Klassen: Die Konstruktoren noch etwas aufgeräumt - keine Ahnung wieso ich das damals so umständlich machte. 'void *'
  hab ich allerdings als Parameter gelassen, man 'könnte' zwar eine direkte Referenz auf das TinyXml Objekt übergeben, aber
  dann 'müsste' diese TinyXml Klasse als 'Predefinition' in unseren XML-Headern stehen... und das will ich nicht. :D
  Nur die 'XmlDocument' Klassen Dokumentation weist darauf hin das intern TinyXml verwendet wird, ansonnsten sollte das wie
  gehabt absolut verborgen bleiben WIE das Implementiert ist.
- CmdLineParser nochmal etwas aufgeräumt



>> 14.09.2007
[CO]
- Element & Resource: 'Delete()'-Funktion liefert als Rückgabewert nun ob alles gut ging oder ein Fehler auftrat



>> 13.09.2007
[CO]
- Da ich in Jens 'Kabiene'-Szene hin und wieder recht heftige stocker habe wenn ich einen neuen Raum betrete (wie es aussieht
  muss die GPU viele Textur Daten umschaufeln) das dazu führt das alles kurz 'einfriert' und ich danach weit außerhalb der
  Szene bin, versuchte ich solche unregelmäßigkeiten im Timing etwas zu Kompensieren.
  In 'Timing::Update()' wird die Änderung des Zeit unterschiedes mit dem des letzten Frames verglichen und wenn diese Werte
  ZU stark voneinander abweichen wird hier 'geglättet'. Über die neue Funktion 'GetTimeDifferenceNoCompensating()' kann
  man sich den 'wirklichen' Zeit unterschied ohne 'Korrekturen' zurückgeben lassen um z.B. feststellen zu können ob
  unregelmäßigkeiten auftraten.



>> 08.09.2007
[CO]
- DirectoryZip::SearchCentralDir() vereinfacht, der Zwischenbuffer liegt nun direkt auf dem Runtime-Stack
- DirectoryZip::OpenObject(): Der verwendete ZIP-Iterator liegt nun direkt auf dem Runtime-Stack



>> 24.08.2007
[CO]
- SystemWin32::ErrorCodeToString() statisch gemacht da man wirklich keine Instanz der System Klasse dafür braucht
- DynLibWin32::Load(): Gibt nun über 'SystemWin32::ErrorCodeToString()' eine Fehlerbeschreibung aus
- Localization::SetLanguage(): Nahm hier das [TODO] raus. Diese Funktion setzt wirklich nur einen String, für das Laden
  der konkreten Sprachen ist die jeweilige Implementation selbst verantwortlich. Generell wird die Sprache am besten NUR
  beim Programm-Start gesetzt und geladen, denn das jederzeit ändern zu können wäre ziemlich Tricky... denn man müsste dann
  irgendwie ALLES Informatieren das sich die Sprache geändert hat, alle Strings in allen Programmteilen müssten sich updaten
  etc. - sehr viel sehr unschöne Arbeit für wenig Nutzen. Das sparen wir uns lieber und gehen den einfachen Weg. :D



>> 22.08.2007
[CO]
- Machte ein paar Änderungen an der Time-Klasse:
  - Ein paar statische Zeiten spendiert, 'Null' wird z.B. in PLNetworkIRC::IRCConnection::ProcessServerMessage()
    verwendet.
  - Fügte eine Funktion Namens 'ToString()' hinzu über die man sich eine String Repräsentation der Zeit zurückgeben lassen kann.
  - m_nDay in m_nDayOfMonth + die entsprechenen Funktionen umbenannt damit eindeutig ist WAS das ist
  - 'EMonth' fängt nun wie EDay bei 0 (wie bei Linux und nicht wie bei Win32 SYSTEMTIME) an damit das einheitlich ist + man
    sich direkt die in ToString() verwendete String Representation des Monats/Tages über ShortMonthName[Month] bzw. ShortDayName[Day]
    zurückgeben lassen kann.
  - Einfache vergleichs-Operatoren hinzugefügt.
  - Funktion IsLeapYear()' hinzugefügt die ermittelt ob ein gegebenes Jahr ein Schaltjahr ist oder nicht.
  - Funktion 'SetUnixDate()' hinzugefügt.
  - Funktion CalculateDayOfWeek()' hinzugefügt die den Wochentag berechnent auf den ein Datum fällt. SetDOSDate() nutzt
    diese Funktion.
  - 'Unkown' aus 'EDay' entfernt da man sich diese Information nun berechnen lassen kann wenn man diese nicht direkt hat.



>> 21.08.2007
[CO]
- "NoMemoryManager.h" entfernt da wir das derzeit so nicht brauchen da wir keine Memory-Makros nutzen
- Konnte in "Checksum::Get(const String &sClass, File &cFile, PLResult *pResult)" das [TODO] entfernen da es mittlerweile
  möglich ist zu prüfen ob man aus einer Datei lesen kann.



>> 07.08.2007
[CO]
- FSTools: ValidatePath(): War leider etwas Problematisch da man nicht genau wusste ob nun am ende ein '/' eingefügt werden
  sollte oder nicht. Darum zerlegte ich diese Funktion in zwei Funktionen:
  - Einmal ValidateFilePath() welche einen Dateinamen korrekt macht
  - Und ValidateDirectoryPath() welche auf ValidateFilePath() aufbaut + sicherstellt das am Ende ein '/' ist
  -> Gefällt mir zwar nicht wirklich gut, alledings wüsste ich nicht wie man das anderst handhaben sollte... der User MUSS
     wissen WAS dieser 'Pfad' Darstellt, darum muss er uns das auch mitteilen damit man nicht irgendetwas falsches annimmt.
     "C:/MyDirectory/Test" könnte ein Verzeichniss sein, aber auch eine Datei ohne Dateiendung, darum MÜSSEN Verzeichnisse
     bei uns ausdrücklich mit '/' am Ende gekennzeichnet werden damit keine Mehrdeutigkeiten vorhanden sind. Allmählich fände
     ich es irgendwie erleichternd wenn wir überall bei Datei/Verzeichniss Namen die 'Url'-Klasse nehmen würden - das würde an
     vielen  Stellen einiges einfacher machen da man nicht mehr irgendeinen Mehrdeutigen Schrott übergeben bekommen kann.
     Derzeit sind an vielen Stellen immer ähnliche Abfragen, und an ein paar Stellen auch nicht wo es dann schnell mal zu
     Problemen kommen kann. :(
  -> Auf jedenfall sind sind nun keine FS Basis Pfade mehr 'doppelt' eingetragen (dort kam gerade durch eventuell fehlende
     '/' einiges durcheinander)



>> 03.08.2007
[CO]
Allgemein:
- Nahm überall
    m_pImage->SetInteger(PLGraphics::Image::Mode_OriginSet,  true);
    m_pImage->SetInteger(PLGraphics::Image::Mode_OriginMode, PLGraphics::Image::Origin_UpperLeft);
  vor dem Laden von Bildern raus - diese Einstellungen sind/waren bei uns bereits Default, und innerhalb von PL sollte da
  auch nix umgestellt werden. (0, 0) ist bei uns also überall 'links oben'. (u.a. DirectX nutzt diese Regel) Texturen die
  der GPU übergeben werden nutzen bis jetzt "(0, 0) ist links unten". (wie in OpenGL) Bis jetzt war das 'nur' inkonsistent,
  aber da wir nun verstärkt dds nutzen (um die Textur Massen halbwechs bewältigen zu können) zeigte sich das dies hier sehr
  unhandlich ist da dds von DirectX kommt. Zwar passt DevIL immer braf 'oben/unten' für uns an, aber bei den DXTC Daten die
  wir, wenn verfügbar direkt zur GPU jagen, wird nix verändert. (war auch wenig Sinnvoll wäre da man sich dadurch wieder
  den Geschwindigkeitsvorteil kaputt machen würde :)
  Dadurch hatte man dann 'geflippte' Texturen. Darum nun dieses Änderung, damit das zum einen bei uns einheitlich wird +
  das man die Vorteile die dds bietet richtig nutzen kann.
  Musste nun zwar sorfältig prüfen wo z.B. Textur Koordinaten verwendet werden und dort über "1-y" vertauschen, oder "1-y"
  rausnehmen wo nun nicht mehr vertauscht wird - aber das lohnte defintiv. Endlich ist da Ordnung drinnen und in
  PLMesh::Texture::Load() konnte ich nun endlich einen doofen Hack rausnehmen der sowieso nicht zu 100% funktionierte.
  (über dieses 'flip'-Problemchen stolperte ich schon früher im Zusammenspiel mit cube dds Texturen)
- Stellte überall wo möglich/sinnig Texturen auf das dds-Format um. (Texturen != OS Gui Bitmaps, da macht das natürlich weniger
  Sinn da man dadurch keine Vorteile hat :)
-> Es wird sicherlich noch einige Tage dauern bis ich 'soweit alle' Stellen angepasst habe die von diesen Änderungen betroffen
   sind. Aber im großen und ganzen geht alles wieder wie vorher - nur halt flotter zu laden + Grafiker haben direkt selbst
   Kontrolle über die MipMaps und was genau für Kompression verwendet werden soll. :D
   (ohne dds geht das im Grunde nur automatisch -> man hat weniger Kontrolle)



>> 02.08.2007
[CO]
Allgemein:
- Alle Doxygen Konfigurations-Dateien über "doxygen -u" auf den neusten Stand gebracht
- Machte bei allen Loadern alle Funktionen const. Da es von diesen Loader Klassen jeweils nur eine globale Instanz gibt darf
  keine der Funktionen etwas an diesen Objekten ändern oder man bekommt spätestens bei Multi-Threading probleme. Ein paar
  wenige Loader nutzen nun einfach 'pro Instanz'-Daten.



>> 01.08.2007
[CO]
- 'SearchHandleZip' hatte nicht das gleiche Verhalten wie die anderen Implementationen die zuerst '.', anschließend '..' und
  erst dann die 'richtigen' Dateien auflistet... das viel in 'PLSceneViewer.exe' auf wenn man im Datei-Dialog in ein
  'zip-Verzeichniss' wechselte, aber keine '..' mehr da waren zum zurück gehen.



>> 30.07.2007
[CO]
- Loadable: Merkt sich nun auch den 'original' Dateinamen der zum Laden verwendet wurde
- LoadableType::AddLoader: Wenn ein Format bereits im Manager durch einen anderen Loader eingetragen wurde so ist das kein
  Fehler, sondern heist nur das man nicht eindeutig über die Dateiendung rausbekommen kann welcher Loader für dieses Format
  zuständig ist. Dies ist allerdings KEIN Problem da sowieso immer bekannt sein sollte WAS man denn eigentlich laden will,
  also obs ein Mesh, eine Scene etc. ist. Das DirectX Format kann z.B. als Mesh verwendet werden, aber da es sehr flexibel
  erweiterbar ist + Hierarische Strukturen hat kann es genauso auch als Scene genutzt werden.
  Was allerdings auch vorkommen kann ist, das z.B. zwei verschiedene Mesh Formate die gleiche Dateiendung haben, ja eventuell
  sogar im Grunde das gleiche Format sind, aber unterschiedliche Versionen davon. Derzeit wird soetwas noch nicht Unterstützt,
  müsste sich später aber erweitern lassen... macht die Sache allerdings bestimmt nicht einfacher oder übersichtlicher. *g*
- Nahm die String Duplizierung aus Loadable::Reload() heraus, in Loadable::Load() ist nun ein universellerer 'Sicherheits'
  Test drinnen



>> 22.07.2007
[CO]
- 'Function': Machte den Konstruktor protected und Dokumentierte kräftig da ich gerade ein paar Stunden damit verbrachte
  rauszubekommen was 'genau' (hatte vorher nur eine sehr grobe Vorstellung) das ist bzw. wie man es verwendet. In PLBaseTest
  gibts nun einige Tests für diese Funktionalität... anhand dieser Tests hab ich mich an die Sache rangetastet - Stefan,
  gib mir irgendwann bitte bescheit ob ich das soweit richtig verstanden habe und es auch wie vorgesehen nutze. :)
  Die Investierte Zeit hat sich auf jedenfall gelohnt, denn nun versteh ich was da abläuft - wirklich eine sseeehr feine
  Sache. :)
- Container-Klassen abermals durchgeschaut und kleinigkeiten verbessert



>> 21.07.2007
[CO]
Alle Projekte:
- Die paar 'realloc' welche noch verwendet wurden durch 'MemoryManager::Reallocator()' ersetzt + stellen an denen noch z.B.
  'memcpy' verwendet wurde ebenfalls umgestellt damit wirklich alles über den Memory Manager läuft. Das mag zwar auf den
  ersten (und eventuell zweiten und dritten und... *g*) Blick 'extrem' erscheinen, hat aber durchaus so seine Vortelle da
  alles eine 'Zentralverwaltung' passiert. (...big brother is watching you...)
PLGeneral:
- SystemWin32: Erste Öffentliche Funktion eingebaut: ErrorCodeToString(): Wandelt einen Win32 Fehler Code den man über
  GetLastError() erhalten hat in einen PL-String den man dann z.B. direkt ins Log schreiben kann... das hatte ich vor einiger
  Zeit schonmal irgendwo lokal reingehackt als ich mir beim Debuggen Win32 Fehler als String zurückgeben lies.
  In SystemLinux hab ich soetwas nicht eingebaut da es unter Linux eine Funktion namens 'strerror' gibt die sich sehr leicht
  weiternutzen lässt.
- System: Neue Funktion: IsLittleEndian(): Damit kann man feststellen welche Byte-Reihenfolge die aktuelle Maschine für
  größere primitive Datentypen verwendet. Zukünftig können wir diese Funktion nutzen um zu entscheiden wie man z.B. ein
  'float' in eine Binär Datei schreiben oder auslesen muss. Das bringt allerdings erst 'wirklich' etwas sobald wir nicht mehr
  wie momentan direkt über die Write/Read-Funktionen der File-Klasse diese Daten schreiben/lesen... da muss dann ein kleiner
  Wrapper her damit wir 'wirklich' Plattform unabhängig werden, also auch damit klarkommen wenn die Byte-Reihenfolge anderst
  herum ist. :)
  Ich habe die Funktion 'IsLittleEndian()' und nicht 'IsBigEndian()' genannt da wir derzeit eigentlich nur auf Little-Endian
  Geräten arbeiten und ich denke auch diese Anordnung in unseren Binär Formaten behalten werden - der Funktionsname deutet
  also so bereits an mit welcher Anordnung PL 'intern' arbeitet.
- Nahm die auskommentierten Memory-Makros aus 'MemoryManager.h' nun komplett raus da wir das denk ich mal so nicht nutzen
  werden da es einfach 'unschön' und fehleranfällig ist - es wäre einfach nur doof 'überall' 'MemoryManager.h' einbinden zu
  müssen nur damit die Makros 'wirksam' werden. Wenn man brav mit new/delete arbeitet braucht man das auch nicht wirklich.



>> 19.07.2007
[CO]
Alle Projekte:
- Wenn über new Instanzen von Klassen erzeugt werden, aber dem Konstruktor nix übergeben wird, war die Schreibweise nicht
  einheitlich. Überwiegend hatten wir z.B. "new MyClass()" -> also mit "()" am Ende. So sieht man im Grunde sehr häufig,
  und mittlerweile bin ich diese Schreibweise auch durch Jave gewohnt. Daher änderte ich das entsprechend. (aber nicht
  wenn z.B. Primitive Datentypen oder Strukturen erzeugt werden... das kommt mir da etwas merkwürdig vor und das sieht
  man auch praktisch nie so geschrieben :)
PLGeneral:
- Fand noch zwei Stellen wo ich sehr einfach malloc/free durch new/delete ersetzen konnte. Wo immer möglich (also praktisch
  überall :) sollte man lieber new statt malloc etc. nutzen - dadurch braucht man sich dann auch keine Sorgen zu machen 'wo'
  bzw. 'wer' den Speicher anlegt. 'new' lässt sich ja sehr einfach überladen was auch bereits gemacht wird... aber 'malloc' &
  CO kann man nicht wirklich überladen. Zwar könnte man ein Makro schreiben, (was ich zum probieren auch machte :) das führt
  allerdings dann zu mehr Problemen (teils sogar zu Compiler fehler in Third-Party libs) als es Nutzen bringt.
  An ein paar Stellen wird noch realloc genutzt, diese Stellen werde ich bei Zeiten noch ändern damit wir in PL wirklich
  nur new/delete nutzen um möglichen Problemen der Speicherverwaltung gleich von Anfang an aus dem Weg zu gehen.
  (man muss soetwas ja nicht provozieren :)



>> 08.07.2007
[CO]
Alle Projekte:
- Entfernte einige &<Name>[0] da & und [0] automatisch vom Compiler hinzugefügt wird und das ohne besser Lesbar ist :)
PLGeneral:
- Fügte ein paar  #error "Unsupported platform"  ein (z.B. in SystemImpl.cpp)



>> 06.07.2007
[CO]
- Die Datei & Klassen Namen der FS Implementationen folgten nicht der Benennung der anderen PL Dateien



>> 24.06.2007
[CO]
Alle Projekte:
- Merkte gerade das in den meisten Dateien der inline Implementationen z.B.
    #ifndef __PLRENDERER_SHADERCGBACKEND_INL__
    #define __PLRENDERER_SHADERCGBACKEND_INL__
  etc. steht, also wie bei den Headern. Dies ist hier allerdings völlig überflüssig da diese Dateien NUR von den jeweiligen
  Headern selbst eingebunden werden dürfen und dort bereits im 'geschützten'-Teil liegen. (dem Compiler unnötige Arbeit
  sparen iss immer ne gute Sache, auch wenn das absolut nicht ins Gewicht fällt *g*)
PLGeneral:
- 'PL_F2DW()' und 'PL_DW2F()' aus 'PLRenderer/Types.h' entfernt und in 'PLGeneral/Tools/Tools.h' als FloatToUInt32() und
  UInt32FloatTo() eingefügt. Zum einen fand ich es schon lange nicht mehr sonderlich prall das diese zwei Funktionen (früher
  Makros :) so lieblos irgendwo in der Gegend herumstehen + die Namen selbst waren nicht mehr ganz korrekt und nicht
  sonderlich aussagekräftig.



>> 23.06.2007
[CO]
Alle Projekte:
- Verbesserte an einigen Stellen groß/kleinschreibung. Wenn z.B. mit 'windows' das Betriebssystem und nicht etwa 'GUI Fenster'
  gemeint sind sollte das 'Windows' geschrieben werden da Name. 'win32' konsequent zu 'Win32' gemacht. 'linux' ist ebenfalls
  ein Name, also 'Linux'.
- Bei 'Abkürzungen' wurde so richtig wild gemischt und ich selbst war auch immer sehr unsicher 'wie' man das nun 'überlicherweise'
  schreibt. Da wollte ich schon lange mal was machen damit das halbwechs konsequent ist. Daher googelte ich erstmal etwas +
  informierte mich auf Wikipedia wie man üblicherweise diverse Dinge schreibt. Danach änderte ich u.a. 'url/Url' -> 'URL',
  'xml/Xml' -> 'XML', 'html/Html' -> 'HTML', 'zip/Zip' -> 'ZIP', 'gui/Gui' -> 'GUI' (bis auf die Dateiendung 'gui') - nur in den
  Dateinamen änderte ich erstmal nix da dies die Lesbarkeit etwas verschlechtert - da können wir uns später überlegen ob wir das
  so lassen, oder ob wir das überall durchwech konsequent schreiben wollen damit keine Unklarkeiten reinkommen. Das alles könnte man
  natürlich als 'belanglose fusselei' abtun... allerdings empfinde ich soetwas als wichtig da es gerade in der Informatik mittlerweile
  sooo viele Abkürzungen gibt und ich es auch in Mathematik höchst verwirrend und störend empfinde wenn ein und dieselbse Sache
  immer wieder etwas anderst geschrieben wird - das hilft definitiv nicht Anfängern sich in die Materie einzuarbeiten! :(
  Zudem ist PixelLight generell 'case-sensitive' so das wir da (vorallem den Grafikern *g*) mit gutem Vorbild vorausgehen sollten.
PLGeneral:
- FileSystem vom Style und der Ordnung her aktualsiert. Also Dinge privat gemacht die privat zu sein haben, Konkrete
  Implementationen werden wo das nicht benötigt wird oder wünschenswert ist nicht Exportiert. Wo möglich Zeiger zu Referenzen
  gemacht damit man den NULL-Fall nicht berücksichten muss. Einige Kommentare verbessert oder genauer gemacht. Einige short
  zu int16 und long zu int32 (+ unsigned Variationen) gemacht damit das in PL überall gleich ist + das ist deutlich besser
  lesbar + man weis wirklich ganz genau was das für größen zu sein haben.
- Bei der File-Klasse ein 'IsReadable()' hinzugefügt. Dies wurde bereits im Loadable-System benötigt + ist das passende
  Gegenstück zu 'IsWritable()'
- LogFormater Implementationen umbenannt da diese nicht dem PL Namens Style folgten und es mich auch schon mehrmals störte
  das ich erstmal kurz die einzelnen Implementationen zusammensuchen musste - durch die Namens-Änderung sind diese Dateien
  wenn man Alphabetisch Ordnen lässt immer nett beisammen was enorm Handlich ist.
- BufferedReader Implementationen umbenannt da diese nicht dem PL Namens Style folgten
- CMakeLists.txt: LogFormaterConsole.cpp fehlte
- 'PLEFileSeek' von FileSystem.h in die File-Klasse verschoben und in 'ESeek' umbenannt. 'PLEFileAccess' von FileSystem.h
  in die File-Klasse verschoben und in 'EAccess' umbenannt. Dadurch konnte man auch gleich wieder Header abhänigkeiten
  reduzieren. :)
- FileSystem: GetRootDirectory() und GetCurrentDirectory() liefern nun Referencen statt Zeiger zurück denn diese Dinge
  MÜSSEN immer gültig sein... ansonnsten läuft gerade etwas soetwas von total daneben. Durch diese Änderung wird an einigen
  Stellen der Code nun etwas Übersichtlicher da man keine NULL-Abfragen mehr machen muss/sollte.
- FileSystem: GetCurrentDirectory() fügt nicht mehr automatisch eine Referenz zum aktuellen Verzeichniss hinzu



>> 22.06.2007
[CO]
- Entfernte aus Timing die Funktionen Start(), Stop() und GetEllapsedTime() und führte eine neue Klasse Namens 'Stopwatch'
  ein welche diese Funktionalität bereitstellt. Stellte gleich eine Handvoll Stellen in verschiedenen Projekten auf diese
  neue Klasse um - das ist wirklich sehr Handlich. :)
- Time um SetDosDate()-Funktion aus ZipDate erweitert und ZipDate anschließend entfernt da doppelte Funktionalität



>> 16.06.2007
[CO]
Alle Projekte:
- Entfernte bei allen virtuellen und nicht Implementierten Funktionen (=0) das Export Makro da in diesen Fällen nicht benötigt
PLGeneral:
- 'PL_UNUSED'-Makro entfernt da dieses mittlerweile gerade im Zusammenhang mit ungenutzten Referenzen wo man dann zwanghaft
  Header einbinden muss obwohl nix benötigt wird sehr unhandlich wird - zudem wollte Stefan das sowieso vor einigen Montaten
  raushaben. :)
  Das war eine Zeitlang recht nett dieses Makro um überall zu checken ob Parameter überhaupt benötigt werden bzw. korrekt
  genutzt werden, mittlerweile ist das aber nicht mehr wirklich nötig. Die 'nicht verwendet' Warnung erscheint üblicherweise
  nur in der allerhöchsten Warn-Stufe, wenn das jemand aktiv haben will, muss er es für sein Projekt wieder per Hand aktivieren.



>> 12.06.2007
[CO]
- Sleep() von der System Klasse in ThreadManager verschoben da dies dort Thematisch besser reinpasst (der aktuelle aktive
  Thread wird schlafen gelegt...)



>> 09.06.2007
[CO]
- MemoryCopy() & MemorySet() & MemoryCompare() aus Wrapper.h in MemoryManager.h verschoben, das ist dort denke ich recht
  gut aufgehoben
- MemoryManager.h: Defines auskommentiert: Diese Definitionen sind leider recht problematisch und verursachen recht schnell
  Fehler in 'Fremd-Header'.



>> 08.06.2007
[CO]
- BufferedFileReader: Laut Konstruktor Dokumentation wird die übergebene Datei automatisch freigegeben, das war allerdings
  nicht der Fall wenn das Dateiende bereits erreicht war - vereinfachte/verallgemeinerte daher den Konstruktor etwas
- An einigen Stellen wo möglich/sinnig Zeiger durch Referenzen ersetzt. Uh, verstehe gar nicht wieso ich das früher noch
  nicht gesehen habe das es 'meistens' über Referenzen viel eleganter und sicherer geht da man den 'NULL'-Fall nicht
  berücksichtigen muss wenn er eigentlich gar nicht erst vorkommen sollte. :)
  Ist zwar einiges an Arbeit nun alle Codes/Interfaces nochmal genau durchzuschaun, aber es lohnt definitiv + nebenbei
  fallen mir auch noch immer einige andere Dinge auf die nicht mehr ganz Up-To-Date sind... ganz nebenbei stehen in ein paar
  Wochen bei mir mal wieder Prüfungen im Studium an und da sind solche Arbeiten genau das richtige da man das nebenbei
  machen kann ohne sich Gedanklich voll reinhängen zu müssen was zur Prüfungszeit weniger optimal ist.



>> 07.06.2007
[CO]
Alle Projekte:
- Rechtschreib-Korrektur: 'childs' in 'children' geändert (das war an einigen Stellen noch falsch :)
PLGeneral:
- XmlAttribute: QueryIntValue() & QueryDoubleValue() ändern den Wert der übergebenen Variable im Fehlerfall nicht, damit
  ist das Verhalten vergleichbar zu den ähnlichen Funktionen in XmlElement



>> 05.06.2007
[CO]
- Time für die Tage Enums spendiert
- Semaphore: m_nValue wurde nicht initialisiert (?)
- Thread::Thread(bool bMainThread): Hier wurden die Variablen nicht initialisiert



>> 29.05.2007
[CO]
- Erweiterte das Var-Interface etwas damit man besseren Zugriff auf die Enumeration-Daten hat



>> 26.05.2007
[CO]
- Das mischen von Debug/Release Builds gestern klappte nicht wirklich gut. Es gab merkwürdige Crashs etc. da beide Builds
  intern unterschiedliche VC Memory Manager nutzen die nicht wirklich kompatibel zueinander sind. Da ich das aber wirklich
  wirklich endlich mal sauber am laufen haben wollte befasste ich mich heute etwas mit der Speicherverwaltung. Heraus kam
  ein eigener minimal Memory Manager der im 'PLGeneral/Core'-Ordner liegt und der die C++ new/delete Operatoren 'überläd'.
  Solche Operationen werden nun direkt in unseren eigenen Memory Manager 'umgeleitet' der fürs erste nur malloc/free nutzt.
  Alles Speicher anlegen/freigeben findet nun also NUR noch innerhalb von PLGeneral statt und dadurch verschwinden diese
  merkwürdigen Speicherproblemen + wir haben viele weitere möglichkeiten wie Speicher-Statistiken, Sicherheits-Checks -
  oder das die Implementation einer komplett eigenen Speicher-Verwaltung!
  Der einzige Hacken bei der Sache ist, das jedes Projekt nun per Hand 'PLGeneral/Core/MemoryManager.inl' einmal irgendwo
  einbinden müsste damit diese Operatoren sauber überladen werden...
- Fügte einen Header Namens 'PLGeneral/ModuleMain.h' hinzu. Dieser ist das gegenstück von 'PLGeneral/Main.h' welches für
  Anwendungen verwendet wird. Verschob aus 'RTTIDefs.h' die paar Module-Makros in diese neue Datei - das sind Dinge die
  genauso wie in 'PLGeneral/Main.h' NUR einmal pro Projekt für den Einstiegspunkt benötigt werden. 'PLGeneral/Main.h'
  baut somit auf 'PLGeneral/ModuleMain.h' auf, welches wiederum 'RTTIDefs.h' nutzt - so müsste das recht Überschaubar sein.
  Ich muss allerdings zusgeben das 'Überschaubarkeit' nicht der eigentliche Grund für diese kleine Änderung war, sondern
  meine aktuellen arbeiten am Memory Manager. NUR einmal pro Projekt sollte 'PLGeneral/Core/MemoryManager.inl' eingebunden
  werden welches dann new/delete Operatoren mit PL eigenen Implementationen 'überschreibt'. Allerdings wollte ich das nicht
  jedesmal an zig verschiedene Stellen schreiben müssen da man es mal schnell vergisst und dann der Memory Manager nicht
  korrekt in diesen Modulen arbeiten kann. Daher wird dieser eine Header gleich automatisch in 'ModuleMain.h' eingebunden das
  so oder so genutzt wird - wenn man sich an die PL Richtlinen hält und 'PLMain' etc. nutzt... wer das nicht tut und meint
  er müsste selbst beim Einstiegspunkt herumwurschteln der muss sich halt auch selbst um andere Dinge kümmern. *g*
  Somit muss sich der User also überhaupt nicht um diese Speicher-Geschichte kümmern.
-> Als Folge dieser Änderungen ist das mischen von Release/Debug Builds nun endlich möglich. Da im Grunde im PL-SDK IMMER
   Release genutzt wird und mir die Plugin-Datei Änderungen von gestern nicht soo gut gefielen da es dadurch etwas
   unübersichtlich und unnötig aufwändig wird, machte ich diese Plugin-Datei Änderung wieder rückgängig... lies es aber
   hier im Diary stehen damit man nachlesen kann was wieso etc.
   Nutze ich die Release Versionen von PL kann ich aber immer noch mein eigenes Programm wie gehabt Debuggen - das klappt
   sogar mit Dll's. Natürlich kann man mit dem Debugger nicht in die PL Funktionen 'einsteigen', aber das würde sowieso nicht
   wirklich gehen da im SDK die cpp-Dateien von PL nicht liegen. :)
   Leider ist derzeit ein zu 100% mischen nicht möglich. Trage ich z.B. als Release Library eine Debug Version ein, wird
   die dll zwar ohne Crash etc. geladen, aber die RTTI Klassen werden nicht Regestriert... genau weis ich noch nicht was
   da im Detail abläuft. Aber das was mir wichtig war, also z.B. Debuggen einer dll im zusammenspiel mit einer release exe
   klappt ganz wunderbar.



>> 25.05.2007
[CO]
Alle Projekte:
- In den letzten Tagen lies ich in allen Projekten nach 'DEFINE_VAR_LIST' suchen und stellte sicher das die am RTTI
  hängenden Variablen direkt in der Konstruktor Initialisierer-Liste initialisiert werden.
PLGeneral:
- Base: CreateInstance(): 'bSetVars'-Parameter entfernt. Das kann man als User selbst nachträglich machen wenn man will -
  zudem würde das nicht Initialisieren nicht wirklich Sinn machen bzw. wäre höchst Gefährlich da man undefinierte Zustände
  hätte. (bzw. früher hatte) Generell sollten IMMER alle Klassen ihre Variablen selbstständig auf korrekte Default Werte
  setzen (also unabhängig ob diese am 'RTTI' eingehängt sind oder nicht) die mit den in den RTTI Makros angegeben Werten
  übereinstimmen. Gefällt mir zwar nicht wirklich dieses 'doppelte' reinschreiben von Default-Werten, wüsste aber momentan
  nicht wie man das anderst lösen sollte. Auf diese weise kann man u.a. bereits in den Klassen Konstruktoren diese Variablen
  nutzen was voher nicht so ohne weiteres möglich war da die Variablen erst 'nach' dem erzeugen auf die Default-Werte gesetzt
  wurden... das war eine sehr unglückliche Situation in die ich in den letzten Jahren natürlich immer mal wieder reinstolperte.
  'DEFINE_VAR_RO' ging früher nicht korrekt da SetVars() genutzt wurde was dann natürlich das setzen der 'read-only'
  Variablen zu verhindern weis.
  Auch war das Initialisieren von am RTTI hängenden Variablen in der Initialisierer-Liste der Konstruktoren inkonsistent.
  Einmal wie z.B. in Vector3 wurde dort initialisiert da man diese auch ohne RTTI nutzen kann, und bei anderen Klassen wie
  z.B. SceneNode nicht da diese 'nur' über das RTTI Instanziert werden können.
  Zusammenfassend hat man mehr 'Sicherheit' da immer Variablen in bekannten Initialzuständen - da muss wie üblich natürlich
  JEDER Klassen-Schreiber dafür sorgen! CreateInstance() ist schlanker + weniger 'Overhead' beim erzeugen von Instanzen -
  da das RTTI System mittlerweile sehr intensiv genutzt wird ein sicherlich nicht ganz unerheblicher Faktor... wird z.B.
  eine *wirklich* große Szene mit mehreren tausend Nodes eingeladen spart man sich nicht gerade wenig Arbeit ein und auch
  wenn man mit dem Debugger Schrittweise den Code Analysiert ist das nun um einiges durchschaubarer.
  Hab mal noch kleine Performance Tests in 'PLSampleScene.exe' gemacht - größte Szene (F3) die 4098 Nodes hat, aber nur
  'sehr' wenig verschiedene Daten nutzt und daher optimal für diesen Test ist: (jeweils zwei anläufe)
  - Vorher: 6.483 sec & 6.191 sec 
  - Nacher: 5.571 sec & 5.232 sec
  -> Also in dieser Szene mit 'etwas mehr' Nodes 'minimal' schneller, jedes bischn bringt uns weiter. :)
- Plugin XML Dateien: Ich überlegte mir bereits seit geraumer Zeit wie man das mit Debug/Release Builds 'mischen' am besten
  auf die Reihe bekommt - denn im öffentlichen PL-SDK liegen NUR Release Builds (bzw. sollten!) und trotzdem soll man auch
  seine auf PL aufbauenden Projekte korrekt Debuggen können. Wenn man die Debug Builds hat sollen diese auch genutzt werden
  können. Von 3ds Max hab ich auch 'nur' die Release Version, und kann trotzdem meine Exporter Plugins dafür korrekt Debuggen,
  also irgendwie ist das sauber realisierbar. :)
  Schlägt das einladen einer 'Library' fehl, so können nun alternative 'Fallback Libraries' verwendet werden. Konkret ist
  das bei Debug-Libraries sinnvoll. Im öffentlichen PL-SDK sind üblicherweise keine Debug Versionen von PixelLight dabei,
  folglich schlägt der Versuch diese zu laden fehl - als Fallback wird nun versucht die entsprechende Release Library zu
  laden. Hat man also die Debug Version (warum auch immer *g*) wird diese korrekt genutzt, ansonnsten die Release Version.
  Als 'normaler PL-User' bin ich aber denk ich ganz froh die Release-Builds von PL beim Debuggen nutzen zu können, denn
  diese sind um einiges (!!) flotter und so kann man sich recht gut auf das Debuggen seines eigenen Projektes konzentrieren.
  Somit kann man problemlos und ich denke mal recht Intuitiv Release & Debug Builds mischen - das Plugin System über diese
  XML Dateien müsste nun soweit alles können das wir derzeit brauchen.
  Nahm den Parameter der 'PLGetPluginInfo'-Funktion im 'DEFINE_MODULE_PLUGIN'-Makro heraus und fügte dafür eine weitere Funktion
  namens 'PLIsPluginDebugBuild' hinzu über die ermittelt werden kann ob das Plugin als Release oder Debug übersetzt wurde.
  ClassManager::LoadPlugin() kann dann auf wunsch einen Build Type Test erzwingen so das NUR zusammen passende Builds verwendet
  werden können - als Default ist dies allerdings deaktiviert da dies normalerweise nicht nötig/üblich ist bzw. sein sollte.



>> 22.05.2007
[CO]
- Bugfix: Class::GetVar(): Meine Änderung der Implementation vom 18.03.2007 war natürlich nicht ganz korrekt da nicht
  berücksichtigt wurde das es sehr wohl sein kann das die Variablen der Basis Klasse noch nicht Initialisiert sind - korrigiert.



>> 21.05.2007
[CO]
Alle Projekte:
- Rechtschreib-Korrektur: 'choosen' in 'chosen' geändert



>> 19.05.2007
[CO]
Alle Projekte:
- In Funktionen wo häufiger Instanzen von RTTI Klassen erzeugt werden und 'zur Sicherheit' geprüft wird ob die Basis Klasse
  korrekt ist machte ich eine kleine rein Funktions interne Optimierung:
  Statt Class::HasBaseClass(String) wird nun Class::HasBaseClass(Class) genutzt wodurch man sich HashMap Operationen spart
  und sofort immer einen korrekten Zeiger auf die Basis Klasse hat. (der IMMER korrekt ist da Kern-Komponenten!) Zusätzlich
  kann nun unsere String Klasse ihre Muskeln spielen lassen: Class::HasBaseClass(Class) nutzt intern String::Compare()...
  und hier muss dann am ende NUR noch ein einfacher Zeiger Test gemacht werden um festzustellen das die Basis Klasse gefunden
  wurde ohne die Strings selbst wirklich miteinander zu vergleichen - noch Effektiver gehts wohl kaum! *g*
  An Stellen wo teils nur ein einziges mal pro Programm start Class::HasBaseClass() verwendet wird lohnt soetwas natürlich
  nicht - aber bei z.B. PLEngine::SceneContainer::Create() ist das durchaus eine feine Sache.
PLGeneral:
- Loader: RTTI Variablen sind nun endlich 'read only'. Dies erreichte ich dadurch das nicht das RTTI die Variablen anfangs
  Initialisiert, sondern das die Variablen sauber wie man es gewohnt ist in der Initialisierer Liste der Konstruktoren
  initialisiert werden. Von Loader abgeleitete Klassen 'überschreiben' indem diese den jeweiligen Konstruktoren entsprechend
  neue Werte übergeben - das ist so wirklich deutlich besser. :)
- HtmlLogFormater: Funktionen etwas umsortiert so das die Reihenfolge der Daten immer gleich ist
- Machte bei LogFormater Implementationen einiges 'private' da man nicht weiter davon ableiten können soll + ein paar
  öffenliche Funktonen wurden nicht exportiert



>> 17.05.2007
[CO]
- Stack & Queue: Pop(): Kommentar erweitert (für eine Situation wo man aufpassen sollte)



>> 15.05.2007
[CO]
- System::DeleteEnvironmentVariable() Implementation fehlte
- Bei den System-Klassen einige Dinge 'private' gemacht wo entweder nix von außen drauf zugreifen soll oder wo man nicht
  weiter Ableiten können soll
- Ein paar 'const' hinzugefügt
- Im Loadable System einige Zeiger zu Referenzen gemacht, so muss man bei den Kommentaren nicht mehr 'NEVER NULL!'
  dazuschreiben da es bereits von anfang an unmöglich ist NULL-Zeiger zu übergeben.



>> 12.05.2007
[CO]
- Class::GetBaseClasses() entfernt da es hierfür keine Implementation (mehr) gab (?)
- ClassManager::GetClasses() gibt keine Liste mehr zurück, sondern bekommt eine als Parameter übergeben. Zum einen ist
  das so nun konsistent mit z.B. Class::GetVarList(), aber noch viel wichtiger ist, das so herum nun nicht mehr aufwändig
  viel herumkopiert werden muss. Das gleiche in der Module Klasse.
- Var: Machte ein paar grundliegende Funktionen protected. NUR Class darf hier direkt drauf zugreifen, so ist gewährleistet
  das z.B. wirklich IMMER eine Variable zu einer Klasse gehört.
- Machte an den RTTI Klassen einige 'Sicherungs'-Maßnahmen indem ich einige Parameter & Funktionen const machte (an vielen
  Dingen hat der User einfach selbst nix zu ändern :) und dort wo
  man nicht 'umbedingt' einen Zeiger als Parameter übergeben muss wird nun stattdessen eine Referenz verwendet - denn die kann
  ja nie NULL werden und so kann der User schonmal weniger Schrott übergeben + man spart sich Sicherheits-Abfragen. (die teils
  nicht vorhanden waren)
- Durch die Änderungen kann man sich nun sogar in 'RTTIDefs.h' das Einbinden von 'Var.h' sparen :)



>> 11.05.2007
[CO]
Alle Projekte:
- Rechtschreib-Korrektur: 'socked' in 'socket' geändert
- Rechtschreib-Korrektur: 'terminal NULL', ich glaub damit meinte ich 'terminating zero' (jeder lacht aber keiner sagts :)
PLGeneral:
- String: In der Funktions-Beschreibung von GetLength() fehlte eine ganz entscheidende Information, 'terminating zero'
  ist in der Länge nicht enthalten. Überall anderst stand das bereits wenn ich nix übersehen hab.



>> 10.05.2007
[CO]
- Sortierte ins Diary so richtig alte Einträge aus "PLSDK/internal/old_diaries.zip" ein



>> 09.05.2007
[CO]
- Sortierte ins Diary alte Einträge aus "PLSDK/internal/old_diaries.zip" von ab "02.04.04" ein
- Neue abstrakte Basis-Klasse eingeführt: 'Iterable': Alles was einen Iterator Implementiert sollte von dieser Klasse
  abgeleitet sein. 'Map', 'Heap' und 'Container' sind somit nun also von 'Iterable' abgeleitet - so bekommt man eine noch
  etwas schickere und stimmigere Klassen-Hierarchie. :)



>> 20.04.2007
[CO]
- Timing::Update(): Auf PLBool umgestellt



>> 18.04.2007
[CO]
Alle Projekte:
- Nach kurzer Rücksprache mit Stefan gestern änderte ich (automatisch, also ') = NULL;' zu ') = 0;' gleiche mit const,
  ersetzen lassen, insgesammt an 688 Stellen + 1 wobei diese eine Stelle nur unglücklich Formatiert war so das man per Hand
  ranmusste :) alle z.B. 'virtual void Test() = NULL' in 'virtual void Test() = 0' da 'NULL' in OS-Headern leider nicht immer
  zwanghaft als '0' oder '(void*)0' definiert ist - unter Linux ist das schonmal als '__null' definiert und dann gibts
  Compiler Fehler im Zusammenspiel mit z.B. 'virtual Test() = NULL' und man muss dann immer genau nachprüfen wo/wie NULL in
  Headern einfach umdefiniert wurde das nicht wirklich die Übersichtlichkeit fördert. :(
  Neben diesen Compiler-Problemen war dies über 'NULL' auch hin und wieder etwas unhandlich wenn man wie in
  'PLGeneral::Iterator.h' eigentlich überhaupt kein Include benötigt, aber durch 'NULL' dann eben doch den PLGeneral-Header
  einbinden musste. Ich googelte etwas und schaute mir verschiedene C++ Codes durch, fand aber irgendwie nichts wo bei
  virtuellen-Funktionen 'NULL' statt '0' verwendet wurde. Wenn ich mich recht erinnere sah man das 'früher' häufiger,
  heute aber nicht mehr wirklich oft.
- Nahm '-U__GNUG__' Linux Compiler Definition aus allen CMake-Dateien heraus



>> 14.04.2007
[CO]
- Base::SetVars() verbessert so das man z.B. auch 'Flags=""' in z.B. einer Szene-Datei schreiben kann ohne eine Fehlermeldung
  zu bekommen das ein abschließendes '"' fehlen würde
- Thread::Join() Kommentar etwas erweitert... wie ich gerade in PLPhysicsNewton::WorldThread::~WorldThread() feststellen
  musste ist ein 'join' ohne Timeout mit Vorsicht zu geniesen...



>> 09.04.2007
[CO]
- Nahm weitere 'return' heraus



>> 08.04.2007
[CO]
- Formte einge Codes um so das man weniger 'return' benötigt was die Sache etwas übersichtlicher macht
- ClassManager.cpp: 'NO_GROUP'-Definition entfernt da dies mittlerweile nicht mehr verwendet wird
- ZipSearchHandle::CheckFileInDirectory(): Hier wird nun 'm_pZipDir->m_bCaseSensitive' berücksichtigt
- ZipDirectory: Neue Funktion: IsCaseSensitive() wird von ZipSearchHandle::CheckFileInDirectory() benötigt
- Base::IsVarDefault(): Arbeitet nun Case-Sensitive da PL generell Case-Sensitive ist



>> 07.04.2007
[CO]
- Dort wo in der String Klasse 'isdigit()' oder 'isalpha()' verwendet wird, wird zur Sicherheit auf 'unsigned char' gecasted
  da man sonst schnell ein Assert bekommen kann wenn man z.B. 'ß' im String stehen hat. :(



>> 27.03.2007
[CO]
- Linux Port etwas aufgeräumt



>> 25.03.2007
[CO]
- Types.h entfernt. Überall wo X, Y, Z, W genutzt wurde durch entsprechende Vektor-Enums ersetzt damit man weiterhin sofort
  erkennen kann welche Komponente verändert wird. R, G, B wurde nur an einer einzigen Stelle verwendet. PL_UNUSED-Makro
  in die OS-Header verschoben.
- NULL-Definition in die OS-Header verschoben



>> 24.03.2007
[CO]
Alle Projekte: Alle CMake Dateien:
- Einige Leerzeichen/Tab Änderungen in den CMake Dateien
PLGeneral:
- System: Neue Funktion: GetPlatform(): Diese Funktion gibt im Gegensatz zu GetOS() nur einen übergeordneten Plattform
  Namen wie z.B. 'Win32' für ein 32 Bit Windows System etc. zurück
- Xml Plugin Format nach Stefans Vorschlägen vom 25.02.2007 geändert. Es gibt nur noch eine Plugin Datei und keine für
  Release und Debug. In der Datei kann es beliebig viele 'Platform'-Blöcke geben, jedoch werden nur die berücksichtigt
  welche mit System::GetPlatform() zusammenpassen. (daher diese neue Funktion :) Innerhalb eines 'Platform'-Blockes kann
  es verschiedene 'Library'-Einträge geben welche jeweils einen Release oder Debug Type haben können. Diese Dateien können
  absolute Pfade haben (nicht wirklich immer Sinnvoll *g*) oder relativ zur Plugin-Datei liegen.
  Passte alle Plugin-Dateien entsprechend an. Diese Änderungen machen wie Stefan schon sagte die Sache übersichtlicher und
  ganz nebenbei mächtiger da ein Plugin nun z.B. aus mehreren Bibliotheken bestehen kann und diese nicht mehr zwangsläufig
  im gleichen Ordner liegen müssen wie die Plugin-Datei selbst. :D
  Dependencies werden in diesen Plugin-Dateien pro Library wie gehabt eingetragen. Das ist jedoch rein optional und soll
  wirklich nur dazu dienen das man immer den Überblick behält was von wem abhängt so das man nicht lange herumsuchen oder
  gar herumprobieren muss.



>> 23.03.2007
[CO]
Alle Projekte: Alle VC-Projekt Dateien:
- Deaktivierte die Linker Option '/INCREMENTAL' (nur geänderte Methoden neu übersetzen) da diese in Konflikt mit '/LTCG'
  (gesammte Projekt Optimierung) stand. Damit ist nun folgende Linker Warnung wech:
  "LINK : warning LNK4075: /INCREMENTAL wird aufgrund der Angabe von /LTCG ignoriert."
PLGeneral:
- Im Release Build wird die Bibliothek 'LIBCMT.lib' ignoriert da diese laut Linker Warnung in Konflikt mit einer anderen
  stand.



>> 18.03.2007
[CO]
Da wir mittlerweile sehr viele RTTI Klassen haben und später gerade bei konkreten Projekten sicherlich nochmal einige
hinzukommen versuchte ich die vom RTTI verbrauchten Resourcen 'etwas' in den Griff zu bekommen OHNE das System komplett
umzubauen. Also minimalste Änderungen mit größt möglicher Verbesserung damit das nicht mehr ganz so zäh läuft was mich
ehrlich gesagt mittlerweile etwas stört.
Auf die Hash Map Optimierung vom 14.03.2007 kam ich erst als ich mir mal angeschaut hatte warum bereits einfachste
Programme vergleichsmäßig viel Speicher verbrauchten und beim starten auch viel zu lange brauchten. Es stellte sich heraus
das die Enum Dinge in der Vars Klasse sehr viel Overhead erzeugten. Es wurde gerade für die Enum Hash Map viel zu viel
Speicher verschwendet obwohl diese bei nicht Enum Variablen absolut nie benötigt wurde. Ich überlegte mir dort ob man
die Hash Map da nicht gleich ganz rausnehmen sollte, lies das aber erstmal da es nun nicht mehr so heftig ist und ich meine
Änderungen an diesen Komponenten so klein wie möglich halten will.
Eine andere Sache ist die, das wir zwar viele RTTI Klassen haben, aber ebenfalls viele in den meisten Anwendungen überhaupt
nicht nutzen. Daran DAS RTTI Klassen da sind, da kann man nix ändern außer nicht benötigte Plugins zu deaktiveren. Aber über
das bewärte 'Lazy Evaluation'-Muster das schon so gut im Scene Graph klappt konnte man das ohne zu große Eingriffe Resourcen
schonender machen:
- Class: In 'Init()' werden die Variablen der Basis Klasse NICHT mehr zu der aktuellen Klasse hinzugefügt da dies einfach
  nur unnötig ist. Stattdessen gehen die Funktionen 'GetVarList()' und 'GetVar()' einfach bei Bedarf Rekursiv zu der Basis-
  Klasse weiter - Funktionsmäßig also keine Änderung, aber Resourcen schonender und auch übersichtlicher.
- Class::AddVar(): "Overwrite an already existing variable?"-Teil entfernt da dies nun durch die Änderung von oben
  überflüssig ist
- Die Klassen Variablen werden nun nach dem 'Lazy Evaluation'-Schema Initialisiert, sprich, erst wirklich dann wenn diese
  zum ersten mal wirklich benötigt werden... was öfters NIE der Fall ist und dann müssen die Variablen auch NIE Initialisiert
  werden :D
-> Der Windows Task Manager zeigte mir bei 'PLSampleInitExit' vor dieser Änderung einen Speicherverbraucht von '31.368 K'
   an, danach '29.980 K' + es startet minimal flotter. (hab derzeit bei mir alle nicht umbedingt benötigten Plugins während
   der Entwicklung deaktiviert, sonst wären das nochmal ca. 10 MB mehr Speicher)



>> 16.03.2007
[CO]
Alle Projekte: Einige Inkonsistensen behoben:
- In Headern wurde beim Einbinden von '*.inl' im Block einmal 'Implementation' oder 'Inline includes' geschrieben. Änderte
  das überall in 'Implementation' da dies häufiger verwendet wurde... so braucht man nur nach '//[ Implementation' zu
  suchen um all diese Stellen angezeigt zu bekommen.
- 'filename' wurde nicht überall gleich geschrieben, einmal 'FileName', oder 'file name'. Da 'filename' bei uns am meisten
  verwendet wird und das u.a. so auch auf Wikipedia geschrieben wird und mein Übersetzungs-Tool das so ebenfalls kannte
  machte ich das einheitlich da es mich nun schon ein paar mal verunsicherte wie man das schreiben soll - zudem ist das
  irgendwie doof wenn das innerhalb eines Projektes immer mal wieder anderst geschrieben wird, auch wenn beide schreibweisen
  'richtig' sind... so muss man nicht pro Funktion schaun wie es jeweils geschrieben wird. *g*
- Entfernte den Begriff 'dll' bei z.B. dem 'Import/Export'-Block oder Header Titeln damit das verallgemeinert und nicht
  Begrifflich Windows bezogen ist.
- Bei einigen Klassen sind die Methoden in einzelne 'Blöcke' unterteilt, versuchte den Block Titel soweit einheitlich einzurücken



>> 14.03.2007
[CO]
- HashMap Speicher Optimierung: Die internen Slots werden NICHT mehr sofort angelegt, sondern erst dann wenn das erste Element
  eingefügt wird... denn es kann durchaus vorkommen das eine HashMap warum auch immer mal überhaupt nicht genutzt wird, und in
  dem Fall braucht diese intern keinen weiteren Speicher anzulegen. :)
  Der Windows Task Manager zeigte mir bei 'PLSampleInitExit' vor dieser Änderung einen Speicherverbraucht von '35.596 K' an,
  danach '31.368 K'.



>> 12.03.2007
[CO]
Alle Projekte: PLBase:
- Mit den Header Änderungen bin ich in PLBase nun erstmal soweit durch - mittlerweile wird von TortoiseSVN fast alles rot
  Dargestellt da geändert. Also nicht über die Masse an geänderten Dateien wundern, das zieht sich wirklich durch alle Projekte
  durch. Ich finde das nun wirklich um 'einiges' besser als vorher - auch wenn es noch Details zu verbessern gibt.



>> 10.03.2007
[CO]
- Container + Implementationen: Add() & Remove() & Copy() & Compare(): 'nCount' ist nun uint32, wenn 0, so wird alles hinter
  Start kopiert. <0 war sehr ungeschickt und auch teils fehlerhaft Implementiert - zudem machte das wenig Sinn, wenn jemand
  nix machen will, so hat er erst gar nicht diese Funktionen aufzurufen! :)
- Machte die besprochenen Header Änderungen die auch in PLNetwork schon so gut klappten. In PL Headern sollten unter keinen
  umständen mehr direkt oder indirekt z.B. Standard-Header reinkommen, also u.a. kein direktes 'memcpy' mehr in Headern/Inline
  Implementationen. Da ich die Codes nochmal komplett durch schauen musste, änderte ich dabei gleich Dinge die wir mittlerweile
  anderst schreiben. (u.a. 'strukturierter') Wo möglich reduzierte ich die Abhängigkeiten von z.B. Headern durch Predefinitions
  oder verschieben von Inline in cpp noch weiter. Auch machte ich die besprochenen Änderungen bei der Verwendung von Namespaces,
  also überall 'using namespace' in cpp sobald etwas einmal benötigt wird.
- Kleine 'Wrapper'-Klasse im Tools-Ordner hinzugefügt für Dinge wie z.B. 'memset' die wir in Headern oder Inline-Implementationen
  nutzen. (was nur sehr selten der Fall ist!)



>> 02.03.2007
[CO]
- FileSystem::SetBaseDirPriority() & LoadableType::SetSearchPathPriority() Implementiert
- Loader::OpenFile(): Da das File System bei absoluten Dateinamen nicht erst lange herumsuchen muss, versucht das Loadable System
  erstmal den wahrscheinlichsten absoluten Pfade zu nutzen - das klappt meistens und die Ladezeiten werden dadurch spürbar kürzer!
  Gerade in großen Szenen wie z.B. der aktuellen vom Dungeon Demo ist das Laden nun um einiges annehmbarer - zwar natürlich noch
  nicht Optimal (Memory Mapped Files müssten hier nochmals einiges bringen) aber zumindestens nicht mehr ätzend. *g*



>> 02.03.2007
[SB]
- Da es keine Header geben sollte, die nur dann fehlerfrei benutzt werden können wenn vorher noch andere Header eingebunden werden
  (also Abhängigkeiten des Headers nicht im Header selbt eingebunden werden), habe ich PLGeneralWin32Header.h überall dort, wo
  Win32-Datentypen in einer Klasse direkt verwendet werden, auch direkt in dem entsprechenden Header eingebunden. Zusätzliche
  Abhängigkeiten werden dadurch nicht erzeugt, da diese System-Header sowieso nur in den eigenen .cpp Dateien eingebunden werden
  und in der Factory-Funktion, die das benötigte System-Objekt erzeugt. An beiden Stellen mußten vorher also auch die System-Header
  eingebunden werden, um die Header-Datei überhaupt verwenden zu können, was wie gesagt niemals passieren sollte.   
- PLGeneralOSHeaders.h entfernt. Dieser Header wurde nur ein einziges Mal eingebunden, und sollte auch in Zukunft nur sehr selten
  gebraucht werden, da man meist gleich entweder eine Win32- oder Linux-spezifische Datei hat. Dieser Header ist daher unnötig,
  und kann in diesen seltenen Fällen durch eine direkte Fallunterscheidung ersetzt werden



>> 28.02.2007
[CO]
- FileSystem::Mount(): Unterscheidet nun zwischen groß/kleinschreibung wie es überall in PL der Fall ist
- ZipDirectory::GetName(): Gab etwas anderes zurück als ich erwartet hätte und als es die Dokumentation zu FileObject::GetName()
  beschrieb. Daher änderte ich es so das es passt und fügte eine neue Funktion 'GetNameWithinZipFile()' hinzu welche den Namen
  innerhalb der Zip-Datei zurückgibt.



>> 26.02.2007
[CO]
Alle Projekte:
- Ging die Namensgebung der Funktionen nochmal durch welche im Grunde nur 'ja' oder 'nein' zurückgeben. GetEnabled, GetActive etc.
  zu IsEnabled, IsActive etc. Da wir momentan noch PLBool drinnen haben musste ich nur nach bool Suchen ("bool Get") lassen. :)
  Ein paar Funktions-Namen lies ich jedoch, an Stellen wo 'Is' irgendwie noch unpassender als 'Get' ist und ein 'Has' auch irgendwie
  fehl am Platz ist - da müsste man eventuell nochmal schaun ob die Funktionnamen an sich überhaupt Sinnvoll sind.
  (wenn man mal gerade nix besseres zu tun hat *g*)



>> 25.02.2007
[SB]
- Neue Klassen-Templates für Funktions-Objekte hinzugefügt. Das sind recht praktische Zeitgenossen, mit denen Zeiger auf Funktionen
  als Objekte gespeichert werden können. Diese Objekte können dann genauso aufgerufen werden wie Funktionen. Im Gegensatz zu
  Funktions-Pointern können diese Objekte aber nicht nur Zeiger auf statische Funktionen sein, sondern auch Zeiger
  auf Member-Funktionen von Klassen, die zusammen mit einem Zeiger auf ein Objekt dieser Klasse gespeichert werden.
  Bitte beachten: FunctionTmpl.inl funktioniert etwas anders als unsere üblichen .inl Funktionen, daher auch der etwas andere Name,
  da es sich eben nicht nur um die Inline-Implementation von Function.h handelt. Das #ifdef in dieser Datei wurde NICHT vergessen
  sondern ist GEWOLLT weggelassen worden, da die Makros ansonsten nicht mehr richtig funktionieren würden! :-)   



>> 24.02.2007
[SB]
Alle Projekte:
- Alle Projekte so angepaßt, daß sich wieder alles mit VC7 übersetzen läßt.
- Alle CMake Projektdateien angepaßt: Es wird jetzt ein anderes Kommando für die Postbuild-Kommandos verwendet, da es bei der
  alten Variante u.U. zu Problemen mit den Abhängigkeiten und der Reihenfolge der Projekte kommen konnte. Auch wird so der
  Postbuild-Vorgang nicht mehr als eigenes Target angezeigt.  
PLGeneral:
- Undef einiger weiterer Definitionen aus den Window-Headern in PLGeneralWin32Includes.h hinzugefügt, die benötigt wurden da es
  sonst Namenskonflikte mit eigenen Methoden aus SystemImpl gibt.



>> 23.02.2007
[SB]
Alle Projekte:
- Alle Projekte so angepaßt, daß sich alles auch wieder unter Linux übersetzen läßt



>> 23.02.2007
[CO]
Alle Projekte:
- Da ich gerade vom Compiler in den PL Beispielen mal wieder gesagt bekommen hatte das es einen Namespace Konflikt gibt und
  nicht entschieden werden kann ob 'Rectangle' denn nun ein "Win32 Rectangle" oder ein 'PLMath::Rectangle' sei hatte ich einfach
  absolut KEINE Lust mehr auf dieses total bescheuerte herumgehacke mit den Namespaces etc. nur weil irgendwo ein OS Header
  reinkommt den man eigentlich überhaupt nicht braucht und dort halt Dinge definiert sind die man ebenfalls nicht braucht sondern
  wirklich nichts als Ärger machen. Daher baute ich das endlich mal so um das OS Header NUR noch dann reinkommen wenn man diese
  WIRKLICH braucht, also in den konkreten OS Implementationen. Überall sonst darf von nun an absolut NICHTS OS Abhängiges mehr
  reinkommen - und falls das doch mal 'nötig' sein sollte läuft etwas falsch, denn es MUSS ohne gehen.
  Bei den erstaunlicherweise sehr kleinen Änderungen damit das ohne ständige OS Header klappt gab es ebenfalls erstaunlicherweise
  praktisch keine Probleme da wir im laufe der Jahre bereits alles 'virtualisiert' hatten. :)
  Beim übersetzen unter Windows klappt das nun so ganz wunderbar, und man hat endlich in Projekten welche rein auf PL aufbauen
  praktisch (also bis auf das InputSystem, durch das leider noch derzeit OS Header reinkommen) keine Namespace Probleme mehr mit
  OS-Dingen. *freu*
  An ein paar Stellen bei denen Windows-Header genutzt werden, musste ich ein paar unschicke 'undefs' wie z.B. #undef MessageBox
  einfügen, (gerade in PLGeneralWin32Includes.h ist das krass) ansonnsten bekam ich einmal Compiler Fehler da wir Funktionen haben
  die genauso heißen, und beim anderen mal Linker Fehler das etwas nicht gefunden wurde was wir gar nicht nutzen. Diese define
  Dinge der OS Header sind wirklich übelst und ich bin total froh das wir diese nun nur noch an 'sehr' wenig Stellen einbinden
  müssen.
  Bei den Linux Headern hab ich gekennzeichnet was umbedingt raus sollte.
PLGeneralLinux.h & PLGeneralWin32.h:
- Nahm THREAD_HANDLE heraus da es nirgends mehr verwendet wird
- NativeDirectory liegt nun direkt in FileSystem.cpp, der Benuter sollte davon nix sehen
- RTTI: Wie kurz besprochen PL_VAR_STRING & PL_VAR_FILENAME welche mit klassischen C-Strings arbeiteten entfernt und dafür
  PL_VAR_PLSTRING & PL_VAR_PLFILENAME in PL_VAR_STRING & PL_VAR_FILENAME umbenannt. Alle Projekte daran angepasst.



>> 22.02.2007
[CO]
- ModuleID<T>::SetModuleName() & ModuleID<T>::SetModuleVendor() & ModuleID<T>::SetModuleDescription():
  Tests auf Buffer Überlauf eingebaut + statt strncpy wird nun memcpy genutzt damit einen VC 2005 nicht mit Warnungen
  in allen Projekten zumüllt.
- An Stellen wie z.B. SystemWin32::GetEnvironmentVariable() wird nun neben 'Unicode' auch 'UTF8' geprüft, ist es ein UTF8 String
  müssen die Daten als Unicode zurückgegeben werden damit kein Informationsverlust stattfinden kann... da Windows nur wchar_t
  und kein direktes UTF8 kann muss leider immer Konvertiert werden, aber da kann man nix dran ändern. (ähnliche Thematik dann
  unter Linux, nur umgekehrt *g*)
- Win32File::Rename() auf unsere String Klasse umgestellt. Müssen wir bei Erfolgt ebenfalls auch den neuen Dateinamen speichern?



>> 21.02.2007
[CO]
Alle Projekte:
- Machte wie besprochen die Umstellungen auf die 'sicheren angeblichen Standard-Funktionen' vom 11.02.2007 wieder rückgängig,
  denn wie sich herausstellte sind diese leider nicht wirklich Standard - auf jedenfall wird das derzeit nicht von sonderlich
  vielen Compilern unterstützt und daher ist das leider unbrauchbar für uns. :(
  Schaute mir dabei gleich alle Stellen wo diese C-String Funktionen genutzt werden genau an damit es keine Buffer Überläufe
  geben kann. Überall außerhalb der String Klasse stellte ich soweit irgend möglich/sinnig die letzten Stellen die ich finden
  konnte auf unsere String Klasse um damit man sich gar nicht erst mehr mit den C-String Funktionen herumärgern muss. In den
  Projekten in denen VC 2005 trotzdem noch meckert das etwas 'potentiell unsicher' sein deakvierte ich diese Warnungen einfach,
  wir wissen (meistens :) schon ganz genau was wir tun und müssen uns da nicht von einem Compiler zujammern lassen. *g*
  -> *bin heute noch nicht ganz mit diesen Arbeiten fertig geworden*
PLGeneral:
- FSTools::ValidatePath(): Gleiche Änderung wie gestern in Win32FSTools::ConvertToWindowsPath()
- ZipDirectory::GetComment(): So geändert das kein 'strcpy' mehr verwendet wird, zudem übernimmt die String Klasse direkt den
  Buffer (habs getestet, funkt noch korrekt :)
- Ein paar Kommentare von ZipDirectory & ZipStream korrigiert oder genauer gemacht
- ZipIterator::GetCurrentFileInfo(): Die String Klasse übernimmt den Buffer mit dem Dateinamen und Kommentar direkt
- Fügte in diesem VC 2005 Projekt bei den Compiler Optionen "/D "_CRT_SECURE_NO_DEPRECATE"" ein damit keine unnötigen
  Warnungen kommen
- Formte in der String Klasse ein paar Ausdrücke um so das es etwas besser Strukturiert rüberkommt



>> 20.02.2007
[CO]
Alle Projekte: Machte wie besprochen den ersten Schritt bei den Plugin-Änderungen:
- ClassManager::ScanPlugins(): Sucht wie vorher auch nach Plugins, kann dies jedoch nun auch Rekursiv machen
- ClassManager::LoadPlugin(): Prüft ob es wirklich eine '.plugin'-Datei ist, lies die Meta-Informationen aus und prüft dabei
  gleich den 'Typ' auf gültigkeit/übereinstimmung oder ob ein Plugin aktiviert/deaktiviert ist. Danach wird der Name der
  Dynamischen Bibliothek ermittelt - derzeit wird der Plugin Name genommen und entsprechend geändert so das Plugin und
  Dynamischen Bibliothek also erstmal im gleichen Verzeichniss liegen müssen. Anschließent wird wie gehabt (also 1 zu 1
  übernommen :) die Dynamischen Bibliothek eingeladen.
- Verschob die Plugins der verschiedenen Projekte sammt benötigter externer dlls in einen Plugin-Unterordner + dort wo sinnig
  in weitere Unterordner + schrieb entsprechende '.plugin' Dateien in denen ebenfalls vermerkt ist welche dll's diese benötigen,
  was ich recht hilfreich finde. Hier müssen wir uns allerdings noch überlegen ob wir das drinnen lassen da z.B. unter Linux die
  Dateiendung natürlich anderst ist + auch teils die Namen der benötigten Dynamischen Bibliothek, oder ob wir für jedes OS
  Seperate Dateien machen oder ob das innerhalb der Plugin-Dateien nach OS unterteilt ist.
- DynLibManager::LoadLibrary() & DynLib::Load(): Damit man Plugins + abhängige Dynamischen Bibliothek problemlos auch in
  Unterordnern halten kann was durchaus Sinnig ist änderte ich das Verhalten dieser Funktionen minimal. Die Windows Funktion
  lässt netterweise zu das die anderen nötigen dll's zuerst im gleichen Verzeichniss wie die eingeladene dll zu suchen sind.
  Wenn es unter Linux soetwas nicht gibt muss man es so lösen wie ich es zuerst unter Windows machen wollte: Einfach das
  aktuelle Verzeichniss kurzzeitig entsprechend ändern. Dynamischen Bibliotheken sind also zuallererst im 'kleinsmöglichen Scope'
  zu suchen. *g*
- Passte die Post-Build Operationen aller VC & CMake Projekt entsprechend das herum kopieren)
PLGeneral:
- BufferedStringReader auf unsere String Klasse umgestellt. Diese Implementation ist sogar schlanker und übersichtlicher bei
  gleicher Effektivität. :)
- Win32FSTools::ConvertToWindowsPath(): Das 'großmachen' des Laufwerksbuchstaben 'Unicode sicher' gemacht
- ClassManager::GetVarType(const String &sType) Case-Sensitive gemacht da PL generell Case-Sensitive ist
  (da diese Funktion bis jetzt nirgends genutzt wird, musste man auch nichts prüfen ob das korrekt verwendet wird :)
- Hack: Class::Init() Registriert sich in LoadableManager damit dieser von neuen Loadern Wind bekommen kann. Das war leider
  nötig da ansonnsten u.a. in "PhysicsPlayground.scene" Sichtbar Dinge nicht korrekt Funktionierten. (was mich schon geraume
  Zeit störte, da die Ragdolls dort wirklich extrem cool rüberkommen *g*) In dem Falle bekam man die Meldung das die Ragdolls
  nicht eingeladen werden konnten da 'Radgoll' nichts sei was eingeladen werden könnte. Bei Config ist es im Prinzip genauso,
  aber da man da zum Glück derzeit nix von merkt war auch kein Hack dafür nötig. :)
  Klassen melden sich bei LoadableManager nicht ab, da dies derzeit nicht absolut nötig ist - ich wollte einfach die Hacks
  so gering halten wie möglich und fügte auch ausreichene Dokumentation dazu damit man später noch weis warum das drinnen ist.
- Loadable::Save(File *pFile, const Parameters *pParams) prüft ob die übergebene Datei beschreibbar ist
- SearchFilter::CheckMatch() auf unsere String Klasse umgestellt. Ich brauchte einige Zeit um in etwa nachvollziehen zu können
  was hier passiert. Ich hoffe das ich das Funktionsmäßig soweit verstanden und korrekt über unsere String Klasse realisiert
  habe so es Funktionsmäßig keinen Unterschied gibt.
  Stefan, wäre super wenn du das auch nochmal genau Durchdenken könntest ob ich da nicht doch nun eine Funktions Änderung
  drinnen habe... das war das komplizierteste was ich bis jetzt auf unsere String Klasse umgestellt habe und da kann schonmal
  was daneben gegangen sein. *bibber*
  (zumindestens einfache Dinge wie '*.pak' scheinen noch korrekt zu funktionieren, und das in '*' war der heftigste Teil :)



>> 16.02.2007
[CO]
- 'ConsoleLogFormater' hinzugefügt - stand schon so lange auf dem Plan obwohl so wenig Arbeit *g*
- ClassManager::ScanPlugins(): Musste hier leider einen Hack einfügen: "msvcr80.dll" und "msvcr80d.dll" sollte man nie per
  Hand einladen da ansonnsten eine dll Namens 'COREDLL.dll' verlangt wird (scheinbar WindowsC E) wovon ich nur eine nicht
  wirklich brauchbare Version im Netz nach langem suchen finden konnte. Hm, mit den Plugins müssen wir uns wirklich mal was
  überlegen, denn irgendwie häufen sich ähnliche Probleme wenn man alle dlls einläd und nach PL brachbaren Zeug durchforstet. :(



>> 12.02.2007
[CO]
- String: Neue Funktionen: IsValidInteger(), IsValidFloat(): Prüfen ob im String eine gültige Integer oder Float Zahl ist,
  solche Tests werden u.a. für die EditBox in PLGui benötigt.



>> 11.02.2007
[CO]
Alle Projekte: Auf VC 2005 'umgestellt':
- Als ich zum ersten mal etwas unter VC 2005 übersetze bekam ich natürlich viele 'Depriciated Fehlermeldungen' wie z.B.:
    c:\programme\microsoft visual studio 8\vc\include\string.h(73): Siehe Deklaration von 'strcpy'
        Meldung: "This function or variable may be unsafe. Consider using strcpy_s instead. To disable deprecation, use
        _CRT_SECURE_NO_DEPRECATE. See online help for details."
  Zum Glück nutzen wir mittlerweile 'fast' überall (und wo das noch nicht der Fall ist und sinnig ist, wird das bald der
  Fall sein :) unsere eigene String Klasse so das sich dieses 'Warnungen' auf eine (große) Handvoll Stellen beschränkten.
  Da die 'Sicherheits'-Warnungen + die neuen zusätzlichen Warnungen durchaus Sinnvoll sind stellte ich u.a. auf 'sichere'
  Funktionen um dennen man die Buffer größe übergeben muss damit sich Buffer Überläufe vermeiden lassen. (ich denke da spricht
  absolut nix dagegen :) Es gibt noch aufwändigere Stellen wo man umstellen müsste oder wo wir sowieso bald unsere eigene
  String Klasse nutzen, das mache ich als zweiten Schritt - würde man das auf einmal machen könnten sich schneller Umstell-Bugs
  einschleichen... ich hoffe da sind bis jetzt keine reingekommen, denn bei dem +1 für mit/ohne \0 muss man immer verdammt
  aufpassen und sich genau Informieren wie die verschiedenen Funktionen das übergeben haben wollen. (bitte die Änderungen
  nochmal kurz überfliegen :)
- An Stellen wie z.B.
  .\src\Base\StringBufferASCII.cpp(285) : warning C4996: 'stricmp' wurde als veraltet deklariert
    C:\Programme\Microsoft Visual Studio 8\VC\include\string.h(213): Siehe Deklaration von 'stricmp'
    Meldung: "The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _stricmp. See online help for details."
  passte ich entsprechend an. ('Standardkonform' ist immer gut :) In 'PLGeneralLinux.h' kann man nun sicherlich einige 'stricmp' etc. entfernen.
- TinyXML: Mit VC 2005 neu übersetzt damit der Linker nicht meckert



>> 10.02.2007
[CO]
- SystemWin32::GetOS(): Erweitert damit auch Windows Vista + Service Packs erkannt werden



>> 01.02.2007
[SB]
Alle Projekte:
- CMake build system ist komplett, alle Projekte lassen sich sowohl für Windows als auch für Linux übersetzen
- Kleine Zusammenfassung, welche Probleme es mit CMake gab:
  - PROJECT_OUTPUT konnte nicht auf ein anderes als das Grundverzeichnis gesetzt werden (sollte eigentlich "bin" sein), da CMake
    ansonsten beim linux-build die Abhängigkeiten nicht mehr findet und sofort abbricht. Die Ausgabedateien werden also im
    Grundverzeichnis des Projektes erstellt, was aber nicht weiter schlimm ist, da es sich ja immer um max. 2 Dateien handelt
    und sich dort ansonsten nur die Projektdateien befinden.
  - Beim linux-build werden statische Bibliotheken, die eine Abhängigkeit von einer dynamischen Bibliothek darstellen, nicht nur
    zu dieser Bibliothek gelinkt sondern auch zu allen davon abhängigen Projekten (eine Erklärung hierfür findet sich in der CMake FAQ).
    Da die Pfade zu diesen Bibliotheken aber in den abhängigen Projekten nicht bekannt sind, werden diese nicht gefunden und das
    Übersetzen bricht ab. Um das zu vermeiden müssen die externen Bibliotheken immer mit absolutem Pfad angegeben werden, anstatt
  LINK_DIRECTORIES zu benutzen.
- Altes Linux-Buildsystem ausgebaut



>> 28.01.2007
[CO]
Alle Projekte:
- VC Projekt-Dateien wie besprochen in die jeweiligen Grundordner verschoben



>> 27.01.2007
[SB]
Alle Projekte:
- Neues Build-System für Linux auf Basis von CMake eingebaut. Die Projektdateien können dafür benutzt werden,
  sowohl die Linux-Version zu erstellen als auch mittels Cross-Compiling mit VC7 die Windows-Version.
- PLBase Projektdateien sind komplett, jedoch lassen sich zur Zeit noch nicht alle Projekte auch für Linux übersetzen.
  Das Cross-Compiling für Windows funktioniert aber schon perfekt :-)



>> 26.01.2007
[CO]
Kleinere Aufräumarbeiten in PLGeneral:
- "Friend declarations" in "Friends" geändert
- z.B. "Public interface" in "Public functions" geändert
- Namespace Style vereinheitlicht
- Ein paar Leerzeichen/Tabs korrigiert
- In ein paar Konstruktoren wurden nicht alle Variablen Initialisiert + an ein paar Stellen wurde noch nicht die
  Initialisierungs-Liste genutzt
- Ein paar const eingefügt
- In ein paar Headern wo möglich Includes durch Predefinitions ersetzt
- Fügte in einigen cpp-Dateien 'Blöcke' hinzu damit man sofort sehen kann welche Funktionen public, private etc. sind
- Ein paar Kommentare korrigiert/vervollständigt (u.a. "@remarks:" zu "@note" gemacht, oder "@remarks" zu "@note")
- An ein paar Stellen Codes etwas vereinfacht/verschönert, z.B. "for (;;)" in "do/while" geändert oder 'tote' Codes entfernt
  oder ein [TODO] davor gesetzt wenn nicht eindeutig klar war das es nicht mehr benötigt wird
... An der Funktionalität sollte sich nichts geändert haben. Stellen wo man etwas Funktionell ändern/prüfen
    muss hab ich mir erstmal nur notiert um diese in einem zweiten Schritt abzuarbeiten. (damit nix durcheinander kommt :)
    Gerade einige Umbenennungen waren mir sehr wichtig da diese das durchsuchen aller Projekte nach bestimmten Begriffen
    sehr erleichtern.
- BufferedStringReader::GetString(): Hier kann der String Buffer direkt übernommen werden. Bringt jedoch nur 'im Augenblick'
  etwas, denn BufferedStringReader müsste man komplett auf die String Klasse umstellen ohne 'char *' zu nutzen *Unicode Sicher*
- CmdLineParser Code Style angepasst und 'printf' für Debugging rausgenommen, soetwas sollte nie im Code bleiben und auch nie
  nötig sein... man braucht hier *wirklich* einen brauchbaren Debugger damit man keine printf-Krücken nutzen muss die den Code
  durcheinander werfen. Ich fand auch ein paar Stellen wo man die Implementation etwas vereinfachen konnte + Variablen die nix
  machten entfernen konnte. An der Funktionalität hab ich nichts geändert.
- Bugfix: SearchFilter::SearchFilter(): "m_sFilter.ToLower()" entfernt da PL generell case sensitive ist
- Tokenizer: 'm_sSingleChars' Default Einstellung ist nun eindeutig wie gehabt "{}()[]<*>/=,;\"", in den Codes war auch noch
  "{}()[]<>+-*/=,;\"" auskommentiert drinnen und in der Klassen Dokumentation stand "{}()[]=,;\"" als Default. + und - machen
  im Zusammenspiel mit Zahlen welche ein Vorzeichen haben schwere Probleme, darum sollten diese Zeichen als Default keine
  einzelnen Zeichen sein.



>> 18.01.2007
[CO]
- Bugfix: FSTools::ValidatePath(): ".." und "." wurden nicht korrekt aufgelöst da FSTools::GetFirstPath() ebenfalls '\' am
  Ende stehen hat. (war früher mal anderst) Dies viel vorallem im Datei-Dialog auf. :)



>> 16.01.2007
[CO]
- Timer: SetTimeScaleFactor(), SetSlowMotionFactor() und SetCustomSlowMotionFactor(): Der übergebene Faktor MUSS größer als
  0 sein, ist das nicht der Fall, liefern diese Funktionen nun einen Fehler zurück. Ein Faktor von 0 oder gar ein negativer
  Faktor macht an verschiedenen Stellen nur probleme und logisch überhaupt seinen Sinn. 0 ist das gleiche wie Pause, also
  kann man gleich 'richtig' Pausieren wenn man das will, und negative Faktoren, hm, dann müsste ja automatisch alles
  rückwärts laufen... grrr... *g*



>> 23.12.2006
[CO]
- ChecksumCRC32 Checksum Implementation hinzugefügt
- ChecksumSHA1 Checksum Implementation hinzugefügt. Damit haben wir nun 3 Checksum Implementation (aller guten Dinge sind
  3... 3 Gui-Implementationen, 3 Renderer-Implementationen, 3 Sound-Implementationen... *g*)



>> 17.12.2006
[CO]
Alle Projekte:
- Bei den 'GetLoadableTypeName()'-Implementationen wird nun nicht mehr ein C-String zurückgeben, sondern diese Funktionen
  halten ihren Rückgabe-String in einem statischen PL String der zurückgeben wird. Auf die weise muss nicht jedesmal
  der *wirklich* statische String in einen PL String umgewandelt werden nur um kurz darauf wieder zerstört zu werden.
  Statt z.B.
    String SceneContainer::GetLoadableTypeName() const
    {
      return "Scene";
    }
  wird nun
    String SceneContainer::GetLoadableTypeName() const
    {
      static String sString = "Scene"
      return sString;
    }
  geschrieben. Von außen merkt man also nix, und intern isses eine geschicktere Implementation. Das mag zwar die Performance
  nicht um das tausendfache steigern, aber wenn man soetwas machen kann ohne das es alles total durcheinander bringt sollte
  man das machen. An ähnlichen Stellen sollten wir das immer genauso machen, bin daher mal die Codes durchgegangen und änderte
  es dort wo es sinnig ist. Wird nur "" zurückgeben, können wir das wie gehabt lassen da hier sowieso nix herum kopiert wird,
  oder wo der mehraufwand das überhaupt nicht rechtfertigt und es dadurch nur unübersichtlich wird sollten wir das ebenfalls
  wie gehabt lassen... z.B. bei pButton->SetText("Blah!").



>> 16.12.2006
[CO]
- Loadable: m_sAbsFilename muss leider protected sein da PLMesh::Texture und PLMesh::Material *sehr* spezielle Lade Funktionen
  komplett selbst Implementieren und entsprechend m_sAbsFilename in Eigenverantwortung setzen müssen.
- Loadable::Reload() darf der Lade-Funktion natürlich keine direkte Referenz auf 'm_sAbsFilename' übergeben da dieser String
  innerhalb der Lade-Funktion durch die Unload()-Funktion zurückgesetzt wird und dann natürlich nicht bekannt ist was denn
  nun geladen werden soll. :)



>> 13.12.2006
[CO]
Alle Projekte:
- Schaute mir alle Stellen in den Codes an in denen 'using namespace' verwendet wird: Nahm unötige 'using namespace'
  heraus, entfernte z.B. 'PLGeneral' vor 'PLGeneral::uint32' wenn gerade PLGeneral als Namespace verwendet wird, fand und
  entfernte dabei einige mittlerweile unnötigen Header-Includes.



>> 03.12.2006
[CO]
- Ich schaute mir nochmal kurz die verschiedenen Implementation von Container::Remove() (+ überall wo GetIndex() verwendet wird)
  an und merkte das diese bei weitem nicht Optimal war... denn da wurde ein int Wert von 'GetIndex()' ner Funktion übergeben die
  ein uint32 erwartete und konnte ein Element nicht gefunden werden wurde -1 in uint32 umgewandelt... ging zwar meistens gut
  da wir nie Container mit SO vielen Elementen haben, war aber natürlich nicht korrekt. Bei der Gelegenheit erweiterte ich die
  Container-Kommentare auch noch minimal so das möglichst keine Fragen offen bleiben.



>> 02.12.2006
[CO]
- Der Loadable-Manager ist nun ebenfalls ein Loadable und kann sich somit selbst Laden und Speichern. File System Basis
  Pfade werden momentan ebenfalls speichern, wenn das unnötig/ungeschickt sein sollte, können wir uns überlegen wie wir
  das am besten anderst lösen.
- Loadable um Reload()-Funktion erweitert, das ist zwar praktisch 'nur' ein pLoadable->Load(pLoadable->GetAbsFilename()),
  passt aber wunderbar rein und wird auch mehrmals genutzt. PLMesh::Material und PLMesh::Effect erweitern diese Reload()
  Funktion indem nach dem Neuladen zusätzlich noch die verwendeten Texturen neu geladen werden.
- Bugfix: BufferedFileReader: Beim beenden wurde Release() von File aufgerufen, aber beim Datei Zeiger speichern wurde
  keine Referenz hinzugefügt und so wurde in sehr unglücklichen Situationen die Datei einfach gekillt obwohl diese noch
  Referenziert und auch verwendet wurde. Fügte nur ein 'm_pFile->AddReference();' ein anstatt auf Smart Pointer umzustellen.



>> 01.12.2006
[CO]
Alle Projekte:
- Auf Anregung von Stephan änderte ich überall
    XmlDocument *pDocument = new XmlDocument();
  in
    XmlDocument cDocument;
  wodurch auch kein delete mehr nötig ist.
PLGeneral:
- Stack und Queue Kommentare minimal erweitert: Sucht man nun in PixelLight.chm z.B. nach 'FILO' wird man recht schnell
  das Stack Template finden. :)
- 'Timer' Klasse in 'Timing' umbenannt. Dieser Name ist passender - und ganz nebenbei kann's auch keinen Namenskonflikt mehr
  mit der neuen Timer Klasse in PLGui geben.
- Code im Destruktor von XmlNode entfernt da genau das gleiche in dessen Basis-Klasse XmlBase passiert (kein Fehler, nur unnötig)
- Fügte bei den Xml-Klassen in denen es noch 'keinen' Destruktor gab einen leeren ein (wir hatten uns vor einiger Zeit geeinigt
  das wir das so machen wollen, also immer Destruktoren reinschreiben)



>> 30.11.2006
[CO]
- ClassManager::GetVarType(): PL_VAR_PLSTRING fehlte hier, merkwürdig das dies bis jetzt noch nicht aufgefallen war :D
- XmlDocument::LoadFile() setzt nun ebenfalls den Dokument Wert auf den Dateinamen aus dem dieses Dokument geladen wurde
- Verschob FSTools::GetRelativePath() in den Loadable-Manager. Dieser schaut als allerersten Schritt nach ob's für diese Datei
  Endung überhaupt einen eingetragenen Loadable Type gibt, wenn ja, so wird die Anfrage einen 'relativen Pfad' zu erzeugen
  an diesen Loadable Type weitergeleitet.
FileSystem:
- Nahm folgende Funktionen heraus da nun das Loadable-System für diese Jobs zuständig ist:
  GetNumOfSearchPaths(), GetSearchPath(), IsSearchPath(), AddSearchPath(), SetSearchPathPriority(), RemoveSearchPath(),
  ClearSearchPaths(), GetNumOfFileTypes(), GetFileType(), RemoveFileType().
- OpenInPaths() ist nun unnötig und wurde daher entfernt
- Enfernte die Klasse FileType, Sie ruhe in Frieden *g*



>> 26.11.2006
[CO]
- Container Klassen etwas herausgeputzt: ein paar Klassen-Blöcke hinzugefügt, Prefix bei Klassen-/Stuktur-Namen entfernt,
  ein paar kleinere Kommentare etwas geändert
- XML-Klassen etwas herausgeputzt: Hauptsächlich Kommentare komplettiert/verbessert
- ClassManager::LoadPlugin(): Eine Datei wurde geöffnet, aber nicht wieder freigegeben -> Stefan schau bitte nochmal drüber
  nicht das ich da nun etwas vermurkst habe. :)
- LoadableManager & Config: Ich wunderte mich gerade das Ragdolls im Scene Viewer nicht mehr geladen werden können da angeblich
  'Ragdoll' ein nicht bekannter Loadable Typ ist... als ich der Sache nachging stellte sich schnell heraus das der Loadable
  Manager bereits nach Loadable Typen sucht und diese Registriert (in dessen Konstruktor) bevor der Runtime-Ordner nach Plugins
  durchsucht wurde. Das lässt sich momentan leider nicht 'beheben' da man sich nicht Informieren lassen kann wenn neue Plugins
  eingeladen wurden um anschließend diese 'Neulinge' nach zu Registrierenden Komponenten zu durchsuchen. :(



>> 25.11.2006
[CO]
Alle Projekte:
- Schaute 'NULL' in allen Headern nochmal durch und ersetzte es im zusammenhang mit PL-Strings durch 'empty'
  (das waren noch Zeiten als wir 'char*' nutzten :)
PLGeneral:
- Loadable: Da es bei Mehrfachvererbungen (siehe PLEngine::SceneContainer oder PLPhysics::SNRagoll) leider schnell zu cast
  Problemen kommt baute ich bis eine bessere Lösung gefunden ist virtuelle 'LoadLoadable()' und 'SaveLoadable()' Funktionen
  ein mit denen sich das Problem 'umgehen' lässt. Sehr schade, denn bis auf dieses Problem ist das Loadable-System mittlerweile
  recht nett, sehr einfach zu verwenden und zu erweitern.
- Localization Loader + Implementation für unser eigenes Format hinzugefügt
- Config Loader + Implementation für unser eigenes Format hinzugefügt



>> 24.11.2006
[CO]
- Vereinfachte das Loadable-System noch etwas und nahm einige Dinge aus 'Resource' heraus diese nun in dessen Basis-Klasse 'Loadable'
  liegen... Machte zuvor eine Kopie Namens 'ElementManager' etc. da sehr oft 'Resource' allein von Namen her in der Verwendung
  nicht korrekt war. (oder zumindestens nicht wirklich passend) Das ist zwar ingesammt immer noch nicht sonderlich prall, aber
  immerhin etwas besser als vorher. :)
  'Resourcen' sind 'Dinge' wie man Einladen & Speichern und von denen man überlicherweise viele im Speicher hat und diese
  daher 'Verwaltet' haben möchte. 'Elemente' sind ähnlich, aber einfacher und auch nicht lad oder speicherbar.
- Graph Loader + Implementation für unser eigenes Format hinzugefügt
- Graph Path Loader + Implementation für unser eigenes Format hinzugefügt



>> 11.11.2006
[SW]
- String: da die atof funktion unter linux auch locale abhängig ist, wird in den Funktionen GetFloat und GetDouble
      wie in den Format funktionen die locale auf "C" gesetzt.
- LinuxDirectory: ein Fehler bei der Überprüfung ob der Suchpfad mit einem "./" beginnt
  und dem löschen dieser 2 zeichen behoben. In der ursprünglichen Fassung wurde das Löschen durch die Stringfunktion Replace durchgeführt,
  was aber einen bösen nebeneffekt hatte, wenn der pfad auch "../" enthielt.



>> 04.11.2006
[CO]
- Win32File & LinuxFile: Kann es wirklich sein das im Destruktor die Datei nicht geschlossen wurde falls diese noch offen
  war? (was bei Reference Counting schonmal passieren kann... der letzte hat die Tür zuzumachen... :)



>> 03.11.2006
[CO]
- Entfernte ein paar 'PLGENERAL_API' wo das nicht nötig ist da es rein PLGeneral intern genutzt wird
- Fügte einige 'const' ein
- Virtual vor Destruktor entfernt da unnötig: (verwenden nur eingebettete Implementationen) Semaphore, Mutex, DynLib
- In einigen cpp-Dateien Kommentar Blöcke hinzugefügt damit man sofort sieht ob die Funktionen public etc. sind
- System: Neue Funktion GetLocaleLanguage(): Diese Funktion gibt den Namen der aktuell eingestellten Programm Sprache wie z.B.
  'English' zurück. Diesen String kann man dann nutzen um im Lokalisations-System eine korrekte Default-Sprache zu wählen.
- ~ThreadManager: Änderte das löschen noch vorhandener Threads da Theads sich beim löschen automatisch aus der Liste
  entfernen was beim Interator Probleme machen 'könnte'. In diesem speziellen Fall machte das zwar keine Probleme da der List
  Iterator intern direkt einen Zeiger auf das nächste Element hält, aber beim z.B. Array-Iterator würde das schon nicht mehr
  gehen... lieber auf Nummer sicher gehen. :)
- SystemWin32: SetThreadAffinityMask() aus PLEngine::PL::InitEngine() hierher verschoben
- Thread um SetPriorityClass() und SetPriority() erweitert, PLEngine::PL::InitEngine() nutzt diese Funktionen um das Programm
  mit einer gewünschten Priorität laufen zu lassen. (bis jetzt wurde dort mit einem ifdef gearbeitet)
  Stephan, bitte schau mal nach ob das mit der Thread Priorität unter Linux ähnlich abläuft, wenn nicht, so müssten wir uns
  zusammen überlegen wie wir das in PL handhaben wollen.



>> 28.10.2006
[CO]
- Loadable: Neue Funktion: GetAbsFilename() gibt den absoluten Dateinamen der Datei zurück aus dem dieses 'Ladbare Teil'
  geladen wurde. So einen absoluten Dateinamen braucht man öfters mal, z.B. in PLMesh::Texture::Load() um nach einer
  entsprechenden 'plt'-Datei zu suchen oder wenn eine Resource 'neu geladen' werden soll. Noch find ich die aktuelle
  Lösung noch nicht sooo prall, mal schaun ob wir das noch irgendwie besser & universeller hinbekommen können - aber für
  den Augeblick müsste das reichen.
- FS: Directory::OpenCanonical(): Das Laden aus einer Zip-Datei anhand eines absoluten Namens klappte nicht (mehr) korrekt



>> 27.10.2006
[CO]
Alle Projekte:
- Nahm an ein paar Stellen <Extension>.ToLower() und CompareNoCase() heraus da wir generell zwischen groß/kleinschreibung
  unterscheiden wollen. In den Beispielen musste ich dadurch ein paar 3ds-Meshs per Hex-Editor korrigieren da Max irgendwie
  absolut keinen Wert auf groß/kleinschreibung legt und bei 3ds wie es momentan aussieht IMMER zwanghaft großschreibt.
  (da müsste ich noch etwas Experimentieren ob dem wirklich so ist)
PLGeneral:
- 'Loader'-System eingebaut, dieses System lag bereits seit ein paar Monaten im Lab/PLResource-Ordner. Nahm 'File' aus
  den Klassen Namen heraus damit es etwas deutlicher wird das dies nicht 'direkt' etwas mit dem FS zu tun hat.
  Alles was irgendwie Lad- & Speicherbar ist sollte von nun an von 'Loadable' abgeleitet werden. Die konkreten Lade & Speicher
  Funktionen liegen in von 'Loader' abgeleiteten Klassen. Diese 'Loader' müssen sich wirklich NUR um das Laden & Speichern
  kümmern, und nicht um das öffnen/schließen der Datei - das vereinfacht an vielen Stellen einiges. Abfragen welche Typen & Formate
  unterstützt werden kann man universell & bequem über den 'LoadableManager'. Das muss nun also nicht mehr x mal neu
  geschrieben werden, sondern 'Loader' werden zentral automatisch Registriert und verwaltet. Das System ist noch nicht final
  und wird an ein paar Stellen noch etwas vereinfacht werden. Aber es ist denk ich schonmal etwas besser als vorher... leider
  brachte dies keine großartige Ladezeit Verbesserung, trotzdem ist nun beim Laden einiges an Overhead weg. :)
- XmlDocument: Lade-Funktion hinzugefügt der man dirkt eine Datei übergeben kann



>> 18.10.2006
[CO]
Alle Projekte:
- Fügte "#pragma once" in alle Header ein damit das Übersetzen "minimal" schneller geht. Da dies sowohl unter VC als auch
  gcc bekannt ist, müsste es damit keine 'Kompatibilitätsprobleme' geben.
- Mithilfe von "__pragma" kann man Pragmas auch in Makros nutzen. Änderte daher die PL_WARNING_PUSH & PL_WARNING_POP &
  PL_WARNING_DISABLE Makros entsprechend.



>> 17.10.2006
[CO]
Alle Projekte:
- Wie besprochen "PL_WARNING_POP", "PL_WARNING_PUSH", "PL_WARNING_DISABLE" Precompiler Makros eingebaut. Jedoch konnte man
  es leider nicht so realisieren das man direkt "PL_WARNING_DISABLE(4100)" schreiben kann... stattdessen muss man
  "#pragma PL_WARNING_DISABLE(4100)" schreiben. Nun müssten unter Linux die pragma-Warnungen weg sein. Wie genau man das löst
  wenn man bestimmte Warnungen unter Linux deakivieren will müssten wir sehen wenn das ein Thema wird.



>> 16.10.2006
[SB]
Alle Projekte:
- Habe mal versucht die Export-Makros etwas zu entwirren. In PLGeneral ist jetzt jedes dieser Makros auch noch etwas genauer
  beschrieben, damit hoffentlich keiner mehr verwirrt ist welches Makro wozu gut ist.



>> 14.10.2006
[SW]
Alle Projekte:
- Finale version für das visibility attribute feature vom gcc.



>> 14.10.2006
[CO]
- Error System, zweiter Ansatz: (Namen & Implementation noch nicht final :)
  Hat eine Funktion einen 'boolschen' Rückgabewert, so wird statt bool/PLBool 'PLReturn' genutzt welches ein Smart Pointer
  auf ein 'Result'-Objekt ist. (Experimentelle Implementation) Trat kein Fehler auf, so zeigt dieser auf 'Result::NoError',
  bei Fehler auf ein erzeugtes Result-Objekt. Dieses Result-Objekt kann man wie gehabt genauso wie einen einfachen boolschen
  Rückgabewert verwenden falls man sich 'nur' dafür Interessiert ob es einen Fehler gab. Interessiert einen selbst das nicht,
  wird dank dem Smart Pointer dieses Result-Objekt automatisch wieder 'freigegeben'. Gibt eine Funktion z.B. einen String
  zurück, so sollte es IMMER einen Optionalen PLResult-Zeiger geben der auf Wunsch das Ergebniss bekommt. Zwar bietet der
  Error-Manager die Möglichkeit sich den 'letzen' Fehler zurückgeben zu lassen, dies ist jedoch NICHT Multithreading-Safe...
  aber falls das einen nicht juckt, kann man diesen Optionalen Parameter auch ignorieren und z.B. Error::GetLast() nutzen was
  etwas 'bequemer' zu verwenden ist - das ist dem User überlassen ob er dieses 'Risiko' eingehen will. Wir selbst sollten in
  der Engine aber NIE Error::GetLast() nutzen. :)
  Das System unterstützt auch 'Rekursion' so das man sich den vorherigen Fehler zurückgeben lassen kann um zu sehen wo der erste
  Fehler passierte. Anhand von Checksum::GetFile() kann man sehen wie das mit der Fehler-Rekursion derzeit abläuft. Anhand von
  PLBaseTest::ChecksumTest() kann man sehen das dies bereits sehr gut klappt - wenn wir das so machen wollen, muss sich natürlich
  dann jede Funktion daran halten damit das durchgehend klappt und man Fehler bis an den Ursprung zurückverfolgen kann.
  Die übergebenen Funktions-Parameter sollten wenn möglich IMMER mit einem PL_ASSERT() auf gültigkeit geprüft werden und in der
  Funktions Dokumentation sollte genau beschrieben sein ob ein Parameter gültig sein MUSS oder nicht. Hier wird aber wirklich
  nur geprüft und gewarnt wenn etwas nicht stimmt, danach gehts fröhlich weiter bis zum Crash.



>> 13.10.2006
[CO]
- PLMain Dokumentiert damit wirklich klar ist was die Parameter und vorallem der Rückgabewert zu bedeuten haben
- UTF8Tools: Die 3 neuen Funktionen von Stephan vom Style & der Namensgebung her angepasst. Kommentar "One or both strings
  can be pure ASCII Strings" entfernt da dies eine allgemein gültige UTF8 Eigenschaft ist. 'FindSubString' könnten
  wir eventuell auch 'IsSubString' oder 'GetSubString' nennen... von der Funktionaliät her hab ich nix verändert - konnte
  mit den erweiterten Unit-Tests auch keine Bugs oder so finden. :)



>> 11.10.2006
[SW]
Alle Projekte:
- Die projekte verwenden das neue visibility feature vom gcc, wenn vorhanden.
PLGeneral:
- Neues Makro PLTEMPLATE_EXPORT hinzugefügt, mit denen unter Linux die Templates komplett exportiert werden können.
  Momentan betrifft das nur Array und Singleton



>> 06.10.2006
[CO]
Alle Projekte:
- Nachdem mich Stephan auf eine 'POD-Warnung' in "PLGui/Dialogs/ResourceManagerDialog.inl:288" aufmerksam machte,
  ging ich nochmals alle String::Format-Stellen durch und prüfte auf PLT()-Makro verwendung - denn dieses gibt mittlerweile
  einen PL String zurück. :)



>> 01.10.2006
[CO]
- Bugfix: XmlDocument::GetRootElement() -> Hier ging der Aufruf nicht über GetPLNode() und daher wurde keine korrekte eingebettete
  PL XML Node erzeugt. (gut das Stephan diese Funktion mal ausprobiert hatte *g*)



>> 28.09.2006
[SW]
Alle Projekte: PLBase:
- Die linux-projecte dateine an die Änderungen angepasst.



>> 27.09.2006
[CO]
- Auf PLBool umgestellt und wie üblich alle Projekte entsprechend angepasst. Stellte auch dort auf PLBool um wo das true/false
  bereits passte damit das 'Einheitlich' ist und das einbauen eines netten Fehler Systems leicher geht. (man muss fast nur noch
  nach PLBool suchen *g*)
  Beim Linux Teil *könnte* es noch Stellen geben wo man noch den Fehler Code anpassen muss.



>> 26.09.2006
[SW]
- In RTTIDefs.h an zwei stellen (void)0 anstelle von 0 geschrieben um eine gcc-4.x warnung zu beheben
- ClassManager::LoadPlugin da der DynLibManager momentan in der Hasmap von bereits geladenen Libs nur den Dateinamen speichert,
  wird nun der GetLibrary nur der Dateinamen übergeben und nicht der komplette pfad.
  Wenn jemand was dagegen hat soll es entweder wieder zurückändern oder mir bescheid geben. (diese änderung wieder auf wunsch von stefan revidiert)
- ein paar dumme printfs rausgeschmissen, die eigentlich nicht hochgeladen werden sollten



>> 26.09.2006
[CO]
- Machte ein paar kleinere erste Style anpassungen



>> 21.09.2006
[CO]
- Einfache Error-System Klasse hinzugefügt + diverse Makros die einem das Leben mit Fehlern etwas einfacher machen
- Checksum & Config Klasse auf bessere Fehlerbehandlung umgestellt um zu sehen ob wir das so machen können/wollen



>> 21.09.2006
[SB]
- Neue Klasse Url hinzugefügt. Diese Klasse verwaltet einen Pfad oder Dateinamen, kann zwischen den Unix/Windows Formaten sowie
  der URL Darstellung konvertieren und beinhaltet die üblichen Funktionen um einen Pfad in Verzeichnis, Dateiname, Extension aufzuspalten etc.
  Im Gegensatz zu den Funktionen aus FSTools ist die Klasse darauf ausgelegt, möglichst flexibel zu sein, und mit so vielen Eingaben
  wie möglich noch irgend etwas anfangen zu können. Kommt also z.B. ein Dateiname bunt gemischt mit \ und / herein stört das die
  Url Klasse nicht, der Pfad wird erstmal so gespeichert ohne gleich zwangsläufig konvertiert zu werden. Sobald man dann einen für das
  System gültigen Pfad braucht läßt man sich die Url umwandeln, damit sie korrekt wird.
  Im FS wird ab sofort nur noch diese Klasse verwendet und damit die alten FSTools Funktionen ersetzen. Außerhalb kann die Klasse natürlich
  auch verwendet werden, um z.B. an einen Pfad/Dateiname/Extension o.ä. heranzukommen, zum Speichern eines Dateinamens sollte sie allerdings
  nur sehr selten verwendet werden, da sie einiges an Speicherplatz braucht. Normalerweise sollte ein Pfad also weiterhin einfach als String
  gespeichert werden.
- FSRefCount entfernt. Die Basisklasse für alle FS Objekte (auch SearchHandle) ist nun FileObject, welches direkt von RefCount abgeleitet ist.
- FileObject: EType hinzugefügt, welches angibt um was für ein Objekt es sich handelt. Dies wird nun nur noch in der FileObject Klasse behandelt,
  die virtuellen Funktionen zu diesem Zweck wurden daher entfernt.
- FileObject: Hat nun keinen Pointer mehr auf FileSystem, da es davon nur eine Singleton-Instanz gibt, auf die jetzt direkt zugegriffen wird.



>> 20.09.2006
[SB]
- Neue Hilfsklasse PLBool hinzugefügt. Die macht nicht viel, außer einen bool zu speichern, und kann benutzt werden, um die
  true/false-Umstellung zu machen. Die Klasse ist so aufgebaut, daß sie *nicht* automatisch von/nach bool konvertiert,
  sondern bei jedem solchen Versuch einen Compilerfehler generiert. Das kann also so benutzt werden:
  - In der Funktion, die umgestellt werden soll, den Rückgabetyp von bool in PL_BOOL umändern
  - return true -> return PL_FALSE
  - return false -> return PL_TRUE
  - Alle Projekte compilieren, dadurch gibt es überall dort eine Fehlermeldung, wo die Funktion benutzt wird, z.B. bei
    if (TheFunction()), oder if (!TheFunction()) etc. Dort kann nun die Umstellung erfolgen:
  - if (theFunction()) -> if (PL_NOT theFunction())
  - if (!theFunction()) -> if (PL_IS theFunction())
  - Wenn sich wieder alles übersetzen läßt, kann man den Typus wieder auf bool setzen und per Suchen/Ersetzen alles zurück umwandeln
  - 'PL_FALSE' -> 'false'
  - 'PL_TRUE' -> 'true'
  - 'PL_NOT ' -> '!'
  - 'PL_IS ' -> ''
Auf diese Weise sollte die Umstellung wesentlich erleichtert werden, und dank der Compilerfehler müßte man auch *alle* Stellen finden,
an denen die jeweilige Funktion verwendet wird, man kann also nichts mehr übersehen. Natürlich müssen immer alle Projekte compiliert werden,
denn nach dem Umwandeln sieht für die Compiler wieder alles richtig aus, auch wenn man ein Projekt noch nicht angepaßt hat. Hoffe das macht
diese Umstellung etwas erträglicher ;-)



>> 19.09.2006
[CO]
- UTF8Tools: Neue Funktionen FromWideCharacterString() & FromWideCharacterString() + änderte ein paar Namen so das klar ist
  das es sich z.B. um einen 'wide character' handelt. Änderte den Datentyp von 'wide character' von uint32 zu wchar_t - das
  ist zwar irgendwie total doof da wchar_t keine fest vorgegebene größe hat, allerdings können wir mit uint32 'wide character
  Dingen nix anfangen da die Windoof Unicode Funktionen nunmal leider wchar_t und kein UTF8 oder uint32 nutzen. :(
  Hatte mir zuerst überlegt wchar_t UND uint32 Versionen der Funktionen anzubieten - aber das wäre dann doch etwas zuviel
  des guten geworden. Hat man mit wchar_t Problemen da es z.B. unter Windows zu klein ist, muss man ganz einfach NUR UTF8
  in seinem Projekt nutzen - es hindert einen ja bei unserer String Klasse bald (sobald fertig Implementiert) nix dran! *g*
- String Klasse: GetUTF8() müsste mittlerweile Problemlos funktionieren -> Stephan, wenn du willst kannst du mal den Linux
  Port entsprechend anpassen bzw. mit GetUTF8() durchtesten ob das wirklich bereits brauchbar klappt. Der Rest muss noch
  ausgearbeitet werden.



>> 18.09.2006
[CO]
- Neue Tool-Klasse: UTF8Tools: Diverse UTF8 Funktionen die man immer mal wieder benötigt. Hatte diese zuerst direkt als statische
  Hilfs-Funktionen in StringBufferUTF8 drinnen bis ich merkte das es immer mehr Funktionen wurden die man ebenfalls noch bräuchte...
  Daher entschloss ich mich diese Funktionen in einer seperaten Hilfs-Klasse abzulegen damit das nicht zuviel auf einmal wird.
- Fing damit an die String Klasse um UTF8-Support zu erweitern (noch nicht lauffähig!)



>> 13.09.2006
[CO]
Alle Projekte:
- Schrieb bei jedem "#pragma warning(disable : <Number>)" dazu was genau dieses deaktiviert (... zumindestens bei VC...)



>> 12.09.2006
[SW]
- in Main.h das setlocale(LC_ALL, "") hinzugefügt(unter Linux), da dadurch die systemlocale für den Prozess gesetzt werden, ist nötig,
  da sonst im PLSampleGui die jpanischen schriftzeichen nicht angezeigt wurden.
- Durch die Änderung in der Main.h tauchten problem auf, wenn man floats in String und zurück umwandelt, da im Deutschen das Trennzeichen ein ',' ist und im Englischen ein '.'.
  Um das problem zu lösen wurde in den Format-Funktionen des String-Klasse die locale auf "englisch" ("C") gesetzt und am ende der Funktion wieder auf die systemlocale zurückgesetzt.
  Das Problem und die Lösung(momentan nur für LINUX als test) habe ich zusammen mit Christian ausgearbeitet.



>> 11.09.2006
[CO]
- Beseitige Warnungen die erscheinen wenn der Compiler auf Warnungs-Level 4 gestellt wird:
 - Per Absicht nicht verwendete Variablen (da z.B. Virtuelle Funktionen) sollten mit PL_UNUSED() gekennzeichnet werden
   damit hier nicht angewarnt wird.
 - Beim Einbinden externer Header (z.B. tinyxml.h) deaktiviere ich diverse Warnungen da wir hier nix ändern sollten.
 - Musste das PL_LOG-Makro minimal umschreiben damit nicht immer angewarnt wird das ein Ausdruck dort Konstant ist.
 - Deaktivierte die Warnung "warning C4201: Nicht dem Standard entsprechende Erweiterung: Struktur/Union ohne Namen" da
   ich nicht rausbekommen konnte wie man das besser machen könnte ohne das diese Warnung erscheint. :(
   (einfach keine Unions nutzen ist KEINE Option! ;-)
-> In den Projekten in denen ich die Warnungen beseitige hab ich im Debug-Modus erstmal Warn-Leven 4 aktiv gelassen. Solange
   es nicht stört können wir das so lassen und bekommen ein paar weitere nützliche Tips vom Compiler wo möglicherweise
   etwas noch nicht ganz ok aussieht. Viele der 'zusätzlichen' Warnungen sind durchaus hilfreich... um nur ein Beispiel für
   einen dadurch gefundenen Bug zu nennen:
      PLPhysicsNewton::WorldNewton::GenericContactBegin:: -> if (nCollisionGroup1 && Ignore)
    -> !! Übler Bug der nun zum Glück angewarnt wurde! ;-)
   Desweiteren werden auch Variablen angewarnt die zwar Initialisiert, aber nie verwendet wurden, ebenfalls recht nützlich,
   und wie schon oben erwähnt sollte man PL_UNUSED() verwenden wenn das schon korrekt so ist.
-> Ich werde sicherlich noch ein paar Tage brauchen bis ich durch alle Projekte sauber durch bin. :)



>> 10.09.2006
[CO]
- Config: - GetVarBool() entfernt da man dafür mittlerweile auch locker GetVar().GetBool() schreiben kann.
          - GetVarFloat() entfernt da man dafür mittlerweile auch locker GetVar().GetFloat() schreiben kann.
- FSTools::ValidatePath(): Bei einem der Zahlreichen String-Anpassungen der letzten Zeit kam hier ein kleiner Bug rein so
  das es zu Problemen mit '/' oder '\' kommen konnte. Stefan, wäre nett wenn du irgendwann später über diese Funktion
  nochmal drüber schaun könntest - nicht das ich das Schrittweise kaputt oder zu umständlich gemacht habe. :)
- Variant um GetString()-Funktion erweitert damit man sich ausdrücklich die String-Version des Wertes zurückgeben lassen
  kann ohne vorher auf String casten zu müssen



>> 08.09.2006
[CO]
- Abstraktes Checksum-Interface + MD5 Implementation hinzugefügt



>> 04.09.2006
[CO]
Alle Projekte:
- Fand einige Stellen an denen es z.B. netter ist vVector.x anstatt vVector[0] zu schreiben
PLGeneral:
- Types.h: FALSE, TRUE, und NULL flogen heraus bzw. verschob diese Definitionen in den Linux Teil da diese dort soweit ich
  weis benötigt werden. (bei Windows werden diese Dinge in den Win32-Headern definiert)



>> 04.09.2006
[SW]
- Linux implementation des Unicode(wchar_t) supports, habe den aufruf der durch "int vswprintf( wchar_t *buffer,const wchar_t *format, va_list argptr )"
  durch die funtion "int vswprintf(wchar_t *buffer, size_t count, const wchar_t *format,va_list argptr)" ersetzt, da unter linux nur die mit dem count parameter gibt.



>> 01.09.2006
[CO]
Alle Projekte:
- Wie Stefan es wünschte verwenden wir nun überall 'd' als Prefix für 'double' anstatt ein universelles 'f' für 'floating point'.
PLGeneral:
- Lokalisierungs-System eingebaut. Das System an sich ist recht einfach aufgebaut und auch leicht zu bedienen. Texte sind
  in Gruppen aufgeteilt und jedes Projekt kann seine Texte in einer eigenen Gruppe anlegen damit es z.B. keinen Konflikt mit
  PL-Texten gibt. Wie üblich ist das 'Localization' Format in XML gehalten.
  Da wir bereits überall wo Sprachabhängige Texte verwendet werden das 'PLT'-Makro verwenden, waren die Code Umstellungen minimal.
  Nur den Header '#include <PLGeneral/Tools/Localization.h>' muss man nun einfügen wo man Sprachabhänige Texte hat. Neben
  dem 'PLT'-Makro welches 'PixelLight' als Text-Gruppe nutzt gibt es noch ein 'PL_TEXT'-Makro bei dem als zweiter Parameter
  die Gruppe angegeben werden muss. Ob wir das 'PLT'-Makro drinnen lassen müssen wir noch sehen, auf jedenfall ist es im Augenblick
  noch nett da man die Codes dadurch nicht ändern musste oder sich um die Gruppe innerhalb der PL-Codes kümmern muss.
  Als 'native'-Sprache verwenden wir innerhalb von PL Englisch. Für diese 'native'-Sprache ist keine Lokalisierungs-Datei
  nötig da der Englische Text gleich als Schlüssel für die Übersetung verwendet wird. Wird keine Übersetzung gefunden weil
  gerade z.B. Englisch als Sprache aktiv ist, so wird einfach dieser Text-Schlüssel als Ergebniss verwendet. :)
  Was im Augenblick noch fehlt ist ein Tool welches Codes als Eingabe bekommt, nach unseren Lokalisierungs-Makros sucht
  und die Gefundenen Dinge in einer bzw. mehreren Lokalisierungs-Dateien auflistet so das man die Codes nicht per Hand nach
  zu übersetzenden Texten durchwühlen muss.
  Auch wäre es wohl sinnig wenn die Beispiele & Tools ihre Texte in eigenen Gruppen verwalten würden, das muss man aber
  noch ausjungeln wie was am besten ist. Hier ein Beispiel wie so eine Lokalisierungs-Datei aussieht:
    <?xml version="1.0" ?>
    <Localization From="English" To="Deutsch">
        <Text Name="Hello">Hallo</Text>
        <Text Name="This is a test">Dies ist ein Test</Text>
    </Localization>



>> 30.08.2006
[CO]
- Jede String Buffer Implementation speichert nun noch den String in einem jeweils anderen Format. Hab ich z.B. einen ASCII
  String, fordere aber einen Unicode-String an, so wird intern eine Unicode-String Variante erzeugt. Fordere ich nochmals
  Unicode an, so wird direkt dieser gepufferte Unicode-String zurückgegeben. Sobald der Orginal String verändert wird, wird
  dieser gepufferte String 'schmutzig' und muss sobald er wieder angefordert wird neu erzeugt werden. Arbeitete die internen
  String Konvertierungen aus, also wenn ich z.B. 'sMyString = sACII + sUnicode' schreibe.



>> 29.08.2006
[CO]
- String Klasse um wchar_t-Unicodes erweitert. In unseren Projekten sollte nun immer bei den Compiler-Einstellungen 'Unicode'
  anstatt 'Multi-Byte' verwendet werden was normalerweise die Standard-Einstellung ist. Da wchar_t von der größe her nicht
  fest Definiert ist, sollte man NIE davon ausgehen das ein Buchstabe 2 Byte oder so groß ist sondern IMMER sizeof(wchar_t)
  verwenden. Zudem sollte man aus diesem Grund wchar_t Strings auch nicht in Dateien speichern oder aus solchen Laden. Das
  sollte man dann über das 'sicherere' UTF-8 Format machen sobald dies Implementiert ist. Durch die änderung der Compiler
  Einstellung wurden einige fehlerhafte String-Stellen gefunden wo z.B. !sMyString abgefragt wurde, 'true' zurückgegen wurde
  obwohl der Rückgabewert ein String war etc. - also Stellen die man bei den krassen String Umstellungen von damals übersehen
  hatte. :)
  An ein paar Stellen wie z.B. im Win32 PLGui Backend wird bereits das Format des PL Strings geprüft und dann entsprechend
  die Unicode oder ASCII OS Funktions Variante verwendet... wie man anhand von PLSampleGui sehen kann geht nun auch Japanisch
  ganz wunderbar. *g*



>> 28.08.2006
[CO]
- Vorherige String Klasse durch die überarbeite String-Klasse ersetzt. Das Interface ist noch kompatibel mit dem alten und
  wurde nur minimal erweitert. Die ASCII Implementation ist komplett Implementiert, wurde an einigen Stellen neu geschrieben
  und mit den erweiterten String-Tests geprüft so das halbwechs sichergestellt ist das nicht wieder von neuem üble Bugs
  reingekommen sind. ;-) (zudem läuft alles auch im Release Modus noch stabil was auch schonmal ein gutes Zeichen ist *g*)
  Das sehr gut funktionierende String-Buffer Konzept wurde natürlich beibehalten, jedoch haben String Buffer nun auch noch
  den Job die konkreten String Operationen auszuführen - abhängig von deren internen String-Format. Die String Klasse selbst
  ist also sogesehen 'nur' noch ein String-Buffer-Container der bestimmte allgemeine Bedingungen prüft so das diese nicht
  in jeder String Buffer Implementation erneut gemacht werden müssen.
  Es kamen noch ein paar zusätzliche Hilfs-Funktionen hinzu damit man Strings auch mit Zahlen recht einfach zusammenbasteln
  kann. Beispiel: sString = 5 + sString + '_' + true + "HeHo" + 55.9; -> 5MyString_1HeHo55.9
  Damit kann man nun relativ einfach an vielen stellen String::Format() ersetzten was vorallem dann sehr sinnig ist wenn
  dort auch noch Strings miteingewoben werden sollen... man also GetString() nutzen muss. GetString() sollte man jedoch
  wo immer möglich in den PL innereien vermeiden da man sich für auf ein String Format (sollte IMMER Unicode sein) festlegen
  muss. Zudem vergisst man bei String::Format auch mal schnell GetString() und dann bekommt man Schrott zurück - der VC Compiler
  meckert das ja leider nicht an. Am besten & flexibelsten & sichersten ist das String-System, wenn ALLE String Operationen
  KOMPLETT über die String Klasse gemacht werden und GetString() NUR genutzt wird um z.B. dem OS den String zu übergeben.
  (sprich, um mit der Welt außerhalb von PL zu Kommunizieren *g*) Hält man sich an diese Spielregel, so braucht man sich nicht
  darum zu kümmern ob man gerade mit ASCII, Unicode, UTF-8 oder weis der Teufel was arbeitet - man verwendet einfach 'PL-Strings'
  und gut iss. ;-)
  Was noch fehlt sind Unicode-String Buffer die ich als nächstes angehen werde.



>> 26.08.2006
[CO]
- System: GetProgramName() -> Gibt den Namen des laufenden Programms zurück. (z.B. 'c:\MyApplication\Test.exe')



>> 25.08.2006
[CO]
Alle Projekte:
- Nach dem öffnen eines FS Verzeichnisses wurde meistens nicht geprüft ob das gut ging - verbesserte dies um Crashs zu vermeiden
  falls das öffnen eines Verzeichnisses mal nicht klappen sollte.



>> 24.08.2006
[CO]
Alle Projekte:
- Fand noch ein paar Stellen an denen anstatt stricmp/strcmp die String Funktionen verwendet werden können.
- Es gab noch ein paar Interface-Stellen wo 'const char*' anstatt 'String' verwendet wurde. Bei z.B. TestCase::GetName()
  ist dies aber durchaus Absicht da die Tests selbst nicht bereits von unserer String Klasse abhängig sein sollen.
- Entfernte extra 'const char*'-Funktionen in diversen Interfaces wie z.B. PLGeneral::Tokenizer so das 'nur' noch die eigene
  String Klasse verwendet wird. Da die String Klasse mittlerweile auch 'nur' einen Pointer auf einen 'char*' String halten
  kann 'ohne' dabei den gesammten String zu kopieren, ist dies ebenfalls kein 'Performance'-Problem. :)
- An ein paar Stellen wo String::CompareNoCase verwendet wurde wird nun == verwendet welches zwischen groß/kleinschreibung unterscheidet.
- Ersetzte wo möglich String::Format durch String Addition. Zum einen ist das etwas kompakter & besser Lesbar, aber viel wichtiger:
  Das wird so mit z.B. Unicode Strings weniger Probleme bereiten da es nicht mehr über GetString() abläuft.
- Entfernte einige <MyString.>GetString() wo das nicht wirklich nötig ist.
PLGeneral:
- String: Nahm die Print()-Funktion heraus da diese in der überarbeiteten String Klasse auch nicht mehr vorhanden ist. Ab
  jetzt muss man das immer über String::Format() machen, so gibt's nur noch eine einzige Funktion dafür (kein doppelter Code)
  und die 'Performance' wird darunter wohl auch nicht wirklich leiden. ;-)
- String::String(const char *pszString, bool bCopy = true, uint32 nLength = 0) -> Am Ende kann man nun noch optional
  die Länge übergeben. Dies ist u.a. in PLMesh::EffectLoaderFX recht praktisch da man hier einen sehr langen String hat
  wo man aber bereits genau weis wie lange dieser ist.
- Tokenizer::Start(const char *pszBuffer, long nSize) entfernt und die Codes in den anderen Projekten entsprechend angepasst.
- BufferedStringReader::BufferedStringReader(const char *pszBuffer, uint32 nSize) entfernt.



>> 23.08.2006
[CO]
- Da ich momentan an einer neuen String Implementation mit Unicode Support Arbeite muss ich zwangsläufig die String Dinge
  nochmal gaaaaaanz genau durchgehen. Dabei vielen mir gleich ein paar Dumme Dinge in der aktuellen Version auf - UND, wie es
  aussieht fand ich sogar unseren bösen Release Crash Bug!!! String::Replace(char nOld, char nNew) -> 'Set pointers to new
  location' war NICHT in Ordnung, denn da bereits nIndex drauf addiert wurde durfte man nicht einfach nochmal zusätzlich
  die String Länge draufzählen um das Ende des Strings zu bekommen... denn nun schoss man über den Speicher heraus und es
  wurde irgendwo herumgeschrieben wo das nicht sein durfte - KEIN Wunder das dies Probleme machte! *g*



>> 22.08.2006
[CO]
Alle Projekte:
- Die Projekte verwenden nun die .lib's in PLSDK/Actual/libs anstatt die aus den build/win32 Verzeichnissen.
PLGeneral:
- Stellte TinyXML von 2.4.3 auf 2.5.0 (Beta) um. Da etwas an der Lib verändert wurde muss diese auf jedenfall noch
  gepackt vorliegen damit man selbst neu übersetzen kann. (tinyxml_2_5_0_changed.zip)



>> 21.08.2006
[CO]
- XmlDocument: GetErrorDesc() so erweitert das standardmäßig auch in den String geschrieben wird 'wo genau' der Fehler
  auftrat - das will man in den meisten Fällen natürlich auch direkt wissen. :)
  Mir viel dabei auf das die Xml-Datei Namen noch nicht den eigentlichen Klassen Namen entsprachen, änderte dies.



>> 17.08.2006
[SB]
- Bei Log::Open() den Paramter für den LogFormater mit dem Standardwert "" versehen, falls man keine Parameter mit angeben möchte
- Log::GetLogFormater() gibt nun kein const-Objekt mehr zurück, da man ansonsten auf die Optionen, die dieses Objekt zur Verfügung stellt,
  gar nicht zugreifen kann. Das Objekt muß also auch veränderlich sein, damit man sich den LogFormater zurückgeben und dann bequem
  dessen Optionen ändern kann
- Einige Kommentare überarbeitet



>> 16.08.2006
[SW]
- Log: XmlLogFormater hinzugefügt.



>> 14.08.2006
[CO]
- String: Überarbeitete die Replace()-Funktion nochmal sorgfältig, z.B. war bereits der 'Count' am Anfang nicht ok. Die nochmals
  etwas erweiterten String Tests konnten nun keine Fehler mehr feststellen. (was allerdings leider nicht bedeutet das nix mehr
  drin wäre ;-)



>> 13.08.2006
[SW]
- HTML LogFormater hinzugefügt: Und im zuge dieses LogFormaters die OpenFunktion des Logs um den Parameter sParameters erweitert.
  mit diesem Parameter ist es nun möglich die LogFormater bezogenen Parameter zu ändern, welche ans RTTI angebunden sind.
  beim HTML LogFormater sind das die Parameter Title(zum setzten des HTML-Titels), Header(dieser Text direkt nach dem <body>-tag geschrieben)
  Background(zum setzen einer Background farbe bzw. bild) und DefaultTextColor(zum setzten der default Farbe für den Text).
- Log::GetLogFormater hinzugefügt. Hiermit ist es möglich sich den aktuellen LogFormater zu hohlen um dann optionen des LogFormater zu ändern.
  (z.b. beim HTML LogFormater kann man darüber die Formatierung der Meldungen für jeden Loglevel seperat angeben).
- Log: die maximale anzahl der Loglevel von 2^32 auf 255 reduziert, da chris und ich glaube das kaum jemand mehr als 255 Loglevel brauchen wird.
- String::Replace: Hier wurden die restliche Zeichen des alten Textes nicht in den neuen String übertragen, nachdem der eigentliche Replace beendet war.



>> 12.08.2006
[CO]
Log Änderungen:
- Bei LogLevel wieder meine Änderungen eingespielt, also wie besprochen das nur mit 'Debug'. Bei der Ausgabe steht dann auch
  nur 'Debug' - wie Stephan auch merkte wird das hier zuviel Text, das einzige was ich noch mehr hier habe ist das bei Debug
  wirklich 'nur' Debug und nicht Debug0 steht. Erst bei 'User Debug' Levels steht dann Debug1 etc. dabei.
- Verschob das Makro wieder nach oben wie Stephan es vorschlug, unterschied macht das keinen. Ich selbst geh die Codes nur
  immer von oben nach unten durch, und wenn dann oben etwas verwendet wird das aber 'rein Code liniear' gesehen erst 'unten'
  definiert wird sieht das für mich immer etwas merkwürdig aus... aber bei Makros iss das ja Funktionsmäßig kein Unterschied...
  und wenn es euch oben besser gefällt schreiben wir das mit den Makros *immer* oben.
- Wie Stefan vorschlug bei PL_LOG wird vor Level PLGeneral::Log:: eingefügt -> passte alle Codes an, viel schlanker so das nun ist :)
- Nahm wie von Stephan vorgeschlagen die Update-Funktionen heraus, fügte nun *aber* wie von mir geschrieben eine Flush Funktion
  hinzu damit ich von PLEngine::SNConsole aus einen Flush ERZWINGEN kann unabhängig vom Flush Log Level das die Konsole natürlich
  *nicht* ändern soll... zusätzlich *MUSS* dort auch noch geprüft werden ob sich die Datei seit dem letzten Check geändert hat,
  sei es durch ein früheres Log Flush oder durch eine Datei änderung des Users. (warum auch immer er eine machte)
  Derzeit ist das OS abhängig Implementierte, aber das überarbeite FS wird dann ja solche Infos ebenfalls bereitstellen so das dies
  dann universell machbar ist.
- ... bei dieser neuen Flush Funktion merkte ich das Log::Write() noch nicht ganz ok war. Denn sobald m_qLastMessages einmal voll war,
  wurde nach jedem Output flush ausgeführt. Darum fügte ich m_nFlushMessages hinzu. Bei jedem Eintrag wird das um eines erhöht, und
  erst wenn m_nBufferedMessages erreicht ist wird dieser Counter zurückgesetzt und ein Flush ausgeführt.
- Fügte nach 'Quiet' noch ein Log Level namens 'Always' ein. In SNConsoleBase::ProcessCommand() *muss* der gerade eingebene
  Befehl *immer* unabhängig vom aktuell Eingestellten Log Level ausgegeben wird, außer natürlich Log Ausgaben sind wieso auch
  immer mal komplett deaktiviert. Darum ist 'Info' hier nicht nutzbar. Wenn jemand da eine andere Idee hat wie man das lösen könnte gebt
  bescheit... so wie das jetzt im Augenblick alles ist läuft auch die PL Konsole wieder so sauber wie vor der Log Umstellung.



>> 08.08.2006
[SB]
- Kleinen Fehler im Log-Makro behoben: __LINE__ ist eine Zahl, daher muß es im printf-Style mit %d
  in den String eingefügt werden, das %s führte natürlich zu einem Crash



>> 07.08.2006
[CO]
Alle Projekte:
- Stellte auf das neue Log System um



>> 06.08.2006
[CO]
- Timer um Funktion GetTimer() erweitert. Hierbei handelt es sich um einen allgemeinen Timer auf den einfach der aktuelle
  Zeitunterschied bei jedem Update addiert wird.



>> 31.07.2006
[CO]
- Array<AType>::Add(const AType Elements[], uint32 nCount): Hier habe ich Vorsichtshalber das memcpy durch Element weise
  Kopieren ersetzt, denn soetwas wie memcpy kann ja leider sehr schnell nach hinten Losgehen vorallem wenn man etwas komplexere
  Klassen direkt nutzt. Es ist zwar noch memset drinnen um auf *ausdrücklichen* User Wunsch neue Elemente zu Initialisieren,
  da wüsste ich allerdings nicht wie man das anderst machen könnte, einfach jedem Element '0' oder so zuweisen geht ja nicht.



>> 28.07.2006
[CO]
- In SystemLinux/SystemWin32 wird im Konstruktur nun auch srand aufgerufen um den Zufallsgenerator zu Initialisieren. Bis
  jetzt stand in PLMath::Math ein Kommentar das man dies selbst über diese Funktion machen muss, und in PLEngine wurde dies
  dann auch gemacht... allerdings sollte man soweit irgend möglich auf OS/Standardfunktionen verzichten um eventuellen
  Inkompatibiläts oder Makro Problemen gleich von anfang an die Luft anzuschnürren.



>> 26.07.2006
[CO]
- Stellte alles auf die neue HashMap um und nahm die alte HashTable Klasse heraus. Beim Umstellen viel mir auf, das wenn
  etwas aus einer HashMap entfernt wurde das Objekt selbst übergeben wurde, und nicht dessen Name. Wann immer möglich sollte
  man Namen/Keys übergeben da diese *sehr* viel schneller gefunden und entfernt werden kann - bei einem Objekt/Zeiger muss
  man erst die GESAMMTE HashMap durchlaufen um den entsprechenden Eintrag zu finden.
- Nahm an ein paar Stellen 'stdio.h' etc. heraus wo man dies nun nicht mehr benötigt. (vor der String Umstellung brauchte man das
  dort wohl noch) Gerade in Headern sollte man es soweit möglich vermeiden solche Header einzubinden um eventuellen Problemen
  die dadurch entstehen können zu vermeiden. (Makros etc.)
  Das ist momentan zwar noch nicht Optimal, zeigt aber wo es hingehen könnte/sollte. So bekommt man dann auch hoffentlich weniger
  Probleme wenn man mal einen Memory Manager/Tracker hinzufügt, denn manche dieser Standard Header überschreiben new etc. was
  dann ziemlich ungünstig ist.



>> 23.07.2006
[CO]
- Fügte wie vor einigen Wochen mit Stefan bereits besprochen String::SetCharacter() hinzu.
  Ersetze in FSTools::ValidatePath() 'sValidPath.Delete(0, 1); sValidPath.Insert(&c, 0, 1);' durch 'sValidPath.SetCharacter(0, c)'.



>> 22.07.2006
[CO]
- FSTools::GetDirectory(): Hier habs noch einen Bug, wenn in einem gegebenen Pfad kein Verzeichniss vorhanden war, wurde der
  gesammte String als Verzeichniss zurückgegeben was aber sicherlich nicht gewollt war. Es wird in dem Fall nun ein leerer 
  String zurückgegeben. Das gleiche in FSTools::GetFirstPath(). Auch musste FSTools::ValidatePath() angepasst werden da GetFirstPath()
  es wie es bereits in der Funktions-Kommentierung stand am Ende ein '/' hat. Der File System Unit Test läuft nun ohne das
  'Fehler' festgestellt werden. (vorher gabs Fehler bei den zip-Tests)
- Stephan fand gestern noch einen Fehler in XmlDocument::SaveFile(), hier wurde FSTools::GetPathPrefix() anstatt FSTools::GetDirectory()
  verwendet um das Verzeichniss herauszufinden in dem sich die Datei befindet. Solche Stellen gabs noch ein paar mal und ich korrigierte
  das überall.
- Überall wo man eine Datei öffnet um einen Tokenizer darauf arbeiten zu lassen wird eine Datei im Binary Modus geöffnet, ansonnsten
  im Text Modus. Diese Stellen waren bereits mit einem [TEST] versehen und Stefan und ich hatten das auch bereits vor einer weile kurz
  besprochen. (Immer Text Modus kann Probleme machen, und häuftig ist/war das leider auch der Fall :(
- Den Fehler in RefCount<AType>::Release() behoben den ich bereits am 16'ten gefunden hatte. Fügte desweiteren zur Vollständigkeit
  == und != für 'Direkte Zeiger' hinzu. Ebenfalls wird nun VOR einer Zeiger zuweisung geprüft ob dies bereits der aktuell gesetzte
  Zeiger ist, machte man diesen Test nicht, konnte es zu einem üblen Crash kommen wenn man einen Reference Counted SmartPointer sich
  selbst zuwies. Die entsprechenden Bast Tests laufen nun sauber & stabil.



>> 21.07.2006
[SW]
- Linux port Änderungen von Christian teilweise angepasst/fehlendes hinzugefügt.



>> 16.07.2006
[CO]
- Xml-Klassen: Diverse Definitionen nun mit groß/kleinschreibung geschrieben. Das ist zum einen Lesbarer, und manchmal sogar
  etwas kürzer da man keine '_' mehr braucht.
- Types.h: Nahm einige mittlerweile total veraltete Definitionen heraus (das meiste wurde auch überhaupt nicht mehr genutzt)



>> 16.06.2006
[SW]
- GetOpts in CmdLineParser umbennant
- CmdLineParser:
  eine Parse-funktion für PLGeneral::Array<PLGeneral::String> hinzugefügt.
  und 2 statische funktionen ( String CmdArrayToString(int argc, char** argv) und
    Array<String> CmdStringToArry(String cmd_str) )
  hinzugefügt.
  Die 1. Funktion Convertiert das char argumenten Array in ein String um
  Die 2. Funktion Convertiert ein String in ein Array<String> um.
- PLMain übergibt nun ein PLGeneral::Array<PLGeneral::String> für die cmd-Parameter



>> 13.07.2006
[CO]
- HashString<AType>::~HashString(): Hier fehlte ein [], die Klasse ist zwar sowieso veraltet und mittlerweile durch HashMap
  ersetzt, aber solange das noch drinnen ist müssen eventuelle Bugs raus :)
- String::GetSubString(): Es wurde Speicher angelegt, korrekt gefüllt und einem String() Konstruktur übergeben, da dieser jedoch
  selbst den String kopiert und nicht den Zeiger übernimmt, hatten wir danach ein Speicherleck. Hab dem String(const char *pszString)
  Konstruktor erstmal einen Optionalen Parameter geben über den man dann festlegen kann das dieser Speicher übernommen, und nicht
  kopiert werden soll... hat Vorteile wenn man das festlegen kann, ist aber auch etwas 'Gefählich'. Läd man z.B. eine Datei ein,
  so kann man den 'Buffer' nun direkt an String übergeben ohne das nochmal kopiert und danach der eingelesene Buffer wieder
  gerstört werden muss. Standardmäßig wird aber immer Kopiert.
- String: Dem StringBuffer muss man nun immer die Länge des Strings übergeben. Da diese IMMER bekannt ist, ist es einfach nicht
  so prall diese vom StringBuffer nochmals ermitteln zu lassen. Zudem ist der Zeiger auf den String innerhalb es StringBuffers
  NIE NULL, sobald es NULL wird, wird auch der StringBuffer nutzlos... Nahm daher auch den StringBuffer Konstruktor ohne
  Parameter heraus. Auf z.B. m_pStringBufffer->GetString() muss man daher NIE prüfen da es NIE NULL sein kann - bis auf eine Stelle
  in der String Klasse wurde das auch nie geprüft. :)
  Machte die interne StringBuffer Implememtation inline und nahm 'Sicherheitsabfragen' wie z.B. pszString == NULL heraus da diese hier
  einfach nur Sinnlos sind, es ist schlichtweg ein ganz übler Fehler der eigentlich NIE passieren dürfte wenn hier mal NULL kommt,
  und wenn das mal der Fall ist, so ist das ein Bug in der eigentlichen String Implementation der behoben werden muss.
- DynLibManager::~DynLibManager(): Hier wurde der Iterator nicht wieder gelöscht
-> Die oberen Bugs fand ich als ich zum Testen mal den Memory Manager von http://www.fluidstudios.com/ im PLGeneral
   Header includierte, der merkte sofort das in der Hash Table der Speicher anderst wieder freigegeben wurde als er erzeugt wurde.
   Auch wurde ein Speicherleck in String::GetSubString() angemeckert - und tatsächlich war was noch was... wir sollten uns
   wohl dranmachen unseren eigenen kleinen Memory Manager/Tracer zu schreiben, denn gerade bei solchen Speicherlecks hilft das
   enorm viel.



>> 29.06.2006
[CO]
- Bitset::Resize(): Das gleiche wie gestern in Array::Resize()



>> 28.06.2006
[CO]
- Array::Resize(): Hier konnte es zu Problemen kommen wenn ein Array intern bereits genug Elemente hatte und nach einem
  'Größe ändern' bereits alle Elemente 'hinzugefügt' sein sollten. Erstaunlich das dies bis jetzt noch nicht aufgefallen war.



>> 26.06.2006
[CO]
- CmdLineParser: 'DEBUG' zu '_DEBUG' gemacht damit das unter VC klappt



>> 17.06.2006
[CO]
- Container: Neue Funktion 'uint32 Add(const AType Elements[], uint32 nCount)'



>> 14.06.2006
[SB]
- Style-Anpassungen an GetOpts vorgenommen. Bitte mehr auf Spaces und Tabs achten
- PLMain arbeitet nun nur noch mit PLGeneral::String



>> 07.06.2006
[SW]
- Neu Klasse GetOpts hinzufgefügt. Mit dieser Klasse läßt sich ähnlich, wie die getopt funktion unter linux, Optionen parsen.
  Die Klasse wertet nur die Optionen aus welche ihr vorher bekannt gegeben worden sind.



>> 05.06.2006
[CO]
- ResourceManager: Neue Funktion: LoadResource(): Create() sollte jeweils NUR eine Resource erzeugen, aber diese nicht auch noch
  eventuell gleich einladen... dafür ist nun die neue Funktion da. Siehe PLMesh Tagebucheintrag von heute für mehr Informationen.



>> 04.06.2006
[CO]
- String: Vor ein paar Tagen hatte ich in der String Klasse StringBuffer aus dem Interface in die Implementation verschoben
  damit das Interface möglichst keine Implementations Details enthält und etwas übersichtlicher ist. Allerdings konnte man nun
  nicht mehr beim Debuggen ohne weiteres 'in den String' schaun was oft sehr hilfreich ist. Machte daher diese Änderung wieder
  zu gunsten des Debugging rückgängig. Fügte auch gleich ein kleines Kommentar hinzu warum das public ist, nicht, das ich in
  ein paar Jahren wieder vergessen habe wieso das public ist und wieder auf die schlaue Idee komme das in die Implementation
  zu verschieben. ;-)
- Map: Neue Funktion: Replace() -> Stephan viel auf das diese Funktion welche recht nützlich ist noch fehlte



>> 30.05.2006
[CO]
- String: Mir viel gerade auf das wir zwar operator =(const char *pszString) hatten zum String kopieren, aber keine Funktion
  wo man nur eine bestimmte Anzahl von Zeichen kopieren konnte. Also fügte ich eine Copy()-Funktion hinzu welche bereits
  im OpenGL Renderer verwendet wird. Ersetzte außerdem 'strcpy' durch 'strncpy' da das erstere mittlerweile 'deprecated' ist
  da keine überprüfung auf Speicherüberlauf. Nahm auch ein paar mehr oder weniger überflüssige 'strlen' heraus.
  Verschob die interne StringBuffer Klasse in die String.cpp Datei damit das Interface etwas aufgeräumter ist.



>> 25.05.2006
[CO]
- Module::GetClasses() die gleichen Parameter wie bei ClassManager::GetClasses() verpasst damit es einheitlich ist.
  Die Codes der Funktionen sind identisch, baute am Anfang noch eine Abfrage ein ob alle Regestrierten Klassen zurückgebenen
  werden sollen, in diesem Fall kann man sich extra Arbeit sparen und einfach die Klassen Liste zurückgeben. In
  PLEngine::GuiDebugScene::UpdateClassList() macht es die Sache mit dem einheitlichen GetClasses() auch etwas einfacher da
  ich mir dort gleich eine Liste mit in Frage kommenden Klassen zurückgeben lassen kann ohne per Hand aussortieren zu müssen.
  (der Grund für diese Änderung :)



>> 23.05.2006
[SW]
- Linux backend zum filesystem auf die Strings umgestellt



>> 22.05.2006
[CO]
Alle Projekte:
- Fand in diversen Projekten noch Stellen wo man z.B. Vector3::ZERO einsetzen konnte anstatt ein neues Temporäres Objekt zu erzeugen.
  Fand auch jede Menge stellen in denen man Werte direkt den Konstruktoren übergeben konnte anstatt diese Werte intern erst
  initialisieren zu lassen um anschließend einen Wert zuzuweisen.
- Ein paar Variablen Namen angepasst wo man z.B. einen Zeiger auf Zeiger hat (also z.B. **ppMyPointer)
PLGeneral:
- String::LastIndexOf(): An ein paar Stellen in den Codes wurde der Rückgabewert in uint32 gespeichert was probleme gab wenn
  nichts gefunden wurde und '-1' daher als Ergebniss kam.
- FileSystem: IsBaseDir() hinzugefügt. Da es bereits auch IsSearchPath() gibt und ich bereits an ein paar Stellen umständlich
  per Hand prüfte ob ein gegebener Pfad ein Basis Verzeichniss ist oder nicht um z.B. diesen Pfad dann gegebenenfalls während
  dem einladen einer Szene Temporär als Basispfad einzusetzen, denk ich diese Funktion hat im FS seine Existensberechtigung. :)
  Machte bei der Gelegenheit gleich ein paar int zu uint32, damit verschwinden ein paar Compiler cast Warnungen an diversen
  Stellen.
- String: + Operator hinzugefügt damit man auch soetwas wie sResult = "A" + sString schreiben kann... wird bereits in
  PLSamplePhysics verwendet da hier recht praktisch.



>> 21.05.2006
[SB]
- Bösen Fehler im String behoben: Beim Duplizieren des StringBuffers hatte sich ein Fehler eingeschlichen, so daß nicht
  wirklich ein neuer Stringbuffer benutzt wurde. Daher wurde also im falschen Buffer geschrieben, so daß sich Strings veränderten,
  die eigentlich vorher kopiert worden waren. Ein weiterer Fehler war auch noch in Replace(char, char), dort wurde der Index
  innerhalb des Strings erst nach dem Kopieren des Buffers berechnet, so daß man hinterher wieder im alten Buffer landete.
- FileSystem auf String umgestellt. Nach dem Beheben des String-Fehlers funktionierte das meiste wieder erstaunlich gut, nur ein
  paar kleine Fehler die bei der Umstellung des FS passiert waren. Da die FS Funktionen aber aus heftigen String-Manipulationen
  bestehen, die nun dank String-Klasse völlig anders implementiert werden mußten als vorher, kann es aber gut sein daß noch weitere
  Fehler auftauchen. Also bitte mal verstärkt auf Probleme mit dem FS achten.
- Einige kleine Umstellungsfehler beseitigt
- String: Replace(char, char) vereinfacht, so daß nur noch eine Schleife benötigt wird. Schleife in Schleife wobei die erste dann
  abgebrochen wird ist unschön und sollte vermieden werden :-)



>> 18.05.2006
[CO]
- Nachdem Stephan beim übersetzen mit gcc bei der Funktion PLPlugins -> PLSceneNodes1 -> SNLightning.cpp -> GenerateLightning()
  eine Warnung bekam da etwas nicht const war und 'pPoint[f]+vDest' einmal als Parameter verwendet wurde was eine Warnung
  verursachte, fügte ich in GeneralWin32.h etwas hinzu so das auch bei uns bei Warnungs Level 3 bei soetwas eine Warnung kommt.
  (die Warnung empfinde ich als sinnig :)



>> 16.05.2006
[SB]
- Resourcen-Klassen auf Strings umgestellt
- Log-Klasse auf Strings umgestellt
- Profiling-Klasse auf ... Na ihr könnts euch wohl denken ;-)
- Einige Style-Anpassungen vorgenommen
- PLBase::FromString() und PLBase::VarChanged() auf String umgestellt und alle Projekte darauf angepaßt



>> 15.05.2006
[SB]
- Nochmal die XML Klassen verändert. Die vorherige Änderung hatte zur Folge, daß in den Klassen mit einem public Konstruktor
  erstmal eine interne Node erzeugt wurde, und dann wieder überschrieben wurde (Speicherleck). Leider fällt mit keine sinnvolle
  Lösung ein, denn auch eine statische Methode müßte ja intern einen Konstruktor aufrufen, gleiches Problem also.
  Habe daher den internen Konstruktor wie vorher wieder eingebaut, nur statt (void*) nimmt er nun (void*, int).
  Das ganze ist nur nötig, weil ansonsten ein Aufruf von z.B. XmlText("Bla") einen Compilerfehler wegen Aufruf eines privaten
  Konstruktors auslöst (void* passt "besser" als String, daher wird das genommen). Darum also nun der zusätzliche Parameter int,
  der wird zwar nicht verwendet, verhindert aber diesen Fehler.



>> 14.05.2006
[CO]
- Container/Functions.cpp hinzugefügt in dem die Implementation für die String Funktionen liegen. Sobald man die String Klasse
  nutzt muss man PLGeneral einbinden, aber nutzt man 'nur' die Container Templates ohne String Klasse, so braucht man PLGeneral
  nicht einzubinden - praktisch für z.B. Max Exporter damit man nicht für alles diese grässlichen stl Klassen nutzen muss. :)



>> 14.05.2006
[SW]
- POD-warnungen gefixed



>> 14.05.2006
[SB]
- RTTI Funktionen größtenteils auf Strings umgestellt. Dies bringt ein paar Probleme mit sich, denn da die RTTI Funktionen nun natürlich
  auch Strings zurückgeben, ist es nicht mehr so einfach möglich, festzustellen ob ein Fehler aufgetreten ist. Zumeist ist "" als
  Rückgabe zwar ein Anzeichen für einen Fehler, jedoch könnte natürlich auch der leere String eine gültige Variable sein.
  Anders herum ist es auch problematisch, denn wenn eine Variable auf "" gesetzt werden soll, wird jetzt vermutlich der Standardwert
  gesetzt - bei Strings kann jedoch wirklich "" gemeint gewesen sein. Dieses Problem bestand allerdings vorher auch schon, von daher
  sollte es erstmal keine größeren Probleme geben, nach den ganzen Umstellungen überlege ich mir genau, wie wir das mit den Standardwerten
  künftig machen wollen.
- Base besitzt nun keine Funktionen mehr, um die Variablen aufzuzählen oder an ein Var* zu kommen. Dafür muß dann halt
  GetClass()->GetVar() geschrieben werden (intern passierte ja sowieso nichts anderes). 
- GetVarTypeAsString() in GetVarType() umbenannt - die Funktion heißt nun als in "beiden Richtungen" gleich
- Config: m_szVariableValue entfernt. Sollte einmal der Fall eintreten, daß aus zwei Threads auf das gleiche Config-Objekt zugegriffen wird,
  würde das böse schiefgehen. Wir müssen daher in Zukunft darauf achten, daß alles Thread-Safe ist
- Tools: CombineStrings() entfernt. Diese Funktion ist äußerst unschön und wurde sowieso nur an einer Stelle verwendet, wo sie überhaupt
  nicht notwendig war. Die anderen String-Funktionen teilweise umbenannt, damit besser zu verstehen ist was die machen.
- Da die XML Klassen leider noch keine Strings verwenden, war es an einigen Stellen nötig, so etwas wie String(pszString).GetBool() zu schreiben.
  Damit diese Stellen hoffentlich später nicht vergessen werden, habe ich mich bemüht diese immer mit einem [TODO] zu markieren. 
- Es sind immer noch an viel zu vielen Stellen Konvertierfunktionen für Strings vorhanden, teilweise in dreifacher Ausführung und jedesmal
  leicht anders implementiert :-( Habe daher angefangen die zu vereinheitlichen, das werde ich aber in den kommenden Tagen erst richtig angehen.
- XML Klassen auf Strings umgestellt  



>> 13.05.2006
[CO]
- Erweiterte HashMap & SimpleMap um eine Vergleichs-Funktion. Da die definierbaren Funktionen recht universell sind, packte ich
  diese in eine gemeinsame Datei Namens 'Functions.h' welche im Container Ordner liegt.



>> 12.05.2006
[CO]
- Fand einen Bug in HashMap::CSlotsList::Add() -> Falls dies nicht das erste Element dieses Slots ist, so wurde der Next 
  Zeiger nicht Initialiert.



>> 11.05.2006
[SB]
- Class Groups wurden entfernt, da diese künstliche Definition von Gruppen so keinen Sinn mehr ergab.
  Da die Gruppen sowieso mit den Ableitungen von einer Basisklasse übereinstimmen, ist es sinnvoller gleich
  nach Basisklassen zu suchen. Nur das Aufzählen von Gruppen ist jetzt nicht mehr möglich, wird aber auch
  nicht wirklich gebraucht. Das Interface von ClassManager wurde daher so angepaßt, daß man sich entweder alle
  abgeleiteten Klassen einer Basisklasse direkt zurückgeben lassen kann, oder nur die direkt abgeleiteten.
  Einige Klassen wurden außerdem auf Strings umgestellt.



>> 09.05.2006
[SB]
- Externe Libraries wurden nach "external" verschoben und dort entpackt, damit das Projekt direkt übersetzt werden kann
  und keine Archive mehr entpackt werden müssen. Evtl. Sourcen können innerhalb der Lib-Verzeichnisse abgelegt werden,
  aber auch nur wenn diese wirklich benötigt werden, weil z.B. für PL etwas verändert werden mußte.
  Die Projekte wurden entsprechend angepaßt.



>> 26.04.2006
[CO]
- XML Klassen: Ein paar Leerzeichen & Tabs verbessert
- FileSystem: RemoveBaseDir(): Der übergebene Pfad muss zuerst 'korrigiert' werden so das dieser auf jedenfall mit dem
  intern gespeicherten Pfad übereinstimmt.



>> 22.04.2006
[CO]
- Stefan und ich besprachen gestern das Iterator Problem und entschieden das es das beste ist, zusätzlich in den Container
  Klassen neben GetIterator() noch GetEndIterator() anzubieten welches 'hinten' im Container startet. HasNext() gibt
  also 'false' zurück und HasPrevious() 'true'. Die Änderung in den Klassen war nicht wirklich aufwändig. Passte gleich die
  Stellen in allen Projekten an wo man einen Iterator für einen Rückwärtsdurchlauf verwendet.
- XmlDocument::LoadFile(): Hier gabs gleich zwei kleinere Problemchen. Man muss die Datei im Binärmodus öffnen damit TinyXML
  End Of Line (EOF) behandeln kann, und zum anderen fehlte ganz am Ende '\0'. Nun funktioniert im XML Test das Parsen von
  'demotest.xml' korrekt. In der neuen TinyXML Version wurde hier etwas geändert, darum konnte es nun Probleme geben.



>> 21.04.2006
[CO]
- HashMapIterator Konstruktor: Sind keine Elemente in der Map, so wird der Konstruktor nun sofort wieder verlassen da man
  ja bereits weis wie die Suche nach dem ersten Map Element ausgehen wird. Ist NUR ein Element drinnen ist es allerdings
  etwas Problematisch. Hab das nun erstmal so gemacht das man ein nächstes aber kein Vorheriges Element zurückbekommt. Hier
  muss man sich wirklich überlegen wie man diesen Sonderfall behandeln will, denn HasPrevious() gibt hier nun momentan immer
  false zurück. Dieses Problem gibts in jeder Iterator Implementation.
- Bei der Gelegenheit schaute ich gleich nochmal die Container Klassen durch und entfernte überflüssige Tabs & Leerzeichen



>> 20.04.2006
[CO]
- Container Klassen um Copy-Konstuktoren für den eigenen Typ erweitert



>> 17.04.2006
[CO]
- Stellte auf TinyXML 2.4.3 um. Anscheinend wurde intern etwas an den Strings geändert, wird hier nun NULL übergeben gibts
  einfach einen Crash. Daher musste nun in
    XmlDeclaration::XmlDeclaration(const char *pszVersion, const char *pszEncoding, const char *pszStandalone)
  eine Sicherheitsabfrage rein.



>> 08.04.2006
[CO]
- Pool & FastPool: FreeElements(): Hatte vergessen den Fall zu berücksichtigen wenn gerade überhaupt keine Elemente vorhanden 
  sind...
- Bitset: Machte einige Funktionen inline



>> 05.04.2006
[CO]
- Pool & FastPool: FreeElements(): Die alte Implementation war viiieeel zu umständlich. Man muss einfach nur die gesammte 
  Liste gerade verwendeter Elemente in die Liste der freien Liste 'anhängen'... das macht Pool & FastPool dort wo man sehr 
  häufig Elemente einfügt, löscht und alles komplett zurücksetzt extrem Performant. :)



>> 28.03.2006
[SB]
- Base::GetClassName(): return false bei "const char *" ... ? in return NULL geändert :-)



>> 22.03.2006
[CO]
- Base::GetClassName(): Sicherheitsabfrage ob Klasse vorhanden ist eingebaut



>> 12.03.2006
[SW]
- Fehler in PLGeneral/Main.h behoben, explizites angeben des Namespaces für String da nicht immer
  sicher ist, das "using namespace PLGeneral;" vorher "verwendet" wurde wenn dieser Header includiert wird.
- Fehlerausgabe unter linux hinzugefügt, wenn das laden einer LIB fehlschlug.



>> 27.02.2006
[SW]
- SemaphoreLinux.cpp: Der Check für den Maximalen wert des Semaphore eingebaut.
- TheadLinux.cpp: Der Execution Mutex (Er wird verwendet um Join(Timeout) zu implementieren ) wird
  in Terminate() und in Join(Timeout) explizit unlocked.
  In Terminate() wird er unlocked weil der Thread hier nichtmehr dazu kommt den Mutex selbst freizugeben.
  Wenn in Join(Timeout) der Mutex->Lock(Timeout) erfolgreich war, so muss der Mutex dort auch unlocked werden,
  da sonst beim nächsten start des selben Thread-objectes der Thread nicht im versuch des "Locken" des Execution-Mutex
  blocked.



>> 27.02.2006
[SB]
- Ebenfalls noch einige kleine Style-Dinge hochgeladen. Das mit den Tabs und Freizeichen ist manchmal Geschmacksache,
  vor allem wenn man Variablen untereinander anordnen will etc. Am Anfang einer Zeile sollte jedoch immer Tab verwendet
  werden. Ebenfalls sollte darauf geachtet werden, daß Freizeilen auch wirklich frei sind, sprich keine Leerzeichen oder
  Tabs darin enthalten sind
- Einige kleine Änderungen im Linux Port:
  - MutexLinux: Habe den pthread mutex von einem Pointer in eine direkte Variable verwandelt, da bei allen Beispielen
    die ich gefunden habe keine Pointer verwendet wurden, sondern die Struktur direkt. Die Variable heißt nun entsprechend
    m_sMutex, da es sich um eine Struktur handelt. Das mit dem Pointer war natürlich auch in Ordnung, allerdings scheint
    man sich das dynamische Erstellen hier sparen zu können, es ist also nicht notwendig (deswegen aber nicht falsch).
    In dem Falle hätte allerdings nach pthread_mutex_destroy() noch das Objekt selber per delete gelöscht werden müssen,
    da die Funktion dies allem anschein nach nicht tut (wie sollte sie auch unterscheiden, ob das Objekt dynamisch erzeugt
    worden ist oder nicht). Und es ist nicht notwendig, beim Portieren die gleichen Namen zu verwenden wie im Win32 Port -
    dort handelt es sich ja um ein Mutex-Handle, welches man vom System zurückbekommt, daher m_hMutex, handelt es sich aber
    dann beim Linux Port um einen Pointer, so sollte auch der Name in m_pMutex oder wie jetzt für eine Struktur m_sMutex
    verändert werden.
  - Die System-Ports sollten möglichst die Terminologie der entsprechenden System übernehmen, damit sich ein Windowsprogrammierer
    z.B. im Windows-Port gleich zurechtfindet und ein Linux-Programmierer im Linux Port. Daher sollten die Datentypen entsprechend
    angepaßt werden und nicht per Definitionen vereinheitlicht werden - dies ist ja auch nicht mehr nötig, denn es handelt sich
    ja gerade um systemspezifische Klassen, welche nur im entsprechenden System funktionieren müssen. Das unabhängige Interface
    wird ja von den Klassen System, Thread, Mutex etc. bereitgestellt und benutzt die Impl-Klassen als Backend. Daher besteht
    also in den Backends selber keine Notwendigkeit mehr, irgendwelche Datentypen umzudefinieren oder zu vereinheitlichen :-)
  - DynLibLinux: Habe daher HANDLE m_hModule in void *m_pLib umbenannt
  - ThreadLinux: Variable in m_nThreadID umbenannt
  - ThreadLinux: In RunThread lpParameter in pParameter umbenannt. lp ist wieder nur für Windows und den dortigen Datentypen LPVOID üblich
  - ThreadLinux: In RunThread ppThread in pThread umbenannt. pp deutet auf einen zweifachen Pointer hin, es ist jedoch ein direkter Pointer
  - ThreadLinux: m_pMutex wurde nicht in jedem Fall initialisiert, jedoch später benutzt. Nun wird es immer mit NULL initialisiert
  - Die neuen Member-Variablen wurden dokumentiert
  - Variablen sollten immer im kleinst möglichen Kontext deklariert werden, also am besten beim ersten Benutzen und dann gleich
    initialisieren. Wenn es anders geht also möglichst nicht am Anfang einer Methode die Variablen deklarieren und dann erst
    später benutzen
  - Bitte Debug-Code immer mit [DEBUG] kennzeichnen
  - In den Kommentaren "Windows" durch "Linux" ersetzt :-)
- Der Linux Port ist wirklich schon sehr gelungen, ist einfach toll wie übersichtlich das jetzt schon geworden ist :-)
  Hier noch ein Paar Anmerkungen bzw. Dinge die noch getan werden müssen:
  - ThreadLinux: Die Verwendung von m_pMutex muß noch etwas überarbeitet werden. Beim Join beispielsweise muß wohl nicht mehr Unlock()
    aufgerufen werden, dann wenn der Mutex noch gelocked wäre dürfte pthread_join gar nicht zurückgeben. Außerdem ist das Löschen
    des Mutexes an vielen Stellen nicht ok, denn dann geht der Aufruf beim nächsten Starten des Threads schief, da der Mutex nicht
    mehr da ist. Eigentlich müßte es reichen den Mutex nur im destruktor wieder zu löschen, beim Abbrechen des Threads etc. muß nur
    darauf geachtet werden, daß korrekt Unlock() aufgerufen wird.
  - SemaphoreLinux: Hier fehlt noch die Behandlung des Max-Values. Bitte mal schauen ob Linux das bietet, wenn nicht ist die Frage
    ob wir das selber einbauen, oder ob dieses Feature unter Linux halt nicht zur Verfügung steht. Falls wir das selber machen
    sollte dies vielleicht besser in Semaphore geschehen und damit einheitlich für alle Systeme. Blöd ist es natürlich wenn eine
    Semaphore auch von anderen Prozessen verwendet wird, aber in dem Fall würde auch jetzt schon das Mitzählen des aktuellen Wertes
    schiefgehen, und solange es dafür keine Systemfunktionen gibt ist das Problem wohl auch nicht zu lösen



>> 27.02.2006
[CO]
- Linux Dateien dem VC Projekt hinzugefügt (werden jedoch vom Build ausgeschlossen)
- Machte beim Linux hier und da ein paar kleine Style Änderungen damit alles wie aus einem Stück aussieht... die Linux 
  Implementation ist sehr viel übersichtlicher als vor dem PLGeneral umbaun - gute Arbeit Stephan. :)
- Mir ist aufgefallen das an einigen Stellen wo z.B. als Abtrennung von Funktions Sammlungen bei z.B. 
    //[-------------------------------------------------------]
    //[ Public virtual ThreadFunction functions               ]
    //[-------------------------------------------------------]
  oft keine zwei Leerzeilen waren - bis jetzt hatten wir es hier immer so gemacht das wir hier zwei Leerzeilen hatten um 
  die Funktions Blöcke schöner zu trennen so das man schon beim Überfliegen der Codes sehr schnell erkennt was zusammen 
  gehört. Ist natürlich wieder so eine Geschmacksfrage - ich persöhnlich finds so aber einfach übersichtlicher.
  Das ist natürlich wieder so ein mehr oder weniger Sinnfreies 'kleinmist' Zeug... allerdings erleichtert ein durchgängig 
  Einheitlicher Code Style enorm die Arbeit wenn man sich dafür Entscheidet eine Style Änderung vorzunehmen wie wir es in 
  der Vergangenheit ja schon recht oft gemacht hatten. :)
- An ein paar Stellen '/*<' durch '/**<' ersetzt... wenn ich solche Dinge per zufall finde, so ändere ich diese immer 
  gleich so das es nicht noch mehr Stellen werden... man arbeitet ja oft mit Copy'n'Past oder schaut nach wie es woanderst 
  geschrieben wurde. ;-)



>> 26.02.2006
[SW]
- Linuxport auf die Klassen-Umstellung angepasst
- In der Thread-klasse die Funktion Stop in Terminate umbenannt, da die Bezeichnung Stop in meinen Augen nicht 
  "Kill den thread" sondern "Sende thread ein signal damit er sich beendet" bedeutet.



>> 25.02.2006
[SB]
- Haupt-Header von 'General.h' in 'PLGeneral.h' umbenannt
- Projekte an Änderungen angepaßt



>> 23.02.2006
[SB]
- Habe mit der kompletten Umstrukturierung von PLGeneral begonnen. Das Projekt teilt sich ab jetzt in 3 Teile: Base, System und Core.
  In Base kommen alle Basisklassen und Datentypen, welche die Basis von PLGeneral bilden, also sprich Base, String, die Container, XML, Graphics etc.
  In System befinden sich die Klassen welche welche eine Abstraktion des Systems darstellen, also die frühere Platform Klasse, Filesystem, Threading, Libraries, Timing usw.
  In Core letztlich kommt dann das Application-Framework, welche PLGeneral zur Verfügung stellt. Das ist insbesondere das RTTI mit allen dazugehörigen Klassen, also
  Klassen, Module, Config etc. Das wird dann nach und nach ausgebaut, so daß ein richtig schönes Framework entsteht. Die Trennung von System und Core ist wichtig,
  denn dies sind zwei völlig unterschiedliche Dinge, es war daher nicht schön daß diese vorher zusammen waren.
- Die Platform-Klasse wurde entfernt, da diese nicht gut gelungen war. Dafür befinden sich in System nun alle systemabhängigen Klassen, jeweils mit einer
  Implementierung für das jeweilige System. Die Win32 Implementierung ist jeweils schon dabei, die Linux-Implementierung könnte Stephan nachtragen :-)
  Das meiste kann aus der alten Platform-Klasse kopiert werden, es hat sich inhaltlich nicht viel verändert, nur das Interface ist schöner geworden.
- Die System-Klassen benutzen nun ein Backend-System, es gibt also jeweils eine System-unabhängige Klasse als Interface, und eine Implementierungsklasse mit Ableitungen
  für jedes System. Das Interface besitzt dann einen Pointer auf die Implementierungsklasse. Das ist zunächst komplizierter, hat jedoch den Vorteil daß das Interface
  und die Implementierung komplett voneinander getrennt sind, damit entsteht nicht wieder so ein Chaos wie in der alten Platform-Klasse.
- Habe den Threads und der Synchronisation ein vernünftiges OOP System spendiert. Die Thread und Synchronisations Funktionen befinden sich in Threading, es gibt einen
  ThreadManager der die aktuellen Threads auflisten kann etc, für die Threads selber gibt es eine Klasse Thread, Mutex und Semaphore sind ebenfalls eigene Klassen.
  Damit ist dies nun endlich auch vernünftig objektorientiert, wie es sich für C++ gehört.
  Das schreiben eines Threads geht nun auf verschiedene Arten, bevorzugt aber so: Eine Klasse MyThread wird von Thread abgeleitet und ihre Run() Methode überschrieben.
  Mit new MyThread und pMyThread->Start() kann der Thread dann gestartet werden. Auf diese Weise hat der Thread ein Objekt zur Verfügung und muß nicht mehr über void*
  Pointer umständlich Daten übergeben bekommen. Bitte in Zukunft darauf achten auch bei neuen Funktionen gleich vernünftig objektorientiert zu arbeiten, und nicht plötzlich
  in unserem kompletten OOP Framework altbackene prozedurale Methoden zu verwenden. Auch ist es nicht gut das Win32 Interface inklusive der gesamten Kommentierung
  einfach zu kopieren, denn erstens legt man sich damit auf das oftmals merkwürdige Windows Interface fest, und zweitens hat Microsoft sicherlich ein Copyright auf seine
  Hilfetexte :-) Also wenn neue Funktionalität eingebaut wird bitte auch die Mühe machen das vernünftig zu designen, so daß es schön ins System passt.
- Beim Umbauen der Threads bitte wenn möglich von Thread ableiten, oder zumindest von ThreadFunction. Ich habe lange überlegt, ob ich die Möglichkeit eines Function-Pointers
  überhaupt noch anbieten will, habe mich dann dafür entschieden. Das heißt jedoch nicht, daß das nun überall einfach weiter verwendet werden sollte, da es am einfachsten
  ist das so umzubauen. Die OOP Methode ist viel flexibler und besser, der Funktionspointer sollte nur in Ausnahmefällen verwendet werden.
- Die System-Klasse wurde um ein paar nette Funktionen erweitert, so kann man nun z.B. den Computernamen und den Usernamen abfragen. Ebenfalls soll hierüber eine
  Versionsverwaltung implementiert werden, so daß z.B. Plugin-DLLs schnell feststellen können, wenn sie mit einer inkompatiblen PLGeneral.dll arbeiten. Auch dient dies
  natürlich den Log-Ausgaben. Das muß jedoch noch vernünftig implementiert werden.
- Die Methode GetCPUMhz() aus der Tools-Klasse wurde ebenfalls nach System verschoben.



>> 20.02.2006
[CO]
- Array, Bitset: RemoveAtIndex(): Fand und behob einen bööösen uint32 Umstell-Bug... war ja klar das so eine Umstellung 
  diese Viecher anlockt ;-)
  Resize(): Auch hier gabs noch einen heftigen Bug - wow, das ich das bis jetzt übersehen hatte, hm, die Container Tests 
  sind wohl noch nicht genau genug... :)



>> 12.02.2006
[SW]
Alle Projekte: Subversion:
- habe das property svn:eol-style für die neuen Dateien gesetzt.
    um dies automatisch zu machen sollten folgende optionen in der config-datei 
    von subversion vorgenommen werden:
    [miscellany]
    enable-auto-props = yes
    
    [auto-props]
    *.c = svn:eol-style=native
    *.cpp = svn:eol-style=native
    *.h = svn:eol-style=native
    *.inl = svn:eol-style=native
    *.dsp = svn:eol-style=CRLF
    *.dsw = svn:eol-style=CRLF
    *.sln = svn:eol-style=CRLF
    *.vcproj = svn:eol-style=CRLF
    *.sh = svn:eol-style=native;svn:executable
    *.py = svn:eol-style=native
    *.txt = svn:eol-style=native
    SCons* = svn:eol-style=native
    Makefile = svn:eol-style=native
    
    damit sollte jede datei die passende eol-kennung(bis auf die vc-projekt-dateien immer die kennung, welche vom OS verwendet wird)
    beim auschecken haben.
PLGeneral:
- Stellte die linux-thread-functionen auf pthread um.



>> 10.02.2006
[CO]
- Wie mit Stefan vorhin im Chat besprochen änderte ich die Stack & Queue Klassen etwas so das Pop nun NICHT mehr das 
  entfernte Element zurückgibt da dies ziemlich Problematisch war. Stattdessen sollte man sich das Element nun über 
  GetTop()/GetBottom() zurückgeben lassen und danach Pop() aufrufen - oder Pop() einen Zeiger übergeben der das Element 
  bekommen soll. (falls man nicht immer zwei Funktionen aufrufen möchte :)



>> 09.02.2006
[CO]
- Binominal Heap Iterator implementiert, vorwärts ging ja noch, aber rückwärts war etwas fies zu Implementieren. Da in 
  diesem Heap nur der Nachfolger, aber nicht der Vorgänger bekannt ist, ist das rückwärts durchlaufen auch nicht wirklich 
  gut von der Laufzeit her. Dort habe keinen Vorgänger Zeiger eingebaut da er hier unnötig ist und 'nur' die Iterator 
  Implementation für rückwärts durchlauf vereinfachen würde - da aber Iteratoren keine gängige Operation auf Heaps sind, 
  entschied ich mich dagegen hier im Binominal Heap pro Eintrag noch mehr Speicher zu verschwenden.
- Neue Heap Implementation: FibonacciHeap: Hat gewisse Ähnlichkeiten zum Binominal Heap, jedoch geht u.a. das einfügen 
  neuer Elemente superflott... dafür ist das entfernen von Elementen etwas Aufwändiger da hier dann auch gleich etwas 
  aufgeräumt werden muss. Ohne diese Funktion läuft es zwar auch korrekt, aber dann hat man im Prinzip nur eine 
  doppelt verkettete List und diese Struktur wird Witzlos. :)
  Wir haben nun drei gängige Heap Implementationen - das sollte fürs erste reichen.



>> 09.02.2006
[SB]
- Singleton hat nun wieder einen Destruction Guard, da die Benutzung des SmartPtr hier nicht möglich war.
  Aufgrund des static initialization order problems kann es vorkommen, daß der statische SmartPtr später initialisiert wird,
  als der Singleton. Beim Aufruf von GetInstance() wird also die Instanz erzeugt und im SmartPtr gespeichert, danach wird
  dann aber erst der SmartPtr initialisiert und somit der Zeiger wieder auf NULL zurückgesetzt, so daß beim nächsten Aufruf
  von GetInstance() eine zweite Instanz erzeugt wird und die erste natürlich auch niemals mehr gelöscht wird.
  Die statische Instanz welche das Löschen des Singletons überwacht darf also keine Daten haben, die initialisiert werden
  müssen, daher muß hier doch wieder der speziell darauf abgestimmte Destruction Guard verwendet werden
- Der Destruction Guard besitzt nun eine leere inline Methode, welche innerhalb des Singleton einmal aufgerufen wird.
  Dies ist notwendig, damit der Compiler die statische Instanz erzeugt, ansonsten scheint diese in einer template-klasse
  wegoptimiert zu werden, wenn nicht einmal darauf zugegriffen wird. Die Methode macht also nichts ist aber notwendig,
  damit der Compiler richtig arbeitet. Interessant ist, daß dieses Problem nur bei Template Klassen auftrifft, bei Nicht-Templates
  funktioniert das mit der statischen Instanz auch ohne solche einen Trick
- Im Singleton werden nun auch die Zuweisung und der Copy-Constructor deklariert, um ein Kopieren des Objektes und damit
  die Umgehung des Singletons zu verhindern
- Die unschöne Methode CheckInstance() wurde entfernt, statt dessen wird über ein Destroy-Flag überprüft, ob das Objekt
  bereits gelöscht wurde. Damit wird während der Deinitialisierung das Objekt nicht noch einmal neu erzeugt, nachdem es bereits
  gelöscht worden ist.
  Generell sollte man während der Deinitialisierung keine Singletons mehr verwenden, da diese schon gelöscht worden sein
  könnten - static DE-initialization order problem ;-) Also sollte z.B. in einem Destruktor eines Singletons nicht mehr auf andere
  Singletons zugegriffen werden. Sollte man es doch einmal tun muß auf jeden Fall der Rückgabewert von GetInstance() auf NULL
  überprüft werden, da dies nun zurückgegeben wird, falls die Instanz bereits gelöscht wurde
- Singleton generell noch etwas überarbeitet



>> 08.02.2006
[CO]
- Heap Interface um GetTop() und ExtractTop() erweitert um das 'oberste' Element anzufragen bzw. zu entfernen
- Neue Heap Implementation: BinominalHeap: Nachdem ich erstmal die Theorie soweit kapiert hatte war die Implementation 
  nicht soo schwer wie ich anfangs dachte, eigentlich sind nur CTree::Union() und ExtractTop() etwas kompliziert gewesen - 
  der Rest war 'trivial'. ;-)
  Die entsprechende Iterator Klasse muss ich noch Implementieren...



>> 07.02.2006
[CO]
- Für Heaps (Priority Queue) gibts nun wieder wie früher ein eigenes allgemeines Heap Interface da Heaps einfach etwas 
  anderes sind als Maps. (das erkannte ich erst wieder als ich mich wieder genauer mit den Datenstrukturen befasste :)
  Wie auch bei Container & Map hab ich Support für Iteratoren Implementiert. Dies ist zwar genauso wie bei Map eher 
  unüblich bei dieser Datenstruktur, jedoch ist das ein nettes Feature. In welcher Ordnung die Elemente beim Iterator 
  zurückgegeben werden kann man wie bei Map nicht wirklich vorausgesagen - man weis nur das das ERSTE Element jeweils das 
  größte/kleinste aller Elemente ist - je nach verwendeter Compare-Funktion.
- Binary Heap an neues Heap Interface angepasst
- Nam den Sicherheits-Test innerhalb einiger Container Iteratoren der prüfte ob der Container Zeiger gültig ist heraus 
  da total überflüssig - dieser Zeiger MUSS immer gültig sein, ansonnsten läuft gerade etwas total schief... ;-)
- Einige Container Iterator Implementationen waren noch nicht ganz korrekt.



>> 06.02.2006
[SB]
- PLGeneral_Rewrite Branch entfernt. Die Änderungen wurden größtenteils in den main Branch übertragen, der Rest muß sowieso
  noch einmal komplett überarbeitet werden, was dann direkt in den aktuellen Sourcen geschieht.
- Kleine Fehler in RefCountPtr und SmartPtr entfernt. Diese Klassen werde ich wohl nochmal gründlich durchgehen müssen, da der
  Compiler ja leider nur die Teile compiliert die auch wirklich benötigt werden. Und diese Klassen sind schon etwas kompliziert,
  da sie einige template Tricks verwenden :-)
- Singleton: DestructionGuard entfernt. Statt dessen wird der Zeiger nun in einem SmartPtr gespeichert, dieser löscht genauso wie
  vorher der Guard das Objekt wenn er selbst gelöscht wird (also am Ende des Programmes, da es sich um eine statische Instanz handelt).
  Diese statische Instanz wird auch korrekt initialisiert, was wohl daran liegt daß sie nicht selbst zum Template gehört - dies ist wohl
  ein Fehler der Sprache, daß dies nicht korrekt funktioniert.
  Singleton ist nun von RefCount abgeleitet, damit der SmartPtr vernünftig die Referenz halten und löschen kann. Die Ableitung ist
  jedoch private, da ansonsten jeder den RefCount erhöhen oder verringern könnte, und somit das Singleton ad absurdum führen würde.
  Damit der SmartPointer dennoch den RefCount nutzen und die Instanz löschen kann, mußte er als friend deklariert werden.
  Falls es Probleme mit dieser Lösung gibt, bitte Bescheid sagen, denn dies ist schon einigermaßen kompliziert - und bei den
  Templates noch durchzuschauen fällt hier schon etwas schwer :-)



>> 06.02.2006
[CO]
- Bitset: Die Anzahl der benötigten Integers wurde noch nicht immer korrekt berechnet + verbesserte das Initialisieren 
  der Bits. Container::GetSize() Kommentar etwas erweitert damit wirklich klar ist WAS hier zurückgebenen wird.
  (Kommentar also bitte nicht löschen :)
- Tokenizer: Da momentan + und - als einzelnde Zeichen betrachtet werden funktioniert ParseNumber() nicht korrekt - 
  negative Zahlen werden nicht mehr korrekt gesetzt. Entweder müsste man bei ParseNumber() nun nach Vorzeichen ausschau 
  halten oder wir behandeln diese Zeichen nicht als einzelnde Zeichen. (hab das erstmal auskommentiert damit alles sauber 
  läuft)
- FastPool: FastPoolElement: Virtuellen Destruktor etc. hinzugefügt damit alles sauber über die Bühne läuft



>> 05.02.2006
[SB]
- String: Konstruktor mit Printf-Funktionalität wurde entfernt, da dies nicht bei jedem String erwünscht ist.
  So war es unmöglich, einen normalen String der ein Prozentzeichen (%) enthält zu speichern. Statt dessen
  gibt es nun die statische Funktion Format, die einen formartierten String mit Printf syntax erstellt und einen
  String zurückgibt (named constructor).
- Tokenizer:
  - Fehler in ParseEquation(String, int&) entfernt - hier fehlte die Referenz, das Ergebnis wurde also nicht zurückgegeben
  - SingleChars zu {}()[]<>+.*/=,;" verändert. Damit dürfte die übliche Syntax von C Programmen besser abgedeckt werden
- Auf String::Format() umgestellt



>> 04.02.2006
[SB]
- String:
  - IsFixedNumeric() in IsNumeric() umbenannt. Man muß hier im Hinterkopf behalten, daß es um Eigenschaften der Zeichenkette geht (nicht um den Inhalt!),
     und das umfaßt z.B., ob diese nur aus alphabetischen Zeichen besteht, nur aus numerischen oder aus alpha-numerischen Zeichen. Diese Begriffe sind
     allgemein bekannt und daher sollten diese Funktionen nun sehr verständlich und eindeutig sein. An solchen Stellen sollte drauf geachtet werden, daß keine
     eigenen Begriffe erfunden werden, da dies außenstehende nicht verstehen würden, noch dazu wenn z.B. Fixed noch eine ganz andere Bedeutung hat
     (Fixkomma Zahl), das verwirrt die User dann noch einmal unnötig, in diesem Fall also lieber gleich nach allgemein bekannten Begriffen suchen, wenn es
     einem einmal nicht einfällt :-)
  - IsFloatingPointNumeric() entfernt. Diese Funktion gehört nicht in den String, da es sich nicht mehr um die Eigenschaft einer Zeichenkette handelt. Aus was
    für Zeichen eine Zeichenkette besteht kann direkt als Eigenschaft dieser Zeichenkette gesehen werden, dafür die Funktionen IsAlphaNumeric() etc.
    Hier jedoch geht es eigentlich schon um den Inhalt, und dafür sollte ein Parser zuständig sein. Abgesehen davon sollte so eine Funktion dann auch gleich
    ein anerkanntes Floating-Point Format erkennen, die sehen dann etwas komplizierter aus (123.4567E10 (f/d) o.ä.) Dafür gibt es aber genug Definitionen, die
    man dann benutzen kann. Im Moment bleiben wir beim alten Verfahren, da wir nicht alles auf einmal machen können, später werden dann solche Dinge gleich
    korrekt geparsed z.B. mittels regulärer Ausdrücke.
  - Einige Kommentare angepaßt
  - Bei einigen Funktionen const hinzugefügt
- Profiling:
  - Kleine Änderungen im Coding Style



>> 04.02.2006
[CO]
- Profiling: SelectNextGroup() & SelectPreviousGroup() behob kleine uint32 umstell Fehler
- String:
  - Compare Funktionen wie besprochen um Start Position Parameter erweitert, in der Implementation werden ein paar 
    Sonderfälle berücksichtigt in denen man auf einen Schlag weis ob die Strings gleich sind oder nicht - gerade beim 
    Vergleichen längerer Strings wird das enorm Speed bringen.
  - IsSubString() wie besprochen geändert und neue Funktionen IndexOf() & LastIndexOf() hinzugefügt.
  - IsCharacter() entfernt da mittlerweile überflüssig... IsCharacter() das kann man nun auch selbst per Hand in zwei 
    Schritten machen. (z.B. sToken.GetLength() == 1 && sExpected.IsSubString(sToken))
  - < und > Operatoren hinzugefügt um Strings Lexikographisch vergleichen zu können (für sortieren wichtig)
  - Neue Funktionen: Replace() in 3 Varianten, einmal für const char *, String und für Buchstaben - Ich würde wirklich gerne 
    diese spezielle Replace Funktion für Buchstaben behalten da die Implementation deutlich einfacher ist. Zwar wird auch 
    in der String-Replace Implemenation getestet ob es sich nur um Buchstaben handelt und dann eine schnellere Implementation 
    gewählt, aber in der const char * müsste ich dazu erst die Längen der Strings ermitteln lassen was hier ja nicht 
    'for free' ist... und will man wirklich nur Buchstaben austauschen ist diese extra Funktion handlich & Performant.



>> 03.02.2006
[SW]
- Linux buid: build is wieder fehlerlos unter linux
  habe in RTTIDefs.h den rückgabewert von CLASS_OFS von PLGeneral::uint64 auf size_t geändert.
  da size_t immer die passende länge auf dem entsprechenden sysstem hat.
  (32Bit-System -> 32 Bit, 64Bit-System -> 64Bit)



>> 03.02.2006
[CO]
- Container Klassen: Intern verwendete Klassen & Strukturen sind nun nicht mehr von außen 'sichtbar'... vorallem 'HashMap' 
  sieht nun in der Implementation ziemlich krank aus - dieses Template wirrwar ist kaum noch lesbar. ;-)
- String:
  - Compare Funktionen kann man nun noch optional die Anzahl der zu vergleichenden Zeichen übergeben, so muss man nicht erst 
    umständlich sich einen String & dann einen Substring davon erzeugen lassen damit man bestimmte Regionen von Strings 
    vergleichen kann.
  - Neue Funktion: IsSubString(): Prüft ob ein gegebener String ein Unterstring ist
  - Delete() fängt nun auch den Fall ab wenn der String nun leer ist
  - Print() prüft nun ob der übergebene String NULL ist (ansonnsten gabs einen Crash in '_vscprintf')
  - GetSubString(): Position Parameter wird auf korrektheit überprüft
  - IsAlphabetic() & IsAlphaNumeric(): Kommentare um jeweils eine kleine Beispielzeile erweitert, denn ich hatte total 
    verpeilt für was diese eigentlich da sind und nahm an es würde sich um 'ist keine Zahl/ist eine Zahl' Funktionen handeln. 
    Stefan klärte mich kurz im Chat auf und jetzt ist diese Sache natürlich total logisch - aber da es sicherlich auch 
    andere nicht auf anhib peilen werden lieber kurz nen Beispiel dazu. :)
  - Neue Funktionen IsFixedNumeric() (hm, besserer Name??) prüft ob der String eine Zahl ist, IsFloatingPointNumeric() prüft 
    ob es eine Fließkommazahle ist



>> 31.01.2006
[CO]
- HashMap: HashSlot zu einfacher Stuktur gemacht, das spart Funktionsaufrufe und ist auch etwas kompakter. HashSlot speichert 
  nun auch den Vorgänger, dadurch war nun auch die Implementation der 'Previous' Iterator Funktionen möglich - wobei diese 
  HashMap Iterator Implementation für 'vorwärts' & 'rückwärts' Support etwas Tricky ist... aber ich glaub das es kaum 
  einfacher gehen wird. :(
- SimpleMap Implementiert - diese Klasse verwendet intern 'Fast Pool' damit das häuftige Einfügen & Löschen etwas flotter 
  von dannen geht, aber zum auffinden der entsprechenden Einträge muss man natürlich sequentiell die gesammte Liste 
  durchgehen... diese Klasse sollte daher mit bedacht eingesetzt werden. Andere Map Implementationen wie z.B. 'Binary Heap' 
  sind hier deutlich flotter und diese Implementation hat noch den netten Seiteneffekt das die Elemente vom Iterator gleich 
  'nach Schlüssel geordnet' zurückgegeben werden was bei dieser Implementation 'for free' kommt. Bei SimpleMap und HashMap 
  ist dies nicht der Fall und ein geordnetes zurückgeben der Element zu 'erzwingen' wäre hier definitiv nicht gut da diese 
  Implementationen das einfach nicht 'unterstützen' und dies dann extra Implementiert werden müsste was dann recht langsam 
  wäre. Jede Implementation hat hier genauso wie die Container-Klassen vor und Nachteile die man geschickt nutzen sollte. 
  Wenn wirklich benötigt könnten wir später noch extra Funktionen anbieden die Elemente 'IMMER' geordnet zurückgeben - ob 
  nun performant oder nicht... aber in den meisten Fällen ist es egal in weiler Reihenfolge die Elemente zurückgegeben 
  werden und da sollten wir defintiv die Sache nicht unnütz künstlich ausbremsen.



>> 30.01.2006
[CO]
- Nahm wie mit Stefan besprochen die Funktion ExpectCharacter() wieder aus dem Tokenizer und implementierte eine vergleichbare 
  Funktion namens IsCharacter() in der String Klasse.
- Container, Map & Iterator Templates um virtuellen Destructor erweitert, auch bei Templates scheint dies Pflicht zu sein - 
  gut das genau zu wissen. :)



>> 29.01.2006
[CO]
- Prüfte über Doxygen ob die Kommentare soweit ok sind und verbesserte ein paar Stellen



>> 24.01.2006
[CO]
- Tokenizer: Neue Funktion: ExpectCharacter(): Ähnlich wie ExpectToken(), aber erwartet das der nächste Token ein einzelner
  Buchstabe ist welcher mit einem der übergebenen Buchstaben übereinstimmt. Wird bereits in Var::CheckMinMax() verwendet um 
  zu prüfen ob ein " oder ' vorhanden ist.
- Var::CheckMinMax() Funktionen an neuen Tokenizer angepasst
- Base::SetVars() an neuen Tokenizer angepasst



>> 23.01.2006
[SB]
- Tokenizer verändert, so daß bei Quotes erst die Anführungszeichen ("), dann der Inhalt und dann noch einmal die Anführungszeichen zurückgegeben werden.
  Ist das Wort leer, so wird es nicht zurückgegeben. Auf diese Weise kann der Tokenizer sowohl für strikte Syntax
  verwendet werden oder es kann wie bisher einfach der Inhalt der Quotes ausgelesen und weiterverarbeitet werden



>> 22.01.2006
[CO]
- Resource Manager & Profiling Klassen an uint32 angepasst damit die Warnungen verschwinden



>> 21.01.2006
[SB]
- Neue Tokenizer Klasse geschrieben. Intern benutzt diese nun eine vernünftige State-Machine (TheoInf läßt grüßen) ;-) Dies ist zwar u.U. etwas langsamer, sollte dafür
  aber wesentlich stabiler sein und ist vor allem verständlicher zu lesen
- Die Klasse arbeitet nun mit Strings anstatt mit char arrays
- Die Optionen werden nicht mehr beim Starten des Parsers festgelegt sondern über eigene Get/Set Methoden
- Die grundlegende Funktionalität des Tokenizers wurde besser von den erweiterten Parser-Funktionen getrennt. Diese sind zwar nach wie vor vorhanden, sollten aber nur
  eingesetzt werden, wenn keine strikte Syntax gebraucht wird. Im allgemeinen sollte der Tokenizer nur die Tokens liefern, danach muß der Output vernünftigt
  geparsed werden
- Neue Klassen: BufferedReader, BufferedStreamReader und BufferedFileReader. Diese Klassen werden benutzt, um Schritt für Schritt aus einem Stream oder einem
  Buffer zu lesen. Dies wird im Tokenizer verwendet, so daß dieser jetzt auch direkt aus Dateien parsen kann. Leider ist die Implementierung nicht so performant wie sie
  sein könnte, dies sollte später noch einmal überarbeitet werden. Außerdem sollte es eine Stream-Klasse geben, die Byte für Byte zurückgibt, der BufferedStreamReader
  könnte dann auf beliebige Streams angewendet werden. Auf diese Weise könnte jeder Stream verwendet werden, nicht nur Dateien sondern auch z.B. Netzwerk-Streams o.ä.
- Codes an neuen Tokenizer angepaßt



>> 21.01.2006
[CO]
- Etwas an den Container Klassen gefeilt, u.a. wird nun dort so möglich/sinnig uint32 anstatt int verwendet - dadurch kann 
  man gleich von vorne heraus Negative Werte ausschließen so, das man sich intern extra Abfragen sparen kann. Bei 
  GetIterator() kann man nun optional einen Start Index setzen. Die Iterator Konstruktoren sind nun protected so das diese 
  NUR von dem jeweiligen Container Typ erzeugt werden können.
- Bitset: Damit wir endlich ein paar cpp-Dateien im Container Ordner haben machte ich das Bitset Template zur normalen 
  Klasse. Ein etwas weniger wichtiger Grund war, das man nicht jedesmal <bool> angeben muss - denn ein anderer Typ ist hier 
  sowieso nicht möglich/gewünscht... ein Bitset mit z.B. floats wäre total daneben. :)



>> 17.01.2006
[SB]
- Alle Klassen auf Namespaces umgestellt. Das RTTI machte dabei etwas Probleme, die Makros müssen hier nochmal überarbeitet werden, es
  ist also möglich daß externe Klassen im Moment nicht mehr richtig funktionieren.
- Alle Container-Klassen nach 'PLGeneral/Container' verschoben
- Quicksort nach 'PLGeneral/Tools' verschoben
- Verzeichnis 'FileSystem/Base' gelöscht und alle Dateien direkt nach 'FileSystem' verschoben
- Patch von Christian für einen Fehler in SearchMultiHandle eingearbeitet



>> 16.01.2006
[SB]
PLString:
- Die Operatoren gefielen mir noch nicht wirklich, da dies eine bunte Mischung aus der Verwendung von String und char* war.
  Habe nun bei den wichtigsten Operatoren jeweils beide Varianten eingebaut, wird dies mit char* aufgerufen ist es also minimal
  schneller, da nicht erst ein String-Objekt erzeugt werden muß
- StringModule wurde in StringBuffer umbenannt
- Der StringBuffer implementiert nun nicht mehr einen eigenen Reference Counter sondern benutzt PLTRefCount
- Hilfsfunktionen zur Verwendung von String-Buffern in der Klasse eingebaut. Dies erleichtert die Arbeit mit den Buffern, da ansonsten
  an vielen Stellen immer wieder das gleiche getan werden mußte (Buffer kopieren wenn der String verändert wurde etc)
- Der String-Buffer übernimmt nun immer einen neuen Zeiger auf einen Buffer, die Möglichkeit einen eigenen Buffer zu allokieren und
  den übergebenen String zu kopieren fällt weg. Dies macht die Verwendung des Buffers wesentlich verständlicher, zumal das Kopieren
  des Strings nur an einer einzigen Stelle nötig war
- Compare-Funktionen überarbeitet
- Konstrukturen mit einem Char-Zeichen als Parameter aus StringBuffer entfernt. Im String selbst bleibt dieser Konstruktor erhalten,
  damit Operationen auf Strings auch mit Buchstaben funktionieren, ansonsten wäre das Umwandeln eines Buchstabens in einen String
  der Länge 1 recht kompliziert
- IsAlpha: Wurde umbenannt in IsAlphabetic. Außerdem prüft diese Funktion nun den gesamten String und nicht mehr nur ein Zeichen,
  für ein einzelnes Zeichen sollte entweder die System-Funktion direkt aufgerufen werden oder SubStrings verwendet werden
- IsAlphaNumeric: Prüft nun ebenfalls den gesamten String, ob dieser nur aus alpha-numerischen Zeichen, sprich alphabetischen ODER
  numerischen Zeichen besteht. Vorher prüfte diese Funktion nur auf numerische Zeichen, der Name war also falsch
- PrintF in Print umbenannt. Naja typische Schönheitsoperation, sollte dies auf heftigen Widerstand stoßen können wir es auch wieder
  umbennen, aber ich finde so ein großes F am Ende irgendwie häßlich ;-)
- Insert (char) entfernt. Wenn dies nicht dringend und an performance wichtigen Stellen gebraucht wird sollte dies lieber über einen String
  der Länge 1 gemacht werden
- EatLeadingWhitespace und EatTrailingWhitespace umbenannt in TrimLeading und TrimTrailing. Außerdem noch Trim hinzugefügt, welches
  beides macht. Außerdem geben diese Funktionen nun ebenfalls den String zurück
- Konvertierungsfunktionen aufgeräumt. Kleine Änderung: Beim =(char) wird nun der Buchstabe ausgegeben, nicht dessen Ascii-Wert.
  Dies war zuvor inkonsistent, bei =(char) wurde die Zahl genommen, bei += jedoch der Buchstabe
- Const bei entsprechenden Methoden hinzugefügt
- String-Klasse liegt nun in Base
PLGeneral:
- PLTRefCount Template hinzugefügt, Basisklasse für Reference Counting
- PLTRefCountPtr Template hinzugefügt, diese Klasse ist ein spezieller Reference Counter für externe Objekte
- SmartPtr-Template hinzugefügt. Diese Klasse arbeitet mit dem PLTRefCount Interface und überprüft dabei,
  ob das verwendete Objekt dieses Interface unterstützt oder nicht. Falls nicht wird mittel PLTRefCountPtr ein
  externer Reference-Counter für das Objekt erzeugt, es ist jedoch besser, wenn die Klasse auf die gezeigt
  wird von PLTRefCount abgeleitet wird, da dies Fehler z.B. durch doppeltes Zuweisen des gleichen Zeigers
  besser verhindern kann
- Alle Klassen auf die neue PLTRefCount-Klasse umgestellt



>> 07.01.2006
[CO]
- RTTIDefs.h: Da 'VAR_OFS' bei Stephan unter Linux Compiler Warnungen verursacht bastelte er ein Makro welches unter Linux 
  keine Warnungen produziert. Da VC aber anscheinend kein '__alignof__' kennt musste ich hier defines einsetzen, unter 
  Windows das eine Makro, unter Linux das andere... vielleicht bekommt man irgendwann später etwas Universelles zusammen das 
  überall sauber geht, aber ich denke wir können das erstmal so lassen.



>> 03.01.2006
[SW]
Alle Projekte:
- Habe das subversion property "svn:eol-style 'native' " für die source-files, text-files und project-files gesetzt.
  dieses property sorgt dafür, das beim checkout,update die eol-kennung entsprechend des OSes ist
  d.h. unter linux ist die eol-kennung nur \n und unter windows \r\n und zwar egal vom welchem os aus diese
  Datei verändert oder erstellt worden ist



>> 02.01.2006
[SW]
- Memleak in der String-klasse unter linux behoben. Das Problem war das die _vscprintf-implementation
  fehlerhaft war(ein return hat gefehlt, *asche über mein haupt*).
  Da die vsnprintf-function unter linux das selbe macht, wurde die protabele_vsnprintf-fn aus GeneralLinux.cpp
  entfernt.



>> 01.01.2006
[SW]
- habe die kompabilität zu gcc 3.4 hergestellt bzw. zum c++-template standard
  zum einen musste ich den header string.h in HashTable.inl hinzufügen, weil sonst der gcc mit folgender fehlermeldung 
  bezüglich strlen, strcpy,strcmp abbrach:
  "there are no arguments to `strcmp' that depend on a template parameter, so a declaration of `strcmp' must be available"
  Die änderung von AType zu AType1 in der friend declaration in den Dateien ResourceManager.h, ResourceHandler.h und 
  Resource.h war nötig weil sonst der gcc mit folgender Fehlermeldung abbrach:
  "include/PLGeneral/Base/ResourceManager.h:32: error: declaration of `class AType'
   include/PLGeneral/Base/ResourceManager.h:25: error:  shadows template parm `class AType'"
  es müsste nur getestet werden ob diese Änderungen keine probleme verursachen
- tinyxml: habe eine statische lib für linux von tinyxml in den zips hinzugefügt und tinyxml.h so abgeändert das sie auch 
  unter linux übersetztbar ist
  
  
>> 01.01.2006
[CO]
- PLTString &PLTString::operator += (char nCharacter): Hier waren die Parameter vertauscht



>> 22.12.2005
[CO]
- Optimierte PLTHashTable da diese Klasse recht häufig verwendet wird und etwas lahm war... die alte Implementation war etwas 
  dürftig. Bei 'Add()' wird nun nicht mehr geprüft ob dieses Objekt bereits eingetragen ist - das muss der User schon selbst 
  machen wenn er hier unsicher ist und das jedesmal inter zu prüfen ist schlichweg zu Aufwändig... Codes angepasst habe ich 
  keine da wir eh vorher immer im  Falle des Falles prüfen. Nahm diverse überflüssige 'Sicherheitsabfragen' raus - denn in 
  den Innereien kann man IMMER davon ausgehen das die gegebenen Dinge stimmen da diese bereits vorher mal geprüft wurden. :)
  Desweiteren wird nun zwischen groß/kleinschreibung unterschieden. Die neue Implementation ist nun teils mehr als doppelt 
  so schnell wie die alte und die Namen können beliebig lang sein.
- PLTResource & PLTResourceHandler: Die alte Resource Handler Implementation war viel zu umständlich - daher machte ich dies 
  'direkter', Resource kann also intern direkt auf Handler zugreifen und umgekehrt... da diese Dinge stark zusammenhängen 
  ist das denk ich ok und es vereinfacht die Sache enorm. Wenn ein Resource Manager automatisch nicht länger verwendete 
  Resourcen löschen soll, löschen nun die Resource Handler die alte Resource wenn diese nicht mehr verwendet wird.



>> 15.12.2005
[CO]
- Da PLTString nun stark an Bedeutung gewinnt, überarbeite ich die String Klasse nochmal komplett - die alte Implementation 
  war leider teils heftig Buggy/Unbefriedigend. Das Überarbeiten war zwar einiges an Arbeit, aber ich denke es hat sich 
  definitiv gelohnt. :)
- Stellte intern die Speicherung von Namen im Resource Manager auf PLTString um - den Rest in PLGeneral wird Stefan 
  anpassen. Das verwenden von PLTString zur Speicherung von Namen bringt einige Vorteile, zum einen haben wir so keinen 
  Overflow mehr wenn man einen längeren Namen hat als Speicher für einen Namen verfügtbar ist... und zum anderen Spart man 
  einiges an Speicher da ein 'leerer' String gerade mal 4 Byte groß ist... und ansonnsten wird nur soviel Speicher für den 
  String verwendet wie wirklich nötig ist. Also nicht mal fest char[256/1024 usw.] anlegen und hoffen das dies reichen 
  wird. ;-)
- In PLTParameters::AddParam() kam es nun nach 'PLTVariant *pVar = new PLTVariant(cParam);' zum Crash da in 
  'PLTVariant::m_sName' merkwürdigerweise Schrott stand. Machte hier eine kleine Änderung, lies aber das vorherige als 
  Kommentar drinen. Stefan, schau bitte mal was hier schiefgeht und ob man es so wie es jetzt ist lassen kann.



>> 12.12.2005
[CO]
- PLTXmlElement::GetFirstAttribute(): An ein paar Stellen wo ich diese Funktion verwendete hatte ich vergessen vorher zu 
  Prüfen ob hier überhaupt etwas zurückgegeben wird bevor ich es verwende - wieder soetwas wo man sich schwer wundert das 
  dies nicht schon vorher aufgefallen ist. ;-)
- Nahm wie besprochen die Prioritäten aus dem Resource Manager da diese dort mehr Ärger als nutzen bringen
- PLTSingleton: 'm_pInstance' bekommt nun im Constructor die Instance zugewiesen und nicht mehr in GetInstance(). Nach den 
  kleinen Änderungen im Resource Manager Template hatte ich hier in den konkreten Resource Managern nun das Problem das 
  in deren Constructoren teils GetInstance() verwendet wird - jedoch lieferte dies zu diesem Zeitpunkt NULL zurück da diese 
  Variable erst noch gesetzt werden musste. (endlos Rekursion :)
  Ich hoffe diese kleine Änderung geht ok...



>> 08.12.2005
[CO]
- PLTResourceManager: Die Funktion Get(<Name>) ist nun virtuell, in der Engine beim Scene System hat diese Funktion eine 
  erweiterte funktionalität da man über z.B. 'Root.Scene.Jeep' auch 'absolute Namen' angeben kann. Machte SetResourceName() 
  Protected da es reichen müsste wenn man über PLTResource::SetName() den Namen einer Resource setzen kann. 
  PLTResource::SetName() ist nun ebenfalls virtuell da z.B. in der Engine bei PLTSceneContainer in Namen kein '.' vorkommen 
  darf und der Name 'Root' nicht verwendet werden darf. (NUR die Root Node selbst hat diesen Namen :)
  Dummerweise musste ich auch Get(<int>) virtuell machen und in PLTSceneContainer implementieren, ansonnsten bekam ich 
  folgende Fehlermeldung:
    "error C2664: 'PLTSceneContainer::Get': Konvertierung des Parameters 1 von 'int' in 'const char *' nicht möglich"
  Was machen wir hier? Irgendwie ist das total dämlich. :(



>> 02.12.2005
[CO]
- PLTHeap: Kann nun auf Wunsch auch den Key zurückgeben



>> 30.11.2005
[CO]
- PLTBase::SetVars(): Konnte kein '=' gelesen werden, wurde das nächste gefundene Wort 'übersprungen' was nicht korrekt war.



>> 20.11.2005
[SB]
- Habe das Interface von PLTContainer verändert: Die Funktion Add(const AType &Element) gibt nun ebenfalls einen AType* Zeiger zurück.
  Man braucht dies nicht, wenn man nur eine Liste von Zeigern hat, besteht die Liste jedoch aus direkten Objekten, welche kopiert werden,
  ist dieser Zeiger sehr nützlich, ansonsten würde es wesentlich umständlicher.
- Habe in PLGeneral und PLMath alle Aufrufe von Add(const AType &Element) angepaßt - da vorher true als Fehler zurückgegeben wurde, nun
  aber NULL für den Fehlerfall steht, muß leider jeder Aufruf angepaßt werden. Habe dies auch in den anderen Projekten getan.



>> 18.11.2005
[SB]
- Include von PLTLog in PLTSingleton entfernt, dadurch mußten an anderen Stellen die Include-Files geändert werden



>> 10.11.2005
[CO]
- PLTResourceManager<AType>::SetResourceName(): Ohman, wie konnte DIESER total dämliche Bug nur soo lange unbemerkt 
  bleiben? (war natürlich mein verschulden :) Hier wurde zuerst der neue Resourcen Name gesetzt, und dann wurde die 
  Resource mit hilfe diesen neuen Namens aus 'm_lstNameHashList' entfernt und dann mit dem neuen Namen wieder 
  hinzugefügt... brrr, natürlich muss die Resource mit dem alten Namen aus 'm_lstNameHashList' entfernt werden.



>> 09.11.2005
[CO]
- PLTTools: Neue Funktion: CombineStrings(): Kombiniert Strings miteinander. Diese Funktion wird u.a. im Renderer in den 
  Shader Backends benötigt um den Shader korrekt zusammenzukopieren... denn hier müssen noch Renderer & Custom Definitionen 
  in den Shader eingefügt werden.
- PLTList: Get() & ReplaceAtIndex() & AddAtIndex() & RemoveAtIndex() & Compare() etwas Optimiert: Ist der Index in der 
  'hinteren' hälfte, so wird nun vom letzten Element rückwärts durchlaufen wodurch man in diesen Fällen eine bessere 
  Suchzeit hat... wenn man schon ne doppelt Verkettete Liste hat, so kann man auch ruhig die Vorteile die diese bietet 
  nutzen. ;-)
  Passte ebenfalls PLTPool & PLTFastPool entsprechend an.



>> 07.11.2005
[SB]
Alle Projekte:
- Habe im Repository die Verzeichnisse _Branches und _Tags entfernt - ich fand die störend, und wir nutzen das bisher eh nur sehr selten.
  Der PLGeneral-Branch sitzt nun direkt im Hauptverzeichnis, was nicht weiter stören sollte, zumal Branches ja sowieso keine allzu lange Zeit
  am Leben sein sollen :-)



>> 02.11.2005
[CO]
- Reset-Funktion zu PLTArray hinzugefügt mit der man den Array 'zurücksetzen' kann - recht praktisch das
- PLTTools: Neue Funktionen: GetIntegersFromString(), GetFloatsFromString() und GetDoublesFromString()



>> 01.11.2005
[CO]
- PLTXmlDocument: LoadFile() und SaveFile() setzen nun den Dokument Wert auf den Dateiname + einen TinyXML Fehlercode
  wenn die Datei nicht geöffnet werden konnte.



>> 29.10.2005
[CO]
- PLTSystem: Vergrößerte die Anzahl der Slots der Hash Tables von m_hashClasses & m_hashModules da ich derzeit 217 Klassen, 
  und 19 Module zähle - so ist die Hash Table wieder Effektiver und da es nur eine Instance von PLTSystem gibt gibts auch 
  Speicher mäßig keine Probleme.
- Es können nun auch Passwort Geschütze Zip-Dateien verwendet werden. Dafür musste ich PLTFile::Open() um einen weiteren 
  Optionalen Parameter erweitern. (das Passwort wenn benötigt)



>> 25.10.2005
[CO]
- PLTTools: Neue Funktion GetBooleanFromString() welche einem den booleanischen Wert in einem String zurückgibt. Dies ist 
  z.B. beim Auslesen von XML Attribute Werten recht praktisch da der User dadurch '0' oder auch 'false' schreiben kann.
  PLTVar::Set() verwendet nun ebenfalls diese Funktion damit das Einheitlich gehandhabt wird.
- PLTXmlElement: Schlägt das zurückgeben eines Attribute Wertes fehl, so ändert TinyXML troztdem die übergebene Variable - 
  das ist total unpraktisch und darum wird hier nun diese Variable nicht mehr geändert falls die Funktion fehlschlägt. 
  Hatte mir schon überlegt diese Änderung direkt in TinyXML zu machen, sah aber davon ab da dies eventuell Probleme 
  verursachen könnte.



>> 24.10.2005
[CO]
- PLTBase: Um Funktion AddVarsToXMLElement() erweitert welche die Variablen zu einem XML Element hinzufügen. Dabei kann man 
  als Parameter übergeben ob die Variablen als Attribute oder Elemente hinzugefügt, und ob Variablen mit Default Werten 
  irgnoriert werden sollen. Da dieses 'Variablen zu XML Element hinzufügen' öfters benötigt wird, ist diese hilfs Funktion 
  ziemlich praktisch. Das 'Gegenstück' zu dieser Funktion SetVarsFromXMLElement() ist ebenfalls vorhanden. Diese zweite 
  Funktion kann auf Wünsch selbständig nach Variablen in den Attributen UND Child-Elementen suchen soll, Default Einstellung 
  ist jedoch Variablen nur in den Attributen suchen.
- PLTConfig läd & speichert nun in einem XML Format, dabei werden die verschiedenen Variablen als Elemente hinzugefügt 
  und auch Variablen mit Default Werten werden ebenfalls gespeichert - das ist hier irgendwie übersichtlicher.
- PLTXmlDocument: LoadFile() verwendet nun eigene File System Funktionen um eine Datei einzuladen und zu Parsen



>> 21.10.2005
[CO]
- PLTConfig: Beim Laden & Speichern kann man nun Optional angeben ob die Config Datei NUR im aktuellen Verzeichniss gesucht
  werden soll. Damit kann man Konflikte zwischen verschiedenen Config Files verhindern - z.B. das plöztlich in PLSamples 
  Configs aus PLTools genommen werden da die gewünschten Configs in PLSamples nicht gefunden wurden und PLTools im FS als 
  Basis Pfad eingetragen ist... und somit wurden teils unerwünschte Einstellungen verwendet. :)



>> 05.10.2005
[CO]
- Musste in TinyXML eine weitere kleine Änderung vornehmen: Hatte Probleme beim Scene Format da '[' und ']' nicht in Namen 
  vorkommen durften - aber somit konnte eine Scene nicht mehr geladen werden sobald eine RTTI Array Variable verwendet 
  wurde. Also erweiterte ich TiXmlBase::ReadName() so, das auch '[' und ']' in Namen akzeptiert werden... hoffentlich macht 
  das keine Probleme... hat jemand ne Ahnung ob das 'Absicht' ist das '[' und ']' bei XML nicht in Namen vorkommen darf, 
  sprich, es so in den 'Vorgaben' steht? Wenn ja, und wir uns daran halten wollen, müssten wir uns für RTTI Array Variablen 
  etwas anderes überlegen was aber ziemlich unschön werden würde.
- An ein paar Stellen wo das RTTI float Variablen in einen String schreiben soll %f durch %g ersetzt damit am Ende keine 
  Überflüssigen Nullen stehen.



>> 29.09.2005
[CO]
- PLTString::Insert() um weiteren optionalen Parameter erweitert. Ist dieser nicht -1 so gibt dieser die Anzahl der 
  einzufügenden Zeichen an. Desweiteren noch ein paar Tool Funktionen hinzugefügt.
- PLTSystem::ScanPlugins() um optionalen Parameter erweitert. Da wir mittlerweile ziemlich viele dll's haben kann 
  ScanPlugins() vorallem beim Programmstart im Debug Modus nervend viel Zeit in anspruch nehmen da zuerst einmal die dll 
  geladen werden muss und wenn nichts Interessantes drinen ist wird diese wieder entladen. Ist dieser neue Parameter auf 
  'true' (Default = 'true'), so wird anhand des Namens ein kleiner 'Vortest' gemacht so das man meist gut die hälfte der 
  dll's erst gar nicht zu laden braucht was den Scan Vorgang beschleunigt. Dabei wird das 'D' am Ende des Namens geprüft. 
  Ist man im Release Modus und ist dort ein 'D' wie z.B. bei PLSampleSceneNodesD.dll so wird dieses Module komplett 
  ignoriert. Da wir selbst uns an diese Namens Konvention halten klappt das hier, der User müsste sich am Ende auch daran 
  halten, oder beim Scannen diesen Parameter auf 'false' setzen damit nicht eigentliche gültige Module ignoriert werden. 
  Ist natürlich eine Sache die schnell daneben gehen kann wenn jemand nicht aufpasst - allerdings spart das Wertvolle 
  Ladezeit was ein deutlicher Pluspunkt ist... und eine andere Lösung um die ScanPlugins() Ladezeit zu verkürzen hab ich 
  bis jetzt noch nicht gefunden. Ich machte das da diese Ladezeit gerade im Debug Modus mittlerweile deutlich auffällig - 
  das iss schon fast so nervend wie bei 3D Studio Max wo am Anfang erstmal tausende von Plugins geladen werden welche man 
  teils gar nicht braucht was Debuggen zur Qualt macht. Das Scannen selbst kann man wohl nicht umgehen, aber halt wie 
  gesagt grob anhand des Names 'ausfiltern'. In meinem Debug Modus Test wurden früher beim Programmstart gut 252 mal dll's 
  geladen und entladen. Jetzt nur noch 39 mal - früher war das so hoch da wenn eine dll geladen wird ja auch gleich noch 
  alle damit Verbundenen dll's geladen werden, und beim endladen werden diese anderen dll's meist auch wieder entladen und 
  das gleiche Spielchen immer und immer wieder. Hoffentlich kommt Stefan mit dieser Lösung klar... oder findet etwas 
  besseres. ;-)
  Alternativ könnten wir vielleicht auch alle Plugin in extra Unterordner wie z.B. 'Plugins' und 'PluginsD' packen und dann 
  gezielt beim Initialisieren der Engine in diesen Ordnern Scannen lassen. Aber dann müsste z.B. 'Newton.dll' auch im 
  entsprechendem Ordner liegen wenn man was 'rausgibt'... und im Grundordner müsste dieses nochmal liegen falls die 
  Anwendung selbst Newton verwendet. (denn in diesem 'rausgeben' Fall wäre es nicht gut an den Environment Variablen zu 
  drehen)



>> 25.09.2005
[CO]
Alle Projekte:
  Ging alle PL Projekte durch und machte einige RTTI Variablen 'read only':
  PLTImageLoader, PLTTextureCreator, PLTMeshCreator, PLTSkeletonAniLoader, PLTMeshLoader
PLGeneral:
- PLTFileSystem: Neue Funktion: IsSearchPath() -> Prüft ob ein gegebener Pfad ein Suchpfad eines gegebenen Types ist. Dies 
  brauchte ich in PLTMeshLoader wo ich prüfe ob ein Pfad bereits eingetragen ist. Wenn nicht, werden bei bedarf 
  während des Laden eines Meshs ein paar Suchpfade hinzugefügt und nach dem Laden wieder entfernt. (siehe PLEngine Diary)
- PLTFileType::RemoveSearchPath() korrigiert nun den übergebenen Pfad wenn nötig (sicher ist sicher)



>> 22.09.2005
[CO]
- Neue Funktion: PLTPlatform::ShellOpen(): Das OS öffnet eine Datei mit dem Programm welches mit diesem Datei Typ vernüpft 
  ist. Weis nicht ob diese Funktion wirklich in Platform passt oder nicht doch eher ins File System. Auf jedenfall ist diese 
  Funktion recht nützlich wenn man z.B. auf einen Link Klickt und sofort auf eine Internet Seite kommt - oder wenn man z.B. 
  im Mesh Editor ein Material öffnen will. (in dem Fall wird nen Text Editor mit diesem Material geöffnet)



>> 10.09.2005
[CO]
- Der einzige Unterschied zwischen PLTPool und PLTResourceManager bestand darin das PLTPool Element zusätzlich noch 
  eine Priorität haben - wichtige Element liegen dann also immer am Anfang. Da Prioritäten bei Resourcen sicherlich auch 
  nicht verkehrt sind erweiterte ich den Resource Manager um solche. Somit hat PLTPool nun keine Existensberechtigung mehr 
  und wurde gekillt. Nötige (meist kleinere) Anpassungen:
  - PLGeneral: PLTProfiling
  - PLModel: PLTAnchorPoint, PLTAnimationEvent, PLTAnimationInfo, PLTMesh, PLTMeshHandler, PLTMorphTargetAni
  - PLEngine: PLTSurfaceListener, PLTSky
  - MeshEditor: TGuiEditAnimationEdit
- Das mit PLTPool hatte ich mir nochmal angeschaut da ich den Namen PLTPool für etwas anderes brauchte - es gibt nun eine 
  Neue Container-Klasse mit diesem Namen. Im Prinzip handelt es sich hierbei um eine Verkettete Liste wie bei PLTList, 
  jedoch gibts Intern zwei Listen, eine mit den aktuell verwendeten Elementen und eine Liste mit derzeit nicht benötigten 
  Elementen. Diese Klasse ist recht praktisch wenn man viele Dynamischen Elemente Managen will, also wenn häufig Element 
  gelöscht und wieder hinzugefügt werden. Beim Löschen wird das eigentliche Element 'nur' zur Liste der freien Elemente 
  hinzugefügt, und fügt man wieder ein Element hinzu wird erst geschaut obs noch ein nicht verwendetes Element gibt - 
  ansonnsten muss wie bei der normalen Liste ein neues erzeugt werden.
- Neben PLTPool gibts noch eine schnellere Variante Namens 'PLTFastPool'. Bei diesem Container MÜSSEN die Elemente von 
  PLTFastPoolElement abgeleitet sein - damit kann man dann superschnell ein Element direkt vom Container entfernen ohne 
  voher wie bei PLTPool das reale Pool Element zu finden. Diese Klasse ist also Optimal wenn man sehr viele Elemente 
  regelmäßig löscht und hinzufügt. Ansonnsten verhält sich diese wie alle anderen Container Klassen auch. In der Engine 
  werde ich wohl PLTParticleGroup auf diese Klasse umgestellen und die neue Scene Hierarchy 'PLTSceneHierarchySphereTree' 
  verwendet diese Klasse ebenfalls da hier oft etwas gelöscht und wieder eingefügt wird und dies daher so flott wie möglich 
  gehen muss.
- In PLTList::RemoveAtIndex() war noch nen Bug, der Index wurde nicht erhöht - das dies nicht schon vorher aufgefallen ist...
- PLTStack: PushBack() Privat gemacht da dies nicht in das 'übliche' Stack Schema passt
- Neue Klasse: PLTQueue (FIFO) ist das Gegenstück zu PLTStack (FILO)



>> 30.08.2005
[CO]
- PLTBitset::Resize(): Parameter waren vertauscht



>> 26.08.2005
[CO]
- Bei einigen XML Funktionen Funktionen ein Get davor gesetzt + ein paar interne Sicherheits Abfragen auf NULL Zeiger
- XML Interface Kommentare soweit vervollständigt, sind aber noch hier und da nicht wirklich Aussagekräftig da die TinyXML 
  Doku hier leider teils lückenhaft ist. Einiges undokumentiertes Verhalten hab ich bereits direkt in den Codes nachgeschaut 
  und bei uns Dokumentiert. Drehte auch ein paar boolische Rückgabe Werte um so das diese zu unserem Style passen. 
  (bei Fehler 'true' statt 'false' - da wir fragen 'gabs nen Fehler?' und nicht 'ging alles glatt';-)
- PLTXmlDocument: Eigene Speicher Funktion eingebaut



>> 17.08.2005
[CO]
- XML Wrapper Versucht Nr. 2: Wie beim Treffen bei Jens Besprochen hat nun jede XML Klasse eine eigene Datei und alles 
  liegt in dem  Ordner. Zudem werden von diesen Klassen nun 'echte' Objekte erzeugt. Konkrete PL XML Objekte werden
  erst DANN erzeugt wenn diese benötigt werden - z.B. wenn man sich ein Element zurückgeben lassen will wird intern falls
  zu dem TinyXML Element noch kein PL XML Element vorhanden ist eines erzeugt.
  Mit dieser Lösung kann es sein das bestimmte Elemente/Attribute NIEMALS 'angefasst' werden und man hier daher auch keine
  eigenen PL XML Objekte erzeugen muss. (wird wohl vorallem bei Attributen der Fall sein :)
  Bei der Implementation gabs nen paar Kleinigkeiten zu beachten:
  Da die User Data Variable von TinyXML verwendet wird, muss man beim Kopieren und beim Einfügen der Objekte aufpassen da 
  sonst die PL XML Objekte Zeiger nicht mehr stimmen. Änderte in TinyXML TiXmlNode::CopyTo() es so das User Data NICHT
  mehr mitkopiert wird - denn das im Wrapper zu kompensieren war zuviel Aufwand. (rekursiv)
  Das Löschen der PL XML Objekte war etwas mehr Aufwand da man rausbekommen musste wann ein TinyXML Objekt zerstört wurde - 
  da TinyXML aber soetwas nicht anbietet erweiterte ich TinyXML um eine Destroy-Callback Funktion welche jedesmal aufgerufen 
  wird wenn ein Objekte zerstört wird. Durch diese Mini Erweiterung spart man sich dann in unseren Wrapper eine ganze Menge 
  an Arbeit. :)
  Alles in allem find ich diesen Wrapper recht brauchbar und der Aufwand/Nutzen Faktor stimmt. Mit einer komplett eigenen
  internen Hierarchy wäre alles mehr Arbeit als dies momentan der Fall ist. Zwar musste ich nun zwei mini Änderungen an 
  TinyXML selbst machen - aber ohne diese Änderungen hätte man sich teils heftig im Wrapper verbiegen müssen um es sauber
  laufen zu lassen, ich finde das ist nen akzeptabler kompromiss zwischen 'TinyXML umschreiben und direkt in PLGeneral',
  'gesammte XML Hierachy selbst Managen' oder gar gleich 'komplett eigenen XML Parser schreiben'.



>> 16.08.2005
[CO]
- PLTTokenizer::GetNextToken(): Quote verhalten minimal geändert. Bis jetzt wurden = und ` gleich gehandelt. Man konnte also
  mit " starten und mit ` Enden. Nun wird es so gehandhabt das wenn mit " begonnen muss es mit " auch wieder enden muss. Hat
  den Vorteil das man nun Quotes 'Schachteln" kann was enorm Praktisch ist. z.B. kann man nun Problemlos eine Scene Node 
  erzeugen dessen Mesh automatisch erzeugt wird mit z.B. 
  pContainer->Create("PLTObject", "Sphere", "Pos=\"0.0 0.0 5.0\" MeshFilename=\"PLTMeshCreatorSphere 
  Name=`Sphere` Radius=`4.0` Detail=`20.0`\"");
- PLTArray: Ist nun wieder ein 'richtiger' Array, bei meinen Tests hatte ich keine Probleme und alles läuft mit dieser 
  Änderung genau wie früher. Änderungen in den anderen Codes sind nicht nötig. Mit GetData() bekommt man den Zeiger auf 
  das erste Element des Arrays.
- Vertauschte bei PLTBitset & PLTArray Init & Add Parameter - denn Init sollte im Normalfall false sein und nicht geändert
  werden. (außer man weis genau was man tut :)
  Init ist praktisch wenn man GENAU weis das man einen Primitiven Variable Typ wie float hat oder einfache Klassen - aber 
  sobald z.B. virtuelle Funktionen ins Spiel kommen sollte man nie nie nie den Init Parameter auf True setzen da memset
  zum Initialisieren der Elemente verwendet wird!
  Keine Anpassungen in PLBase nötig, ansonnsten nur eine Handvoll Parameter Anpassungen in allen Projekten zusammen.
- PLTBitset: SetResizeCount() hat nun den Default Wert 320 - denn da jedes Element hier nur 1 Bit ist und je 32 Bits in
  eine Integer Variable 'passen' ist es so wesentlich Effizienter.
- PLTBitset & PLTArray: RemoveAtIndex() verkleinert nun bei Bedarf den Array wieder. NUR diese Funktion löscht die
  Elemente, alle anderen verwenden diese nur.
- PLTVar::SetEnumString(): Da m_lstEnum Array ist und jedesmal wenn ein neues Element hinzugefügt wird sich die Adresse 
  im Speicher von anderen Elementen ändern kann, darf man m_hashEnum erst nachdem alle Elemente eingetragen wurden
  erzeugen.



>> 10.08.2005
[CO]
- Wrapper für TinyXml geschrieben und im Tools Unterordner abgeladen. (+ Base Test um XML Test erweitert)
  Der Wrapper ist noch nicht 'perfekt' und es fehlen noch nen paar PL spezifische Funktionen für z.B. das eigene
  File System verwenden.



>> 06.08.2005
[SB]
- PLTWin32File::GetS() filtert nun nicht mehr das '\n' heraus sondern verhält sich jetzt genauso
  wie fgets(). Vermutlich werden wir jetzt aufgrund des neuen Verhaltens einige andere Stellen
  anpassen müssen, aber es ist ja immer besser sich an Standards zu halten :-)
- PLTWin32File::PutS() gibt jetzt die länge des Strings zurück, wenn es beim Schreiben keine
  Fehler gab, damit liefert PLTFile::Print() auch keine lästigen Fehler mehr. Bin mit nicht 100%
  sicher, ob das auch beim Textmode immer funktioniert, sollte aber eigentlich :-)
- Habe einen neuen Branch für PLGeneral erstellt, an dem ich in nächster Zeit arbeiten werde.
  Da ich noch einiges an PLGeneral ändern möchte und es unpraktisch wäre, dies im "laufenden Betrieb"
  zu tun, da dann ständig alles angepaßt werden müßte, ist dies eine gute Gelegenheit, mal Branches
  in Subversion auszuprobieren. Dies ist also eine Kopie des aktuellen PLGeneral, an der ich
  beliebig arbeiten kann, wenn die Arbeiten abgeschlossen sind werden die Änderungen wieder mit
  dem Hauptzweig gemerged - bei Bedarf kann man das auch zwischendurch schon machen, wenn ich z.B.
  nur einen kleinen Bugfix mache, der auch in der aktuellen Version ok ist, oder andersherum
  wenn jemand am Hauptzweig was ändert was ich gleich übernehmen kann. Also mal schauen wie gut
  das funktioniert :-)



>> 28.07.2005
[CO]
- Erweiterte das Resource Manager Template um die Virtuelle Funktion PLTResource::DestroyResource(), diese Funktion
  wird/sollte nun immer anstatt delete <Resource> verwendet werden. Als Standard ist ein einfaches 'delete' 
  Implementiert - in PLTSceneNode ist es aber nötig VOR dem Löschen die Scene Node sauber aus dem Container zu 
  entfernen. Vorher wurde in PLTSceneNode erst direkt im Destruktor der Knoten aus dem Container entfernt - dies 
  machte aber casting-Probleme da anscheinend bereits Teile des Objektes gelöscht waren was dazu führte das
  DeInitFunction() nicht mehr korrekt aufgerufen wurde.



>> 11.07.2005
[CO]
- PLTPlaneSet::IsBoxIn() kann nun Optional noch mit ausgeben welche Ebenen die Box schnitten.



>> 11.06.2005
[CO]
- Da ich merkte das man das Informer&Listener Prinzip immer wieder benötigt und es mir einfach zu dumm wurde
  das immer wieder von neuem zu Implementieren erstellte ich Informer&Listener Templates an und legte diese im 
  Base-Unterordner ab. (PLTSceneQuery und PLTSceneQueryListener in der Engine verwenden diese Templates bereits)
- PLTString etwas erweitert



>> 17.05.2005
[CO]
PLTPlatform:
- Fügte Funktionen für Multi-Tasking hinzu da die Rechner (und vorallem neue Konsolen :) immer mehr CPU's
  haben, muss man zwangsläufig versuchen wo immer möglich bestimmte Aufgaben als eigene Tasks zu realisieren um 
  diese Systeme Effektiver nutzen zu können. PLPhysics z.B. werd ich dann gleich in einem eigenen Task laufen
  lassen da dies dort 'relativ' Problemlos möglich ist - und der Trend bei Physik geht eindeutig zum eigenen
  Task dafür. (Thema Physics CPU etc. :)
  Auch müsste man nun so Ladebildschirme realisieren können welche lustige flüssige Animationen zeigen während Parallel 
  dazu in einem Task die Daten geladen werden.
  Damit müssten wir auch das CPU/GPU Problem besser in den Griff bekommen... denn wenn die CPU im Hauptprogramm an einer 
  Stelle einmal dummerweise auf die GPU warten muss, wird die CPU im Hintergrund für z.B. die Physics weiter verwendet so 
  das keine/kaum Resourcen brach liegen.
  Hab mich beim Design an der SDL Implementierungen Orientiert da dies im Endeffekt recht Einfach zu verwenden 
  und Sinnig ist. (und es lässt sich sicherlich kaum anderst machen da man ja nur die Grundfunktionen Wrapt :)
  Der User selbst kommt nur mit einer Handvoll Funktionen für Task & Mutex in Kontakt. Intern und vorallem
  bei den Linux Implementierungen ist das alles teils ziemlich umständlich - da man dort anscheinend XXX
  verschiedene Fälle beachten muss. Hab dort die Funktionen aus SDL übernommen, Stephan muss da aber nochmal drüber schaun
  ob das so ok ist und natürlich das mal ausprobieren - das wir endlich auch mal Multi-Tasking verwenden/unterstüzen sollen
  war ja schließlich seine Idee. ;-)
  Ich bin mir seeehr sicher das es sich so wie es momentan ist noch nicht einmal Übersetzten lässt. ;-)
  Erweiterte PLBaseTests gleich um einen einfachen Multi-Tasking Test.



>> 12.05.2005
[CO]
- PLTBase::SetVars(): Der Tokenzier behandelt hier '[' und ']' nun nicht mehr als einzelne Zeichnen da ansonnsten Variable
  Namen wie 'Test[3]' nur als 'Test' gelesen werden - sehr merkwürdig das dies bis jetzt noch nicht Aufgefallen war. ;-)
- PLTConfig::GetVarInt() berücksichtigt nun die Fälle wenn die Variable vom Typ Flag oder Enum ist
- PLTResourceManager<AType>: Add() & Remove() waren noch nicht ganz ok. Der Resource wird nun mitgeteilt das dies nun in 
  dem Manager ist und bei Remove() das diese nun in keinem Manager mehr ist. Den Bug merkte ich erst als ich eine Resource
  nachträglich einem Manager zuwies in es einen Crash gab als der Manager wieder gelöscht wurde... ohmanohman, wie konnte 
  ich das nur übersehen. ;-)



>> 09.05.2005
[CO]
- In VC 7.1 spuckte der Compiler bei PLGeneral leider diverse Fehler aus. Diese liesen sich aber zum Glück recht leicht
  beheben:
- PLTSingleton
  template <class AType> PLTSingleton<AType>::__Destruction_Guard PLTSingleton<AType>::__Guard;
  Hier muss typename Eingefügt werden:
  template <class AType> typename PLTSingleton<AType>::__Destruction_Guard PLTSingleton<AType>::__Guard;
- PLRTTIDefs.h
  template <class T> typename PLTModuleID<T>::SelfInit__Class PLTModuleID<T>::__SelfInit;
  Hier muss ebenfalls typename Eingefügt werden:
  template <class T> typename PLTModuleID<T>::SelfInit__Class PLTModuleID<T>::__SelfInit;
- PLTParameters::AddParam(const char *pszName, const PLTVariant &cParam) -> cParam ist nun const -> Machte sonst Probleme
  unter VC 7.1. und noch krassere Probleme auf dem Linux Compiler :)
- Musste in PLGeneralWin32.h auf einmal das Makro 'min' selbst definieren da es ansonnsten nicht gefunden werden konnte
Beseitigte probleme welche bei Stephans Linux Compiler auftraten:
- PLTSystem: Friend Definitionen:
 'friend class PLTModuleID<int>;
' zu 'template<class T> friend class PLTModuleID;
' gemacht
- PLRTTIDefs.h: Ca Zeile 150: 'template PLTModuleID<int>;' wurde entfernt da es Compiler Probleme verursachte.
  (die Zeile wird anscheinend auch nicht benötigt :)
  Desweiteren musste hier 'PLSystem.h' eingebunden werden und in PLBase.h wurde 'PLSystem.h' entfernt.
  (sollte keinen Unterschied machen - tut es aber ;-)



>> 07.05.2005
[CO]
- PLTBase::SetVars() minimal geändert so das auch 'PLTTextureCreatorASCII3D Name=ASCII3D' verstanden wird. In dem Fall wird
  wie üblich eine Fehlermeldung ausgegeben das bei 'PLTTextureCreatorASCII3D' ein '=' + Wert fehlt, der Rest wird nun aber 
  trotzdem weiterverarbeitet.
- PLTFileSystem::OpenInPaths() -> Hier wird nun zuerst in den Suchpfaden für den Typen (falls angegeben) gesucht, erst 
  wenn das nicht klappt wird versucht direkt zu öffnen. (ansonnsten hatte pszType keine Auswirkung)



>> 27.04.2005
[CO]
PLTConfig:
- Implementiere die Funktionen Load() und Save(). Load() ist kein größeres Problem, Save() hingegen bietet die Möglichkeit
  entweder ALLE aktuellen Konfigurationen zu speichern oder nur diejenigen welche in einer bestimmten Konfigurations-Gruppe 
  sind. PLTConfig::GetInstance()->Save("All.cfg"); speichert allso ALLES in eine Datei namens 'All.cfg', während
  PLTConfig::GetInstance()->Save("Engine.cfg", "PLTEngineConfigGroup"); NUR diejenigen Konfigurations Klassen in eine Datei
  speichert welche von PLTEngineConfigGroup abgeleitet wurden. PLTEngineConfigGroup hingegen wurde von PLTConfigGroup 
  abgeleitet. Auf die Art ist das Config-System nun sehr flexibel und man kann beliebig neue Gruppen von Gruppen von Gruppen
  etc. Erzeugen. Die Engine selbst läd/speichert also NUR 'PLTEngineConfigGroup'. :)
  Passte gleich PLRenderer (jedes Backend läd/speichert sich selbst), PLEngine und PixelLab + Plugins an. (nur minimalste 
  Erweiterungen :) Bei der Gelegenheit vergab ich dort auch gleich entsprechende Variable Namen.
- PLTFileSystem::AddBaseDir() -> Baute Abfrage ein ob dieser Basis-Pfad bereits Regestriert ist.



>> 23.04.2005
[CO]
Alle Projekte:
- Stellte bei ALLEN Projekten die Release Einstellungen etwas Resourcen schonender ein. Im Netz gibts nen kleinen 
  Artikel Namens 'Compiler Optimization Of MechAssault 2' wo diese Einstell 'Tips/Tricks' beschrieben wurden.
  - Exception handling /EHsc) wird Deaktiviert - wir verwenden dad sowieso nicht
  - Whole program optimization (WPO) Aktiviert



>> 10.04.2005
[CO]
- PLSingleton.inl: Hm, irgendwie will das mit PLTLog dort nicht funktionieren. Sobald das Log hier verwendet wird beendet 
  sich jedes Programm welches PLGeneralD.dll mal kurz prüft sofort ohne weitere Warnungen!??



>> 09.04.2005
[CO]
- Stellte PLGeneral auf neuen Kommentar Style um. PLSingleton.inl: Dort wo '[TODO] Add to log' stand stellte ich auf PLTLog
  um. PLTZipDate -> Packte die Inline Funktionen in PLZipDate.inl.



>> 20.03.2005
[SB]
- PLTZipStream::Read():
  Auch hier muß nun nSize und nCount angegeben werden, um Daten aus dem Stream auszulesen.
  Zwar wird intern wieder multipliziert und Byteweise gelesen, jedoch ist dies zur Kompatibilität
  mit anderen Funktionen nötig: Will eine Funktion einen Block von 18 Byte lesen, so ist der
  korrekte Rückgabewert nach dem Lesen '1', und nicht '18', die Anzahl der gelesenen Bytes muß
  also noch einmal durch die Blockgröße geteilt werden. Genau dies führte zum Fehler beim
  Lesen von "standardflare.tga", da der falsche Rückgabewert '18' gefunden wurde, brach DevIL
  das Lesen der Datei ab


  
>> 20.03.2005
[CO]
- PLTZipFile::Seek() -> Wird der Offset auf 0 gesetzt, so wird nur zurückgesetzt, aber nicht 0 Bytes gelesen.
  (könnte probleme machen)



>> 02.02.2005
[CO]
- PLTVar::Set() -> Fügte optionalen Parameter hinzu mit dem man den Aufruf von VarChanged() unterdrücken kann. Z.B. ist
  der Aufruf von VarChanged() in PLTBase::IsVarDefault() total ungünstig da im schlimmsten Fall hierdurch etwas kaputt gehen
  kann - das hatte ich beim Klonen im WE. Danach waren die Orginal Entities plötzlich in keiner Gruppe mehr da der Gruppen
  String leer war. Diese Gruppen wurden Dynamisch hinzugefügt - dumme Sache das, derzeit hab ich noch keine Ahnung was man
  da machen kann außer auch die Dynamischen Gruppen einfach zu diesem String hinzuzufügen.
  Zudem ist das hier in PLTBase::IsVarDefault() nen totaler Overhead. Mir gefällt das zwar irgendwie nicht mit diesem Extra
  Parameter da priniziell IMMER Informiert werden sollte, aber bis uns für PLTBase::IsVarDefault() was besseres einfällt ist
  das denk ich ok. Hauptsache es geht hier (vorallem im WE :) erstmal ohne oben Beschriebene Probleme beim einfachen
  Vergleichen zu erzeugen. Hatte mit VarChanged() auch bei PLTEntity Probleme wenn nen Entity noch nicht Initialiert war,
  aber bereits seine Variablen z.B. beim Initialisieren gesetzt wurden. Das umging ich dort über IsInitialized() Tests. 



>> 25.02.2005
[CO]
- PLTBase::GetVars() -> Intern auf PLTString umgestellt da ansonnsten der String aus PLTString wieder zerstört wurde und am 
  ende Schrott in pszBuffer Kopiert wurde.



>> 23.02.2005
[CO]
- PLTString um ein paar Sicherheits abfragen erweitert



>> 22.02.2005
[SB]
- Neue Klassen:
  - PLTVariant: Dies ist ein Variabler Datentyp, welcher verwendet werden kann wenn der Datentyp einer
    Variablen nicht feststeht. Dies wird bei dynamischen Parametern verwendet, auch könnte die Scriptsprache
    später gebraucht davon machen. Ansonsten sollte es aber eigentlich kaum Verwendung dafür geben :-)
  - PLTParameters: Dynamische Parameterliste, die bei Methodenaufrufen übergeben werden kann. Im Moment ist
    dies nur für den Konstruktor da, wenn das RTTI eine Klasse mit Parametern kreieren will. Sollte das
    RTTI später noch um dynamische Methodenaufrufe erweitert werden, wird diese Klasse auch dort Verwendung
    finden
- RTTI-Makros angepaßt:
  - DEFINE_CLASS erstellt keine öffentlichen Konstruktoren mehr, arbeitet also so wie vorher DEFINE_CLASS_PRIVATE
  - Zum Erstellen über CreateInstance() muß nun zusätzlich das Makros DEFINE_CONSTRUCTION_PUBLIC hinzugefügt werden
  - Zusätzlich kann ein Konstruktor definiert werden, dem Parameter übergeben werden können, dies geschieht mit
    DEFINE_CONSTRUCTION_PARAMS, der Konstruktor muß die form Class(PLTParams&) haben
  - Vor den Variablen muß die Liste mit DEFINE_VAR_LIST begonnen werden
  - Durch diese Änderungen war es nun möglich, das Registrieren der Variablen wieder einfacher zu gestalten,
    es müssen also keine Variablen mehr rückwärts und von vorne eingetragen werden. REDEFINE_VAR wurde
    ebenfalls entfernt, statt dessen werden bei DEFINE_VAR schon vorhandene Variablen mit dem gleichen
    Namen einfach überschrieben
  - Neue PL_VAR-Variablentypen hinzugefügt
  - Bei DEFINE_VAR muß nun immer auch der Enum-String als letzter Parameter angegeben werden, dafür wurde
    DEFINE_ENUM entfernt
  - Bei DEFINE_VAR kann hinter der Variablen nun noch ein Variablen-Name angegeben werden. Ist dieser "",
    wird wie bisher der richtige Name der Variablen verwendet
- PLTBase: IsVarDefault() hinzugefügt
- Klassen an neue RTTI-Definitionen angepaßt



>> 11.02.2005
[CO]
- RTTI: REDEFINE_VAR() funktioniert durch die letzte Änderung nicht mehr da die Basis-Variablen nun erst bei Init()
        eingetragen werden. Zuerst wollte ich ne PLTClass Interne Liste anlegen wo die dann bei Init() zu 'überschreibenden'
        Variablen eingetragen werden... Aber ich merkte schnell das dies etwas viel Aufwand ist - und wenn wir das so machen
        wollen wäre es das beste wenn Stefan, der sich ja deutlich besser mit dem RTTI auskennt das übernimmt. Ich entschloss
        mich stattdessen erstmal in den MeshLoadern DEFINE_VAR() zu verwenden. Und will die Basis-Klasse dann ihre gleiche
        Variable eintragen geht das schief da diese Variable bereits vorhanden ist. War die einfachste Lösung - nur Typ
        Sicherheit hat man damit nun natürlich nicht... da könnte man ne Warnung ins Log schreiben wenn wir das so lassen
        wollen...
        Macht REDEFINE_VAR() überhaupt noch Sinn? Denn dann müsste man auch DEFINE_ENUM() etc. Varianten anbieten.
- PLTLog::Open() -> Erzeugt nun ein neues Log wenn kein solches vorhanden ist.



>> 10.02.2005
[CO]
- PLTArray::AddAtIndex() und PLTList::AddAtIndex() waren noch nicht ganz ok. Wenn man ganz am ende ein neues Element einfügen
  wollte ging das noch nicht wie erwartet. Dadurch funktionierte bei mir dann das Regestrieren der Klassen-Variablen nicht
  richtig.



>> 09.02.2005
[SB]
- PLTConfig: Die Methoden GetVarb() etc. umbenannt in GetVarBool(), GetVarInt(), etc. Wie haben bisher immer aussagekräftige Namen
  verwendet, daher sollten wir dies auch hier tun. Es wäre zu überlegen, ob Methoden dieser Art nicht gleich in PLTBase
  eingebaut werden sollten, um es dem Programmierer zu erleichten, auf Variablen zuzugreifen (ist natürlich dann
  schlecht, wenn der Programmierer den falschen Typ verwendet).
- PLTConfig: Habe AddClass() wieder entfernt und durch eine simple "Create-On-Demand" Lösung ersetzt, da mir kein Grund einfiel,
  der dagegen sprach :-) Wenn jemand versucht, auf eine Konfiguration eines bestimmten Typs zuzugreifen, wird erst
  einmal geschaut, ob es diese schon gibt. Wenn nicht, wird das Objekt in dem Moment erzeugt und zurückgegeben.
  Sollte während das Programm läuft niemand versuchen, auf eine Config-Klasse zuzugreifen, wird diese auch niemals
  erzeugt, was ich auch für genau richtig halte, warum sollte man erst einmal alle möglichen Objekte erzeugen,
  wenn diese dann gar nicht gebraucht werden? Wir müssen da nur evtl. beim Speichern darauf achten, aber es stellt
  sich mir sowieso die Frage, ob das Speichern der gesamten Konfiguration sinnvoll ist, da ja z.B. Game-Config und
  Engine-Config nicht zusammen in eine Datei kommen sollten.
- PLTSystem: Eintragen der Config-Klassen wieder ausgebaut (s.o.). Lösungen dieser Art sollten grundsätzlich vermieden werden,
  da sie die Hierarchie eines Systems durcheinander bringen. PLTSystem steht ganz oben in der Hierarchie, d.h. alle
  anderen Teile der Engine verwenden PLTSystem, aber PLTSystem weiß nichts von diesen anderen Teilen. Wenn wir nun
  anfangen, das zu ändern (PLTSystem weiß plötzlich von PLTConfig und trägt dort Klassen ein), wird das ganz schnell
  unüberschaubar, da in beide Richtungen aufeinander zugegriffen wird - wozu das führen kann, sah man sehr deutlich
  beim alten FS, wo GetValidFileName() zu abwechselnden Aufrufen im Manager und im FS führte, dadurch konnte überhaupt
  nicht nachvollzogen werden, was wo getan wird und welches System wofür verantwortlich ist. Das gleich könnte leicht
  bei PLTConfig und PLTSystem passieren, wenn nun PLTConfig im Gegenzug anfängt, neue Klassen einzutragen, und schon
  pendeln die Aufrufe wieder hin und her. Darum also: Aufrufe immer nur in eine Richtung, so daß die Hierarchie erhalten
  bleibt, niemals wieder zurück vom oberen Teil der Hierarchie in untergeordnete Teile.
- PLTSystem: Beim Eintragen der Klassen wird nun geschaut, ob die Basisklasse bereits registriert wurde, ist dies nicht der Fall
  wird so lange gewartet, bis die Basisklasse da ist und erst dann die Registrierung der Variablen aus dieser
  Basisklasse vorgenommen. Damit die Variablen in der richtigen Reihenfolge bleiben, mußte ich bei den Schleifen und beim
  Eintragen der Variablen etwas tricksen, schönere Lösungen wären hier sehr willkommen. Bitte mal schauen ob die Probleme
  damit gelöst sind, in meinen Tests hat's jedenfalls funktioniert :-)
- PLTSystem: Mir ist aufgefallen, daß immer wieder PLGENERAL_API zu allen Funktionen hinzugefügt wird. Dies ist ok, wenn es wirklich
  benötigt wird, also die Funktion soll von außen verwendet werden und es gibt unaufgelöste externe Symbole aufgrund des
  fehlenden Exports. Ist dies aber nicht der Fall, bitte nicht einfach so hinzufügen, denn die Entscheidung, welche
  Methoden exportiert werden sollen und welche nicht, ist an den meisten Stellen schon mit Bedacht gewählt worden!
  Dies ist z.B. eine gute Möglichkeit, um noch etwas mehr Sicherheit zu gewährleisten, indem Methoden, die nur intern
  verwendet werden sollen, auch nur intern aufgerufen werden können (im System ist dies z.B. bei kritischen Methoden
  wie dem Hinzufügen von Modulen der Fall). Dies kann dann auch nicht durchs Verändern eines Headers (protected in
  public ändern) umgangen werden, und ist daher für solche kritischen Methoden nützlich.
  Also bitte immer überlegen, ob das Exportieren einer Methode wirklich gewünscht ist, und nicht einfach alle Methoden
  exportieren.



>> 08.02.2005
[CO]
- PLTResourceHandler: Machte SetResource() virtuell da es man z.B. in PLTSkeletonHandler sobald eine Resource gesetzt wurde
  diverse Aufgaben erledigen muss.




>> 05.02.2005
[CO]
- PLTConfig: Neue Funktion: AddClass() -> Da jederzeit neue Module mit eventuell neuen Konfigurations-Klassen darin
  eingeladen werden können war es nötig eine Funktion anzubieten um neue Config-Klassen zu regestrieren.
  In PLTSystem::RegisterClass() wird nun versucht die neue Klasse in PLTConfig einzutragen - mir viel da 
  keine bessere Möglichkeit ein... vielleicht wäre da ne art von System-Listener angebracht, falls man noch
  an anderen Stellen mitbekommen möchte wenn z.B. neue Klassen regestriert/entladen werden.
- PLTFile: Die Read&Write Funktion wurde so erweitert das man auch Count angeben kann -
  das war leider nötig da DevIL nicht korrekt laden konnte wenn man nSize*nCount direkt berechnete und als zu
  lesende Bytes übergab - da gibts anscheinend intern irgendwo doch nen Unterschied. 
  Auch bei ZLib ists nen Unterschied wenn man die Parameter size und count bei fread vertauscht.
  Stefan, wenn du weißt wieso dad so iss kläre mich bitte auf - ich kanns mir momentan noch nicht Erklären. ;-)



>> 04.02.2005
[CO]
- PLTResourceManager: In Create() wird nun die interne Funktion CreateResource() verwendet welche man in einem konkreten
  Manager überschreiben MUSS. Da das mit der automatischen Erzeugung im Template nicht klappt falls
  der Resource-Typ abstrakt ist, wie dies beim Sound-Manager der Fall ist, musste das geändert werden.



>> 02.02.2005
[CO]
- Ein paar kleinigkeiten an den Resource-Templates geändert



>> 01.02.2005
[CO]
- Neue Funktion: PLTFSTools::GetRelativePath() -> Macht aus einem Absoluten Pfad wenn möglich einen Relativen 
- PLTWin32FSTools::ConvertToWindowsPath() & PLTFSTools::ValidatePath() -> Kleine Laufwerksbuchstaben werden zu
  Großbuchstaben gemacht da es sonst Probleme geben kann. (ich hatte da eines in AddBaseDir() :)



>> 01.02.2005
[SB]
- PLFSTools, PLPlatform: Nannte FileNameEnding in FileExtension um.
  Dieser Begriff sollte wohl allgemein bekannt sein, und wir sollten es dem User nicht unnötig schwer machen :-)
- PLSearchHandle: Nahm die Änderung, daß '.' und '..' grundsätzlich aufgelistet werden, wieder heraus (und wenn ich
  es richtig sah, wurden inzwischen sogar alle Verzeichnisse aufgelistet). Dies mag an einigen Stellen nützlich sein,
  doch es gibt genügend Situationen, in denen das ausdrücklich nicht gewünscht ist, doch die können dann nichts
  mehr daran ändern (z.B. versucht unser PluginSystem "." und ".." als DLL zu laden, was sicher nicht gut ist).
  Wenn also alle Verzeichnisse sowie bestimmte Dateien gefunden werden sollen, sollte dies ist zwei
  Schritten erfolgen, worin ich kein Problem sehe (der FileDialog macht dieses ja auch genau so), denn diese Lösung
  behindert im Gegensatz zur anderen nicht die entsprechend andere Situation.



>> 31.01.2005
[CO]
- Machte PLTProfiling zum Singleton und passte Engine etc. an.



>> 29.01.2005
[CO]
- Nahm die Module-Templates aus der Engine, benannte diese in ResourceManager etc. um, überarbeitete diese etwas - diese
  Resource-Templates liegen im Base-Unterordner da es universelle Grundklassen sind die man überall gut brauchen kann.
  Dabei implementierte ich es so das man auch Resourcen & Resource Handler OHNE Resource Manager verwenden kann. Ist jedoch
  ein solcher Resource Manager vorhanden so MUSS jede Resource einen einmaligen Namen bestitzen - und das wird intern 
  auch sichergestellt. :)
  Somit können diese Resource & Resource Handler Templates auch in PLRenderer, PLSound etc. verwendet werden, denn dort gibt
  es auch Resourcen, allerdings ohne konkreten Manager dahinter da dies dort unnötig ist - das würde sonst dort zuviel des
  guten sein.
- Die konkreten Template Implementationen von PLTStack, PLTHashTable, PLTHeapBinary, PLTSingleton liegen nun in seperaten
  'inl'-Dateien. Ich finde es einfach übersichtlicher wenn im Header NUR das Interface liegt. :)


>> 26.01.2005
[CO]
- PLTConfig: Funktionen wie GetVarb() hinzugefügt mit dem man komfortabel gleich den Boolean Wert abfragen kann etc.
- PLTFileType::AddSearchPath(): Pfad wird nun intern bei Bedarf 'korrigiert'



>> 21.01.2005
[CO]
- PLTPlatform: GetTickFrequency() entfernt und PLTTimer entsprechend angepasst. Dies war nötig da es erstens so nicht
  unter Linux ging (dort hab es schwere Probleme mit dem richtigen Timing...) und zweitens war das mit der extra Frequenz
  sowieso nicht so brall. ;-) Da der Name 'TickCount' nicht wirklich aussagekräftig war, benannte ich ihn in
  GetMilliseconds() und GetMicroseconds() um, damit weiß man auch sofort in welcher Einheit man die vergangene Zeit
  zurückbekommt. Ein paar Dateien mussten in diversen Teilprojekten angepasst werden, aber nun müsste das etwas Sauberer
  sein.



>> 17.01.2005
[CO]
- Kleinen Fehler in PLTFile::Seek() behoben - das viel mir erst auf als bei FMod das Streaming aus PLTFile einfach
  nicht funktionieren wollte - nun gehts. ;-)



>> 10.01.2005
[CO]
- PLTPlatform: Neue Funktion: GetModuleFileNameEnding() -> Gibt die Dateiendung von Modulen, also unter Windows 
  'dll' und unter Linux 'so' zurück. PLTSystem::ScanPlugins() verwendet nun diese Funktion. Das IMMER über #ifdef
   zu machen wäre keine so dolle Lösung gewesen. :)
- PLRTTIDefs.h: Foreward declaration von PLTSystem eingefügt da es ansonnsten unter Linux einen Compiler
  fehler gibt.
- PLGeneralWin32.h/PLGeneralLinux.h: Dort wird nun PLEXPORT/PLIMPORT definiert da man dies ja seehr oft benötigt.
  PLRTTIDefs.h -> DEFINE_MODULE_PLUGIN verwendet nun PLEXPORT. (ging ja sonst so nicht unter Linux :)
-> Das waren noch die paar Dinge wie Port-mäßig gemacht werden mussten. Damit es unter Linux problemlos übersetzen geht.
- PLStack.h: Nahm PLGeneral.h include raus da ich dann z.B. beim Max Exporter nun durch die weiter intern
  eingebundenen Dinge dazu gezwungen bin PLGeneral dort miteinzubinden was ich aber nicht will. :)
- PLTPlatformWin32::LoadModule() -> Der Dateiname wird nun zuerst in einen Win32-Pfad umgewandelt bevor die Lib
  geladen wird.



>> 10.01.2005
[SB]
- Die Änderung vom 29.12. geht leider so nicht, weil sie dazu führt, daß der DestructionManager
  nicht mehr korrekt gelöscht wird und somit ein Speicherleck entsteht:
  DestructionGuard wird beim beenden deinitialisiert und löscht den DestructionManager
  -> dieser löscht alle Singletons
  -> Singleton ruft PLTDestructionManager::GetInstance()->RemoveObject(this) auf
  -> Dadurch wird der DestructionManager neu erzeugt und nie wieder gelöscht.
  Dies habe ich nur deswegen so ausführlich aufgeschrieben um klarzumachen, daß kleine und völlig
  harmlos aussehende Änderungen beim RTTI sehr bösartig sein können, da das RTTI leider auf vielen
  Tricks basiert, aber genau dies ermöglicht erst, daß es so gut und einfach zu bedienen ist :-)
- Habe nun DestructionManager und DestructionObj gelöscht, statt dessen hat jede Singleton-Klasse
  ab jetzt einen eigenen DestructionGuard, welcher das Singleton beim Beenden wieder löscht
  (damit ist die Abhängigkeit der Singletons von einem weiteren Singleton nicht mehr gegegeben).
- Die Klassen eines Moduls melden sich beim Beenden nicht mehr vom System ab, weil dies ein
  ähnliches Problem wie oben ergab: Die Reihenfolge der Deinitialisierung statischer Variablen
  wird vom Compiler vorgegeben und kann nicht beeinflußt werden, es passiert also, daß zuerst
  das PLTSystem-Singleton gelöscht wird und dann die Klassen eines Modules deinitialisiert werden,
  wenn diese dann PLTSystem::GetInstance()->Remove() aufrufen, wird PLTSystem neu erstellt und
  wir haben wieder ein Speicherleck.
  Um die Abhängigkeiten möglichst gerin zu halten, melden sich also die Klassen nicht mehr ab,
  sondern nur noch das Modul, wodurch automatisch alle Klassen entfernt werden. Um das Problem
  hier zu beheben, gibt es in PLTSingleton nun noch eine Methode CheckInstance(), welche nur die
  Instanz zurückgibt aber keine erstellt. Im oben genannten Fall meldet sich ein Modul also
  nicht mehr ab, wenn das System bereits deinitialisiert worden ist, denn in diesem Fall
  wurden ja sowieso schon alle Klassen beim Beenden gelöscht.



>> 09.01.2005
[CO]
- PLTPool: GetElements() in GetNumOfElements() umbenannt, PLTProfiling musste entsprechend angepasst werden.
- PLTArray & PLTBitset & PLTList: Compare() so umgeschrieben das der Operator != nun nicht mehr zwangsläufig vorhanden
  sein muss



>> 03.01.2005
[CO]
- PLTSearchFilter::CheckMatch() -> '.' und '..' kommen nun immer durch den Test, ansonnsten gibts probleme beim Auflisten
  des Inhaltes eines Verzeichnisses.
- PLTFSTools::GetFileNameEnding() -> Berücksichtigt nun auch nicht vorhandene Dateinamen Endungen
- PLTFSTools::ValidatePath() -> Fügt nun am Ende des Pfades noch ein / an falls dort keines ist damit Pfade immer mit /
  Enden.



>> 29.12.2004
[SW] + [CO]
- Die Linux Tests Crashten immer nachdem das Programm bendet wurden - nach Stundenlanger Such und dem durchgehen aller
  möglichkeiten waren wir schon nahe am Verzweifeln da man sich den Crash einfach nicht erklären konnte. Tja, und irgendwie
  landeten wir dann eher per Zufall im Destruktor von PLTDestructionManager und dort Crashte es beim Löschen eines Objektes.
  Es stellte sich raus das Zeiger ungültig waren - ein Blick auf den Destruktor von PLTDestructionObj zeigte das sich Objekte
  nicht wieder bei Tot abmeldeten sondern sich einfach ins Nirvana schlichen. ;-)
  Kleines Problem, merkwürdige Phänomene - viele Stunden suchen. ;-)
- PLGeneral und PLMathLib auf Linux portiert:
  -> Nun laufen PLBaseTest, PLFileTest und PLMathTest auch problemlos und sauber unter Linux - wir haben Teils auch alles über
     Eclipse Debugt etc. Jetzt da diese Dinge auf zwei Platformen laufen kann man annehmen das es so nun schon recht ordentlich
     ist.  :):)



>> 27.12.2004
[CO]
- Passte PLTTimer an die aktuellen Änderungen an. Die Timer Klasse verwendet nun PLTPlatform und ist dadurch Platform unabhängig
  und die ganzen Timer Platform-Dinge konnten entfernt werden - erleichtert das Portieren. :)
- Erweiterte PLTPlatform um GetTickFrequency() - wird für PLTTimer benötigt
- Dort wo in PLGeneral noch PLTDynamicList verwendet wurde stellte ich auch PLTArray um. Hab nun die alten Listen Klassen +
  PLTDataSet was wir ja mittlerweile nicht mehr brauchen gelöscht. Desweiteren alte Stack-Klasse herausgenommen.
  -> Endlich wieder Ordnung in PLGeneral - da Stephan und ich uns die nächsten Tage intensiv mit der Linux Portierung beschäftigen,
     wollte ich dieses alte Zeug draußen haben so das wir nicht mit unnötig vielen Dateien jonglieren müssen.



>> 26.12.2004
[CO]
- PLTArray: Musste internes Speicher Management etwas umstellen da es Probleme mit Klassen welche Klassen etc. beinhalten gab
  ... diese wurden dann nicht korrekt Initialisiert wenn alle Element in einem großen Buffer lagen. Nun hat PLTArray einen Buffer
  aus Zeigern auf die Elemente welche über new erzeugt und über delete wieder gelöscht werden... hat den kleinen Vorteil das nun
  auch die Konstruktoren & Destruktoren verwendung finden. :)
  -> Mittlerweile ist auch das merkwürdige Static Initialization Problem in der Engine verschwunden und alles läuft wieder
     einigermaßen - so langsam müssten die Container Klassen aber so passen. :):)



>> 25.12.2004
[CO]
- PLTFileSystem: Um GetNumOfFileTypes() & GetFileType() & RemoveFileType() erweitert damit ich in 
                 GuiFileSystemDialog die Search Path Ansicht füllen konnte
- In PLTFileSystem::AddSearchPath() wurde der File Type Name nicht korrekt gesetzt
-> Diese Änderungen wurden nur gemacht um GuiFileSystemDialog implementieren zu können - es zeigte sich ja schon bei
   GuiSystemView das es ganz Praktisch ist diese Dinge über einen Dialog 'anfassbar' zu machen... zudem wird dieser Dialog
   auch in PixelLab verwendung finden damit man Einstellen kann von wo die Daten kommen sollen.
- PLTBitset & PLTArray: Resize() kann nun optional mitgeteilt werden das ALLE Speicherplätze für Elemente automatisch
  zugreifbar sind... ist dann so als hätte man alle Elemente einzelnd hinzugefügt. Dies ist immer wieder nützlich wenn man
  einfach ein Feld haben will bei dem man frei auf die Elemente zugreifen kann ohne vorher alle über Add hinzugefügt zu haben
  wie dies bei 'normalen Listen' der Fall ist.
  Wenn man Resize() per Hand aufruft sind immer standardmäßig ALLE Elemente gleich verfügbar, so, als hätte man alle über Add()
  hinzugefügt - denn wenn man schon selbst Resize() aufruft erwartet man normalerweise das alles gleich zugreifbar ist, xxx
  mal beim Array Add() aufzurufen wäre schlichtweg zu umständlich. :)



>> 24.12.2004
[CO]
- PLContainer: AddAtIndex(int nIndex) hinzugefügt um ein neues Element an einer bestimmten Stelle zu erzeugen
- In PLTConfig() korrekten Config Klassen Name gesetzt



>> 22.12.2004
[CO]
- PLTFSTools: Neue Funktionen: - GetFileNameEnding() -> Liefert die Datei-Endung zurück
                               - CutFileNameEnding() -> Liefert Dateinamen ohne Endung
                               - GetDirectory() -> Liefert das Verzeichniss eines Dateinamens zurück
- PLContainer Klassen minimal erweitert



>> 21.12.2004
[SB]
- PLTBase.h: Die virtuelle Funktionen stehen nun in einem eigenen Bereich, wie wir es sonst auch meistens haben. Ich finde
  das zwar an dieser Stelle etwas unschön, da z.B. die beiden ToString() Methoden damit auseinandergerissen werden, es
  dient jedoch der Übersicht des Programmierers. Die Dokumentation der Methoden habe ich auch noch etwas erweitert.
- PLGeneral: Die Definition von systemabhängigen Klassen wird nun einheitlich in den Include-Dateien für das jeweilige
  System vorgenommen. Dies führt zwar dazu, daß einige Header immer eingebunden sind, scheint mir jedoch besser zu sein,
  da dann alle Plattformdefinitionen an einem Ort sind und somit schnell wiedergefunden werden können.
- FileSystem: PLNativeDirectory.h gelöscht und die Definition entsprechend nach PLGeneralWin32/Linux.h verschoben
- PLTTimer: Anpassung an unseren üblichen Stil, die Basisklasse ist nun abstrakt, da es kaum sinnvoll ist, diese direkt
  zu instanziieren (es gibt ja auf jeder Plattform eine systemspezifische Implementierung). Die Konstrukturen/Destruktoren
  sind nun protected (nicht unbeding nötig, aber einheitlich), und auch die Basisklasse besitzt Konstruktur/Destruktor
  wobei der letztere virtuell ist, da die Klasse virtuelle Methoden besitzt. Auch hier wurde die Definition von PLTTimer
  verschoben
- PLTPlatform: Neue Klasse, welche plattformabhängige Systemfunktionen enthält. Der Einfachheit halber, und weil man es
  vom Namen her sowieso so erwarten könnte, habe ich PLTSystem einfach von dieser Klasse abgeleitet - damit braucht man
  sich nicht mehr überlegen, wer wo eine Instanz davon erzeugen könnte sondern bekommt diese bei PLTSystem::GetInstance()
  ja gleich mit (nur für die Doku ist es nicht so schön, weil die Systemfunktionen nicht direkt in PLTSystem dokumentiert
  sind, allerdings sollten diese Funktionen sowieso nicht von einer Applikation verwendet werden, da wir ja alles schön
  mit unserem eigenen System abgekapselt haben). Auch die Timerfunktionen sind jetzt in PLTPlatform zu finden - fragt
  sich ob das so gut ist, wenn ja müßten wir eigentlich auf die Unterteilung der Timerklassen verzichten können, oder?
- PLTSystem: Zum Zugriff auf dynamische Bibliotheken wird jetzt PLTPlatform verwendet, womit PLTSystem jetzt hoffentlich
  plattformunabhängig ist



>> 21.12.2004
[CO]
- Behob kleines Problem in PLTBase::GetVars() mit dem vergleichen von Default-Werten - denn z.B. bei float-Werten können
  u.a. am ende noch diverse Nullen sein - um solche Probleme zu verhindern wird zuerst der aktuelle Wert der Variable gespeichert,
  dann wird der Default Wert gesetzt welcher dann wieder als String ausgelesen wird, anschließend wird der Variable Wert wieder
  auf seinen aktuellen Wert gesetzt - und nun hat man zwei vergleichbare Strings welche bei float Zahlen am Ende gleich viele  
  Nullen haben wodurch korrekt geprüft werden kann ob dies wirklich der Default Wert ist.
  -> bei pVar->Set() ist es an dieser Stelle unnötig und vielleicht auch etwas Riskant das in Set() pObject->VarChanged(m_szName);
     aufgerufen wird, vielleicht könnte man es hier noch etwas schöner machen - hab aber die Finger davon gelassen da es ansonnsten
     zu viele Änderungen geworden wären... Stefan, wenn du Zeit und Lust hast kannst du ja mal schaun wie man das besser Lösen
     könnte. :)
- Bei PLTBase::ToString() -> pszBuffer[nCopy+1] zu pszBuffer[nCopy] gemacht da das letzte Zeichen ansonnsten Schrott war :(
- PLTIterator um Funktionen erweitert um zum vorherigen Element zu springen, dies ist hin und wieder nötig wenn z.B. während
  der Iterator verwendet wird ein Element aus der Liste gelöscht wird, in dem Fall muss man den Iterator um ein Element 
  zurücksetzen und ganz nebenbei wird nun endlich auch pPreviousElement in PLTList verwendet.
  (Previous() brauchte ich zum ersten mal in GuiSys::Update())
- PLContainer: AddAtIndex() ist Index = -1 wird nun am Ende eingefügt (wie früher)



>> 19.12.2004
[SB]
- Containerklassen in PLGeneral eingebaut, dabei die alten Klassen umbenannt, damit diese noch verwendet werden können
  und schrittweise umgestellt werden kann
- Iteratoren: Remove() entfernt, ein Iterator dient nun nur noch zum Anschauen der Container, nicht zum Ändern. Dadurch
  ist es auch möglich, Iteratoren von const-Listen zu erhalten, dies ging vorher leider gar nicht
- Container: Jeweils einen operator= hinzugefügt, welcher die selbe Klasse als Parameter erwartet. Dies scheint leider
  nötig, da der Compiler diese Methode anscheinend implizit verwendet und nicht die vorhandene Methode mit PLTContainer
  als Parameter verwendet, wenn beide Operanden vom selben Typ sind (bei z.B. *pList = *pArray geht es dagegen!)
- PLGeneral: Auf neue Containerklassen umgestellt. Zunächst ist dies nur eine 1:1 Umstellung, also noch keine Verbesserung
  der Interfaces was Listen/Container angeht, dies wird im nächsten Schritt passieren (erstmal sehen, ob alles noch
  funktioniert)
- RTTI: Kleinen Fehler bei der Registration von Modulen behoben. Wenn ein Module zuerst registriert wird, bevor Klassen
  aus diesem Modul registriert worden sind, war die ModuleID noch nicht gesetzt worden, was dazu führte daß die Klassen
  nicht dem Modul zugeordnet werden konnten. Da man auf die Reihenfolge der Initialisierungen keinen Einfluß hat (das
  macht der Compiler), kann dies mal so und mal so passieren, es muß also in beiden Fällen funktionieren - und ich hatte
  es auf den worst-case ausgelegt, so daß der best-case fehlerhaft war ;-))



>> 19.12.2004
[CO]
- PLTFSTools: Um GetPathInfix() erweitert damit es vollständig ist. (prefix, infix & postfix :)
  Wollte das zuerst in GuiSys::SaveWindows() verwenden, dort reicht aber schon GetPathPrefix().



>> 18.12.2004
[CO]
- PLTVar::SetFlagsString(): Kleine zusätliche Abfrage eingebaut damit bei Flags am anfang kein '|' steht.
- PLTVar: Musste m_szEnum vergrößern da z.B. bei GuiSlider mehr Zeichen benötigt werden (hab lustige fehler am ende :)
- PLTFile::PrintLn() musste Buffer etwas vergrößern da es oft nicht reichte - vielleicht finden wir da bei Zeiten ne bessere
  Lösung für die Dynamische Übergabe von Strings - f(char *text, ...)



>> 18.12.2004
[SB]
- PLTClass:  Constructor und Destructor sind jetzt protected, da ja nur die Klassen selber eine Instanz von sich erzeugen
             sollen und diese dann selbständig am System anmelden
- PLTModule: Die Informationen über das Modul wurden in zwei Teile aufgeteilt, einmal dem Info-Teil bestehend aus
             Name/Vendor/Description, und dem Handle-Teil, bestehend aus ModuleID, Instance-Handle und Dateinamen
- PLTSystem: Neue Funktion zum Registrieren von Modulen eingebaut. Ein Modul wird erzeugt, sobald die erste Klasse aus
             diesem Modul registriert wird, dann wird auch die Module-ID zugeordnet, danach kann dann diese Funktion
             verwendet werden, um die Informationen über dieses Modul zu setzen
- PLTSystem: Einige Umstrukturierungen sowie Namensänderungen der Funktionen, die Funktionen zum Registrieren sind nun
             protected, womit das ganze wenigstens halbwegs sauber ist ;-)
- RTTI:      Makros zum Registrieren von Modulen so angepaßt, daß diese sich per Selbstinitialisierung nun ebenfalls beim
             System anmelden, um ihre Informationen zu übertragen. Dadurch können nun sowohl interne als auch plugin-module
             registriert werden, die Makros wurden dafür entsprechend angepaßt und erweitert
- PLGeneral: Hauptdatei PLGeneral.cpp hinzugefügt, in welcher das PLGeneral-Modul registriert wird



>> 15.12.2004
[CO]
- Neue Listen-Klassen geschrieben welche die alten ersetzen werden. Es gibt nun eine universelle abstrakte Klasse namens
  PLTContainer. PLTList, PLTArray und PLTBitset werden davon abgeleitet. Desweiteren gibt es eine universelle Iterator
  Klasse für die es jeweils pro Listen-Art eine spezielle Variante gibt. Die Codes hab ich noch nicht in PLGeneral 
  geladen da Stefan die Anpassungen in PLGeneral & PLGui vornehmen wird.



>> 13.12.2004
[CO]
- PLConfig.h: PLTConfigGroup eingeführt, alle Configurations Gruppen sollten davon abgeleitet werden.



>> 13.12.2004
[SB]
- Module:    Es gibt nun für jedes Module eine eindeutige ModuleID, welche von PLGeneral und nicht vom System vergeben wird.
             Über diese ID sollten die einzelnen Module angesprochen werden, da dies auf jeder Plattform funktioniert,
             die System-Handles sollten nur noch dann verwendet werden, wenn z.B. ein Modul wieder entladen werden soll,
             was jedoch innerhalb von PLTSystem passiert (es dürfte also eigentlich gar keinen Grund geben, das System-Handle
             anstatt der ModuleID zu verwenden).
- Module:    Klasse überarbeitet, so daß nur PLTSystem die wichtigen Daten der Klassen ändern kann sowie Zugriff auf die
             darin enthaltenen Klassen hat. Ebenso einige Änderungen bezüglich der Daten, da bei neuen Module zunächst
             nur die ModuleID bekannt ist, während die anderen Daten (Dateiname, Name, Vendor) erst später bekannt
             werden. Btw: Es hat seinen Grund, daß der Name nur Module und nicht PLTModule ist :-)
- PLTClass:  Anstatt des Module-Handles besitzt die Klasse nun nur noch die ModuleID ihres Modules
- PLTSystem: Auch hier wurden die Module-Handles durch Module-IDs ausgetauscht. Außerdem besitzt diese Klasse nun eine
             Methode, um die eindeutigen IDs zu erzeugen, dies wird von den RTTI-Makros benutzt um für jedes Modul
             eine eigene ID zu erhalten
- RTTI:      Die Makros wurden so geändert, daß sie pro Modul eine eindeutige ID erhalten und diese in ihren Klassen
             vermerken. Damit ist das System in der Lage, jede Klasse einem eindeutigen Modul zuzuordnen, auch wenn
             das System-Handle dieses Modules zur Zeit der Registrierung noch nicht bekannt ist (was leider immer
             der Fall ist, deswegen kann nicht einfach die HINSTANCE durchgereicht werden). Um dies zu erreichen,
             speichert eine Template-Klasse die ModuleID, welche sie vom System bekommen hat, und gibt diese an
             die Klassen weiter. Später setzt das System die zugehörigen Daten wie System-Handle, Dateinamen etc.
             im Modul, so daß diese Daten angezeigt werden können. Anmerkung: Dieses Vorgehen führt dazu, wirklich
             jedes Modul seine eigene ID bekommt, auch alle nicht dynamisch geladenen, dadurch sind also
             PLGeneral/PLEngine/PLGui/etc. unterschiedliche Module, welche allerdings erstmal alle den Namen
             "Internal" bekommen (wie kann man von loadtime-gelinkten DLLs den Namen herausbekommen?). Ob das ein
             Vor- oder Nachteil ist, kann unterschiedlich sein, wenn jemandem einfällt, wie man anders die Module
             und Klassen zuordnen kann, bitte sagen :-)
- PLTClass:  Der Gruppenname wurde entfernt, dafür kann jede Klasse als Basisklasse einer Gruppe definiert werden, welche
             dann alle abgeleiteten Klassen enthält
- RTTI:      Das Makro DEFINE_GROUP() angepaßt
- PLTSystem: Gruppen wurden entfernt, dafür kann bei GetClassList() die Basisklasse angegeben werden. Zusätzlich können
             alle als Gruppen definieren Klassen zurückgegeben werden



>> 12.12.2004
[CO]
- Bei der Klasse Module fehlten noch ein paar PLGENERAL_API - vielleicht sollte man diese Klasse bei Zeiten in 
  PLTModule umbenennen damit es einheitlich ist.
- PLTSystem::UnloadPlugin() -> Nur Dynamische Module können entladen werden
- PLTSystem::ScanPlugins() -> verwendet nun LoadPlugin() um die Module einzuladen
- PLTSystem::LoadPlugin() -> Module werden nun korrekt regestriert
- IsClass(), IsClassGroup() und IsModule() - hm, vielleicht wäre ne art von Iterator Klasse nicht schlecht damit das 
  überall einfach Einheitlich ist :)



>> 30.11.2004
[SW]
- PLGeneral: linux port + project archiv upgedated



>> 29.11.2004
[SB]
- PLTBase: Der Destruktor ist nun wieder protected, da dies unbedingt nötig ist, wenn das ganze RTTI System überhaupt
           einen Sinn machen soll. Das Problem ist, wenn der Destruktor in PLTBase öffentlich ist, kann jede Klasse
           damit gelöscht werden, es besteht für die Klasse also keinerlei Möglichkeit mehr, dies zu verhindern. Damit
           wird die Verwendung von DEFINE_CLASS_PRIVATE() nutzlos, und alle Sicherheitsvorkehrungen von abgeleiteten
           Klassen können damit umgangen werden: z.B. PLTRefCount ist so angelegt, daß es sich nur selber löschen
           kann, wenn der RefCount auf 0 sinkt, dies stellt sicher daß das Objekt niemals gelöscht werden kann, wenn
           es noch irgendwo gebraucht wird. Wenn nun aber PLTBase einen öffentlichen Destruktor hat, wird es
           möglich, dieses Verhalten von PLTRefCount zu umgehen und das Objekt von außen ungeachtet des RefCounts
           zu löschen, was natürlich gravierende Fehler zu Folge haben könnte. In PLTBase ist dies nun außerdem
           näher erleutert, warum Constructor und Destructor von PLTBase protected sind :-)
- RTTI:    Habe das RTTI nun so erweitert, daß ein Objekt mit PLTBase::Destroy() gelöscht werden kann, FALLS dessen
           Klasse mit DEFINE_CLASS() und nicht mit DEFINE_CLASS_PRIVATE() definiert wurde. Auf diese Weise kann
           man ein Objekt nur mit Hilfe eines PLTBase-Pointers löschen, aber nur wenn die Klasse dies explizit
           erlaubt, denn dies ist wichtig um die Wahl bei den Klassen zu belassen (s.o.).
           Hierzu waren einige Änderungen in PLTBase, PLTClass und PLRTTIDefs notwendig



>> 26.11.2004
[CO]
- PLTBase: Musste Destruktor public machen damit ich Klassen Instanzen von denen ich nur einen Zeiger auf 
  PLTBase habe auch wieder zerstören kann. Ich hoffe das ist ok so - ich fand keine andere möglichkeit...
  (siehe PLTConfig::~PLTConfig())
- Neues Configuration-System PLTConfig als Singleton implementiert. Dieses Config-System verwendet das RTTI
  und lässt sich daher sehr einfach bedienen und erweitern. Load() & Save() ist noch nicht implementiert,
  ansonnsten funktioniert alles.
          


>> 24.11.2004
[CO]
- Neue Datenstruktur: PLTHeap welche als Prioritätswarteschlange verwendet werden kann. Bereits implementierter
  konkreter Heap: PLTHeapBinary. Ich entschloss mich zu dieser abstrakten Template realisierung damit der Schlüssel
  und der damit verbundene Wert sowie die konkrete Implementation möglichst universell sind.



>> 21.11.2004
[CO]
- PLTQuickSort: QuickSort Algorithmus der später u.a. zum sortieren der Partikel verwendet wird. Ich hab versucht
  die Klasse so allgemein wie möglich zu halten, die Compare Funktion wird ähnlich wie in Java über eine abgeleitete
  Klasse implementiert. Lässt sich im Prinzip also genauso verwenden wie das bereits in VC vorhandene qsort - aber
  ich denke es ist das beste wenn man da was eigenes hat, man weis ja nie... ;-)



>> 21.11.2004
[SB]
- PLMain.h: Diese Datei beinhaltet nun einen plattformunabhängigen Einstiegspunkt für die Programme. Die Lösung per Makro
  war zwar eine gute Idee, jedoch nicht wirklich praktikabel, da ein Zugriff auf Programmparameter und Optionen damit 
  faktisch unmöglich gemacht worden wäre, denn diese Parameter wären nach wie vor je nach System unterschiedlich gewesen.
  Auch fand ich die Verwendung dieser Makros nicht sonderlich schön, da innerhalb eines Makros-Blocks dann der
  Funktions-Quellcode gestanden hätte, man aber gar nicht gewußt hätte, wie diese Funktion nun wirklich aussieht.
  Ein Programm, welches die plattformunabhängige Einstiegsfunktion verwenden will, muß nun einfach PLMain.h einbinden
  und die Funktion PLMain deklarieren, die Parameter dieser Funktion sind dabei nun wirklich auf jedem System gleich,
  da sie je nach OS unterschiedlich implementiert wird.
  Es muß natürlich darauf geachtet werden, daß PLMain.h nur ein einziges Mal in eine .cpp Datei eingebunden wird, da
  ansonsten die Einstiegsfunktion für das System mehrfach im Programm vorhanden wäre und es dann beim Linken natürlich
  einen Fehler gäbe. Dies sollte aber kein Problem darstellen, wenn dies einfach in der main.cpp verwendet wird, wie
  es wohl natürlicher Weise der Fall sein sollte.
- PLRTTIDefs.h: Makros für den Programm Einstiegspunkt entfernt



>> 20.11.2004
[CO]
- PLRTTIDefs.h: Makros für den Programm Einstiegspunkt hinzugefügt. (DEFINE_MAIN/END_MAIN) Diese sind zwar Optional, sollten aber
  IMMER verwendet werden damit man Plattform unabhängig bleibt ohne sich immer selbst drum kümmern zu müssen.



>> 19.11.2004
[CO]
- PLTTimer zum Singleton gemacht, PLTTimer in PLTTimerBase umbenannt und PLTTimer definiert das wie beim Gui automatisch jeweils korrekt
  je nach Plattform definiert wird so das man sich nicht mehr drum kümmern muss. Hab auch gleich die Linux Variante mit angepasst,
  Stephan - bitte gleich mal prüfen ob ich nicht fehler reingemacht hab. :)
  Passte gleich alle Codes an so das der Renderer nun endlich von der Engine selbst unabhängig sein kann.
- PLTLog: Ein paar kleine Änderungen gemacht, z.B. wird nun bei PLTLog::OutputString(const char *pszText) direkt in die Datei geschrieben
  damit man keinen Crash bekommt wenn der String länger als 1024 ist. Bei den mit ,... gehen wir einfach momentan noch aus das diese Strings
  nicht ZU lang werden. ;)
- PLTFile: PutC() -> Parameter mit const versehen



>> 18.11.04
[SW]
- Bis auf das FS auf linux portiert und ein paar kleine include fehler behoben (pfadangaben)



>> 15.11.2004
[SB]
- PLTPluginManager wurde wieder ausgebaut, und dessen Funktionalität nach PLTSystem verschoben. Dies ist sinnvoller
  und vor allem für den Programmierer einfacher, da PLTSystem besser zwischen den Klassen und den Modulen verknüpfen
  kann - das wäre mit einer getrennten Lösung kaum möglich gewesen, da die Libraries und die Klassen damit scheinbar
  voneinander getrennt gewesen wären. Da PLTSystem nun aber beides managed, kann es die Klassen gleich den entsprechenden
  Modulen zuordnen und bietet so auch für den Programmierer einen flexibleren Zugriff auf diese Informationen.
  PLTSystem ist jetzt also eine übergeordnete Klasse, die der Programmierer nutzen kann um auf Klassen und Bibliotheken
  zuzugreifen sowie alle Plugins zu managen, ohne dabei die Struktur der Applikation oder der Plugins festzulegen.
- PLTSystem wurde noch einmal in großen Teilen umgebaut, und ist nun sowohl einheitlicher als auch komfortabler.
  Dabei gibt es für Klassen, Gruppen und Module jeweils eine Methode GetXXXList(), um alle Objekte des Typs aufzulisten,
  sowie eine Methode GetXXX(), um einzelne Objekte per Name bzw. ID anzusprechen. Es ist jetzt also möglich, alle
  Klassen, Gruppen oder Module aufzulisten sowie deren Zugehörigkeiten untereinander zu erkennen. Die Methode
  GetClassList() wurde dabei so erweitert, daß entweder alle Klassen, oder alle Klassen einer Gruppe und/oder eines
  Moduls aufgelistet werden können, was die Einordnung der Klassen wiederum vereinfacht. Intern wurden die Methoden
  vereinheitlicht, außerdem sind die Add/Remove Methoden nun protected und können also nicht mehr wie vorher von
  außen aufgerufen werden, was hätte mißbraucht werden können.
- Die wahnwitzigen RTTI-Makros wurden noch einmal umgebaut, indem die Register-Funktionen nun nicht mehr Teil der
  zu registrierenden Klasse sind, sondern Teil der geschachtelten Info-Klasse. Durch Ableitung von der Basisklasse
  PLTClass und Aufruf der darin deklarierten Basisfunktionen _Register und _Unregister kann die Klasse dann bei PLTSystem
  angemeldet werden. Dieser weitere Trick dient nur dazu, die Add/Remove-Methoden von PLTSystem nach außen abzuschotten
  und als protected zu deklarieren, damit diese nicht beliebig aufgerufen werden können.
- Da sich die RTTI-Makros verändert haben, müssen sämtliche Projekte, welche diese verwenden, neu übersetzt werden, damit
  die Klassen vom aktuellen System korrekt registriert werden können. Dies sollte jedoch in der Zukunft nicht mehr so
  oft vorkommen :-)



>> 06.11.04
[SB]
- PLGeneral: Das Template PLTShared wurde gelöscht, die Idee war zwar nicht schlecht, hätte aber zu mehr Verwirrung geführt
  als daß es Nutzen gebracht hätte. Es gibt nun also nur noch Singletons, welche nur eine globale Instanz der Klasse
  erlauben, dies gilt z.B. für Syste, FileSystem, Log, etc. Die Klassen sollten also so strukturiert werden. daß entweder
  beliebig viele Instanzen möglich sind (wie z.B. bei der Gui), oder nur eine globale Klasse, um eine saubere Struktur
  zu bewahren.
- PLGeneral: Neue Klasse PLTPluginManager eingebaut, welche das Laden und Verwalten von Plugin-DLLs übernimmt. Dabei wird
  überprüft, ob eine DLL bereits geladen wurde und ob debug/release Modus übereinstimmen. Das Scannen einen Verzeichnisses
  nach Plugins wird zunächst von der Engine aufgerufen, jedoch kann ein Programm auch weitere Verzeichnisse Scannen.
  Zur Definition von Plugin-DLLs wurde PLRTTIDefs.h um entsprechende Makros erweitert.



>> 05.11.04
[SB]
- PLTRefCount: Abfrage des counts ist nun eine const-Funktion
- PLTFileSystem: Ist nun wieder ein singleton, es kann also nur eine einzige Instanz davon geben, die von allen
  Programmteilen verwendet werden muß. Dies ist aber kein Problem, da die Verwaltung von Suchpfaden nun doch
  nicht zentral im FS stattfinden wird, da dies einfach zu komplex geworden wäre (vor allem auch die Verwaltung
  durch den Programmierer, denn die Implementierung war ja bereits komplett).
- PLTFileSystem: Beim erstellen des FS wird nun das aktuelle Verzeichnis vom OS übernommen
- PLTFSTools: GetFileName() gibt den Dateinamen aus einem kompletten Pfad zurück (splitpath() äquivalent)
- PLTWin32Directory: Bei Angabe von "." wird das aktuelle Verzeichnis vom OS genommen
- PLTLog: Ist ebenfalls wieder ein Singleton, zur Unterscheidung verschiedener Logs wird diese Klasse entsprechend erweitert



>> 27.10.04
[CO]
- Behob kleinen 'Fehler' in den Vektor und Farb Klassen welche Offset Probleme im zusammenspiel mit dem RTTI erzeugten.
  Heute dazugelernt: "Vorsicht beim umgang mit this Zeigern!" ;-)
  Desweiteren ist es beim RTTI erfordlich das ALLE von PLTBase abgeleiteten Klassen virtuelle Destruktoren haben da es 
  ansonnsten bei delete [] zu einem Crash kommt - ebenfalls in PLTBase Notiert.



>> 15.10.04
[SB]
- PLTStack2: Da leider jedes Mal, wenn ich die Stack-Klasse benutzen will, irgend etwas nicht funktioniert, habe ich
  eine neue, sehr einfache Stack-Klasse geschrieben, welche auch wirklich nur das tut, was von einem Stack erwartet
  wird und dafür hoffentlich stabiler ist als die bisherige Klasse. Implementiert sind die Standardmethoden eines
  Stacks, Push()/Top()/Pop(), sowie noch eine Extramethode PushBack(), um ein Element an das andere Ende des Stacks
  anzufügen (dies ist vor allem beim Kopieren eines Stacks sehr wichtig). Ansonsten ist der Stack als einfache
  verkettete Liste implementiert, was vollkommen ausreicht da ja nur auf das Top-Element des Stacks zugegriffen werden
  kann, worauf immer ein direkter Zeiger existiert. Ein beliebiger Zugriff auf alle Elemente des Stacks ist also nicht
  implementiert und sollte auch nicht gebraucht werden, für einen solchen Fall sollte entweder eine Liste oder eine
  Array-Klasse verwendet werden. Dann ist auch endlich gegeben, daß sich die Containerklassen wirklich voneinander
  unterscheiden und somit je nach Situation optimal eingesetzt werden können.
  Die alte Klasse PLTStack sollte nun überall durch PLTStack2 ersetzt werden, oder durch eine andere Containerklasse,
  falls die Stackoperationen nicht ausreichend sind für einen bestimmten Fall, danach sollte die alte Klasse gelöscht
  werden und die neue Klasse in PLTStack umbenannt werden. Die zwei Klassen sollen also nur vorübergehend nebeneinander
  existieren, um die Anpassung zu erleichtern
- PLTTokenizer: Auch hier habe ich zunächst Änderungen vorgenommen, ohne die alte Version davon zu entfernen, damit die
  entsprechenden Stellen problemlos angepaßt werden können. Die Methoden Push()/Pop() implizieren schon vom Namen her
  eine Stack-Funktionalität, die sie dann jedoch nicht bieten, da nur ein einziger State gespeichert werden kann. Solche
  Dinge sind es aber, die später andere Programmierer, die mit PL arbeiten wollen, in den Wahnsinn treiben werden, denn
  ein Programmierer weiß, was er von einer Push()/Pop() Methode erwarten kann und wird nicht auf den Gedanken kommen, 
  daß der Name vielleicht zu viel verspricht. Ich habe daher einen echten Stack in den Tokenizer eingebaut sowie
  Funktionen, um auf diesen zuzugreifen. Mit PushState() kann der aktuelle Status des Tokenizers auf dem Stack gespeichert
  werden, mit PopState() wird dieser wiederhergestellt oder mit DropState() vom Stack verworfen. Damit ist ein einfacher
  recursive-descent parser, der natürlicher Weise mehr als einmal den Status speichern muß, also sehr leicht zu schreiben.
  Auch hier sollten die alten Methoden entfernt werden und durch die neuen ersetzt werden, sobald alle Stellen angepaßt
  sind, wo dies verwendet wird. Sollten die alten Methoden aus irgend einem Grund erhalten bleiben, könnten sie z.B. in
  SaveState()/RestoreState() umbenannt werden, was auch ihrer Funktionalität entspräche.



>> 08.09.2004
[CO]
- PLTArray um const [] erweitert



>> 05.09.2004
[CO]
- PLVar.h: Zwei Includes hinzugefügt



>> 29.08.2004
[SB]
- PLTRefCount: GetRefCount() ist nun const
- PLTVar besitzt nun eine Funktion, um eine Zeiger auf die Variable selbst zu erhalten. Da der Variablentyp natürlich nicht
  bekannt ist, ist der Rückgabewert ein void* Zeiger. Diese Funktion sollte natürlich nur mit größter Vorsicht verwendet
  werden, da man hiermit quer im Speicher rumschreiben kann. Auch alle Sicherheitsmechanismen wie readonly-variablen können
  mit dieser Funktion natürlich umgangen werden. Dennoch war eine solche Funktion nötig, um z.B. bei Variablen von Typ
  PL_VAR_CLASS an den Klassennamen heranzukommen (hierzu muß man sich den Zeiger auf das Objekt zurückgeben lassen und dann
  mit PLTBase::GetClassName() den Klassennamen ermitteln). Hierzu viel mir leider bisher kein besserer Weg ein...



>> 28.08.2004
[CO]
- Fügte PLTList<AType>::Add() noch einen Parameter hinzu mit dem man bei bedarf verhindern kann das geprüft wird ob etwas bereits
  in der Liste ist. Bei GuiListBox war es tötlich wenn extrem viele Elemente eingefügt wurden - da war der Aufwand ganz enorm so das 
  es teils viele Sekunden dauerte bis alles eingefügt war. :(
  Durch das deaktivieren des Tests geht es zwar nur etwas flotter, aber immerhin.
  


>> 26.08.2004
[SB]
PLGeneral:
- Habe PLGeneral.h umgebaut: Hier werden nun die OS-Spezifischen include-files eingebunden, so daß die Verwendung möglichst
  auf allen Betriebssystem identisch ist. Bei einer Portierung wird also einfach eine neue .h-Datei hinzugefügt und
  in PLGeneral.h mit den entsprechenden #ifdef's eingebaut. In PLGeneralWin32.h und PLGeneralLinux.h sind nun für das
  jeweilige Betriebssystem die import/export Makros sowie  die Datentypen definiert.
  Die Unterscheidung zwischen Import und Export geschieht nun nicht mehr über unterschiedliche .h Dateien sondern
  über eine Compilerdefinition (welche von VC++ automatisch gesetzt wird, diese müßte dann nur für Linux in die
  Makefiles eingebaut werden)
- Datentypen angepaßt, es werden nun nur noch die nötigsten definiert: int32, uint32, etc. Diese sollten nur da verwendet
  werden, wo es auf die Bitgröße des Datentyps explizit ankommt, also meist bei Dateizugriffen. Ansonsten sollten nur
  noch die primitiven Datentypen, also z.B. int, long, ... verwendet werden (für Flags z.B. unsigned long). Da DWORD/WORD
  von vielen als Windows-Datentypen verstanden werden, die man nicht braucht, habe ich mich für die Bezeichnung
  int16/int32/int64 entschieden, um klarzumachen daß es nur um die Bitgröße der Datentypen geht.
- PLTypes.h: Alle immer wieder verwendeten Datentypen/Definitionen der Engine befinden sich nun in dieser Datei,
  statt wie vorher noch in PLEngine. Da PLGeneral von den anderen Teilprojekten eingebunden wird ist dies besser,
  so muß PLEngine nicht mehr eingebunden werden, um z.B. die Definitionen für X/Y/Z verwenden zu können, wie dies
  bisher der Fall war
- Dummerweise vergessene PLGENERAL_API in PLTVar eingefügt :-)
RTTI:
- PLTSystem: Fehler bei den ClassGroups behoben: Da "" nicht als gültiger Hash-String gilt, wird nun ein Dummy-GroupName
  verwendet, um Klassen ohne Gruppe zu bezeichnen
- SelfInit-Class so erweitert, daß Klassen auch wieder automatisch ausgetragen werden, wenn das entsprechende Modul
  entladen wurde. Wenn kein SelfInit verwendet wird, muß der Programmierer stattdessen das Makro UNREGISTER_CLASS verwenden.
  Wie er mitbekommt, daß seine DLL entladen wurde, ist dann allerdings sein eigenes Problem ;-)



>> 18.08.2004
[CO]
- PLTBase::ToString: Behob String Problem, der Zeiger auf den Speicher wurde ungültig da das String Objekt nach ToString() wieder
  zerstört wurde und auch den String-Speicher selbst dabei killte.
- PLTSystem: Zwei neue Funktionen: GetVarType() & GetVarTypeAsString()



>> 10.08.2004
[SB]
- Neuer Variablentyp PL_VAR_PLSTRING zum Zugriff auf Variablen vom Typ PLTString eingebaut
- PL_ENUM Makros verändert: Der enum-string steht nun doch am Ende des Makros, da dies die Variablendefinition übersichtlicher gestaltet



>> 08.08.2004
[SB]
- PLTClass: Der Methode CreateInstance kann nun angegeben werden, ob die Variablen des erzeugten Objektes automatisch auf
  ihre Default-Werte gesetzt werden wollen, dies ist nun auch das Standardverhalten von CreateInstance().
- PLTBase: Neue virtuelle Methode VarChanged() eingebaut, diese wird aufgerufen wenn der Wert einer Variablen durch das
  RTTI verändert worden ist, um ggf. nötige Aktionen nach dem Verändern einer Variable durchzuführen



>> 07.08.2004
[SB]
- PLTBase, PLTClass: GetVarList(List, true) gibt nur die Variablen der eigenen Klasse zurück, ohne die von Basisklassen
  vererbten
- PLTVar::GetClass() gibt zurück, in welcher Klasse die Variable deklariert wurde
- Mittels DEFINE_ENUM können Aufzählungs-Variablen registriert werden. Als Typ kann hier entweder PL_VAR_ENUM oder
  PL_VAR_FLAGS angegeben werden. Das Setzen der Variablen kann entweder über die numerischen Werte oder über die
  enum-Namen erfolgen: z.B. Set("2|4"); Set("beta"); Set("Read|Write");



>> 06.08.2004
[SB]
- PLTypes.h erweitert, so daß die Definitionen an anderer Stelle komplett entfallen können. Die verwendeten Datentypen
  sollten jedoch noch einmal komplett überarbeitet werden
- Log-Ausgaben wieder eingebaut, dazu wird nun das "shared"-Log verwendet. Zur Zeit wird dieses jedoch nirgendwie aktiviert,
  deshalb verschwinden die Logausgaben im Nirvana :-)
- RTTI System erweitert:
  - Klassen beinhalten nun auch die Variablen ihrer Basisklassen
  - Es wird nun mit m_nBaseOfs auch der Offset zu PLTBase gespeichert, damit die Variablen auch dann noch korrekt gesetzt
    werden können, wenn eine Klasse nicht als erstes PLTBase in der Ableitungsliste stehen hat
  - DEFINE_VAR_READONLY erlaubt das Definieren von Variablen, die nur gelesen aber nicht verändert werden können
  - REDEFINE_VAR erlaubt das "Überschreiben" von Variablen in abgeleiteten Klassen, dabei können DefaultValue,
    Description und Annotation verändert werden



>> 05.08.2004
[CO]
- Den Ordner Tools in PLTools umbenannt. Beim Includieren wäre es am ende unschön wenn man #include <Tools/...> schreiben
  würde, da vermiss ich irgendwie das PL davor... und so musste ich die anderen Codes nicht an die verschiebung von PLTools
  in PLGeneral anpassen. ;-)
  Vielleicht sollten wir auch die anderen Ordner entsprechend anpassen damit es einheitlich ist. 
  (wieder so ne dumme Namensgeschichte ;-)
- Bei ein paar Headern in PLTools noch PLGeneral.h eingebunden - bei der Gelegenheit ging ich gleich alle Includes unserer
  Projekte durch und passte alles an. (waren ja in letzter Zeit einige Änderungen)
  Nun sieht man z.B. schön wie die Libs aufeinander aufbauen da alles geordnet ist.
- PLTimerWin32.inl & PLTimer.inl gelöscht da die inlines dort nicht so doll sind (was dachte ich mir früher dabei? :-)
- PLTypes.h von der Engine in PLGeneral verschoben, musste PLTypes in z.B. PLList.h einbinden da in der Engine teils
  NULL unbekannt war da windows.h dort nicht eingebunden werden musste



>> 04.08.2004
[SB]
- PLTDestructionManager eingebaut. Diese Klassen sorgen dafür, daß Instanzen von Singleton- oder Shared-Klassen am
  Ende der Programmausführung auch wieder gelöscht werden. Die Implementierung ist relativ kompliziert, da man
  hierbei wieder sehr mit der Compiler- und Exportproblematik herumschlagen mußte. Die Funktionsweise des Systems:
  - Statische Initialisierung wird durch Singleton::GetInstance() vermieden, dies ist nötig damit die Klassen sich
    über Selbstinitialisierung beim Programmstart bei PLTSystem anmelden können. Wäre PLTSystem eine statische
    Variable, könnte dies zu Problemen führen, wenn PLTSystem noch nicht initialisiert wurde
  - Jede Instanz von PLTSingleton und PLTShared meldet sich beim PLTDestructionManager an. Dies ist möglich, da
    PLTDestructionManager selbst ein Singleton ist und daher bei der ersten Verwendung erzeugt wird
  - Am Ende müssen alle Instanzen wieder gelöscht werden. Dazu dient die einzige statisch Variable
    PLTDestructionGuard::Instance, deren Destructor am Ende des Programmes automatisch aufgerufen wird. Diese löscht
    die Instanz von PLTDestructionManager, welche wiederum alle bei ihr angemeldeten Objekte löscht. Auf diese
    Weise werden alle erzeugten Instanzen auch wieder automatisch gelöscht :-)



>> 03.08.2004
[SB]
- Neues Verzeichnis PLTools, hier befinden sich nun allgemeine Tool-Klassen
- PLTTokenizer nach Tools verschoben
- Klassen aus PLEngine nach PLGeneral verschoben, welche allgemein verwendet werden können. Die Klassen sind nun
  allgemein und können auch außerhalb der Engine verwendet werden, PLEngine-spezifischer Code wurde dabei entfernt
  und muß weitern in der Engine selbst ausgeführt werden (z.B. Anzeige von Informationen etc).
  Verschobene Klassen: PLTLog, PLTProfiling, PLTTimer, PLTTools



>> 02.08.2004
[SB]
- PLTRefCount nach Base verschoben und von PLTBase abgeleitet
- PLTFile: Neue Methode PrintLn eingebaut
- PLTFile: Neue Methode Flush eingebaut
- PLTWin32File und PLTZipFile angepaßt



>> 01.08.2004
[CO]
- PLTDynamicList: In der Engine hab es nun mit den const/nicht const etwas probleme. Hab die Warnung
  "PLTDynamicList<AType>' : multiple assignment operators specified" fürs erste Deaktiviert da diese ansonnsten tausende male
  kam. ;-)
  Bei Zeiten müssten wir nochmal schaun wie wir das besser machen können...
- PLTPool: Um Copy Operator erweitert



>> 01.08.2004
[SB]
- Neue Basisklassen PLTShared und PLTSingleton eingebaut. Dies sind Template-Klassen, welche verwendet werden können,
  um Klassen mit nur einer Instanz (PLTSingleton) oder mit einer gemeinsamen Instanz für alle Programmteile (PLTShared)
  zu definieren.
- PLTFileSystem benutzt nun die neuen Basisklassen PLTSingleton und PLTRefCount
- PLTSystem: Anpassung an neue Basisklassen sowie kleinere Korrekturen
- Neue Definition PLGENERAL_TEMPLATE zum Exportieren von template-Klassen, dies muß bei allen zu exportierenden
  Template-Instanzen verwendet werden
- Verzeichnisse umbenannt



>> 30.07.2004
[SB]
- Habe das RTTI System in PLGeneral eingebaut und dafür die vorläufigen Plugin-Klassen wieder entfernt, da diese
  damit überflüssig geworden sind :-)



>> 29.07.2004
[SB]
- Die Gruppe einer Klasse wird nun mittels eines eigenen Makros gesetzt, wird dieses nicht verwendet gehört die Klasse
  keiner Gruppe an
- Die Basisklassen einer Klasse werden nun in PLTClass gespeichert und können dort abgefragt werden. Ebenso kann
  PLTBase::IsInstanceOf() als Shortcut zur Abfrage einer Basisklasse verwendet werden
- PLTBase selbst wird jetzt als Klasse registriert
- Beim Definieren einer Klasse wird nun eine interne von PLTClass abgeleitete Klasse erzeugt, welche dann in PLTSystem
  gespeichert wird. Dadurch ist es möglich, private Methoden von PLTClass zu verwenden sowie virtuelle Methoden
  zu überschreiben
- PLTClass::CreateInstance() kann benutzt werden, um eine neue Instanz einer Klasse zu erzeugen. Es muß allerdings noch
  ein Weg gefunden werden, daß Klassen dieses Verhalten unterbinden können, wenn eine direkte Erzeugung von Instanzen
  nicht erwünscht ist
- PLTClass: Methoden zum Ändern einer Klasse sind nun protected, können von Außen also nicht mehr aufgerufen werden,
  damit sind auch die konstanten Zeiger nicht mehr von Nöten und wurden durch normale Zeiger (PLTClass*) ersetzt
- Pointer-Truncation Warnungen wurden beseitigt, indem zur Speicherung des Offsets nun der 64Bit-Datentyp int__64
  verwendet wird
- Neues Makro: Wird DEFINE_CLASS_PRIVATE anstelle von DEFINE_CLASS verwendet, so kann die Klasse nicht über
  CreateInstance() instanziiert werden. Dies ist nützlich für Klassen, die nicht beliebig instanziiert werden
  sollen und daher meits auch keinen öffentlichen Standardkonstruktor besitzen
- Mittels der Compiler-Definition USE_SELFINIT kann bestimmt werden, ob die Selbstinitialisierung verwendet werden soll
- In PLTClass wird nun ein Module-Handle gespeichert, zu dem die Klasse gehört



>> 28.07.2004
[SB]
- Zugriff auf Variablen vollständig implementiert und getestet
- Klassen können nun in Gruppen eingeteilt werden, um einfach die Klassen eines bestimmten Typs auflisten zu können. Dies
  dient nur dem Entwickler zur Einfacheren Verwaltung seiner Klassen, z.B. sollten alle Plugins eines Typs den gleichen
  Gruppennamen bekommen (z.B. PLEntities), dann kann der Plugin-Manager sich eine Liste aller Klassen dieses Typs herausgeben
  lassen um die Plugins dann zu verwenden
- PLTVar wurde doch noch einmal umgeschrieben, es ist nun nicht mehr möglich, mit hilfe eines PLTVar-Objekts direkt auf
  eine Instanz einer Variablen zu zeigen, da dies zu Inkonsistenzen führte (PLTClass::GetVar() gab einen konstanten Zeiger
  auf PLTVar zurück, der nicht gelöscht werden durfte, währen PLTBase::GetVar() ein neues PLTVar Objekt erzeugte, welches
  dann wieder gelöscht werden mußte!). Die jetzt zurückgegebenen Objekte müssen grundsätzlich nicht mehr gelöscht werden,
  da sie Zeiger auf feste Instanzen darstellen und nicht neu erzeugt werden. Dafür gibt es nun Methoden in PLTVar,
  um den Wert der Variablen bezogen auf eine Instanz zu setzen: SetVar(PLTObject*, const char *pszValue)
- RTTI Interface ist nun komplett



>> 27.07.2004
[SB]
- Neue Funktionen in PLTBase: ToString() und FromString(). Mit diesen Methoden wird der Inhalt eines
  Objektes in einem String übergeben. Dies entspricht in wesentlichen dem VarString, jedoch kann das
  Aussehen dieses Strings von der Klasse bestimmt werden, es müssen also nicht die Variablennamen
  angegeben werden (die Repräsentation eines 3D-Vectors könnte z.B. "10 20 30" sein, anstatt "X=10 Y=20 Z=30")
- Mittels PLTVar können nun Werte von Variablen gesetzt und abgefragt werden
- Klassen werden in PLTClassRegistry gespeichert und können dort abgefragt werden
- PLTClassRegistry wurde in PLTSystem umbenannt, da diese Klasse die allgemeine Verwaltung des Systems übernehmen
  wird (neben Registrierung der Klassen werden auch Plugins, Dynamic Libraries etc. in ihren Aufgabenbereich fallen,
  evtl. kann man später auf Log etc. in PLTSystem einbetten)
- Die Klassen wurden überarbeitet und vereinheitlicht, z.B. wurden Unterschiede beim Zugriff auf Listen und Daten
  der Klassen beseitigt
- SelfInit-Part eingebaut, welcher die Klasse automatisch registriert
 


>> 25.07.2004
[SB]
- PLTVar überarbeitet, die Instanz des Objektes kann nun nur noch im Konstruktor übergeben werden
- Zugriff auf Variablen über PLTClass implementiert



>> 24.07.2004
[SB]
- PLTVar fertiggestellt, diese Klasse beinhaltet Informationen über eine Variable innerhalb einer Klasse. In PLTClass
  kann man eine Liste der registrierten Variablen abfragen, und in PLTObject können die Werte der Variablen gesetzt
  oder abgefragt werden. Zusätzlich kann auch PLTVar die Instance einer Variablen darstellen, dann kann auch über
  PLTVar auf die Werte der Variablen zugegriffen werden



>> 22.07.2004
[SB]
- Habe endlich einen generellen Weg gefunden, daß die Variablen einer Klasse nicht mehr pro Objekt gespeichert werden
  müssen sondern nur noch einmal für jede Klasse. Bisher besaß jede Instanz einer Klasse eine eigene Variablenliste,
  in der die Zeiger auf die Variablen gespeichert wurden (die Informationen über die Variablen wurden nur einmal
  gespeichert, dies führte jedoch dazu, daß es zwei unterschiedliche Klassen für Variablen geben mußte, was auch
  nicht schön war). Dies ist nun nicht mehr nötig :-)



>> 21.07.2004
[SB]
- PLGeneral: PLTDynamicList und PLTList so erweitert, daß diese nun auch mit konstanten Daten umgehen können.
  Dies ist z.B. dann nützlich, wenn der Zugriff auf eine const PLTList/PLTDynamicList erfolgt
- RTTI System begonnen. Mit Hilfe dieses Systems wird es möglich sein, zur Laufzeit auf Klasseninformationen zuzugreifen,
  damit können z.B. die vorhanden Variablen oder Methoden eines Objektes abgefragt und verändert werden, sowie
  natürlich generelle Informationen über den Typ eines Objektes abgefragt werden.
  Das System entspricht in seiner Funktionsweise dem EntityPluginSystem, ist jedoch allgemeiner und soll um einiges
  flexibler werden. Wenn alles klappt, wird durch dieses Klassensystem auch gleich ein sehr einfach zu verwendendes
  Pluginsystem zur Verfügung stehen, wobei die bisherigen Fallunterscheidungen nicht mehr benötigt werden sollten
  (bisher mußte unterschieden werden, ob eine Klasse im Hauptprojekt, in der Engine-DLL oder in einer Plugin-DLL
  deklariert wurde, dies ist nicht sehr schön und kann hoffentlich vermieden werden). Auch das Scriptsystem wird
  nach der Implementierung der RTTI leicht zu entwickeln sein, da der Zugriff auf Klassen und Variablen/Methoden
  zur Laufzeit damit bereits implementiert ist :-)
  Das RTTI wird also eine Reihe von Basisklassen zur Verfügung stellen, die in der gesamten Engine verwendet werden,
  zusätzlich wird es noch einige abgeleitete Klassen geben, welche für bestimmte Klassentypen zum Einsatz kommen
  können (RefCount, Singleton, etc)



>> 30.06.2004
[SB]
PLFileSystem:
- Fehler in PLTSearchMultiHandle behoben: HasNextFile() gab false zurück, sobald der erste SearchHandle komplett durchlaufen
  war, dadurch wurden die anderen SearchHandles ignoriert
- Das Interface von PLTFileSystem wurde noch einmal leicht verändert. GetRootDirectory() gibt nun das System-Root-Verzeichnis
  zurück, dieses kann jedoch nicht selbst gesetzt werden. SetCurrentDirectory()/GetCurrentDirectory() ermöglichen das Setzen
  eines aktuellen Verzeichnisses, sowie AddBaseDir() etc., welche im Prinzip weitere aktuelle Verzeichnisse hinzufügen lassen
  (falls mehrere benötigt werden). Hierdurch bleibt das System kompatibel zu den üblichen Dateisysteme, erlaubt jedoch zusätzlich
  mehr Kontrolle
- Zugriff auf Suchpfade und Rootverzeichnisse ist vollständig, es funktioniert nun also alles was für die Engine benötigt
  wird. Es können Dateitypen (z.B. "Textures", "Sounds", etc.) festgelegt werden und Suchpfade dafür angelegt werden.
  Das FS durchsucht dann beim Öffnen einer Datei automatisch diese Pfade, so daß sich die Anwendung nicht mehr darum
  kümmern muß, was wo liegt
- Suchpfade/Rootverzeichnisse ausgetestet und den PL-Realfall simuliert (separate Verzeichnisse für Textures/Models/etc)



>> 29.06.2004
[SB]
PLFileSystem:
- Geschwindigkeitstests durchgeführt. Leider ist das FS vor allem beim Zugriff auf viele kleine Dateien deutlich langsamer
  als die Standardfunktionen, beim Zugriff auf große Dateien fällt der Unterschied allerdings kaum mehr ins Gewicht.
  Dies dürfte hauptsächlich an den vielen String-Operationen liegen, wie müssen also einfach austesten, ob dies im reellen
  Gebrauch negativ auffällt und ggf. versuchen, diese Funktionen zu optimieren
- Neue Funktion PLTSearchHandle::GetNextFileAbs(), diese Funktion liefert den absoluten Pfad zurück. Funktion wurde in
  allen abgeleiteten Klassen implementiert
- Neue Funktion PLTZipDirectory::GetZipFile(), liefert ein Handle auf die Zip-Datei zurück, die das Verzeichnis beinhaltet.
  Der Rückgabewert ist const, damit zwar Dateiattribute (Namen etc.) abgefragt werden können, die Datei aber nicht
  verändert werden kann
- Fehler in PLTZipSearchHandle behoben: Das zugrunde liegende Verzeichnis wurde nicht gesichert (refcount)



>> 28.06.2004
[SB]
PLFileSystem:
- Dateien aus Zip komplett überarbeitet und an den PL-Style angepaßt
- Alle Dateien überarbeitet und die üblichen "Verschönerungen" vorgenommen :-)



>> 25.06.2004
[SB]
PLFileSystem:
- Beim Suchen mit Filter entspricht der Filter "" nun der Suche nach allen Dateien
- Beim Suchen mit Filter ist es nun auch möglich, noch Unterverzeichnisse mit anzugeben (z.B. Suche nach "subdir/*.txt")
- Mounten von Root-Verzeichnissen implementiert
- Dateitypen und Suchpfade wurden implementiert
- PLTSearchMultiHandle eingebaut: Dies ist ein Search-Handle, welches intern wiederum aus mehreren Search-Handles besteht
  und diese nacheinander abarbeitet
- PLTFileSystem interface wurde komplett implementiert
- Dateien aus Base und Win32 überarbeitet und komplett kommentiert



>> 23.06.2004
[SB]
PLFileSystem:
- PLEFileType und entsprechende Zugriffsmethoden in PLTFileObject wurden entfernt, IsDirectory() und IsFile() werden
  nun von abgeleiteten Klassen implementiert
- Neue Methoden GetName() und GetAbsName() in der Basisklasse PLTFileObject eingebaut, diese dienen dem Abfragen von
  relativen und absoluten Namen aller Dateiobjekte
- Interface von PLTFileObject wurde überarbeitet (const-Methoden)
- GetName() und GetAbsName() in allen abgeleiteten Klassen implementiert und getestet, es kann nun immer der relative
  sowie der absolute Pfad angefragt werden
- PLTSearchFilter implementiert, dieser filtert Suchergebnisse nach Wildcards
- Beim Erzeugen des Dateisystems wird das aktuelle Verzeichnis '/' automatisch als system-root gemountet
- Setzen des aktuellen Verzeichnisses implementiert
- Design von PLTFileSystem wurde festgelegt. Diese Klasse stellt das Hauptinterface zum FS dar, dient also dem Benutzer
  zum Öffnen von Dateien und Verzeichnissen sowie zum Suchen von Dateien



>> 22.06.2004
[SB]
PLFileSystem:
- FSTools: Neue Funktion IsAbsolutePath() eingebaut
- PLTWin32Directory: Es können nun auch absolute Pfade angegeben werden (z.B. D:\test.txt), welche unabhängig vom aktuellen
  Verzeichnis gefunden werden. Außerdem kleine Anpassungen an IsValid() vorgenommen



>> 20.06.2004
[SB]
PLGeneral:
- Neue Basisklasse PLTRefCount in PLGeneral eingebaut, da dies nun bereits in mehreren Klassen verwendet wird.
  Davon abgeleitet gibt es speziell für das FS die Klasse PLTFSRefCount, welche zusätzlich die Anmeldung erzeugter Objekte
  beim FileSystem übernimmt



>> 19.06.2004
[SB]
PLFileSystem:
- Fehler behoben: Das MountParent-Attribut eines Verzeichnisses wird nun weitergegeben, wenn ein Unterverzeichnis geöffnet
  wird. Dadurch bezeichnet MountParent jedoch nicht mehr unbedingt das direkte Superdirectory, wenn es gesetzt ist, sondern
  das Basisverzeichnis des gesamten Unterbaumes. Dies wurde ebenfalls in PLTZipFile implementiert
- Die einzelnen Implementierungen von PLTDirectory::Open() rufen nun intern OpenCanonical auf, wenn sie die Datei auf
  direktem Wege nicht öffnen können
- PLTWin32Directory und PLTZipDirectory: Enthält der zu öffnende Dateiname ein / (bzw. \) am Ende, so wird nur ein
  PLTDirectory* zurückgegeben. Wird nur eine Datei gefunden, beendet die Funktion mit einem Fehler und gibt NULL zurück
- PLTFileSystem: Mount ist nun protected, darf also nur vom FileSystem selbst (und PLTDirectory) aufgerufen werden
- Weitere kleine Fehler in Mount() und PLTWin32Directory/PLTZipDirectory behoben. Der Zugriff auf Dateien und Verzeichnisse
  scheint nun komplett zu funktionieren
- ReferenceCounting und garbage collection wurden nun auch in PLTSearchHandle implementiert, damit dies einheitlich für das
  gesamte FS ist
- Kleinere Fehler im ReferenceCounting und beim ObjectManagement behoben, dies scheint nun fehlerfrei zu funktionieren
  (nicht mehr benötigte Objekte werden selbständig gelöscht)
- Umstrukturierung der Open/OpenCanonical Funktionen. Dadurch konnten redundante Überprüfungen entfernt werden (Öffnen von
  Verzeichnissen oder Dateien), und eine endlose Rekursion zwischen den Funktionen Open und OpenCanonical ausgeschlossen werden
- PLTDirectory::FindFirst() gibt nun einen SearchHandle zurück, der immer alle Dateien im Verzeichnis auflistet. Daher muß
  PLTSearchHandle also keine Suchmaske mehr implementieren, dies wird später durch eine ContainerKlasse implementiert
- Hilfsfunktion FindFirst(pszFilter) und neue Klasse PLTSearchFilter erstellt, worüber das Suchen von Dateien mit einem
  Filter möglich ist. PLTSearchFilter ist jedoch noch nicht implementiert
- Die Grundfunktionen des FS sind nun *endlich* komplett implementiert, d.h. es kann auf alle Dateien und Verzeichnisse
  zugegriffen werden, wobei ZIP-Dateien bei Bedarf automatisch gemountet werden. Auch der Zugriff auf Dateien und
  Verzeichnisse über Dateisystemgrenzen hinweg ist möglich. Es fehlt nun noch das Mounten von root-Verzeichnissen
  sowie die Verwaltung von Dateitypen und Suchpfaden



>> 18.06.2004
[SB]
PLFileSystem:
- Beim Öffnen des Verzeichnisses '..' wird nun immer das korrekte Verzeichnis zurückgegeben, auch wenn dazu auf ein früher
  gemountetes Verzeichnis zurückgegriffen werden muß
- OpenCanonical wurde implementiert. Diese Funktion öffnet einen Pfad Schritt für Schritt, wobei wenn nötig auch Dateisystem
  gemountet werden (z.B. ZIP-Dateien)
- On-The-Fly-Mounten implementiert (z.B. beim Öffnen von "C:\test.zip\test.txt")



>> 16.06.2004
[SB]
PLFileSystem:
- PLTZipDirectory wurde so erweitert, daß nun auf ein bestimmtes Verzeichnis im ZIP-File zugegriffen werden kann.
  Mittels Open() können jetzt auch Unterverzeichnisse geöffnet werden
- Fehler in PLTZipFile behoben: Das PLTZipFile erhöht nun den Reference-Counter seines Zip-Verzeichnisses, damit
  dieses nicht gelöscht werden kann, solange das PLTZipFile existiert
- Zip-Implementierung wurde komplett implementiert. Der Code basiert auf unzip.c, wurde jedoch objektorientiert umgesetzt



>> 14.06.2004
[SB]
PLFileSystem:
- IsValid() wurde als Basisfunktion in PLTFileObject fertiggestellt
- PLTFSTools::ValidatePath() wurde implementiert. Diese Funktion validiert einen Verzeichnisnamen, indem z.B. '..'
  und '.' soweit möglich entfernt werden, / und \ vereinheitlicht werden und sonstige Fehler möglichst korrigiert werden



>> 11.06.2004
[SB]
PLFileSystem:
- Das Interface von PLTFileSystem wurde noch einmal komplett überarbeitet
- Dateisysteme können nun gemountet werden, wobei der Typ des Dateisystems automatisch festgestellt wird
  (z.B. zum Mounten von ZIP-Dateien). Damit der Kontext erhalten bleibt, kann ein Basisdirectory übergeben werden,
  welches die zu mountende Datei enthält



>> 05.06.2004
[SB]
PLFileSystem:
- Win32-Implementierung wurde komplett fertiggestellt



>> 04.06.2004
[SB]
PLFileSystem:
- Die Interfaces wurden noch einmal komplett umgestellt und vereinheitlicht
- Das Erzeugen und Löschen von Instanzen ist nun nur noch über spezielle Methoden und Klassen möglich
- Reference-Counting für PLTFileObject (und abgeleitete Klassen) implementiert
- Alle erzeugten PLTFileObject-Instanzen werden nun beim PLTFileSystem gespeichert und spätestens dann gelöscht,
  wenn auch das PLTFileSystem selbst gelöscht wird
- Auch PLTFileSystem selbst besitzt nun einen Reference counter



>> 26.05.2004
[SB]
PLFileSystem:
- Die erste Version vom PLFileSystem wurde fertiggestellt



>> 11.05.2004
[CO]
- PLGeneral: PLError wurde entfernt. Gelöschte Dateien: PLBuffer.h, PLError.cpp, PLError.h. Nahm desweiteren PL_ASSERT
  aus diversen Codes heraus da WENN da müsste man dies konsequent in ALLEN Codes machen. :)



>> 30.03.04
[SB]
- Plugin-Basisklassen in PLGeneral eingebaut. Diese ist noch nicht ganz fertig, funktioniert
  aber schon ganz gut. Es fehlen noch einige Optimierungen sowie die Verknüpfung mit dem
  FileSystem, damit die Plugins leicht gefunden werden können. Auch müßten die Klassen noch
  auf Linux Systeme angepaßt werden. Wenn dies fertig ist kann ein PluginManager in der Engine
  erzeugt werden, der alle Arten von Plugins einlädt und zur für Verfügung stellt, die
  einzelnen Programmteile benutzen dann den Manager um ihre Plugins zu erzeugen



>> 25.03.04
[CO]
- Wie ich sehe hat Michael nochmals PLTBuffer verbessert... ich selbst hatte gestern in PLBuffer in PLArray
  umbenannt und mehr oder weniger komplett umgeschrieben da ich diese Klasse mittlerweile im neuen Renderer beim
  Wrappen von Render States etc verwende und die alte Klasse nicht stabil genug war. Hatte die Codes aber noch
  nicht hochgeladen - PLArray.h ist nun auf dem Server, PLBuffer.h lass ich auch erstmal noch oben nicht das da
  etwas durcheinander kommt. :)



>> 23.02.04
[CO]
- PLTStack leicht modifiziert



>> 19.02.04
[CO]
- PLTString um Funktionen zum setzen und auslesen von Zahlen hinzugefügt.



>> 15.02.04
[CO]
- Plugin Systeme wie Entity und Sound: Dadurch das nun während der Entwicklung zwei Versionen eines jeden Plugins vorhanden
  sind (Debug und Release) gab es teils crashs da dann doppelt noch das andere z.B: Release Plugin eingeladen wurde was
  aufgrund inkompatiblem Compiler Modus einen crash verursachte. Diese Plugins haben nun intern einen vermerk ob diese im
  Release oder Debug Modus sind - Plugins in einem falschen Compiler Modus werden nun nicht mehr geladen. Nun müsste das mit
  dem Release/Debug Problemen entgültig der Vergangenheit angehören! Wenn nun was nicht geht dann liegts nur an nichtzusammen
  passenden Release Versionen. (da z.b. eine dll veraltet ist :)
- PLTList und PLTDynamicList -> Add Funktion so erweitert das optional ein Index mitgegeben werden kann um 
  festzulegen WO in der Liste das neue Element eingefügt wird



>> 11.02.04
[CO]
- PLTLanguageManager::GenerateLanguageList() -> Kann nun auch aus einer Preload Datei im Languages Block die verfügbaren
  sprachen auslesen falls mal ALLE Daten in einer pak Datei sind und daher die Sprachverzeichnisse nicht direkt abgelesen
  werden können.
- PLTList + PLTDynamicList: -> Da man beim Kopieren oft Start+Anzahl trifft (siehe read etc) haben wir nun beide
  Kopier Funktionen drin, also Start+Anzahl und Start-End. (heist CopyFromTo())
  Da die Listen sehr häufig Verwendung finden müsste es ok sein wenn man da etwas mehr komfort bietet.
  Die Kopier Funktionen müssten so nun wirklich passen. (getestet)



>> 07.02.04
[CO]
- Ein paar kleinigkeiten am alten FS geändert so das man nun im HDRI Viewer auch direkt pak/zip files einladen kann



>> 05.02.04
[CO]
- PLTTimer: Delay() in Sleep() umbenannt damit es identisch mit dem PLGui Sleep() ist. Ist zwar nun im GuiNative und Timer
  doppelt, aber so hat man alles Timer Relevante in der Engine sauber in einer Klasse beisammen. :)



>> 04.02.04
[CO]
- PLTDynamicList: Copy() kopierte durch <= ein Element mehr als man angab
- PLTList: Neue Funktion. Copy
- PLTBitset: Neue Funktionen: GetSize() -> Liefert die Bitset größe zurück
                              Copy() -> Copiert Bits in ein anderes Bitset



>> 01.02.04
[CO]
- PLTTokenizer: GetDataBlock() Funktionen erweitert. Es gibt nun neben der Block Schreibweise [X Y Z ...] auch alternativ
  {X, Y, Z ...} da man beide Schreibweisen häufig antrifft. wird z.B. im überarbeiteten Material Format bei den Parametern
  verwendet um dort ein fx-ähnliches Aussehen beizubehalten damit die Grafiker nicht zu 100% umdenken müssen und es leicht
  ist ein fx File in unser eignes Material Format umzuschreiben.



>> 29.01.04
[CO]
- PLTList: neuer operator: Concat. Zur Verkettung zweier Listen.
  Desweiteren wurden in einem Kunstruktor noch nicht die Variablen Initialisiert. (siehe MH oben)



>> 22.01.04
[CO]
- PLTOutputDevice in PLTErrorOutputDevice und PLTError in PLError (da gleich statische instanz) umbenannt.
- Erweiterte PLGeneral Headers um jeweils ein kleines Beispiel wie man die verschiedenen Klassen einsetzt



>> 21.01.04
[CO]
- Nahm aus PLList, PLHashTable und PLStack wieder die Assertion Funktionen heraus da man durch diese selbst bei
  einfachen Templates GEZWUNGEN wurde PLGeneral ins Projekt mit einzubinden auch wenn man eigentlich 'nur' Templates
  aus PLGeneral verwendete. PLMath ist somit wie PLGeneral komplett eigenständig - verwendet zwar z.B. Listen aus PLGeneral
  aber dies erfordert keine Einbindung von PLGeneral in das PLMath Projekt.
  In Klassen welche sowieso die Einbingung von PLGeneral erfordern kann man ja sorgenlos die Assert Funktionen verwenden. :)
- Einige von Michals änderungen an String und Error wieder angepasst - ich hoffe da kam nun nichts durcheinander da unsere
  Codes diesmal stark voneinander abwichen - Michael, passe bitte auf das du nicht auf dem Server
  bereits geänderte Dateien überschreibst. (wie dieses Tagebuch oder Codes)
  Am besten bevor du etwas hochläds zur Sicherheit prüfen ob jemand was dran geändert hat. Am FileSystem ändern wir erstmal
  nichts bis du nicht das ok gibst - sonst kommt das durcheinander. :)
  Sobald wir auf CVS umstellen wird das sicherlich besser da diese Programm dann heftig warnt wenn man Datein die man
  hochladen will auf dem Server geändert wurden.
  Ps. Es ist wirklich, wirklich wichtig das die Codes so sauber sind wie möglich und möglichst kein Buchstabe vom Style
  abweicht. Wir haben mittlerweile insgesammt weit mehr als 2 MB an Quellcodes und wenn man da anfängt mit soetwas nachlässig
  zu werden wird man sich ganz bestimmt später mal drüber ärgern. Von daher kommts schonmal vor das wir mehr Zeit in die Code
  pflege stecken als in das schreiben des Codes selbst... aber es lohnt sich da man sich dadurch später Zeit spart!



>> 20.01.04
[CO]
- PLTTokenizer::GetDataBlockInt() und PLTTokenizer::GetDataBlockFloat() -> Brechen nun ab wenn beendende Klammer ]
  gefunden wurde und füllen den Rest mit 0. Geben die Anzahl der gelesenen Elemente zurück.
  (PLModelLoad.cpp und PLTextureHandler.cpp mussten aktualisiert werden)



>> 12.01.04
[CO]
- PLTFile::GetS() -> Fehler korrigiert (sonst gibts probleme beim HDRI maps im Viewer einladen)



>> 09.01.04
[CO]
- PLGeneral.h muss nun nicht mehr inkludiert werden bevor man z.B. PLTBitset verwenden will
  (dies geschieht nun in den PLGeneral Headern automatisch)



>> 03.01.04
[CO]
- PLTDynamicList: Neue Funktion: Add() -> Fügt ein neues Element in die Liste ein und gibt einen Zeiger darauf zurück
- PLTBitset erweitert -> Prüft nun auch ob ein gegebener Bit Index korrekt ist
- PLTTokenizer: Neue Funktionen: GetNextTokenBool() und GetTokenBool() -> Machen das gleiche wie die Funktionen ohne Bool
  am Ende außer das diese den gefundenen Token als boolean Wert zurückgeben (erkennt auch 'false' und 'true')
- Überall in Formaten wo man statt einer 1 auch 'true' schreiben könnte ist dies nun dank umstellung auf GetNextTokenBool()
  auch möglich



>> 30.12.03
[CO]
- PLTString: Michales neue Änderungen wieder angepasst (bitte noch mehr drauf achten wie wir was schreiben Michael :)



>> 27.12.03
[CO]
- Passte noch ein paar kleinigkeiten von Michaels änderungen an PLTString an. Find() gibt nun direkt den Index zurück.



>> 20.12.03
[CO]
- PLTFileSystem::GetFilenameEnding() -> Wenn Datei keine Datei endung hat so wird pszFilenameEnding nun auf "" gesetzt



>> 13.12.03
[CO]
- PLTTimer: Neue Funktion: GetTickCountLow() -> Macht das gleiche wie GetTickCount() nur mit weniger genauigkeit
- PLTDataSet.Get() -> Gibt nun NULL zurück wenn ungültiger Index -> ein paar stellen in der Engine an denen Zeiger
  verglichen werden mussten angepasst werden



>> 27.11.03
[CO]
- PLString: Neue Funktion: - TStringModule::GetUsage() -> Gibt zurück wie oft ein String Module verwendet wird
  Neue Operatoren: += -> Hängt einen String an einen String an +  -> Verbindet zwei Strings zu einem neuen



>> 25.11.03
[CO]
- Mir war ein paar Minuten langweilig und da warf ich nochmal einen kurzen Blick auf PLGeneral und behob
  ein paar kleine Schönheits fehler - also absolut unnötige Änderungen. (sieht nun aber etwas universeller aus ;-)



/*********************************************************\
 *  Einträge aus altem Diary, damals noch ohne genaue Datum angaben. (oben -> unten = neuer -> älter)
\*********************************************************/



[SB] Neues Projekt PLGeneral erstellt, welches alle allgemeinen Toolklassen enthält (Listen, Strings, ...). Die
     entsprechenden Toolklassen wurden aus PLEngine entfernt, alle Projekte wuredn umgestellt (betrifft nahezu alle
     Projekte)
[CO] In PLTypes.h stehen nun auch Daten-Typ definationen wie z.B. WORD oder DWORD
[CO] PLTTimer: Portabel gemacht -> System abhängige Funktionen abgekapselt
[CO] PLTFileSystem::GetValidFilename() -> Prüft ZUERST ob eine Datei in einem Sprach Unterornder ist und somit für eine
     Sprache quasi 'überladen' wird (wichtig für Lokalisierungen :)
[CO] PLTFileSystem: Neue Funktionen: ConvertBackslashsToSlashs() und ConvertSlashsToBackslashs()
[CO] Kleinen fehler in PLTList::Remove(int nIndex) behoben
[CO] PLTModule::IsHandler() war mittlerweile veraltet und musste daher aktualisiert werden
[CO] PLTList & PLTDynamicList um ein paar hilfreiche weitere Funktionen erweitert - auch in PLGui2
[CO] PLTLog: GetSystemMetrics herausgenommen, somit ist diese Klasse Windows unabhängig :)
[CO] PLTLanguageHandler: Strings werden nun anstatt mit Get() mit [] angefordert, etwas kürzere und angenehmere
     Schreibweise :) CustomUpdate-Funktionen entfernt da wechseln der Sprache während das Programm läuft nicht mehr
     möglich ist. *nur probleme mach* -> API Doku um Language System erweitert
[CO] Ordnungs-Wahn: Alle Dateien nochmal durchgegangen um sicherzustellen das alle das gleiche Layout haben... also die
     Beschreibung der Dateien, #idndef usw.   Den Code durchgegangen um sicherzustellen das immer zuerst Get und danach
     erst Set funktionen kommen. (damit alles einem einheitlichen Schema folgt ;-)
[CO] File System um Ordner für 2D Guis erweitert, der Gui2D Loaded setzt nun wie alle anderen Loader den Dateinamen
     selbstständig dynamisch zusammen
[CO] PLTPluginManager: Alle Entity Plugins befinden sich in einem Module (internal, dll, entities) dessen name nun im
     Plugin selbst gespeichert wird. Mit GetModulePluginList() kann man eine Liste aller Plugins in einem Module
     anfordern. GetNumberOfModules() und GetModuleName() um Module Namen zu erhalten.
[CO] PLTTimer: Neue Funktion: Delay() -> Hält die ausführung des Programms für eine gewisse zeit an
[CO] PLTDataSet: Neue Funktionen: GetTotalSize() of den gesammten speicherbedarf in Bytes abzufragen GetElementSize() ->
     Liefert die größe eines grund Elements in Bytes zurück GetAllocated() -> Liefert die Anzahl der belegten grund
     Elements zurück. Desweiteren oben eine kurze Beschreibung des Data-Sets hinzugefügt.
[CO] PLTModuleManager: Behob einen (mehr oder weniger) kleinen fehler beim Laden von Modulen... bei SetName() wird das
     Module in den Module Handler eingetragen, kann das Module nicht geladen werden so wird es nun wieder korrekt vom
     Manager entfernt (ansonnsten crash beim Laden von nicht vorhandenen Resourcen :)
[CO] PLTTools: Neue Funktionen: FlipRB3() & FlipRB4() -> Optimierte Assembler Funktionen welche die RB komponenten in
     einem RGB bzw. RGBA Buffer vertauschen... ist bei diversen Bild Formaten notwendig... und so kann man die
     Ladezeiten etwas verkürzen :)
[CO] PLTLog: Neue Funktion: GetActive()
[CO] PLTFile um Funktionen zum Schreiben in Dateien erweitert
[CO] PLTModuleHandler: Neue Lade Funktion welche den Handler direkt mit einem Objekt läd
[CO] Stil der Friend deklarationen in den Klassen vereinheitlicht (über all nun friend class, so machts auch weniger
     probleme mit den Predefinationen :)
[CO] PLTTimer: mit GetFPSLimit() & SetFPSLimit() kann man nun eine FPS limitierung einbauen, diese FPS wird dann nicht
     überschritten... die Engine wird entsprechend aktualisiert, dadurch bleiben dem System mehr Resourcen für andere
     Dinge -> in fertigen Anwendungen sollte es keine FPS limitierung geben, zum Debuggen usw. könnte es aber nütlich
     sein :)
[CO] PLTModelHandler: GetStaticBoundingBox() & GetCollisionBoundingBox() entfernt. Wird ein Modell geladen so übergibt
     dieses all seine Bounding Boxes an sein Entity. Wird ein Modell entladen so verliert auch das Entity automatisch
     ALLE Bounding Boxes. Im Modell Handler selbst ist nun nur noch eine Bounding Box welche für die Sichtbarkeits
     bestimmung verwendet wird! (diese wird beim Modell Laden automatisch erzeugt)
[CO] PLTTools: Neue Funktionen: GetVarType() & GetVarTypeString() -> Tool-Funktionen welche einen Variable Typen in
     einen String konvertieren oder umgekehrt
[CO] Änderte bei den Pfadangaben die Backslashs zu Slashs damit alles einheitlich ist (es sind ja zwei verschiedene
     Schreibweisen im Umlauf :)
[CO] Alle PL-Tools in PLTools verschoben (ME, WE & Max plugin)
[CO] Die PLEBitField Flags waren falsch... das führte zu einem ganz erheblichen Performance verlust (da die Clear flags
     somit schrott waren :)
[CO] PLTTools: Neue Funktionen: SetFlagsString() und GetFlagsFromString() zum setzen und auslesen eines Flag-Strings
[CO] Ist der Timer 'eingefrohren' so werden nun auch keine Eingaben usw. akzeptiert, alles steht still ;-)
[CO] PLTModuleManager & PLTModule geändert. Nun hat PLTModule einen zeiger zurück auf PLTModuleManager denn wenn der
     Name von PLTModule geändert wird, so muss der Module Manager aktualisiert werden! Wichtig da die Module meist mit
     ihrem Namen angesprochen werden, daher darf es keine doppelten Module Namen geben! :)  ('Hey DU!... wer ich? NEIN
     du!' ;-)
[CO] PLTTokenizer: Einige Funktionen wie z.B. FindToken() und GetDataBlockInt() setzten am Ende automatisch auf den
     nächsten Token, dies erwies sich als ziemlich unpraktisch, daher ist dies nun geändert. (Funktionen welche den
     Parser verwenden wurden angepasst)
[CO] PLTModuleManager: Instance Check vorherst herausgestrichen da es ansonnsten unmöglich ist den Module Manager von
     einer Anwendung aus zu verwenden (da durch Template Problem Instance dort immer NULL), desweiteren nahm ich
     m_lstIDHashList heraus womit die Get(ID) funktion nun besser zum durchlaufen einer Module Schleife geeignet ist
[CO] Neue Funktion: PLTModuleManager::Create() -> Erzeugt ein neues Modul und liefert den Zeiger darauf zurück
[CO] Über PLTConfig kann man nun einstellen ob die 3 Ebenen visualisiert werden sollen oder nicht
[CO] PLTFileSystem::SetApplicationPath() fügt nun am Ende automatisch ein '\' ein wenn dieses nicht vorhanden ist
[CO] Neue Window-Klasse: PLTWindowOpenDialog -> Ein Dialog zum auswählen von Dateien -> Nam
     PLTFileSystem::GetFilenameDialog() heraus da nun überflüssig
[CO] PLTList ist nun nur noch ein 'Hilfmittel', sprich, es kann keine Zeiger mehr Löschen!
[SB] Makros geringfügig verändert und die Namen vereinheitlicht, über PL_IMPLEMENT_BASECLASS können nun auch mehrere
     Basisklassen implementiert werden
[SB] Die Makros wurden so erweitert, daß nun auch die Variablen der Entity-Klassen exportiert werden können. In einer
     VarTable werden diese Variablen dann mit ihren Namen gespeichert
[CO] PLTFileSystem: Neue Funktion: SetApplicationPath() -> Damit lässt sich der Pfad der Anwendung einstellen, im Fall
     des Modell Editos kann man diesen Pfad nun einstellen
[CO] Diverse Tool-Klassen erweitert
[CO] PLTModuleManager hatte teils gleiches problem wie das PLTGui... in den Listen wurden gelöschte Einträge nochmals
     gelöscht...
[CO] PLTTime -> Mit m_fTimeScaleFactor lässt sich nun ein universeller Zeit Faktor einstellen welcher IMMER angewannt
     wird. In der Konsole kann man diesen mit 'timescale 'f'' einstellen... beim Debuggen hilfreich :)
[CO] PLTPool -> Die Priorität eines Pool-Elements lässt sich nun verändern... praktisch wenn man ein Element vor einem
     anderen haben will (z.B. Sky layer verändern) :)
[CO] Baute eine Profiling Tool Klasse ein welche Hilfreich bei der Überwachung der verschiedenen Engine Teile sein wird,
     grob gesehen ist es nur eine Klasse welche verschiedene Gruppen von Texten verwaltet... aber mit diversen
     Hilfs-Funktionen :)
[CO] Neue Tool-Klasse: PLTPool -> Verwaltet eine Gruppe von Elementen wie z.B. Animations Informationen, Anker Punkten,
     Animation Events usw.
[CO] Copy funktionen eingebaut in: PLTMesh, PLTDataSet, PLTList, PLTDynamicList, PLTStack, PLTBitset
[CO] Neue Tool-Klasse PLTBitset zum verwalten beliebiger bits (z.B. um zu vermerken ob eine Geometry schon gerendert
     wurde oder nicht)
[CO] PLTFileSystem -> Neue Funktionen -> GetOnlyFilename() und GetDirectory()
[CO] Neue Funktion: PLTTimer::GetTickCount()
[CO] PLTTokenizer: GetNextToken() liefert nun einen Zeiger auf den gefundenen Token zurück damit man diesen z.B. sofort
     via atoi() in eine zahl umwandeln kann
[CO] PLTList & PLTDynamicList & PLTStack: Nahm Funktionen FindFirst(), FindNext() und GetCurrent() heraus da diese
     potentielle Fehlerquellen sind und der Operator [] durch die intere Zeiger optimierung mittlerweile genauso wenig
     Performance benötigt
[CO] Behob einen Fehler in der Listen-Klasse (beim Löschen... man, wie viele Fehler sind denn noch im Code!?? ;-)
[CO] Code sinnloserweise 'verschönert' ;-)
[SB] PLTTokenizer: Habe einen kleinen Fehler in den Abbruchbedingungen der Parserschleife behoben: Es ist auch möglich,
     daß sich z.B. Kommentare und ungültige Zeichen mehrfach abwechseln, diese müssen alle ignoriert werden und dürfen
     nicht als korrekte Zeichen angesehen werden
[CO] Behob einen kleinen Fehler im ModuleManager (zuerst Remove() und dann Objekt selbst entladen)
[CO] Erstellte eine einheitliche Tokenizer Klasse... benannte meine Klasse um und fügte Funktionen deiner hinzu... nun
     haben wir ein Monster Tokenizer ;-)
[SB] PLTTokenizer: Delimiters können nun auch während des Parsens ausgewechselt werden
[SB] PLTTokenizer Klasse hinzugefügt, welche zum direkten Auslesen von Tokens aus einer Textdatei dient.
[CO] PLTParser: Neue Funktionen: CompareTokens(), FindTokens(), GetTokensValueInt(), GetTokensValueStr(),
     GetDataBlockInt(), GetDataBlockFloat(), Push(), Pop()
[CO] Das Laden aus Archiven funktioniert nun endlich!! :)
[CO] Arbeitete etwas am FileSystem weiter. U.a. kann man nun auch über die Klasse PLTFile aus zip Archiven laden.
[CO] FileSystem: Dateien können nun auch außerhalb des Spieleordners liegen
     (dies sollte man aber trotzdem vermeiden :)
[CO] Baute eine Hash-Klasse ein (PLTHash) welche z.B. im Entity Manager verwendet wird
[CO] Baute PLTString Klasse ein
[SB] Module System eingebaut
[CO] PLTDataSet wurde erweitert und kann nun auch die Daten anderer Daten sets verwenden. Dies wird z.B. in PLTMesh
     verwendet um einzelne Daten mit anderen Meshs zu teilen. Ein Vorteil dieser Technik: Kommen die geteilten Daten
     'abhanden', so werden die anderen Daten Sets darüber informiert.
[CO] Erweiterte PLTDataSet um einzelene Elemente um alles noch dynamischer zu machen. Um z.B. Textur Koordinaten zu
     speichern kann man entweder PLTDataSet<PLFLOAT2> fTexCoord (1 element) oder PLTDataSet<float> fTexCoord (mit 2
     elementen) verwenden... wobei die letztere Technik mehr freiheiten lässt. ;-)
[CO] umbekannt: PLTDynamicLinkedList in PLTDynamicList
[CO] umbekannt: PLTLinkedList in PLTList
[CO] beseitigte den hässlichen Zeiger auf die delete-Funktion...  (Projekt-Einstellungen auf SE werte eingestellt :)
[CO] einen dummen Rechtschreibfehler behoben
[CO] baute dein Data Set Template ein (und erweiterte es etwas :)
[CO] viele kleine Stil anpassungen :)
[CO] Ordner strukturierung & docs
[CO] Namens Ändung
[CO] Intel-Jpg-Lib durch Independent JPEG Group's ersetzt
