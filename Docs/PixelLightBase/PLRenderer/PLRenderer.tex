\chapter{PLRenderer}


\paragraph{Motivation}
The PixelLight renderer component provides API-independence from the underlying 3D graphics APIs using renderer libraries that are dynamically loaded at runtime. The public interface of the PixelLight renderer can itself be seen as an object-oriented 3D graphics API. The render component acts as an abstraction layer between the application and the underlying rendering API, such as OpenGL, DirectX, or possibly even theoretically a software renderer. It maps the functionality offered by the underlying rendering API to a well-defined, object-oriented interface that the application uses to render scenes. The application only works with the interfaces offered by the render component and usually does not have to concern itself much with the peculiarities of the underlying 3D graphics API.

If you have the headers and and libraries of a renderer backend, you can also use the API functions by hand, for instance to use special/new OpenGL extensions. In fact, even if you don't have the headers and you KNOW that you are using for instance OpenGL, no one will hinder you using API dependent calls like \emph{glVertex}. But this is NOT recommended because you limit yourself to ONE API and porting your application is more work. If you are missing features - ask the PixelLight team for it.

The main functionality of the render component comprises routines to create render contexts and render targets, to begin and end a scene, to swap back with front buffers, to render primitives, to create vertex and index buffers, to manage render states and texture sampler stages and to offer support for high-level shading languages.

More than one renderer can be used by an application at the same time, which allows using different 3D graphics APIs to render into multiple windows - but this isn't recommended in practice and the PixelLight application framework itself can only use ONE renderer at the same time to keep things simple. Else you need to store your textures, shaders, vertex data etc. several times - one copy for each renderer API. One texture manager, one shader manager etc. are quite handy - aren't they?

Things like meshes, scene graphs etc. are NOT implemented within the renderer itself because the renderer is developed as an universal and basic component. On top of the abstract renderer interfaces there are texture, shader etc. managers within the renderer to avoid storing the same resource multiple times and to be able to use them in a more comfortable way.\footnote{But the backend implementations don't know anything about this and don't need to!} More advanced things are implemented within projects using the renderer. For instance the mesh library will add meshes and more complex animated meshes. An advanced scene system is added by the framework itself.


\paragraph{External Dependences}
PLRenderer depends on the \textbf{PLCore}, \textbf{PLMath} and \textbf{PLGraphics} libraries.




% Include the other sections of the chapter
\input{PLRenderer/General}
\cleardoublepage
\input{PLRenderer/Animation}
\cleardoublepage
\input{PLRenderer/RendererBackends}
\cleardoublepage
%\input{PLRenderer/GPUPrograms}			%[TODO] Update!
\cleardoublepage
%\input{PLRenderer/HighLevel_Textures}	%[TODO] Update!
\cleardoublepage
%\input{PLRenderer/HighLevel_Shaders}	%[TODO] Update!
\cleardoublepage
%\input{PLRenderer/HighLevel_Effects}	%[TODO] Update!
\cleardoublepage
%\input{PLRenderer/HighLevel_FAQ}		%[TODO] Update!
\cleardoublepage
