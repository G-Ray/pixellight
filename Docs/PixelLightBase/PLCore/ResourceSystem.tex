\section{Resource System}
The resource system within PLCore consists of two major parts, the loadable manager singleton, and the resource manager template.




\subsection{Resource Manager Template}
One often used element of the PixelLight technology is it's resource manager which allows resource sharing and some other features. A resource like a texture, mesh or sound which should not exist more than once in memory. Different resource handlers are able to use this resource while storing additional individual information like the current animation frame. Resource handlers keep track of the lifetime of their loaded resource and if the used resource is destroyed they will be informed automatically in order to avoid access to invalid data. Resources can be preloaded at start although no handler is using the at the moment, this can be useful to avoid loading of large resources like textures during runtime which would cause that the program holds on for a while. It's on you whether resources should be unloaded automatically or not when they are no longer used by any handler. This would avoid a memory overload. But often it's useful to hold currently unused resources still in memory to ensure good performance and not to much reloading. Therefore when e.g. a new scene is loaded resources which are already loaded needn't to be load up again which will shorten the loading times. If the new scene is loaded you can force the manager to unload all unused resources to free memory. It's also possible to protect resources which means that they are never unloaded which should be used for frequently used data. Also the resource handler provides an automatic security system which avoids that you are able to access invalid data which would cause undefined things. If you request a pointer to the resource handlers resource although no one is loaded a null pointer would be returned and accessing it would be catastrophical! It's all the time possible that a resource is unloaded and therefore the resource handlers pointer would be a null pointer. Therefore you normally have to check whether a resource handlers resource pointer is valid or not before using it - which can be nerve much. Therefore PixelLight provides a tricky system which will return a pointer to the resource managers standard resource if you request a resource pointer from an unload resource handler. Because there's normally always a standard resource you will never receive an invalid pointer which avoids crash's! You are still able to check whether or not a resource handler is loaded but the most time that's not necessary.

Note that the manager get function itself WILL return a null pointer if the requested resource wasn't found! Therefore you should never access this returned pointer without to check whether it's valid or not!


\paragraph{Pointers}
There are many functions which deal with pointers. If a function returns a pointer you should always check if it's valid and not a null pointer. Through the handler resource system you can ensure that resource pointers will always return a valid pointer. A resource handler is informed if the resource it points to is removed\ldots if a handler points to no resource it will automatically return the standard resource to ensure that always a valid pointer is returned. Therefore you should never use direct pointers to resources like textures, meshes, shaders, paths or even entities because you can't be sure that this pointer is valid. Use the offered handlers instead, or you can also merge the resource name and then query the given manager for a pointer to it but handlers are the more performance friendly way if a link to a resource is used many times.


\paragraph{Creating your own Resource Manager}
Because the resource manager is a loose template class you are able to use it to manage your own data, too! You only have to derive the 3 resource classes (resource, resource handler and resource manager) and overload the required virtual functions.
