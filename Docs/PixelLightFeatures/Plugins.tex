\chapter{Plugins}
The PixelLight \ac{SDK} comes with multiple optional plugins.




\section{Frontends}
Applications, including their lifecyle, are controlled by frontends. The \ac{SDK} provides the choice between
\begin{itemize}
\item{A null frontend without any \ac{GUI} involved, useful for example when only rendering into background buffers}
\item{A lightweight native \ac{OS} frontend}
\item{A frontend for PixelLight's own \ac{GUI} system (uniform for \ac{OS} \& ingame) perfectly integrated into the complete system\footnote{Stuff like scripting doesn't need wrappers, it just works out of the box thank's to the \ac{RTTI}}}
\item{A frontend for Qt\footnote{Qt is a cross-platform application and \ac{UI} framework, \url{http://qt.nokia.com/}}}
\item{Experimental frontends for Mozilla and ActiveX so you can run your PixelLight applications also for example within a browser window}
\end{itemize}


\paragraph{PLFrontendQt}
\begin{itemize}
\item{Frontend and adapter project to bring PixelLight and Qt together, use PixelLight to e.g. render into one or multiple Qt widgets}
\item{Static adapter class for mapping Qt strings to PixelLight strings and vice versa}
\end{itemize}


\paragraph{libRocket\_PL}
\begin{itemize}
\item{Integrates the free open source \ac{HTML}/\ac{CSS} game interface middleware \emph{libRocket} (\url{http://librocket.com/}) into PixelLight}
\end{itemize}


\paragraph{PLNature}
\begin{itemize}
\item{The sky scene node comes with multiple sky layers and creates impressive animated and atmospheric backgrounds like hills, where slowly moving clouds appear behind them}
\item{The terrain scene node is using GeoMipMapping to create easily usable, impressive and large landscapes}
\end{itemize}




\section{File Formats}


\paragraph{PLAssimp}
34 mesh and 34 scene loaders using \ac{ASSIMP} (\url{http://assimp.sourceforge.net/})\footnote{3ds, obj, Blender, Collada etc. for a full list, please have a look at \url{assimp.sourceforge.net/main_features_formats.html}}


\paragraph{PLImageLoaderEXR}
\begin{itemize}
\item{EXR using OpenEXR (\url{http://www.openexr.com/}) and \ac{HDR} image plugins}
\end{itemize}




\section{Particle Effects}


\paragraph{SPARK\_PL}
\begin{itemize}
\item{Integrates the free open source particle engine \emph{SPARK} (\url{http://spark.developpez.com}) as a plugin into PixelLight}
\item{Particle systems are usual scene nodes}
\end{itemize}


\paragraph{PLParticleGroups}
\begin{itemize}
\item{Particle groups are usual scene nodes}
\item{They emit and manage particles. Each particle can be customized in an easy way in order to create unique effects}
\item{Each particle group can only have one material for all its particles for performance reasons. But because you are able to set the texture coordinates for each particle individually, you are able to put many different particle images into one texture and then cut them out to create fast and amazing particle effects}
\item{The texture coordinate setting of the particles can be done automatically. You only have to define the rows and columns of the single sub-textures in the main material and then you are able to set the used sub texture by its index. With this technique it is also possible to create particles with animated textures!}
\item{Because the material of the particle group itself can also be animated there are even more particle animation possibilities!}
\item{Advanced particle effects like distorted particles (beams, lasers etc), rotation of the individual particles, particles with individual orientation etc. are possible}
\item{Point sprite support for maximum performance}
\item{Because the \ac{RTTI} is used, no extra particle editor is required - just tweak the variables}
\item{Different particle effects you can use without any effort. You are able to tweak them over several parameters.}
\end{itemize}




\section{Post Process Effects}
\begin{itemize}
\item{A collection of some useful\footnote{Edge detection, sharpen, bloom, blur, old film and so on} and some quite pointless\footnote{Pointless crazy bars and so on} post process effects}
\end{itemize}




\section{Network}
\begin{itemize}
\item{PLJabber project implementing the Jabber protocol}
\item{PLIRC project implementing the IRC protocol}
\end{itemize}




\section{Volume Rendering}
\begin{itemize}
\item{\ac{GPU} shader based volume raycasting}
\item{Volume rendering support is seamlessly integrated into PixelLight by using lose dynamic plugins}
\item{Highly scalable rendering system, the shader is generated automatically on-the-fly and adding new features is possible without changing the complete volume rendering system}
\item{Volumes are handled as usual scene nodes, meaning it's possible to use multiple volumes within a scene}
\item{Volume rendering is done within a scene renderer pass, meaning it's possible to combine volume rendering with already existing rendering features up to the point were volumes are rendered together with fully featured rendered scenes}
\item{The volume scene node as well as the volume scene renderer pass offer many configurable attributes like sampling rate}
\item{Clipping support: Plane, depth buffer\footnote{This makes it possible to move solid objects into the volume}, box, ellipsoid, another volume, using multiple clip primitives at the same time is possible}
\item{Ray traversal: Back-To-Front, Front-To-Back, \ac{MIP}, \ac{GMIP}, \ac{MIDA}, Isosurface}
\item{Gradient is computed on-the-fly using one of multiple techniques like central differences}
\item{Illumination: Lambertian Reflection, Blinn-Phong, Cook-Torrance}
\item{Reconstruction: Nearest neighbour, trilinear, tri-cubic B-spline}
\item{\ac{GUI} plugin for visual editing of a 1D transfer function}
\item{Debug: Several debug visualizations like ray start position are supported}
\item{Support for multiple volume related file formats, including \ac{DICOM} by using GDCM\footnote{http://sourceforge.net/projects/gdcm/}}
\end{itemize}
