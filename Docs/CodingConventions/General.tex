\chapter{General}




\section{Keep it simple!}
The world is complicated enough - if there are multiple solutions, prefer the simplest over the most complicated one! This way, the chances are high that other will understand the solution as well as you when looking at the code some years later.




\section{Encoding}
We work with multiple operation systems so we have to take into account \emph{how} text files are saved. All \emph{Diary}, \emph{Readme}, \emph{Todo} and \emph{Plan} text files saved as "Unicode (UTF-8 with signature) - Codepage 65001". All other text files like code or make files saved in classic \emph{ANSI}.




\section{File extension}
First of all, we use the old fashion \emph{.h}-file extension to mark header files - \emph{hpp} would be the \emph{correct} extension for C++, but it's not widely used. Usually, we outsource inline implementations into files with an \emph{inl}-extension to keep the header files good readable. For source codes, we use the file extension \emph{cpp}.




\section{C++0x language features}
Using C++0x language features is fine as long as
\begin{itemize}
\item{It's possible to emulate, or at least deactivate the feature within compilers don't supporting it (yet)}
\item{There's no comfortable/acceptable way to solve a task without using the feature, \emph{extern templates} is an example for such a situation - ugly hacks just to support out-of-date compilers often isn't worth the effort}
\end{itemize}
\textsl{}
Currently the following C++0x language features are used:
\begin{itemize}
\item{\emph{nullptr} - a null pointer literal}
\item{\emph{extern templates} - avoid template instantiation in other modules}
\item{\emph{override} - gives the compiler a chance to detect and blame errors related to overwriting methods}
\end{itemize}





\section{For-scope}
Within the PixelLight projects, the \emph{for-scope} is active by default. The following for instance will produce a compiler error:
\begin{lstlisting}[caption=for-scope]
for (int i=0; i<1; i++) {
  // Do anything
}
i = 20;  // i has already gone out of scope
\end{lstlisting}




\section{Null pointer}
For null pointers, use \emph{nullptr}\footnote{For example \emph{Microsoft Visual Studio 2010} and \emph{GCC 4.6} have native support for \emph{nullptr}} from \emph{C++0x} and not for example the legacy, but traditional \emph{NULL} definition or even directly a integer $0$.

\begin{lstlisting}[caption=Null pointer]
char *pszMyString = nullptr;
\end{lstlisting}




\section{Overwriting methods}
Put the methods within the base class, which are allowed to be overwritten, into a separate code block so everyone is able to find them at once.
\begin{lstlisting}[caption=Virtual methods within a base class]
//[-------------------------------------------------------]
//[ Public virtual MyClass functions                      ]
//[-------------------------------------------------------]
virtual void MyMethod() = 0;
\end{lstlisting}

When overwriting virtual methods within a derived class, put the overwritten methods into a code block telling were those methods originally came from.
\begin{lstlisting}[caption=Overwriting virtual methods within a derived class]
//[-------------------------------------------------------]
//[ Public virtual MyClass functions                      ]
//[-------------------------------------------------------]
virtual void MyMethod() override;
\end{lstlisting}
Although technically not required, do also add a \emph{virtual} to make it absolutely clear that this is a virtual method. To give the compiler a chance to find and blame possible errors like a signature change within the base class, use the C++0x language keyword \emph{override}.




\section{Casting}
PixelLight is using \emph{C++ style casts} (\emph{int i = static\_cast<int>(42.21f)}), not \emph{C style casts} (\emph{int i = (int)42.21f}). It's much easier to search for \emph{C++ style casts}\footnote{\emph{static\_cast}, \emph{reinterpret\_cast}, \emph{const\_cast}, and \emph{dynamic\_cast}} and they are less vulnerable to unintended effects as well - and because they are not that compact as the \emph{C style casts}, one may think about it a second time why there's a need for a cast.

\paragraph{GCC}
GCC, the GNU compiler, offers an option called \emph{-Wold-style-cast} to let the compiler warn if an old-style (C-style) cast to a non-void type is used within a C++ program.




\section{Const correctness}
Define functions, variables etc. whenever possible to be constant. By giving the compiler this hint, it may be possible to use special optimizations or uncover bugs within the implementation.

There's one situation were we do not use \emph{const} - when dealing with function parameters because

\begin{lstlisting}[caption=Function parameters]
void MyFunction(int nVariable1, int nVariable2);
\end{lstlisting}

is inside headers better readable than

\begin{lstlisting}[caption=Constant function parameters]
void MyFunction(const int nVariable1, const int nVariable2);
\end{lstlisting}

In this situation, the readability is more important for us. This rule does not apply for pointer or reference parameters like

\begin{lstlisting}[caption=Constant function pointer/reference parameter]
void MyFunction(const String &sVariable);
\end{lstlisting}

because the user should be able to see whether or not a function is going to manipulate the parameter variable!




\section{static const Vs. const static}
Use \emph{static const} instead of \emph{const static}. Have a look at e.g. the GCC option \emph{Wold-style-declaration} resulting in the warning \begin{quote}`static' is not at beginning of declaration\end{quote} or into chapter 6.11 of ISO C99 (\emph{Future Language Directions} -> \emph{Storage-class specifiers}).




\section{Namespaces}
PixelLight is using multiple namespaces, one for each sub-project. If you want to use for instance the string class which is defined in \emph{PLCore} you need to do this:

\begin{lstlisting}[caption=Explicit namespace]
PLCore::String sMyString;
\end{lstlisting}

Or this:

\begin{lstlisting}[caption=Using namespace]
using namespace PLCore;
...
String sMyString;
\end{lstlisting}

Try to avoid using \emph{using namespace} too often or this will result in name conflicts which you then have to resolve by hand by adding for instance \emph{PLCore::}. We recommend to NEVER use \emph{using namespace} within header files!




\section{Dynamic parameters}
When dynamic parameters are used and the name of the parameters inside a string is irrelevant, as this is the case for \emph{PLCore::Params::FromString}, the parameters are named using \emph{Param<x>} were x starts with $0$ (example: \emph{Param0=1 Param1=''Hello''}).  




\section{Names}
In general, names of classes, functions, variables and so on must have human readable names. The name has to tell as much as possible about the usage - if the user can guess correctly the usage of for example a variable by just looking at it's name, the name is perfect.

General rules:

\begin{itemize}
\item A single character as name for local (only local!) control variables like \emph{i} within a for-loop is acceptable as long as there are not to much of those at once (else use reasonable names to avoid confusion!)
\item Short cuts should be avoided whenever possible because they may leads to confusion\footnote{True story: When using \emph{Rot} as short cut for \emph{Rotation}, we once had the situation that a German speaking programmer asked confused what the color \emph{Rot} should do inside the scene node... in German, \emph{Rot} is the word for \emph{red}...} (NO stuff like \emph{stricmp()}!)
\item If there's a \emph{commonly used} name for something, just this name instead of creating a totally new one
\item Avoid long names, if there's an expressive shorter name it's the preferred one... but keep the short cut rule in mind!
\end{itemize}

Classes, structures and so on have a upper case letter at the beginning. Example:

\begin{lstlisting}[caption=Name convention]
class Player {
};
struct Info {
};
\end{lstlisting}




\section{Prefix}
Because the readability of code is extremely important when working in a team and/or using code from others, one of our goals was to make the PixelLight code as readable and well structured as possible. We are using a name style convention\footnote{We know that there are a lot of discussions around the internet whether or not prefixes should be used. In the year 2002 we decided to use them and we don't change it - due to the dimension of the PixelLight project, it would be a huge effort to change it anyway.}.

Variable prefixes for standard types:

\begin{lstlisting}[caption=Variable prefixes for standard types]
Type               Prefix    Example
bool               b         bool bActive

(n for all none standard floating point types)
int                n         int  nNumber
char               n         char nCharacter
long               n         long nHuge

float              f
double             d

(Character arrays -> strings)
char[]             sz        char szName[64]
char*              psz       char *pszName

(Pointers)
*                  p         Player *pPlayer

(References)
&                  -         char &nTest = nTest2;

struct instance    s         Info sPlayer (struct Info)

class instance     c         Player cPlayer (class Player)
\end{lstlisting}

General variable prefix for class variables:
m\_ (m for member)\\
Example: char *m\_pszName\\

Variable prefixes for PixelLight types:

\begin{lstlisting}[caption=Variable prefixes for PixelLight types]
Type               Prefix    Example
String             s         String sName

Container          lst       List lstNames

Map                map       HashMap mapNames

VectorX            v         Vector3 vPosition
(X for dimension: 2, 3 or 4)

MatrixXxX          m         Matrix4x4 mRotation
(X for dimension: 3 or 4)

Quaternion         q         Quaternion qRotation

ColorX             c         Color3 cColor (same as class)
(X for dimension: 3 or 4)
\end{lstlisting}




\section{Postfix}
We recommend you to use the PixelLight name convention and marking debug versions with a \emph{D} at the end of the filename. Example: \emph{MyPlugins.dll} = release version, \emph{MyPluginsD.dll} = debug version.




\section{Events and signals}
As soon as an event is inside a class, we refer to it as \emph{signal}. As such, the prefix \emph{Event} like within \emph{EventKeyDown} is used outside classes while prefix \emph{Signal} like within \emph{SignalKeyDown} is used inside classes.




\section{Event handlers and slots}
Within our name convention for event handlers and RTTI slot names, there's a \emph{On} within for example \emph{OnMyEvent} indicating that this is a handler/slot method. The other part of the name consists of the name of the event/signal - for \emph{OnMyEvent} this would be an event/signal with the name \emph{MyEvent}.




\section{RTTI interface}
Within PixelLight, the RTTI class properties and members are always defined in the following order:
\begin{itemize}
\item Properties
\item Attributes
\item Constructors
\item Methods
\item Signals
\item Slots
\end{itemize}
This way one knows exactly were to look for something. Further, within the RTTI class properties and members definitions, only tabs and no spaces are used to make it easier to write the definitions like a table. This makes it more comfortable for the eyes and brain to navigate to certain definition parts without to much searching around.

Here's an example source code showing the common RTTI interface layout (without the word wrap):
\begin{lstlisting}[caption=RTTI interface (without the word wrap)]
//[-------------------------------------------------------]
//[ RTTI interface                                        ]
//[-------------------------------------------------------]
pl_class(pl_rtti_export, MyRTTIClass, "", PLCore::Object, "Sample RTTI class, don't take it to serious")
	// Properties
	pl_properties
		pl_property("MyProperty",	"This is a property value")
	pl_properties_end
	// Attributes
	pl_attribute(Name,	PLCore::String,	"Bob",	ReadWrite,	GetSet,			"A name, emits MySignal after the name was changed",			"")
	pl_attribute(Level,	int,			1,		ReadWrite,	DirectValue,	"Level, automatically increased on get/set name and OnMyEvent",	"")
	// Constructors
	pl_constructor_0(DefaultConstructor,	"Default constructor",	"")
	// Methods
	pl_method_0(Return42,			int,					"Returns 42",							"")
	pl_method_1(IgnoreTheParameter,	void,			float,	"Ignores the provided parameter",		"")
	pl_method_0(SaySomethingWise,	void,					"Says something wise",					"")
	pl_method_0(GetSelf,			MyRTTIClass*,			"Returns a pointer to this instance",	"")
	// Signals
	pl_signal_1(MySignal,	PLCore::String,	"My signal, automatically emitted after the name was changed",	"")
	// Slots
	pl_slot_0(OnMyEvent,	"My slot",	"")
pl_class_end
\end{lstlisting}



\section{Reuseability and adding new stuff}
Before you add new classes, functions an so on - check first whether there's already something similar within PixelLight. If there's something you can already use directly, use it instead of writing new stuff. If there's something quite similar, have a more detailed look at it and contact your team colleagues to discuss whether a refactoring is possible and reasonable to update and/or to enhance existing stuff.

Reuseability is one of the most important concepts when creating frameworks like PixelLight... and reuseability does NOT mean that it's possible to copy'n'past it and then hacking around for a certain project! Reuseability means that it's possible to directly reuse, to share, something between multiple projects in a quite universal way without the need to enhance and hack around constantly!
