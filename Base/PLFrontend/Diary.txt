>> 02.08.2011
[CO]
PLFrontendPLGui:
- Moved "SNGui" from "PLEngine" to "PLFrontendPLGui" because it's using PLGui



>> 01.08.2011
[CO]
- Started the PLFrontend project (kind of "PLPlugin"-project successor)... now that scripting is working, it's finally time to attack another big design task.
  When we started the development of the PixelLight engine on 16 September 2002, we just had one single project: "PLEngine"
  This project just used a quite simple OS window to render stuff into it. Back then, the world was more simple regarding to required supported platforms.
  Providing support to be able to render into multiple OS windows was really a cool feature because most engines were just able to render into a single
  OS window. Over the years, the GUI stuff was moved into an own, platform independent, GUI library called PLGui. All other PixelLight projects were build
  on the top of it. PLGui is currently already within it's third (!) reincarnation.
  In the last past 9 years, the world has dramatically evolved regarding to the platforms one should really support and the current PixelLight design regarding
  to GUI handling does no longer really completely satisfies the changed needs. Now those are the requirements to be fulfilled:
  -> Be able to have absolutely no GUI at all, e.g. for server side applications or applications rendering just into a buffer *currently there's always a PLGui dependency*
  -> A quite primitive OS window for applications requiring no GUI handling, except for the OS window it's running in *PLGui is an overkill for this use case*
  -> "PLGui": PixelLight own GUI system (OS & ingame) perfectly integrated into the complete system, stuff like scripting doesn't need wrappers, it just works out of the box *currently used way*
  -> Be able to just use third party GUI systems like Qt for front-ends *currently there's always a PLGui dependency*
    -> The PixelLight editor will be Qt based because getting PLGui to the point were it's possible to write such an complex editor is just impossible with a team of two
       active spare-time developers (we already tried it years ago *PixelLab* and it was a total failure :/)
  -> Be able to embed an PixelLight application into another application, meaning another GUI system has the control and we're just a slave
    -> Be able to run in a web browser (e.g. by using "Java Web Start"/"JNLP" or/and by writing special browser plugins)
    -> Be able to run on mobile devices, e.g. Android based
    -> Be able to use ActiveX under MS Windows to embed 3D stuff into e.g. a MFC dialog (we already had to do this for a project some years ago)
    ... scripting is especially useful for the first two mentioned embed-points. This way, an application developer doesn't need to care about the target platform and is just
        writing some scripts...
  Ok, as you can see, a whole bunch of new requirements since the start of the PixelLight engine. In "Docs\Diagrams\PixelLight_PackageDiagram.png" I outlined how it will probably
  look when PLFrontend is up and running.
  Please note that the PLFrontend approach doesn't mean that I abandon the PLGui project, but having the whole system be dependent of a GUI system is not working any more with
  the changed requirements. Also, while the third reincarnation of Stefans PLGui is really cool and can be used for OS and ingame and has, by using the PL RTTI, automatic support
  for scripting and therefore integrates itself perfectly into the whole system... PLGui is still missing some features and fine-tuning. Sadly, such a GUI system is a huge task
  and currently, as already mentioned, there are only two active spare-time developers. Personally, I finally want to get PixelLight to the point were it's possible to create
  simple prototype applications in a matter of minutes by using e.g. a Lua script to load in a scene and adding some interaction - and then be able to run this on multiple
  platforms/targets. So, my focus is on that instead of taking over the development of Stefans PLGui (I already ruined the previous second reincarnation and don't want to repeat
  this experience). I really hope that in the future there's someone continuing the development of PLGui because especially the scripting-argument is a really cool argument for PLGui!
  (connecting e.g. libRocket or Qt to the PL RTTI and scripting system will be probably lot of work while it's no work at all with PLGui!)
  ... enough introduction and explanation why there's need for the PLFrontend project. Let's go to work...
- Added the (currently empty) frontend plugins
  - "PLFrontendNull": The usual dummy project doing nothing at all
  - "PLFrontendOS": Just a totally primitve OS window
  - "PLFrontendPLGui": PLGui connection
  - "PLFrontendQt": Qt connection (the new "PLQt")
  - "PLFrontendActiveX": ActiveX connection (the new "PLPluginActiveX")
  - "PLFrontendMozilla": Mozilla connection  (the new "PLPluginMozilla")
  ... while "PLFrontendNull", "PLFrontendOS", "PLFrontendActiveX" and "PLFrontendMozilla" are intended to be 100% loose dynamic plugins, "PLFrontendPLGui" and "PLFrontendQt" are
  of course also such plugins, but one is usually going to also use those libraries directly within an application (meaning linking aginst them).
- Copied the diaries of "PLPlugin", "PLPluginActiveX" and "PLPluginMozilla" into this diary because PLFrontend will be the successor of the "PLPlugin"-project... which is not limited
  to "PixelLight application as a plugin for e.g. a browser" but will also cover the "PixelLight application as executable" use case. Meaning, in the future it will be possible to just
  recompile a C++ PixelLight as shared library and then be able to use it in any available frontend.
- Using "PLPlugin::Plugin" as start point for the class "Frontend"
- Renamed "PLPluginActiveX" (still working, just tested it :) into "PLFrontendActiveX"
- Renamed "PLQt" into "PLFrontendQt"
- Renamed "PLPluginMozilla" into "PLFrontendMozilla", when testing it with Firefox 5.0 the browser didn't want to load it (sayed something about corrupt... before I did the changes...)...
  I'll check it later when PLFrontend is working as a whole...
- Removed "PLPlugin", it's been replaced by "PLFrontend"



>> 02.07.2011
[CO]
PLQt:
- Added empty project "PLQt". In the next steps, PLQt (https://sourceforge.net/projects/pixellight/) from Stephan Wezel will be integrated directly into the PixelLight
  Git repository and SDK because e.g. the editor will be Qt based. I currently use Qt 4.7.0 and I know that there's already a newer version available... but I already
  had Qt 4.7.0 compiled for VisualStudio 2010 (to avoid using VC 2008 within the PL SDK) a while ago and right now I don't want to spend time in recompiling Qt, again.
- Moved "QtStringAdapter" from PLGeneral into PLQt
- Integrated PLQt, I'am sure it's not yet final and that over time, there will be multiple simplifications



/*********************************************************\
 *  The entries below are in German only
\*********************************************************/



>> 16.04.2009
[SB]
PLPlugin:
- Fehlende Abhängigkeiten in der CMakeLists.txt hinzugefügt.



>> 03.12.2008
[CO]
PLPlugin:
- 64 Bit VC Projekt Einstellungen hinzugefügt



>> 03.12.2008
[SB]
PLPlugin:
- BasicSceneApplet entfernt. Dies wäre eine totale Verkomplizierung, wenn man hier nochmal eine extra Ableitungshierarchie
  aufmacht. Und damit könnte dann immer noch nicht eine Applikation zwischen Plugin und Exe 'geteilt' werden.
- Statt dessen hat PluginPixelLight nun direkt einen Zeiger auf eine Applikation, die dann eingebettet wird. Dank der
  Änderungen am Application-Framework kann nun generell jede Applikation (ab GuiApplication) in fremde Fenster eingebettet
  werden, dies wird hier nun einfach verwendet. Es wird eine Application wie gewohnt instanziiert, dann wird aber nicht
  Run() aufgerufen, sondern die Applikation in das Plugin-Window eingebettet. Als Test habe ich die Teapot-Application
  verwendet, die Application kann aber jetzt ganz einfach ausgetauscht werden.



>> 03.12.2008
[CO]
PLPluginMozilla:
- 64 Bit VC Projekt Einstellungen hinzugefügt



>> 16.10.2008
[CO]
PLPlugin:
- Projekt ist wieder übersetzbar, aber noch nicht wirklich wieder lauffähig. 'PL::Init()' etc. gibts nun nicht mehr, habe erstmal
  BasicSceneApplet angelegt - eine Klasse von 'BasicSceneApplication' abgeleitet die als 'Applet' fungieren soll.



>> 29.06.2008
[SB]
PLPluginMozilla:
- PLPluginMozilla implementiert.
- Anbindung an unsere abstrakte Plugin-Klasse vorgenommen und PixelLight-Plugin erfolgreich im
  Mozilla ausgeführt.



>> 28.06.2008
[SB]
PLPlugin:
- Projekt gestartet. PLPlugin stellt eine Schnittstelle zur Verfügung, um PixelLight als Plugin in andere
  Umgebungen/Applikationen einzubinden. Also PixelLight als Plugin für z.B. Browser, nicht Plugins für PixelLight :-)
  Dazu wird eine abstrakte Plugin-Klasse bereitgestellt, die von konkreten Wrappern für verschiedene Plugin-Schnittstellen
  angesprochen wird. Von dieser Plugin-Klasse werden dann konkrete Plugins abgeleitet, z.B. das standard PixelLight-Plugin,
  das wir letztlich im Browser oder sonstwo sehen wollen.
- Basisklasse Plugin implementiert, die das abstrakte Plugin-Interface darstellt.
- Basisklasse PluginImpl implementiert, die nach dem Backend-Prinzip das Interface
  für konkrete Backends bereitstellt.
- PluginOpenGL als Testplugin implementiert, in dem eine minimale OpenGL Szene angezeigt wird.
- PluginPixelLight erstellt für das standard PixelLight-Plugin. 
- Das Triangle-Sample genommen und als vorläufiges PixelLight-Plugin implementiert :-)
PLPluginActiveX:
- PLPluginActiveX implementiert. Diese konkrete Implementation von PluginImpl
  stellt das ActiveX Backend für unsere eigene Plugin-Klasse dar.
- Den Wrapper auf die Verwendung unseres abstrakten Plugin-Interfaces umgestellt.
- Den OpenGL-Test hier entfernt und dafür als PluginOpenGL in PLPlugin implementiert.
- Das PixelLight-Plugin läuft nun zum ersten Mal korrekt im Browserfenster :-)



>> 24.06.2008
[SB]
PLPluginActiveX:
- Projekt gestartet. PLPluginActiveX ist ein Container und Wrapper für ActiveX, über den das PLPlugin-Interface unter
  ActiveX verwendet werden kann.
- ActiveX control erstellt und an unsere Projektstruktur angepasst. Einstellungen
  gefunden, die zur Einbindung von OpenGL erforderlich sind.
- Kleines OpenGL Testplugin implementiert.
