>> 29.07.2011
[CO]
- Started the roadmap-point (http://www.pixellight.org/site/index.php/page/Roadmap.html) "Make elements like ingame GUI, ingame console and load
  screens to compositing layers" by moving several classes from "PLScene" into "PLEngine"
  -> Moved "SNEngineInformation" from "PLScene" to "PLEngine"
  -> Moved "SNGui" from "PLScene" to "PLEngine"
  -> Moved "SNConsole", "SNConsoleBase" from "PLScene" to "PLEngine"
  -> Moved "SNLoadScreen", "SNLoadScreenBase" and "SNLoadScreenBase" from "PLScene" to "PLEngine"
  -> More details in the PLEngine diary
  -> As a side effect, PLScene no longer depends on PLGui



>> 18.06.2011
[CO]
- "SceneNode": Renamed "RemoveModifier(SceneNodeModifier &cModifier)" into "RemoveModifierByReference(SceneNodeModifier &cModifier)" in order
  to make it possible to expose it to the RTTI



>> 07.06.2011
[CO]
- "PLScene::SceneNode" events are now implemented as RTTI signals
- "PLScene::SceneContainer" events are now implemented as RTTI signals
- "PLScene::SceneQuery" events are now implemented as RTTI signals



>> 01.06.2011
[CO]
- "SceneNode::DrawDebug()": Using the debug flags "DebugContainerAABBox" and "DebugContainerSphere" together was not working properly.
  Currently the sphere is drawn using fixed functions stuff, but the AABox was setting a GPU program which was then also used for drawing
  the sphere which was of course not working.



>> 22.04.2011
[CO]
- "SNBitmap3D" is now using "PLRenderer::DrawHelpers::DrawImage()" and is therefore finally fixed functions independent



>> 17.02.2011
[CO]
- Moved the somewhat out-dated particle group base class "PLScene::SNParticleGroup" into the "PLParticleGroups" plugin project.
  See "PLParticleGroups"-diary for more details.
- Bugfix: Ouch! There was a (as usual) stupid bug within "SceneNode::DirtyAABoundingBox()": When the axis align bounding box is
  marked as "dirty" so that it is recalculated the next time it is used, we also need to mark the data derived from the axis align
  bounding box as dirty! This was the reason why particle effects were "culled to early" within the "PLParticleGroups.scene" scene
  when looking around... because the particle effects frequently mark their bounding box as dirty - but then, it was actually never
  recalculated because derived data like the container space axis aligned bounding box looked still "clean" and therefore were not updated.
  (... double checked the lazy evaluation within scene node - because this bug should have had happened due to the importance and already
  long usage of this scene node class...)



>> 14.02.2011
[CO]
- Bugfix: "WidgetPL::~WidgetPL()": When a widget gets destroyed, we really need to remove GUI messages within the internal GUI message queue using
  this widget!



>> 19.12.2010
[CO]
- SceneNode debug text: Printed rotation is now between [0, 360]



>> 18.12.2010
[CO]
- "SceneNode::Icon" is now a property instead of an attribute because this icon should be the same for all scene node instances of the same class
  (and beside that reasonable reason, we safe a few bytes per scene node instance *g*)



>> 17.12.2010
[CO]
- SceneNode: The "Rotation"-attribute of the scene node is now a derived (human friendly) Euler angles (in degree) representation of the internal
  rotation quaternion, so, whenever possible, work internally with "GetTransform()" instead of "GetRotation()". Of course, it's not always 100%
  possible to transform an Euler angles rotation representation into an quaternion rotation representation and vice versa - but most times, it's
  sufficient. At least I found an acceptable way to get rid of the stupied double rotation storage inside scene nodes! :D



/*********************************************************\
 *  The entries below are in German only
\*********************************************************/



>> 10.12.2010
[CO]
- Das was bisher in "SNMesh::UpdateFunction()" lag, liegt nun in "SNMMeshUpdate::NotifyUpdate()", sprich, in einem Scene Node Modifier.
  Mit "SNMesh::UpdateFunction()" war ich nun ebenfalls schon gut seit 2 Jahren überhaupt nicht mehr zufrieden, hier passiert einfach
  zuviel was aber oft überhaupt nicht nötig ist da die meisten Meshes statisch sind.
  Will man das ein Mesh regelmäßig aktualisiert wird (MeshHandler::Update), so muss man nun also einen SNMMeshUpdate Scene Node Modifier
  anhängen. Dies ist denke ich aber weniger ein Problem da man ohnehin meist Manipulationen über Scene Node Modifier ausführen lässt.
  Spielt man Animationen über SNMMeshAnimation ab, muss man sich z.B. nicht weiter um ein Update kümmern.
- "SNMesh": "BuildInfo"-Attribut entfernt da schon seit längerer Zeit nicht mehr verwendet
- "SNMesh": "StaticMesh", "CalculateNormals", "CalculateTSVs" und "GenerateStrips" zu Flags gemacht (... Speicherverbrauch...), auch
  das stand bereits seit etlichen Jahren auf meiner gigantischen ToDo-Liste *g*
  "StaticMesh" in "DynamicMesh" geändert, standardmäßig sind Meshes statisch.
- VisNode um "GetProjectionMatrix()", "GetViewMatrix()" und "GetViewProjectionMatrix()" erweitert so das man direkt alle gängigen Matrizen
  Griffbereit hat, und nicht z.B. umständlich eine View Projection Matrix "herausrechnen" muss obwohl diese intern bereits vorliegt



>> 09.12.2010
[CO]
- SceneNode: "EventDrawn"-Event und "GetDrawn()" & "SetDrawn()" Methoden entfernt. Mit dieser Lösung rauszufinden ob etwas
  "Sichtbarkeits relevant" ist und daher z.B. ein Update benötigt, war ich noch nie sonderlich zufrieden da man an zu vielen Stellen
  "SetDrawn()" aufrufen musste und der interne "Drawn"-Zustand irgendwann auch wieder zurückgesetzt werden musste - was bisher in
  der nun nicht mehr vorhandenen "Update()"-Methode passierte. Viel zu kompliziert.
- SceneNode: "EventAddedToVisibilityTree"-Event und "OnAddedToVisibilityTree()"-Methode hinzugefügt... der Nachfolger von
  "Drawn". Sobald etwas in einen Sichtbarkeitsbaum eingehängt wird, der anschließend zum Rendern verwended wird, wird
  "OnAddedToVisibilityTree()" der Scene Node aufgerufen. Die Standardimplementation dieser neuen Methode erzeugt standardmäßig
  ein "EventAddedToVisibilityTree"-Event. Die "AddedToVisibilityTree" Benachrichtung kann nun dazu verwendet werden um sich z.B.
  zu merken "aha, diese Partikel sind auf dem Bildschirm und sollten daher eventuell animiert werden". Ein anderes bisher bestehendes
  Problem konnte ich mit dieser Lösung nun auch endlich erschlagen: Scene Nodes die sich wie Billboards verhalten, also "immer in die
  Kamera schaun" -> "AddedToVisibilityTree" erhält als Parameter den Sichtbarkeitsknoten der diese Scene Node representiert, hier
  kann man nun z.B. die World Matrix noch manipulieren. :D
  Ich frage mich wieso ich nicht schon früher auf diese relativ einfache Lösung, über die sich mehrere Problemstellungen lösen lassen,
  gekommen bin ...



>> 08.12.2010
[CO]
- Am Scene Graph Update Refactoring weitergearbeitet (mit nur max ein paar wenigen Stunden pro Tag kommt man einfach schleppend voran :/)



>> 07.12.2010
[CO]
- SceneNode und SceneNodeModifier eine virtuelle "OnActivate()"-Methode erweitert, diese Methode wird immer aufgerufen wenn etwas "wirklich"
  Aktiv oder Inaktiv wird (da z.B. alle Scene Nodes eines Scene Containers inaktiv werden sobald der Scene Container inaktiv wird). In dieser
  Methode träge man dann normalerweise Events ein/aus, je nach active-State - bisher wurde hierfür immer "SetFlags()" mißbraucht was definitiv
  nicht gut war. Mittlerweile trägt das Update-Refactoring erste Früchte - statt in größeren Szenen über 1000 Nodes-Updates in jedem Frame zu haben,
  hat man nun oft nur noch so um die 50 Node-Updates pro Frame (Look Around Scene Node Modifier etc.).
  Ich weis nicht ob der Name "OnActivate()" optimal ist, da man das eventuell mit "IsActive()" verwechseln könnte, ich fand allerdings keinen besseren
  treffenden Namen. :/



>> 06.12.2010
[CO]
- SceneNode: "EventUpdate"-Event entfernt, "UpdateNode()"-Methode entfernt, virtuelle "UpdateFunction()"-Methode entfernt.
  -> Da es von Scene Nodes eine enorme Masse von Instanzen geben kann, sollte eine Scene Node von sich aus passiv sein und kein ständiges
     Update benötigen - der großteil von Scene Nodes benötigt ohnehin keine Updates. Entsprechende Umbauten wollte ich schon seit Jahren
     vornehmen, und jetzt ist's einfach höchste Eisenbahn da gerade bei größeren Szenen hier CPU-Leistung unnötig verheizt wird. :/
- SceneContext: Um "Update()"-Methode, die das neue "EventUpdate"-Event auslöst, erweitert - eine art von "Taktgeber". Wenn sich etwas,
  z.B. eine Scene Node regelmäßig aktualisieren muss, kann es sich hier einklinken. Natürlich kann man über die Update-Reihenfolge keine
  Aussage treffen, aber das war auch vorher nicht immer so einfach - und generell sollte die Update-Reihenfolge egal sein. Ich hätte gleich
  ein kompliziertes "Scheduling"-System einbauen können, wollte den ersten Refactoring Schritt betreffend Scene Graph Update aber einfach halten.



>> 26.11.2010
[CO]
- Alles was bisher in "Compositing/General/" & "Compositing/Debug/" & "Compositing/PostProcessing" lag in das Grundverzeichnis von PLCompositing verschoben
- "SNMPostProcess" & "SNMPostProcessDepthOfField" & "SNMPostProcessGlow" von PLScene nach PLCompositing verschoben
- "FullscreenQuad" von PLScene nach PLCompositing verschoben
- "SceneRenderer::DrawScene()": Nahm das ändern von Render-States raus, diese Methode macht nun nichts anderes mehr als die Draw-Methoden aller Szene
  Renderer Schritte aufzurufen
- "SceneRenderer::DrawPass()" entfernt da mittlerweile überflüssig
- "SceneRenderer::SetRenderTarget()" entfernt da mittlerweile überflüssig



>> 14.11.2010
[CO]
- SRPBackgroundBitmap: "Material"-Attribute ist nun leer anstatt einen Standard-Wert zu haben. In den Scene Renderer Dateien ist
  "SRPBackgroundBitmap" nun standardmäßig aktiviert, da allerdings kein Material gesetzt ist passiert dann auch nicht viel weiter... will man ein
  Hintergrundbild haben, so muss man nun nur noch "Material" setzen ohne dann "SRPBackgroundBitmap" auch noch aktivieren zu müssen. :)
- "WidgetPL::Destroy()": Die Ingame-GUI Implementation hält einen Zeiger auf das aktuelle Mouse Over Widget (m_pMouseOver), dieser Zeiger wurde
  allerdings nicht auf NULL gesetzt wenn dieses Widget zerstört wurde...
- "GuiPL::FindWidgetAtPos()": Die Maus sollte nicht mit deaktivierten Widgets interagieren können... die Abfrage war bereits auskommentiert und
  mit einem [TODO] versehen drinnen - scheint mittlerweile so wie gewünscht problemlos zu gehen :D



>> 12.11.2010
[CO]
- Endlich mit dem längst überfälligen Refactoring des Shadow Mappings begonnen. Verschob als ersten Schritt die aktuelle Shadow Mapping implementation
  von PLScene nach PLCompositing da diese hochspezielle Render-Technik nix im allgemeinen, soweit möglich Render unabhängigen, PLScene Projekt zu
  suchen hat (das PLScene Projekt ist nebenbei ohnehin enorm umfangreich, da muss hier nicht auch noch Shadow Mapping mit reingestopft sein :).
- "EngineGraphicConfig": "Shadows", "HighRenderQuality", "Detail" und "Visibility" entfernt da schon seit geraumer Zeit nicht mehr verwendet und als
  Globale *fixed build in* Option auch schon länger nicht mehr Sinnvoll. Dies wird man auf "Application"-Ebene entscheiden müssen welche Optionen
  man für den Endbenutzer nach außen hin geben will.



>> 15.10.2010
[CO]
- Wie mit Stefan vor einigen Tagen bespochen (das Master-Studium ist leider ziemlich Zeitintensiv so das ich bisher noch nicht dazu kam das abzuarbeiten :/),
  besitzen nun alle Scene Nodes und Scene Node Modifiers welche "GetInputController()" implementieren ein Attribute Namens "InputSemantic". Als Default Wert
  von "InputSemantic" habe ich mich für Klassenname mit Prefix "PixelLight" statt "SNM"/"SN" und ohne "Controller" am Ende entschieden.
- Wie mit Stefan vor einigen Tagen bespochen, "SceneContext" um "EventInputControllerFound" Ereigniss erweitert welches von den Input Controllern
  abgefeuert wird so das man an zentraler Stelle eine Möglichkeit hat rauszufinden, welche Input Controller es gibt, und dann diese mit z.B. realen
  Eingabegeräten verbinden kann. Der erste Parameter ist der gefundene Input Controller, der zweite Parameter "Input Semantic" wodurch man rausfinden
  kann für was der Input Controller gut sein soll. (z.B. einen Spieler herumbewegen, ein Fahrzeug steuern etc.) Woher der Input Controller kommt,
  z.B. ob von einer Scene Node oder einem Scene Node Modifier, sollte hier nicht weiter interessieren.



>> 08.10.2010
[CO]
- SceneNode besitzt nun genauso wie SceneNodeModifier eine virtuelle Methode namens GetInputController, es wäre sicherlich nicht Benutzerfreundlich
  zu erzwingen das Eingabebehandlung *ausschließlich* über Modifier zu erfolgen hat. (in PLDemo2DGame z.B. ist es Praktisch das direkt in der SceneNode
  zu erledigen)
  Zwar besitzen in der Regel nur *extrem* wenige SceneNodes Eingabebehandlung, allerdings ist es dann denke ich nett direkt über SceneNode an den
  Input-Controller gelangen zu können - Speicher, oder Performancenachteile hat man durch diese weitere virtuelle, standardmäßig nicht Implementierte
  Methode ja nicht.
- SNMOrbitingController: Nutzt nun einen Virtuellen Input Controller, die Implementation ist dadurch *minimal* einfacher geworden *g*



>> 02.10.2010
[CO]
- Nicht verwendetes "SNMMouseMoveController" entfernt... das wird ohnehin demnächst überflüssig durch die Nutzung von virtuellen Input Controllern
- "SNMMoveController" verwendet nun virtuelle Input Controller, "FlipXAxis", "FlipYAxis" & "FlipZAxis" Flags entfernt da sich das nun universeller
  über die Input Controller konfigurieren lässt (auch wenn dies im Augenblick z.B. in PLViewer noch nicht komplett über scene/config Dateien geht)



>> 01.10.2010
[CO]
- Nach einer Diskussion mit Stefan "SNMRotationController" in "SNMLookController" umbenannt
- "SNMMouseLookController" entfernt (zukünftig "SNMLookController" verwenden)
- Wie mit Stefan besprochen SNMPosition & SNMRotation & SNMScale zu SNMTransform Basisklasse kombiniert
- Wie mit Stefan besprochen SceneNodeModifier um virtuelle Methode "GetInputController()" erweitert



>> 30.09.2010
[CO]
- "SNMCameraZoom": "Zoom" Attribute in "ZoomDegree" umbenannt
- "SNMCameraZoom": Input Nutzung entfernt, dafür "SNMCameraZoomController" hinzugefügt das von "SNMCameraZoom" abgeleitet ist und sich "ausschließlich"
  um Input kümmert
- "SNMRotationController" Scene Node Modifier als Ersatz für das alte "SNMMouseLookController" hinzugefügt, durch den Virtuellen Controller ist das ja
  nun nicht mehr nur auf Maus fixiert (war es ohnehin nicht mehr da auch Space Mouse unterstützt wurde)



>> 26.09.2010
[CO]
- Shader & Zeichnen Dinge aus "FullscreenQuad" entfernt da diese Hilfs-Klasse möglichst universell sein soll... im Grunde besteht diese Klasse
  nun nur noch aus einem Vertex-Buffer, ist aber ok da der Vertex Buffer hier einfach das relevante ist und es bereits hilft wenn man den Buffer
  nicht ständig selbst anlegen und füllen muss :D
- ShadowMapManager verwendet nun das neue Shader-Interface, den Program Generator und unterstützt nun ebenfalls GLSL



>> 25.09.2010
[CO]
PLCompositing:
- HDRBloom verwendet nun das neue Shader-Interface, den Program Generator und unterstützt nun ebenfalls GLSL
- SRPDeferredGlow verwendet nun das neue Shader-Interface und unterstützt nun ebenfalls GLSL
- SRPDeferredDOF verwendet nun das neue Shader-Interface und unterstützt nun ebenfalls GLSL
- SRPDeferredSSAO verwendet nun das neue Shader-Interface und unterstützt nun ebenfalls GLSL
-> Damit ist endlich alles in PLCompositing auf das neue Shader-Interface umgestellt und läuft auch direkt mit GLSL-Shadern :D



>> 18.09.2010
[CO]
- PLCompositing: SRPEndHDR: Wird automatische Helligkeitsermittlung verwendet, so wird beim Tone Mapping die Helligkeit nun im Vertex Shader
  aus der Texture ausgelesen (Vertex Texture Fetch) und als z-Komponente der Texture Koordinate an den Fragment Shader weitergegeben. So hat
  man nur noch 4 Zugriffe auf die Texture mit der Helligkeit anstatt xxxx zugriffe im Fragment Shader. Performancemäßig konnte ich zwar keinen
  unterschied messen, eventuell weil der Texture Cache seinen Job sehr gut erledigt, aber man muss der GPU das Leben auch nicht unnötig schwerer
  machen wenn es offensichtliche Optimierungsmöglichkeiten gibt. :D



>> 17.09.2010
[CO]
PLCompositing:
- SRPDeferredGBuffer: Ein kleines Experiment gemacht das sogar geglückt ist: Anstatt Meshes als gesamtes anzugehen, werden nun nur noch die
  Mesh Geometrien betrachtet. In einem ersten Schritt werden von allen sichtbaren Scene Nodes Mesh Geometry relevante Daten in "Mesh Batches" gepackt,
  die u.a. Material, Index Buffer, Vertex Buffer etc. haben - also total abstrakt und losgelöst von der komplexen Mesh Klasse. Beim Rendern werden
  dann die "Mesh Batches" verwendet, dazu werden momentan alle gefundenen Materialien durchlaufen, und dann jeweils alle Mesh Batches gezeichnet
  welche ein gemeinesames Material nutzen. Somit wird nun also pro Render Schritt jedes Material nur noch einmal gebunden, und dann auf einen schlag
  alles gezeichnet das dieses Material nutzt. Da die Materialien recht viele State Changes auslösen können, bringt das mehr als nur darauf zu achten
  Meshes von vorne nach hinten sortiert zu zeichnen um Füllrate zu sparen... wenn der Tiefenbuffer für z.B. Dynamic Occlusion Culling gefüllt wird,
  bringt das sortieren nach Tiefe hier in SRPDeferredGBuffer ohnehin nichts mehr. Die aktuelle SRPDeferredGBuffer lässt sich natürlich noch weiter
  Optimieren, diese relativ einfache Umbauarbeit hat in ein paar Projekten allerdings bereits einen netten Performance schub gebracht... und
  die Implementation ist zumindestens ein klein wenig Überschaubarer geworden. :D



>> 16.09.2010
[CO]
PLCompositing:
- HDRLightAdaptation verwendet nun das neue Shader-Interface und unterstützt nun ebenfalls GLSL
- HDRAverageLuminance verwendet nun das neue Shader-Interface und unterstützt nun ebenfalls GLSL



>> 07.09.2010
[CO]
PLCompositing:
- SRPDeferredLighting verwendet nun das neue Shader-Interface, den Program Generator und unterstützt nun ebenfalls GLSL
- SRPDeferredGBuffer verwendet nun das neue Shader-Interface, den Program Generator und unterstützt nun ebenfalls GLSL



>> 06.09.2010
[CO]
PLCompositing:
- SRPDeferredHDAO verwendet nun das neue Shader-Interface, den Program Generator und unterstützt nun ebenfalls GLSL
- SRPDeferredGBuffer & SNDirectionalLight & SNLight um LATC2 Support erweitert, dazu habe ich erstmal entsprechende Shader-Flags hinzugefügt, auch
  wenn das mittlerweile stellenweise extrem viele Flags sind. Für Texture-Komponenten tauschen gibts mittlerweile auch "GL_EXT_texture_swizzle",
  ich wollte allerdings jetzt nicht NOCH eine OpenGL Erweiterung hinzufügen für Komponenten vertauschen, am Ende gibts Systeme die das nicht
  unterstüzen etc....



>> 05.09.2010
[CO]
PLCompositing:
- SRPDeferredAmbient verwendet nun das neue Shader-Interface, den Program Generator und unterstützt nun ebenfalls GLSL
- SRPDeferredDepthFog verwendet nun das neue Shader-Interface, den Program Generator und unterstützt nun ebenfalls GLSL
- SRPDeferredGBufferDebug verwendet nun das neue Shader-Interface, den Program Generator und unterstützt nun ebenfalls GLSL
- SRPDeferredGodRays verwendet nun das neue Shader-Interface, den Program Generator und unterstützt nun ebenfalls GLSL
- SRPDeferredEdgeAA verwendet nun das neue Shader-Interface, den Program Generator und unterstützt nun ebenfalls GLSL
- SRPEndHDR verwendet nun das neue Shader-Interface, den Program Generator und unterstützt nun ebenfalls GLSL
- SRPDeferredHBAO verwendet nun das neue Shader-Interface, den Program Generator und unterstützt nun ebenfalls GLSL



>> 20.08.2010
[CO]
- Ingame GUI um "CaptureMouse" Support erweitert



>> 19.08.2010
[CO]
- Ingame GUI um "AlphaTransparency" Support erweitert



>> 11.08.2010
[CO]
- FontPL: Die verwendete Renderer-Font wird nicht mehr zerstört da ansonnsten der Renderer FontManager keine Chance hat
  vernümpftig Fonts zu cachen so das diese nicht ständig neu erzeugt werden müssen (Slideshow)



>> 08.08.2010
[SB]
- In allen SceneNodes und Modifiern, die Input-Devices verwenden, wird nun zunächst überprüft, ob das VirtualInput-Device
  vom SceneContext gerade aktiviert ist, oder nicht. Somit kann zumindest verhindert werden, dass Eingaben entgegen genommen
  werden, wenn gerade das Fenster deaktiviert ist, auch wenn ansonsten noch direkt mit Devices gearbeitet wird. Als nächstes
  müssten hier alle Klassen, die Input verwenden, auf die Verwendung des virtuellen Input-Controllers umgestellt werden,
  also am besten eigene Controller definieren, auf die dann von aussen zugegriffen wird und die man dann mit dem virtuellen
  Controller verbindet. Zum Übergang reicht es aber so.



>> 08.08.2010
[CO]
- SRPFunctionsPost, SRPFunctionsPre, SRPFunctionsSolid und SRPFunctionsTransparent setzen nun zur Sicherheit auch nochmal
  Fixed Functions View & Projection Matrize... denn ein anderer Compositing Layer kann diese verändert haben...
- SNBitmap2D läuft wieder



>> 07.08.2010
[SB]
- SceneContext hat nun einen Zeiger auf einen virtuellen InputController, der von SceneNodes verwendet werden soll. Dies
  ist in keiner Weise verbindlich oder automatisiert, sondern dient nur als Hinweis für die SceneNodes, die auf Eingaben
  reagieren wollen. Da wir vom Konzept her eine Scene fest an ihren SceneContext gebunden haben, scheint mir dies der
  logischste Platz dafür zu sein, denn Applications könnte es mehrere oder auch gar keine geben, jede SceneNode kann jedoch
  auf ihren Context zugreifen. Eine SceneNode, die auf Eingabegeräte angewiesen ist, sollte also mittels GetSceneContext()
  und GetDefaultInputController() einen Zeiger auf das virtuelle Gerät abfragen und dieses dann nutzen. In einigen Fällen
  kann es auch immer noch sinnvoll sein, direkt auf echte Devices zuzugreifen, dabei muss jedoch berücksichtigt werden, dass
  diese z.B. immer aktiv sind. Im Regelfall sollte also immer der virtuelle Input-Controller verwendet werden.



>> 07.08.2010
[CO]
- Minimalistischen Ladebildschirm SNLoadScreenPL hinzugefügt (PL Logo + Ladefortschritt Text)



>> 06.08.2010
[SB]
- An erschreckend vielen Stellen wird hier noch zentral auf die Config zugegriffen, und um diese zu erhalten muss natürloch
  auch zentral auf die Applikation zugegriffen werden. Das geht zwar im Standardfall, aber wir erlauben eben auch explizit
  die Möglichkeit, dass jemand *nicht* das Application-Framework verwendet. In diesem Falle ist dann der Crash vorprogrammiert.
  Ebenfalls wird es wohl beim Embedding so sein, z.B. beim Browser-Plugin oder in anderen Toolkits, hier ist es auch zumindest
  nicht unwahrscheinlich, dass die Application-Klassen nicht verwendet werden. Habe nun erstmal Sicherheitsabfragen eingebaut,
  so dass es zumindest keinen Absturz geben sollte, wenn keine Application-Klassen vorhanden ist. Für Config-Werte werden dann
  erstmal Default-Werte verwendet. Insgesamt muss hier aber das gesamte Config-System überarbeitet werden, so dass nicht mehr
  von einer zentralen Config-Instanz ausgegangen wird, in der alle steht, sondern alles hübsch top-down *von* einer zentralen
  Instanz nach unten weitergegeben wird, anstatt dass von unten auf die zentrale config "durchgegriffen" wird, was natürlich
  auch verhindert, dass man z.B. von etwas zwei Instanzen mit unterschiedlichen Configs hat etc.



>> 06.08.2010
[CO]
- SQCull: Das "Schwarz werden" das beim durch Portale durchlaufen auftreten konnte ist nun weg. Die Dinge die man am direkten Horizont
  eines Portals berücksichtigen muss, sind etwas tricky. Hier in diesem Fall hatte ich es wohl mit Rechenungenauigkeiten zu tun, der
  "durch das Portal laufen"-Test meldete das man noch nicht durch das Portal ist, bei der Sichtbarkeitsbestimmung wurde hingegen festgestellt
  das man sich bereits auf der anderen Portal Seite befand - und wenn einem ein Portal den Rücken zuwendet, kann man es überspringen.
  Da ich momentan keine Ahnung habe wie ich diesen Randfall besser behandeln kann, wird, wenn Portal und Kamera im gleichen Container sind,
  der Portal-Seiten test nicht ausgeführt. Wenn das Sichtbarkeitssystem nochmal überarbeitet wird, findet man eventuell bessere Lösungen.
  (diese Refactoring wird allerdings etliche Wochen in Anspruch nehmen da viel Research nötig wird um ein besseres Sichtbarkeitssystem
  auf die Beine stellen zu können, derzeit gibts wichtigeres und das aktuelle System tuts momentan noch)
  Ein zweites Problem ergab sich, ebenfalls am Portal horizont, mit dem neu errechneten View Frustum - wenn die Kamera in der Portal Bounding
  Box ist, wird daher nun einfach der Kamera View Frustum weiterverwendet damit keine ungültigen da gigantisch ausgedehten View Frustums mehr
  entstehen.



>> 04.08.2010
[CO]
- SRPLightEffectsFixedFunctions: Setzt zur Sicherheit Projection & View Matrize... denn leider kann es sein das sich diese Zustände
  jederzeit ändern. Im Dungeon Demo hatte ich ganz selten mal ein "Aufblitzen" wo ich der Meinung war "das sieht nach Corona/Lensflare"
  aus - scheint tatsächlich so zu sein das selten mal diese Matrizen irgendwo auf etwas anderes gesetzt wurden. (was auch ok ist, denn
  das sind eben Render-Zustände) Nun konnte ich diesen Grafik-Bug noch nicht wieder beobachten.



>> 28.07.2010
[CO]
- PLCompositing::SRPDeferredGBufferDebug Bugfix: Wenn eine GBuffer Texture nicht da ist, weil dort z.B. keinerlei Inhalt drinnen ist,
  wird der Bildschirm nun bei der Debug-Ansicht Schwarz gezeichnet wie man es erwarten würde



>> 27.07.2010
[CO]
- SNMPositionKeyframeAnimation & SNMRotationKeyframeAnimation & SNMScaleKeyframeAnimation um PlaybackNoLoop & PlaybackPingPong Flags erweitert



>> 25.07.2010
[CO]
- SNConsoleBase an PLInput refactoring angepasst so das man wieder Befehle eingeben kann
- SNMPositionKeyframeAnimation um CoordinateSystem erweitert, dadurch müssen die Keys nicht mehr zwangläufig im gleichen Scene Container
  liegen wie die Scene Node selbst. Dies ist bei über Portalen aufgebauten Szenen ziemlich sinnvoll. Für Rotation & Skalierung macht
  das denke ich weniger Sinn und daher habe ich diese Modifier nicht erweitert.



>> 24.07.2010
[CO]
- "VisContainer::AddSceneNode(" Bugfix: Wenn ein Portal bei der Sichtbarkeitsbestimmung gefunden wurde, die Ziel-Zelle allerdings zu diesem
  Zeitpunkt noch nicht vorhanden ist (weil diese eventuell erst später geladen wird...), so konnte man durch dieses Portal dann dauerhaft
  nicht die Ziel-Zelle sehen auch wenn diese dann im späteren Verlauf existierte.



>> 23.07.2010
[CO]
- SNBitmap3D::PositionOffset wurde wie GetSet implementiert und sollte das auch sein, war aber DirectValue - nun sind die Kerzen-Flammen
  im Dungeon-Demo endlich wieder korrekt positioniert :D
- SNMBillboardCylindrical nutzt kein Fixed Functions mehr - und schon sieht das Fackel-Feuer im Dungeon korrekt aus, einfach nur Chaotisch
  dieses Fixed Functions zeug :/ (gleiche Änderung für SNMBillboardSpherical)



>> 17.07.2010
[CO]
- Wie von Stefan gewünscht, PLCompositingShaders & PLCompositingFixedFunctions zu einem gemeinsamen Projekt PLCompositing
  zusammengefasst. Ich habe einfach PLCompositingShaders in PLCompositing umbenannt, und die paar PLCompositingFixedFunctions
  in einen FixedFunctions Unterordner verschoben und die Klassen entsprechend umbenannt damit es keine Namenskonflikte gibt.
  So herum ist's denke ich das beste da Fixed Functions nur noch zur Vollständigkeit drinen sind, und das Shader basierende
  *deutlich* mehr ist, und sicherlich auch noch mehr wird.



>> 15.07.2010
[CO]
PLCompositingShaders:
- Material State Change Optimierung vom "30.06.2010" rückgängig gemacht da die Material Features mittlerweile auch davon Abhängig sind was
  ein Mesh an Vertex Daten bietet - daher konnte es zu Fehlerhafter Darstellung kommen.



>> 14.07.2010
[CO]
- Ingame GUI: Die Bildschirmgröße der GUI lässt sich nun Einstellen, somit ist auch eine GUI größe von z.B. 320x200 statt 1024x768 möglich
- GraphicsPL::DrawText: Text Hintergrund wird gezeichnet
- GraphicsPL::DrawRect & GraphicsPL::DrawBox Bugfix, die Renderer Funktion erwartet die größe, nicht eine zweite Ecke
- PLCompositingShaders Bugfix: SRPDirectionalLighting & SRPLighting: Wenn keine Normal Map vorhanden ist, kann auch kein Parallax Mapping verwendet werden
  (führte hier zu einem Shader Fehler da ich im Shader davon Ausging das die Definitionen passend sind)
- Altes PLEngine Projekt in PLScene umbenannt
- Application Framework Klassen aus PLScene nach PLEngine verschoben



>> 13.07.2010
[CO]
- "MousePicking::PerformMousePicking()" nutzt das neue "PLGui::Widget::GetMousePos()" um die aktuelle Mausposition im verwendeten
  Fenster zu ermitteln. Man "hätte" dafür sicherlich auch Events von Widget nutzen können, allerdings wäre dies Aufwändiger geworden +
  ein Picking Versuch ohne das sich die Maus vorher bewegt hat, hätte nicht funktioniert da man noch keine gültigen Mausdaten über Events
  bekommen hätte.
- Ingame GUI: Maus Implementiert, es gibt allerdings immer noch einiges an Detailarbeit im Ingame GUI zu erledigen
- In allen GLSL Shadern wird nun mit dem Veralteten "attribute" und "varying" anstatt "in" und "out" gearbeitet da Stefans NVIDIA GPU
  scheinbar Probleme mit neueren GLSL hat + OpenGL ES 2.0 ebenfalls nur "attribute" und "varying" kennt



>> 09.07.2010
[CO]
- FontPL & ImagePL Implementiert
- TrayIconPL wird für ein Ingame GUI nicht benötigt
- ClipBoardPL verwendet direkt die Implementation der System GUI
- GraphicsPL implementiert



>> 08.07.2010
[CO]
- (Noch) Leeres PLGui3 Ingame GUI Backend hinzugefügt



>> 08.07.2010
[SB]
- RenderWindow: Wenn das Fenster aktiviert wird, wird nun die neue Methode SetTrapMouse() verwendet, um die Maus im
  Fenster "gefangen" zu halten. Hier sollte später noch der Cursor ausgeblendet werden, und mit z.B. Escape müsste man
  dann die Möglichkeit geben, das MouseTrapping zu deaktivieren, um z.B. dann das Fenster schließen oder den Task
  wechseln zu können. Ausserdem sollte dieser Modus natürlich ein- und ausschaltbar sein, da es von der Art der
  Applikation abhängt, ob man dies verwenden möchte oder nicht (in Games wie z.B. Shootern ist dieser Modus sicherlich
  notwendig, bei hauptsächlich mit der Maus bedienten Programmen wie OCD aber eher nicht).



>> 03.07.2010
[CO]
- "Guis"-Verzeichnis entfernt, sprich, der alte Debug Dialog ist nun weg
- Das was früher "Debug Dialog" etc. hies, heißst zukünftig "Edit Dialog" etc. da es eigentlich schon seit
  Jahren tatsächlich mehr als nur für Debugging brauchbare war, und zwar wirklich zum Bearbeiten von z.B.
  Scenen... und "Edit" ist zudem kürzer als "Debug". *g*
- WindowConnection (habe das vom Namen her erstmal so gelassen, und nicht z.B. in "WidgetConnection" umbenannt),
  RenderWindow und RenderFrame auf PLGui3 umgestellt
- RenderWindow in RenderWidget umbenannt
- RenderFrame in RenderWindow umbenannt
- PreviewWindow in PreviewWidget umbenannt



>> 01.07.2010
[CO]
- SNEngineInformation & SNCoordinateAxisRotation funktionieren wieder wie vor den DrawHelpers umstellungen



>> 30.06.2010
[CO]
PLCompositingShaders:
- SRPDiffuseOnly & SRPDirectionalLighting: Kleine Optimierug eingebaut die unter umständen die Anzahl der Material wechsel reduzieren kann
  (kommt jeweils auf die Szene und den Aufbau der Meshes an)



>> 29.06.2010
[CO]
- Die Szene Renderer Dateien heißen nun "FixedFunctions.sr" (früher "Basic.sr") und "Forward.sr" (früher "ShaderLighting.sr") damit diese
  nun auch Namentlich auf einem aktuellen Stand sind. "Deferred.sr" war vom Namen her bereits ok. "Forward.sr" ist nun der Standard-Renderer
  da dieser denk ich die beste Kompatibilität bietet. (gerade auch in hinlick auf OpenGL ES 2.0)
  Das mit den Fixed Functions ist nur noch zur Vollständigkeit da, sollte aber nicht verwendet werden wenns es keinen wichtigen Grund dafür
  gibt.



>> 27.06.2010
[CO]
- SNMTransformGizmo und abgeleitete Klassen entfernt... durch die DrawHelper Umstellungen läuft das derzeit nicht, es lief noch nie
  so gut das man es Produktiv hätte einsetzen können, und derzeit ist keine Zeit das zu überarbeiten und da es derzeit auch nicht
  wirklich benötigt wird -> ab ins Archive damit



>> 26.06.2010
[CO]
- Durch die PLRenderer::DrawHelpers Arbeiten können nun SRPDebugSceneNodeIcons, SRPEnd und SRPBackgroundBitmap direkt in PLEngine liegen
  da diese nicht mehr direkt Fixed Functions nutzen



>> 25.06.2010
[CO]
- SNMPositionPath: Debug Visualisierung läuft wieder
- SNText2D: 2D Schrift an 3D Position läuft wieder
PLCompositingFixedFunctions:
- SRPLightEffects läuft wieder korrekt



>> 24.06.2010
[CO]
- SRPDebugSceneNodeNames: Durch das neue PLRenderer Font Interface kann dieser Scene Renderer Schritt nun direkt in PLEngine liegen



>> 20.06.2010
[CO]
- "ShadowVolume"-Klasse und die dazugehörenden Vertex Shader "ShadowVolumeCPU.cg" und "ShadowVolumeGPU.cg" aus "Standard.zip" ins
  Archive verschoben. Shadow Volumes werden schon seit Jahren bei uns nicht mehr genutzt da Shadow Mapping deutlich mehr zu bieten
  hat und zudem viel einfacher und universeller ist (und vorallem Geometry unabhängig!!). Bevor ich nun die Klasse nochmal groß
  an das neue Shader Interface anpasse und wieder lauffähig mache obwohl wir das nicht brauchen - ab ins Archive. :D



>> 19.06.2010
[CO]
PLCompositingShaders:
- SRPLighting: GLSL Spot Shadow Mapping funktioniert nun - dafür musste ich sampler2DShadow/shadow2DProj verwenden da dieses Shadow
  Mapping derzeit einen eingebauten Tiefenvergleich verwendet, das war früher die einzige wirkliche Möglichkeit. Bei Zeiten muss noch Spot
  Shadow Mapping her das z.B. direkt in eine Fließkommatexture rendert - denn sampler2DShadow/shadow2DProj gibt es unter OpenGL ES
  2.0 nicht. (wollte nun aber nicht abermals zu einem neuen Thema springen, dann gehen halt unter OpenGL ES 2.0 erstmal keine Spot
  Shadow Maps)
- SRPLighting & SRPDirectionalLighting um DiffuseRampMap, SpecularRampMap und EdgeRampMap erweitert
- SRPDirectionalLighting nutzt das neue "ProgramGenerator::GeneratedProgram" um beim User Data Teil eine Struktur einzuhängen in
  der direkte Zeiger auf Uniforms & Attribute des erzeugten Programes gespeichert werden. Vor dieser Änderung hatte ich in meinem
  Test 68 FPS, nach der Änderung 79 FPS - die CPU wird etwas entlastet da nicht mehr ständig über eine Hash-Map (samt String Hash
  erzeugen!) auf die Programm Parameter zugegriffen wird. Offen gesagt war das der Grund wieso im neuen Shader Interface die Parameter
  nun direkt einzelnd vorhanden sind, damit schlichtweg Overhead wegkommt. Das lustige ist, das dadurch SRPDirectionalLighting.cpp
  sogar kleiner wurde, vorher 1111 Zeilen, nun 1078. Ich denke diese Änderung hat sich wirklich gelohnt.
- SRPLighting & SRPDiffuseOnly nutzen nun ebenfalls "ProgramGenerator::GeneratedProgram"
- SRPForwardLighting entfernt da nun so wie es aussieht SRPLighting und/oder SRPDirectionalLighting diesen Job übernehmen können
- SRPForwardVolumetricFog durch SRPVolumetricFog ersetzt
- Fragment Shader "DiffuseNormal.cg" & "DiffuseNormal_xGxR.cg" und Vertex Shader "DiffuseNormal.cg" und Effekte "DiffuseNormal.plfx" &
  "DiffuseNormal.plfx" & "Diffuse.plfx" aus "Standard.zip" entfernt. Dies waren damals Standard Effekte die von "EffectManager"
  erzeugt werden konnten damit etwas Darstellbar war. Das ist aber schon seit einiger Zeit draußen und von "Effekten" will ich ohnehin nicht
  mehr viel Wissen - das Scene Renderer Konzept ist deutlich Eleganter und Mächtiger! :D
- Fragment Shader "EarlyOut.cg" und Vertex Shader "EarlyOut.cg" aus "Standard.zip" entfernt, ebenfalls ein Echo aus vergangenen
  Zeiten *g*
- "Noise1.dds" & "Noise2.dds" aus "Standard.zip" entfernt, das gehörte zum mittlerweile entfernten SNProjectiveSpotLightShafts



>> 18.06.2010
[CO]
PLCompositingShaders:
- SRPDirectionalLighting um Support für Glow & DOF erweitert wie es in SRPForwardAmbient zur Verfügung stand. Dank Programm-Generator
  Konzept ging das nun relativ einfach hinzuzufügen. *einfach nur ein paar weitere Schalter*
- "SRPForwardAmbient" entfernt da durch "SRPDirectionalLighting" ersetzt
-> SRPDiffuseOnly & SRPDirectionalLighting sind mittlerweile zu ziemlich universellen Render Schritten geworden die man dank zahlreicher
   Konfigurationsmöglichkeiten für die verschiedensten Zwecke einsetzen kann :D
- SRPDirectionalLighting um weitere Flags erweitert: NoGlow, NoDOF, NoFresnelReflection
- SRPDiffuseOnly & SRPDirectionalLighting Gamma Correction Support läuft - macht aber nur richtig Sinn wenn am Ende des Renderns ein
  Gamma Correction Post Process da ist (daher ist das in "ShaderLighting.sr" derzeit deaktiviert)
- Support für das alte "ReflectionMapColor" rausgenommen, das war nun lange genuch als Übergang noch drinnen. Zukünftig heist dies
  also nur noch "ReflectionColor". (für Reflection Maps & Fresnel Reflection)
- SRPDeferredGBuffer: NoFresnelReflection Flag hinzugefügt
- Flags werden in PLCompositingShaders nun nur noch über Bitshift Definiert, das ist viel weniger Fehleranfällig, einfacher zu Erweitern
  und insgesammt Übersichtlicher. Bei Zeiten wäre es nett wenn es überall so wäre, aber das Eilt nicht und wir haben derzeit wichtigeres
  zu tun als solche Schönheitskorrekturen. *g*
- SRPDirectionalLighting: Über GetUsedLight() lässt sich von außen ermitteln welche Direktionale Lichtquelle zum Rendern verwendet wurde -
  so kann z.B. ein folgender seperater Beleuchtungsschritt in Erfahrung bringen welches Licht er nicht mehr Rendern muss da es bereits
  gerendert wurde. Das heißst natürlich das bestimmte Scene Renderer Schritte untereinander Kommunizieren, aber das war auch schon für
  Deferred Rendering hilfreich/nötig und geht denke ich ok solange es nicht zu extrem wird.
- SRPLighting als Ersatz für das in die Tage gekommene SRPForwardLighting hinzugefügt. "Forward" hab ich absichtlich im Namen weggelassen
  da dieser Renderer Schritt im Grunde recht universell ist, und z.B. auch bei Deferred Rendering genutzt werden kann - auch wenn das in
  diesem Beispiel etwas am Sinn der Sache vorbeigehen würde. *g*
  SRPLighting habe ich dabei auf Basis von SRPDirectionalLighting angefangen, und dann Komponenten von SRPDeferredLighting übernommen...
  SRPForwardLighting ist mittlerweile leider kaum noch wirklich Referenzfähig - ok, das war der Scene Renderer Schritt über den ich mir
  die nötigen Erfahrungen erarbeitet habe wie soetwas aussehen kann, und wie es noch besser aussieht. *g* Der Programm-Generator ist auch
  hier eine enorm große Erleichterung. Für komplexere Szenen mit komplexerer Beleuchtung ist Deferred Rendering meineserachtens Sinnvoller,
  aber es gibt Anwendungsszenarien wo auch SRPLighting eine Existenzberechtigung hat, z.B. wenn Hardware keine Multi Render Targets kann
  oder die Szene und Beleuchtungsverhältnisse sehr einfach sind so das SRPLighting flotter sein kann da Deferred Rendering eine gewisse
  Grundlast mit sich bringt. Die Beleuchtung läuft in SRPLighting, wie eigentlich nun immer, im View Space ab - alles andere ist schlichtweg
  zu Umständlich. (Thematik Scene Node Skalierung etc.)
-> Standardmäßig zeichnet SRPDirectionalLighting direkt die erste gefundene Direktionale Lichtquelle mit, diese kann man als die Primäre
   Lichtquelle ansehen. SRPLighting überspringt dann diese Lichtquelle so das es nicht doppelt gerendert wird. Dies kommt natürlich der
   Performance zu gute da zum einen weniger Polygone gezeichnet werden müssen (GPU), dann der ganze Render Overhead wegfällt (CPU/GPU),
   und auch das Übereinanderblenden der Bilder (GPU). 245 FPS wenn die Direktionale Lichtquelle direkt mitgezeichnet wird,
   185 FPS wenn die Lichtquelle seperat nochmal drübergezeichnet wird. Ich denke diese Zahlen sprechen für sich und daher ist dieser
   Mechanismus Standardmäßig aktiviert - kleiner netter Seiteneffekt ist, das auch das Antialiasing etwas besser aussieht da alles in einem
   Rutsch gezeichnet wird. Anti Aliasing und Transparenzen ist so eine Sache... und die Lichter werden da Drübergeblendet... - kurzum, auch
   die Bildqualität profitiert davon! :D (weniger "unruhige" Stellen im Bild)
-> Durch meine kleinen Änderungen in PLRenderer von gestern, scheint nun auch das wechseln der Shader Sprache zur Laufzeit Problemlos
   zu funktionieren... dabei kann man recht schön sehen das wenn man GLSL Shader nutzt, die FPS sichtbar besser wird! Hier Ergebnisse aus
   meinem Test, die erste Zahl ist wenn alles in einem Rutsch gezeichnet wird, die zweite Zahl wenn das Licht seperat drübergeblendet wird:
   (siehe Punkt oben) Cg 245/185 FPS und GLSL 289/223 FPS... also ich denke man kann einen Unterschied erkennen. Man, dann hat sich all
   die Arbeit ja wirklich gelohnt, nicht nur das wir nun auch einfacher OpenGL ES 2.0 untersützen können, oder spezielle GLSL Erweiterungen
   nützen können wie diese ATI Tessellation die ab HD 2000 Karten läuft - nein, auch die Performance ist mit GLSL etwas besser! :D



>> 17.06.2010
[CO]
- "PreviewWindow" von PLRenderer nach PLEngine verschoben
- "WindowConnection", "RenderWindow" und "RenderFrame" von PLRenderer nach PLEngine verschoben
- "SNProjectiveSpotLightShafts" samt Scene Renderer Schritt erstmal entfernt... das lief noch nie wirklich gut und das jetzt nochmal
  an alles anzupassen wäre verschwendete Zeit. Dann lieber erstmal raus, und irgendwann später wenn bei Bedarf nochmal so einen Effekt
  neu schreiben. (da gibts zig Ansätze für diesen Effekt)
PLCompositingShaders:
- SRPDirectionalLighting um "ZWriteEnable"-Flag erweitert, damit lässt sich dieser Render Schritt besser in eine Forward Rendering Pipeline
  einfügen. Statt SRPForwardAmbient nochmal mit dem neuen Shader Interface neu zu implementieren... ist es viel einfacher stattdessen direkt
  SRPDirectionalLighting zu nutzen und einfach das Licht dort zu deaktivieren. Das ist nun also hier der Weg den ich gehen werde.
- SRPForwardDepth darf demnächst gehen, ich habe SRPDiffuseOnly entsprechend Erweitert so das dieser supereinfache Scene Renderer Schritt
  auch direkt als "Tiefenbufer füllen Render Schritt" verwendet werden kann - wieso zweimal Implementieren wenn das fast identisch ist?
  (man, ich werde langsam Faul *g*)
- "SRPForwardDepth" entfernt da durch "SRPDiffuseOnly" ersetzt



>> 15.06.2010
[CO]
- Über die neue Methode "SRPDirectionalLighting::GetFirstDirectionalLight()" lässt sich die erste sichbare Direktionale Lichtquelle ermitteln.
  "PLCompositingShaders::SRPDirectionalLighting" und "PLCompositingFixedFunctions::SRPDirectionalLighting" nutzen
  "SRPDirectionalLighting::GetFirstDirectionalLight()" um eine geeignete Direktionale Lichtquelle zu finden und zu verwenden.



>> 12.06.2010
[CO]
- "AntiAliasing" Option in "RendererConfig" in "MultisampleAntialiasingSamples" umbenannt damit klar ist für was das ist. Das steht
  standardmäßig auf 4, also nicht übertrieben, aber auch nicht aus da es die Bildqualität wirklich deutlich verbessert - kostet natürlich etwas
  Leistung, aber dafür bekommt man wie gesagt ne ganze menge zurück. :D (ich kann diese lästigen pixligen Kanten einfach nicht mehr sehen)
  Multisample Antialisasing arbeitet allerdings nicht mit "allen" Render Techniken problemlos zusammen... z.B. muss ich noch rausfinden wie
  das bei Deferred Rendering vernümpftig verwendet wird. (geht scheinbar aber bei den modernen Grafik-APIs)



>> 11.06.2010
[CO]
- SRPDirectionalLighting hinzugefügt, quasi ein "All In One" Render Schritt der denke ich Optimal für Projekte ist die nur eine direktionale
  Lichtquelle haben. Genauso wie bei SRPDiffuseOnly die abstrakte Basisklasse in PLEngine, Implementationen in PLCompositingShaders und
  PLCompositingFixedFunctions. Das werde ich nicht für *alle* Render Schritte machen da vieles dann eher speziell ist, aber für ganz allgemeines
  was auch mit Fixed Functions super geht macht das denke ich Sinn hier eine gemeinsame Basis zu haben.
PLCompositingFixedFunctions:
- SRPDirectionalLighting habe ich auf Basis von SRPLightingTransparent implementiert. Zukünftig kann man diesen Render Schritt auch auf Transparent
  Schalten, so das nur eine Implementation für Solid & Transparent da ist. Die Klassen SRPLighting, SRPLightingSolid, SRPLightingTransparent,
  SRPSolid und SRPTransparent entfernt.



>> 10.06.2010
[CO]
PLCompositingShaders:
- Klasse "ProgramGenerator" hinzugefügt. Darüber laufen Zukünftig "Über-Shader" ("Ueber-Shader" wäre zwar dann korrekt
  in Englisch, das nutzt aber scheinbar keiner) und darunter versteht man einen Shader der ultra viel Funktionalität bietet. Also das was ich
  nun schon seit Jahren nutze, einen großen Shader, und dann über defines sagen welche Features gerade benötigt werden. Jede Operation ist schon
  eine Operation zuviel wenns um gute Performance geht da der Shader dann pro Bild zigtausend, für z.B. jeden Pixel, angewand wird. Bisher hat
  jeder Szene Renderer das aussuchen und setzen von Defines selbst übernommen, das wird allerdings langsam lästig da es nicht wenig ist und
  gerade wenn man nun mehrere Shader-Sprachen unterstützen will - muss da ein vernümpftiges System her. Bei Zeiten werd ich die Klasse denke
  ich nach PLEngine verschieben, aber jetzt gerade ist das zum Entwickeln in diesem anderen Projekt praktischer. Ich weis noch nicht ob das
  so bleiben wird, aber läuft bereits so wie ich es will - und macht die Sache im vergleich zu früher viel einfacher und übersichtlicher. :D
- SRPDiffuseOnly hat nun Support für GLSL und Cg, Prinzipiell kann man sogar zur Laufzeit die Shader Sprache wechseln... das geht auch,
  nur kann es derzeit sein das Cg dann nicht richtig zeichnet da es wohl irgendwelche Zustände verwendet die nicht korrekt gesetzt wurden -
  GLSL funktioniert bei wechsel hingegen ganz wunderbar. :D
- Cg Shader für "SRPDeferredAmbient" liegen nun in "SRPDeferredAmbient_Cg.h", das gleiche für die anderen Szene Renderer Schritte. Also
  Vertex & Fragment Shader zusammen in einer Datei - das ist denk ich das beste und Übersichtlichste.



>> 09.06.2010
[CO]
- Bugfix in SNMMouseOrbitingController: ZoomMouseWheel wurde nicht verwendet, daher konnte das Mausrad IMMER verwendet werden, auch wenn
  dieses Flag gar nicht gesetzt war
- Die Scene Renderer Schritte SRPDebugWireframes, SRPDebugHierarchies, SRPDebugSceneNodeIcons, SRPDebugSceneNodeNames und
  SRPDebugContainerScissorRectangles in PLEngine sind nun Abstrakt. Die bisherigen Implementationen liegen nun in PLCompositingFixedFunctions -
  denn diese verwenden Fixed Functions. Auf die Dauer müssten hier also auch noch Shader-Varianten her, ist aber derzeit nicht absolut
  dringend da diese nur für die Entwicklung oder Präsentationen gedacht sind. (erstmal das wichtigste zuerst :)
- SRPLightEffects in PLEngine ist nun Abstrakt, die bisherige Implementation liegt nun in PLCompositingFixedFunctions
- Mit den ersten im Eintrag von "03.06.2010" beschriebenen Arbeiten begonnen. Den "SceneRenderer" Ordner habe ich in "Compositing" umbenannt,
  das trifft es einfach sehr viel besser und mit dem Namen bin ich deutlich Glücklicher, und er ist kürzer! *g*
  In die Kategorie "Compositing" fällt nun also alles was dazu beiträgt das finale Endbild auf den Bildschirm zu zaubern... oft liest man
  den Begriff "Compositing" nur im Zusammenhang mit Post-Processing, aber eigentlich umfasst der Begriff deutlich mehr. Ich denke das auch
  gerade Grafiker mit dem Begriff "Compositing" mehr anfangen können und sich dann vorstellen können was da abläuft, als beim künstlichen von
  mir geschaffenen zusammengesetzten Begriff "SceneRenderer".
- "FullscreenQuad" vom "PostProcessing" Verzeichnis ins neue "Compositing" Verzeichnis verschoben, endlich ein passendes Zuhause für diese
  recht nüzliche Klasse die ich gerade beim Deferred Rendering kräftig nutze :D
- "PostProcessing" in den "Compositing" Ordner verschoben. Früher lag "PostProcessing" im "SceneRenderer" Ordner, aber dort passte das schlichtweg
  nicht rein da es absolut null und rein gar nichts mit Szene zu tun hatte. Im Grundordner geviel mir "PostProcessing" aber auch nie so recht
  da das schon etwas spezieller ist das man so meistens auch gar nicht direkt über C++ nutzt sondern das eher intern verwendet wird. Da
  Post-Processing ein Paradebeispiel für Compositing ist... wie gesagt, der Begriff "Compositing" ist einfach nur noch passend - da hab ich
  Jahre drauf gewartet das ich was Griffigeres und passenderes finde als "SceneRenderer". *g*
- VisPortal, VisContainer, VisManager und VisNode vom "Compositing" Verzeichnis in ein neues "Visibility" Verzeichnis im Grundordner verschoben.
  ("VisibilityDetermination" wär mir zu lang :)
  Die Sichtbarkeitsbestimmung passt nicht so recht in "Compositing", zwar kann "Compositing" die Ergebnisse nutzen, aber so recht passt das
  dann doch nicht rein. In "Scene" passt das ebenfalls nicht so recht rein, denn das System für die Sichtbarkeitsbestimmung ist auf Scene
  aufbauend. Sichtbarkeitsbestimmung ist irgendwie ein Punkt für sich, quasi die Zwischenschicht zwischen "Scene Daten" und "Scene auf den
  Bildschirm zeichnen". Das System für die Sichtbarkeitsbestimmung wird sicherlich auf Dauer auch nochmal überarbeitet werden (ist aber nicht
  absolut dringend :), und dann kommt sicherlich nochmal einiges dazu - denn Sichtbarkeitsbestimmung ist ein Thema für sich. Ich denke daher
  ist ein eigener Ordner für dieses System das naheliegendste.
- "SQCull" von "Scene/SceneQueries" in den neuen "Visibility" Ordner verschoben. "SQCull" ist zwar eine "SceneQuery" Ableitung, und das gefällt
  mir irgendwie immer noch gut ("sag mir mal bitte was von hier aus so alles nettes sichtbar ist") - aber das ist schon derart Speziell
  das es in "SQCull" einfach besser reinpasst - hier liegen ohnehin die Klassen aus dennen sich das Erfragte Ergebnis dann zusammensetzt
  (der "Sichtbarkeitsbaum") so das nun alles beisammen ist.
PLCompositingShaders:
- "SRPForwardAmbientMeshes" etc. in "SRPForwardAmbient" umbenannt, das "Meshes" bringt hier nicht wirklich eine Zusatzinformation da alles
  über Meshes läuft. Das gleiche in "PLCompositingFixedFunctions" mit "SRPEmissiveMeshes" etc.
- "SRPDeferredDepthFog_FragmentShader" in "SRPDeferredDepthFog_Cg_FS" etc. umbenannt. Die Abkürzungen VS, GS und FS sind recht gebräuchlich
  und denke ich auch im Kontext des Renderns recht einleuchtend... denn das hier nun immer Ausschreiben wird alles viel zu lang. :/
  Am wichtigsten war "Cg" im Namen, da zukünftig noch "GLSL" Shader dazukommen müssen. Ob die Namen so bleiben, oder ich direkt VS und FS
  dann in eine Datei packe werd ich noch sehen, ich denke aber eine Datei ist am Ende übersichtlicher... auch wenn einzelnde Dateien dann
  größer werden.



>> 08.06.2010
[CO]
- Die Abstrakte Klasse SRPDiffuseOnly dient als Basis für Implementationen die nur Diffuse Rendern. Das dürfte für erste Tests auf neuen
  Geräten/Plattformen sehr handlich werden und auch eine gute Grundlage für Tests etc. sein. (weils nicht wirklich noch einfacher geht *g*)
- "PLCompositingMobile" Projekt wieder entfernt, die Strategie ist erstmal zu versuchen allgemeine Scene Renderer Schritt zu erstellen die
  mit GLSL und Cg laufen... und mit einfacheren GLSL Profilen dann auch so mit OpenGL ES 2.0 laufen sollen. Bisher sieht das so aus als ob
  das funktioniert - damit hätte man auf Dauer die wenigste Arbeit. :D
- SRPPreFunctions, SRPSolidFunctions, SRPPostFunctions, SRPTransparentFunctions in SRPFunctionsPre, SRPFunctionsSolid, SRPFunctionsPost und
  SRPFunctionsPost umbenannt und von SRPFunctions abgeleitet. Die SRPFunctions Implementationen sollte man wenn immer es geht nicht in
  konkreten Projekten verwenden - denn was hier drin geschieht entzieht sich aller Kontrolle und daher ist es nicht mehr klar ob da nun
  Shader oder Fixed Functions verwendet werden, wer wo welche Render States setzt etc. - dies ist quasi die "Chaos Zone" wo zu jedem Zeitpunkt
  alles passieren kann... sich also auch eine Topfplanze in einen Wal verwandeln kann. *g*
- "SRPEnd" ist ebenfalls Shaders/Fixed Functions Abhängig



>> 05.06.2010
[CO]
- "PLCompositingMobile" Projekt hinzugefügt, hier befinden sich Scene Renderer Schritte die speziell für Mobile Endgeräte gedacht sind -
  und da dort OpenGL ES 2.0 ein verbreiteter Standard ist, wird alles mit dieser API gemacht - sprich, GLSL Shader.
- In "Standard.zip" habe ich erstmal "MobileBasic.sr" abgelegt damit sich das einfach nutzen lässt... dieser Scene Renderer kann bereits
  Szenen mit OpenGL ES 2.0 darstellen - im Augenblick nur zum Testen mit einfacher Textur, zukünftig aber auch mit Lightmaps etc.... also
  alles nur keine Beleuchtung. (reicht ja schon z.B. für die Interactive Brücke :)
  Es wird noch ein "MobileDirectionalLight.sr" kommen das SEHR ähnlich zu "MobileBasic.sr" wird, aber zusätzlich eine Directionle Lichtquelle
  kennt... danach müssten eigentlich alle bisherigen Projekte damit dargestellt werden können. (bis auf GUI, Schrift und Post Processing wie
  Glow - das kommt dann wenn das andere geht :)



>> 03.06.2010
[CO]
- Vorbereitungen für den Support von Scene Renderer Schritten für Mobile Geräte: Aufräumarbeiten! :D
  Da PLEngine mittlerweile total überquillt und das Linken am Ende eine Ewigkeit dauert + meine Quadcore-CPU hier absolut nix bringt
  da nicht mehrere Projekte gleichzeitig übersetzt werden können, muss PLEngine etwas schlanker werden... denn es wird sicherlich noch
  einiges mehr hier hinzukommen. Da an den konkreten Scene Renderer Implementationen noch einiges gemacht wird, ist das schlichtweg
  inakzeptabel da ich so, aufgrund ständiger ewiger Wartezeiten nicht vorankomme. (bei den Scenen Renderer Dingen muss man
  viel Optisch testen...) Die ganzen superspeziellen Scene Renderer Schritte direkt in PLEngine sind mir nun schon seit Monaten ein
  Dorn im Auge, durch den umfangreichen Deferred Scene Renderer (da steht im Grunde noch mehr auf meiner Feature-Liste!) wurde das nicht
  besser. Zukünftig werden wie gesagt noch mehr Scene Renderer Schritte hinzukommen, teils hochspezielle - z.B. ein Terrain Scene Renderer
  Schritt speziell für Deferred Rendering - so Dinge müssen dann wirklich konkret für die einzelnen Systeme implementiert werden, anderst
  macht das einfach keinen Sinn wenn am Ende das Gesamtbild stimmen soll. Aber gerade bei Deferred Rendering ist der Aufwand geringer da
  neue hochspezielle Dinge meist nur z.B. den GBuffer verändern müssen, Beleuchtung, HDR und und und müssen nicht angepasst werden sondern
  gehen automatisch wie bisher. Scheintbar kann man sogar so Dinge wie "Decals" (Blutspritzer etc. *g*) oder gar Regen mit Deferred Rendering
  dadurch erreichen, das ein weiterer Bildverarbeitungs Schritt hinzugefügt wird der einfach nur den GBuffer Inhalt etwas ändert. Diffuse Farben
  rot färben, mehr Specular für mehr Glanz etc. - es sind also extrem Elegante Lösungen für weitere Effekte möglich die ohne Deferred Rendering
  einem Alptraum nahekommen da neue Geometry erzeugt werden muss etc. Bei Forward Rendering wird das natürlich deutlich Umständlicher - u.a. daher
  werde ich hier erstmal nix groß Weiterentwickeln da Deferred Rendering schlichtweg mehr Möglichkeiten bietet.
  Aus diesem Grunde habe ich nun zwei neue Plugin-Projekte angelegt, "PLCompositingFixedFunctions" für Fixed Function basierendes,
  "PLCompositingShaders" für Shader basierendes. Bei Shadern wird man, wenn alles klappt, für verschiedene Shader Sprachen die gleichen
  Codes weiternutzen können - leglich der Shader Code wird ein anderer sein, aber das ist eher ein kleinerer Teil. :D
  Ein entsprechendes Projekt mit auf Mobile Geräte zugeschnittenen Render Schritten ("PLCompositingMobile" oder so) kommt aber noch - damit man
  die kleinen nicht überfordert. *g*
  Ich muss seit dem Deferred Renderer ständig an "Compositing" denken wenn ich das System sehe, also das was man u.a. für Filme nutzt,
  ein übereinanderlegen mehrere Elemente - und genau das ist das Scene Rendering System... + mittlerweile sind da noch Komponenten
  als "Scene Renderer" hinzugekommen, die aber genaugenommen absolut rein gar nichts mit "Scene" zu tun haben. Beispiele dafür sind
  z.B. die Post Process Effekte für HDR, Glow etc. die direkt mit dem Deferred Rendering zusammenarbeiten müssen. Derzeit läuft das alte
  Post Processing System nicht so wirklich mit dem Deferred Rendering System zusammen da nun zwei "Render Pipelines" künstlich nebeneinander
  stehen - das muss aber nicht sein. Denn schließlich ist das nur Bildverarbeitung - daher wird zukünftig das alte Post Processing System
  sich in das integrieren was derzeit noch "Scene Renderer" heißt. Das Rendern des Ingame GUI's ist auch nur ein weitere Compositing Schritt,
  der eine weitere "Bildebene", nämlich die GUI-Bildebene hinzufügt - WO diese Bildebene sein soll, kann man dann frei festlegen... z.B. ganz
  am Anfang hinlegen damit dann das GUI nur irgendwo als Hintergrund zu sehen ist. Wichtiger ist dann aber, das man dadurch auch ganz einfach
  festlegen kann welche, z.B. Post Processing Schritte, auch auf das gezeichnete GUI angewand werden sollen. Ein Ladebildschirm oder eine Ingame
  Konsole sind natürlich weitere klassische Bildebenen - so wie bisher, als Scene Nodes, ist das einfach nur daneben da das Scene System auf
  Räumliches ausgelegt ist was auch gut so ist, und dann gibts einfach nur Probleme beim Render da man nicht selbst festlegen kann was in welcher
  Reihenfolge gerendert werden soll.
  Zukünftig wird wohl "Compositing" die Basisklasse für einen Render-Schritt, und Scene Renderer wird in irgendetwas anderes intuitives umbenannt.
  "Scene Renderer" selbst sind dann also nur ein "Compositing" Schritt der Teile der Szene zum gesamtbild hinzufügt. Derzeit sind Abläuft bereits
  so, das zuerst der Bildbuffer gelöscht wird, anschließend wird z.B. eine Hintergrundbitmap oder ein Himmel gezeichnet, anschließend wird der GBuffer
  gefüllt + der Stencil Buffer so gefüllt das dort wo im GBuffer was geschrieben wurde das entsprechend gekennzeichnet ist. Anschließend kommt der
  "Compositing" Schritt der über den Hintergrund GBuffer Inhalt mit Ambient Beleuchtung drüberlegt - aber nur dort wo der Stencil Buffer es zu lässt...
  dadurch kann man dann immer noch an den freien Stellen den Hintergrund sehen. Das ist wie gesagt schon seit Wochen drinnen - aber u.a. das war
  ausschlaggebend dafür das dies alles zukünftig noch etwas verändert wird damit es universeller wird - und dann unter "Compositing" läuft was eigentlich
  ganz genau das beschreibt was hier abläuft. :D
  Das ganze geht mir nun wie gesagt schon etwas länger durch den Kopf - und ich finde das ist einfach die konsequente Weiterentwicklung, die dann auch
  die letzten Probleme lösen sollte. Dinge wie Sichtbarkeitsbestimmung sind natürlich unabhängig von ganzen, hier gehts wirklich *nur* um das ganz konkrete
  Zeichnen von bunten Bildern. Da durch den OpenGL ES Support nun ohnehin ein paar Umstellarbeiten anstehen, macht es Sinn das mit dem "Compositing" paralell
  umzusetzen damit man nicht doppelte Arbeit hat - und überall Fixed Function Dinge zum Zeichnen ist eh daneben da es dann mit z.B. OpenGL ES nicht mehr läuft,
  da es keine Fixed Function Dinge kennt. Ich denke alles in allem wird sich die Arbeit aber eher in Grenzen halten... denn über die Monate/Jahre hat sich das
  bereits kräftig in ganz genau diese Richtung entwickelt.
- "SceneRenderers": "FixedFunction" nach "PLCompositingFixedFunctions" verschoben und "Deferred", "Forward" und "HDR" nach "PLCompositingShaders"
  verschoben. Jetzt ist die übersetzungszeit von PLEngine *etwas* erträglicher und, wenn ich in den Scene Renderern was ände ist das schwups
  übersetzt + wird PL als Gesamtheit übersetzt, kann nun ein Multi-Core Prozessor mehr paralell übersetzen was die gesamte Übersetzungszeit
  etwas reduziert. Jetzt kann man endlich wieder vernümpftig am Scene Rendering weiterarbeiten. :D



>> 31.05.2010
[CO]
- SNMBillboardSpherical, SNMBillboardCylindrical und VisNode: Es gibt Fälle, wo es nötig wird die Transformation von VisNode nochmal
  etwas zu verändern bevor VisNode dann zum Zeichnen verwendet wird. Das beste Beispiel hiefür sind Billboards die immer "In die Kamera
  schauen" sollen. Da eine Szene mehrmals zur gleichen Zeit von verschiedenen Kameras aus gezeichnet werden kann, muss das wirklich
  über VisNode ablaufen und nicht dadurch, das z.B. die Scene Node Transformation verändert wird. Da ich nun endlich wieder einen aktuellen
  PL Release machen möchte, die Billboards aber noch laufen sollten, hab ich erstmal eine dämliche Zwischenlösung eingebaut so das die Modifier
  direkt die Welt Matrize von VisNode verändern. Ich denke zukünftig wird das darüber ablaufen das SceneNode noch ein "Ich werde demnächst
  über diese VisNode hier gezeichnet" Ereignis bekommt - darüber kann man dann feststellen ob die Scene Node gezeichnet wird, und kann dann
  auch noch die VisNode Transformation ändern bevor es dann weiter zu den Scene Renderer Schritten geht. Das wäre so herum dann eine recht
  universelle Lösung... auch wenn mir dies Lösung nun schon seit Monaten durch den Kopf geistert - jetzt in den nächsten Stunden werde ich
  das nicht einbauen da ich dazu das VisNode Interface noch etwas ändern müsste und soetwas nicht übereilt nebenbei gemacht werden sollte
  da das gesamte Scene Rendering auf VisNode aufbaut. :D



>> 28.05.2010
[CO]
- "BasicSceneApplication::LoadScene()": Es wird intern kein temporärer Basis Pfad mehr eingetragen und nach dem Laden entfernt. Dies
  war nie wirklich schön, und klappt gerade mit verzögerten Laden nicht wirklich. Will man das Grundverzeichnis in dem sich eine Szene
  befinden als Quelle nutzen in der Resourcen gesucht werden sollen, so muss man das nun in seiner eigenen Anwendung handhaben.
  ("PLViewer" macht das, ansonnsten ist das normalerweise eigentlich nicht notwendig)



>> 24.05.2010
[CO]
- SceneRenderer muss nicht an das RTTI Angeschlossen sein



>> 14.05.2010
[CO]
- SceneNode nutzt intern die neue PLMath::Transform3 Klasse (erster Refactoring Schritt :)
- SceneNode: Methoden GetPosition, SetPosition, GetRotation, SetRotation, GetScale, SetScale, GetTransformMatrix, SetTransformMatrix
  und GetInverseTransformMatrix entfernt, dies läuft nun über PLMath::Transform3, sprich, cSceneNode.GetTransform().GetPosition() etc.
  (zweiter Refactoring Schritt :)



>> 13.05.2010
[CO]
- SceneNodeModifier: GetFlags() & SetFlags() sind nun virtuell, InformedOnFlags() entfernt. "m_nFlags" ist nun private. Durch das neue RTTI lässt
  sich das nun alles viel Harmonischer Realisieren als dies früher möglich war.
- SceneRendererPass: GetFlags() & SetFlags() sind nun virtuell. "m_nFlags" ist nun private.



>> 05.05.2010
[CO]
- "EffectWeight" aus "SNMPostProcessDepthOfField" nach "SNMPostProcess" verschoben, alle Post Process Effects um "EffectWeight" Parameter erweitert



>> 04.05.2010
[CO]
- SRPDeferredGBuffer führt auf DiffuseMap, LightMap, EmissiveMap und ReflectionMap eine Gamma korrektur aus, ansonnsten sehen diese Daten ausgebleicht aus.
  SRPDeferredLighting führt auf die Texturen von Projektiven Lichtquellen eine Gamma korrektur aus, ansonnsten sehen diese Daten ausgebleicht aus. Dies wird
  jeweils im Fragment Shader gemacht - es gibt mittlerweile allerdings auch spezielle Texture Formate so das die Hardware das intern sofort automatisch machen
  kann... dies könnte aber dann Probleme machen wenn man die Texturen auch in z.B. Fixed Functions Render Schritten nutzen will die keine Gamma Korrektur haben...
  dann würden denk ich die Texturen dort nicht ok aussehen. Daneben könnte man bei Zeiten noch im "plt"-Format pro Texture einstellbar machen ob und wie Gamma
  Korrektur ausgeführt werden soll. Aber das reicht später auch noch, mir war es nun erstmal nur wichtig das die Farben auch im Deferred Scene Renderer korrekt
  aussehen.



>> 03.05.2010
[SB]
- "HDRAverageLuminance_FragmentShader": Habe die NAN-Sicherheitsabfragen erstmal wieder eingebaut, weil bei mir ansonsten
  sofort ein komplett schwarzer Bildschirm entsteht. Solange noch ein NAN-Bug drin ist, sollte dies also wohl erstmal
  hier bleiben, danach sollten wir nochmal schauen (was ist besser? Wenn gar nichts geht, oder wenn zumindest an einer
  Stelle noch Fehler abgefangen werden, und man somit zumindest etwas sieht?)
- SRPDeferredLighting: Die ColorMask() musste nach dem Lighting-Schritt wieder zurückgesetzt werden, damit der State
  für die nachfolgenden Schritte wieder in Ordnung ist. Dies löste die größten Probleme unter nVidia.
- SRPDeferredLighting_FragmentShader: Workaround eingefügt für die verbleibenden Artefakte. Hier scheinen immernoch
  Normalenvektoren übergeben zu werden, die ein NAN enthalten.



>> 03.05.2010
[CO]
- "HDRAverageLuminance_FragmentShader": NAN Sicherheitsabfrage raus, wenn ein NAN drinen ist, isses eh schon oft zu spät und je nach GPU kommt es
  dann wie Stefan und ich nun in den letzten Tagen gesehen haben zu anderen Problemen, z.B. in Form von lustigen schwarzen Klözchen auf dem Bildschirm.
  Das muss also alles 100% NAN frei sein und wenn es das nicht ist, muss ich zukünftig *sofort* bis ins letzte Detail nachgehen wieso ein NAN zustandekommt
  da es sonst auf anderen GPUs nur noch schlimmer wird. (ATI scheint da noch halbwechs tollerant zu sein, während bei NVIDIA die Hölle ausbricht)
- Shader: Alle "pow"-Stellen nochmals ganz genau angeschaut und durchdacht ob die zwei Parameter immer in den, nach der GLSL Spezifikation, gültigen
  Bereichen liegen, ansonnsten kann es hier zu NANs kommen. Zukünftig muss ich wohl öfters mal in die Spezifikation schaun um sicher sein zu können
  das Parameter nur korrekte Werte haben.
- Deferred Scene Renderer: Für encodeNormalVector/decodeNormalVector wird nun http://aras-p.info/texts/CompactNormalStorage.html#method04spheremap
  verwendet was weniger Problematisch sein müsste



>> 01.05.2010
[CO]
- SRPBegin ist nun ganz offiziell auch für das anfängliche Löschen des aktuellen Buffer Inhaltes zuständig. Dazu wurden die zwei Variablen
  "ClearFlags" und "ClearColor" hinzugefügt. Die Scene Node SNClear wurde nun entfernt - der Grundgedanke war zwar ganz nett, eine soweit möglich
  strikte Trennung zwischen "Darstellung" und "SceneGraph" ist aber noch besser. Wir hatten früher ja ewig herumdiskutiert und überlegt wie man
  am besten noch 2D Dinge in den SceneGraph bringt... und immer noch keine wirklich zufriedenstellende Lösung. Das beste isses wohl wirklich das
  man 2D Dinge über das GUI-System macht, und andere Dinge wie das Löschen des Buffers in Scene Renderer Schritten erledigt was auch irgendwie
  *natürlicher* ist ich ich denke das Scene Renderer Schritte Konzept hat sich mittlerweile bewährt.
- Neuer Scene Renderer Schritt SRPBackground. Dies ist die Basisklasse von der Scene Renderer Schritte abgeleitet werden die "Hintergründe"
  zeichnen. Hintergründe die wir bis jetzt verwendeten bestanden meist aus einer Bitmap, einen Farbverlauf oder einem "Himmel" und wurden über
  Scene Nodes realisiert - was oft mehr Probleme als Nutzen brachten. Soetwas als Scene Renderer Schritt zu realisieren macht denke ich einfach
  mehr Sinn da dies sich nicht so wirklich im Scene Graph einordnen lässt.
- Da wir wie erwähnt bis jetzt immer Hintergründe hatten die sich in bestimmte Kategorien unterteilen lassen, habe ich direkt SRPBackgroundBitmap,
  SRPBackgroundColorGradient und SRPBackgroundSky von SRPBackground abgeleitet. (abstrakte Klassen)
- SRPFixedFunctionBackgroundBitmap Implementiert das eine SRPBackgroundBitmap Implementation darstellt die nur über Fixed Functions zeichnet und
  somit z.B. nicht mit OpenGL ES laufen wird. (im Grunde der Code aus SNBitmap2D :)
  Alle Scene Renderer, also auch die rein Shader basierenden, fügen ein deaktiviertes SRPFixedFunctionBackgroundBitmap hinzu - die Shader Versionen
  können dann im laufe der Zeit sobald nötig recht schnell hinzugefügt werden. (aber erstmal schaun das das Gesamtsystem steht und alles wie vorher
  läuft)



>> 29.04.2010
[CO]
- SNMPostProcessDepthOfField um "EffectWeight" Parameter erweitert, 0 bedeutet der Effekt hat keinen Einfluss, 1 für den "angestrebten" normalen
  Einfluss. "EffectWeight" wird es zukünftig wenn irgend möglich in allen Post Process Effekten geben. Nur "Weight" als Name für diesen Parameter
  wäre sicherlich zu riskant da zu schnell Namenskonflikte entstehen könnten.



>> 17.04.2010
[CO]
- SRPEndHDR: Neues Flag: WriteToOriginalSurface -> Ist dieses Flag gesetzt, so ist dieser Scene Render Schritt im Grunde ein Ersatz für SRPEnd so wie
  es bisher war. Sprich, das Ergebnis liegt dann beispielsweise in einem MS Windows Fenster - dies Resultiert jedoch auch darin das wenn gerade in
  eine Textur gerendert wurde, nun auch ein anderer Tiefenbuffer genutzt wird was Problematisch sein wenn man z.B. noch Debug-Informationen
  unter Zuhilfenahme des Tiefenbuffers über das gerenderte Bild zeichnen will. Man könnte zwar den Tiefenbuffer herumkopieren, aber das muss nicht
  wirklich sein. Daher beendet SRPEndHDR nun standardmäßig nur noch das HDR-Rendering, sprich, Tone-Mapping, HDR Bloom etc. - anschließend kann man
  noch Debug Dinge darüberzeichnen ohne das so Dinge wie Bloom dort Einfluss haben was hier störend ist. Ganz am Ende steht dann ein SRPEnd welches
  das finale Ergebnis *festschreibt*.
- SNSpotLight: Neues Debug-Flag: DebugDepthTest -> Ist das Flag gesetzt, wird beim Zeichnen von z.B. Linien ein Tiefentest durchgeführt
  (kann hilfreich sein wenn man in einer Situation gerade die räumlichen Relationen nicht richtig erkennen kann)



>> 15.04.2010
[CO]
- SNProjectivePointLight & SNProjectiveSpotLight: Über das neue Flag NoProjection lässt sich die Texture Projektion für eine Lichtquelle deaktivieren
- SNProjectiveSpotLight::GetTextureMatrix() entfernt, das ist schon etwas zu speziell und sollte lieber von z.B. den Scene Renderer Schritten übernommen
  werden (hier kann es u.a. Variationen geben)
- SNSpotLight::GetShadowMatrix() entfernt, das ist schon etwas zu speziell und sollte lieber von z.B. den Scene Renderer Schritten übernommen
  werden (hier kann es u.a. Variationen geben)
- SRPDeferredLighting: Juhu, *endlich* geht zumindestens beim Deferred Scene Renderer nun das man Projektive Lichter und Spot Shadows auch durch Portale
  hindurch korrekt sehen kann. Das mit den herumjonglieren der verschiedenen Koordinaten-Systeme ist schon verdammt Tricky, daher Dokumentiere ich seit
  geraumer Zeit so genau wie möglich in welchem Koordinaten System sich was befindet und wie die Wertebereiche sind. Da ist nun fast der gesamte Tag
  dafür drauf gegangen... und es gibt im Grunde noch 2 Stellen wo man eine Transformation machen muss und ich nicht weis warum - weil ich der Meinung
  bin mich bereits im korrekten Koordinatensystem zu befinden, was aber scheinbar nicht der Fall ist. Entweder irgendwo ein Bug, oder ein übler Denk-Fehler
  ... die Zeit wirds zeigen. Jedenfalls Dokumentiere ich nun bei so Dingen soviel wie irgend geht damit möglichst alles so abläuft das man es nachvollziehen
  kann und es keine Stellen gibt wo man sich wundert das es geht, obwohl man der Meinung ist das müsste etwas anderst gehen. Beim Shader Lighting
  Scene Renderer werde ich das erstmal nicht ausbessern - da hier mit anderen Koordinaten Systemen gearbeitet wird würde der ganze Spaß mit abermals
  durchdenken von neuen Anfangen... und derzeit lohnt das aus meiner Sicht nicht da der Deferred Rendering Ansatz soo viel besser ist. :D
  Das war jetzt alles ziemlich frustrierend und ermüdent - aber ich wollte das es durch Portale keine Beleuchtungs-Anomalien mehr gibt da sonst Portale
  nicht wirklich brauchbar sind. (und Jens es aus dem Grund auch noch vermeidet das wirklich zu nutzen, was ich auch verstehen kann)
  Jetzt muss ich nur noch zuschaun das die Portal-Bounding Box dynamisch vergrößert werden kann - denn immer wen gerade etwas *durchragt* muss das auch noch
  sichtbar bleiben wenn das Portal Polygon selbst gerade nicht sichtbar ist. Dies ist der Grund wieso derzeit z.B. in der UBahn-Szene hin und wieder noch
  Lichter an/aus gehen. (und das muss nun auch endlich behoben werden...)
  Zwar liest man immer mal wieder "Portale seien total veraltet und wären heute nutzlos und man solle lieber 100% auf Dynamic Occlusion Queries setzen"...
  ich selbst, wie auch einige andere bin aber der Meinung das im Grunde alle Sichtbarkeitstechniken ihre Existenzberechtigung haben. Portale sind z.B. sehr
  Effizient und gerade der "Warp"-Effekt den man damit erzielen kann... also der geht mit Occlusion Queries natürlich nicht. *g*
  (man geht wo rein, und kommt an einer total anderen Stelle der szene wieder raus, das muss nicht räumlich beisammen liegen :)
  Gerade bei so Szenen wie der UBahn oder dem Dungeon sind Portale finde ich die beste Wahl. Zusätzlich kann man noch Occluder einsetzen, also diese Anti-Portale
  die nicht etwas *freigeben*, sondern hinter denen Objekte verschwinden. Dynamische Occlusion Queries sind zwar drinnen, aber so richtig doll geht das glaub
  ich noch nicht. (hat jetzt gerade aber auch keine große Priorität)
- HAHAHAHAH, ich wunderte mich gerade etwas das Schatten nicht durch Portale durchgingen, bzw. Objekte die durch ein Portal sichtbar waren, auf einmal keine
  Schatten warfen.... obwohl eigentlich alle Transformationen korrekt sein *müssten*...
  ich traute meinen Augen nicht als ich merkte das beim Schatten Rendern ganz am Anfang geprüft wurde ob eine Scene Node Schatten wirft - unabhängig vom Typ.
  Nun kam es das auch Portale natürlich Scene Nodes sind, und derzeit als Standardeinstellung Scene Nodes keine Schatten werfen... tja, und dadurch warfen
  Objekte die man durch Portale sehen konnte standardmäßig keine Schatten wenn die Lichtquelle auf der anderen Seite des Portals war. *g*
  Da der Effekt irgendwie Interessant ist, wird die Schatten Einstellung für Portale immer noch berücksichtigt - aber Standardmäßig "werfen" Portale nun
  Schatten da diese normalerweise *transparent* dem Rendern gegenüber sein sollten. Kann natürlich trotzdem mal übel nach hinten losgehen und dann fängt
  das Rätelraten erneut an wieso da keine Schatten sind, es aber sein müssten... *g*



>> 14.04.2010
[CO]
- SRPLightEffects: Ein paar Flags spendiert
- SRPBegin: Kann nun ebenfalls einen Stencilbuffer mit anlegen was Standardmäßig auch gemacht wird
- SRPDeferredGBuffer: Standardmäßig steht nach diesem Render Schritt überall eine 1 im Stencilbuffer wenn ein der GBuffer für einen Pixel keine Informationen
  niedergeschrieben hat (1 ist besser als 0, wenn kein Stencilbuffer da ist muss man dann nicht überall darauf hin testen *g*)
- SRPDeferredAmbient: Auch hier wieder als Standardeinstellung, die natürlich geändert werden kann: Wenn im Stencilbuffer für einen Pixel eine 1 steht, wird
  dieser Pixel ignoriert. Damit kann man nun auch beim Deferred Scene Renderer im "Hintergrund" wieder Bilder, animierten Himmel etc. sehen da SRPDeferredAmbient
  an den entsprechenden Stellen nix verändert. Interessanterweise scheint das ganze mit dem Stencilbuffer nicht wirklich großen Einfluss auf die Performance
  zu haben, in meinem Test bliebt es immer bei 140 FPS. (und je höher die FPS, desto mehr fallen kleinigkeiten ins Gewicht)
  Ich hatte anfangs etwas länger hin und her überlegt wie ich das gleiche ohne Stencilbuffer hinbekommen könnte... aber das resultierte alles dann immer
  in zu vielen unschönen "Sonderfällen", sprich, Hacks. Ich glaube für genau solche Aufgaben wurde der Stencilbuffer ursprünglich geplant und dann sollte
  man den für genau solche "Ausschneid/Schablone"-Aufgaben nutzen.
- SRPDeferredHBAO ist nun Standardmäßig aktiviert, das sieht einfach damit alles einen Tick besser und vorallem Professioneller aus! Wenn man PL zum ersten
  mal sieht sollte man ja "Wow" sagen müssen... ok, "Wow iss das schick" und "Wow ist das langsam" geht nun beides! (je nachdem ob man aktuellere Hardware hat
  oder nicht *g*) Nachdem ich gestern noch etwas an den Standard-Parametern von SRPDeferredHBAO gedreht habe ist die Performance nun auch besser... aber FullHD
  geht bei mir damit meist nie über 20 FPS. Ein wenig Optimierungsspielraum habe ich allerdings noch... mein Ziel ist ja eigentlich das es mit allen aktiven
  Effekten auf meinem System in FullHD nie unter 30 FPS geht. (Notebook, aktuelle Desktop Rechner haben sicherlich mehr Leistung!)



>> 13.04.2010
[CO]
- SRPDeferredGBuffer: Fragment Shader: Hm, interessanterweise können beim Normal Vektoren ungültige Zahlen entstehen, ich konnte noch nicht herausfinden
  wann oder warum das genau passiert (kann mit und ohne Normal Map Texturen passieren, könnte also eventuell an übergebenen Mesh Normalen liegen?) -
  die Auswirkungen sind jedoch übel und daher muss garantiert werden das im GBuffer NUR gülte Werte stehen. Das viel mir beim HDRAverageLuminance Implementieren
  auf das hin und wieder nan's im GBuffer standen... und früher schonmal das gleiche beim Forward Renderer, da kam ich aber nicht drauf was da los ist. Ein
  weiterer nan-Zahlen erzeuger war die "fresnel()"-Funktion im Fragment Shader, hier muss man darauf achten das der Winkel wirklich wirklich zwischen 0-1 liegt.
- SRPDeferredDOF: pszResult_FragmentShader -> hier konnte es passieren das durch 0 geteilt wurde... Ergebnis: ein nan das später dann viele Probleme bereiten kann
- HDRAverageLuminance: Fragment Shader: Es ist nun nicht mehr nötig auf nan zu prüfen und solle es auch nie sein - in den Ergebnis Puffern sollten IMMER gültige
  Zahlen stehen, sonst kann man sich auf gar nichts mehr Verlassen :(
- Etwas an den SSAO Klassen gefeilt



>> 12.04.2010
[CO]
- SNCamera: Clip Plane Dinge entfernt, wird von modernen Grafik-APIs nicht mehr unterstützt + hatte hier ohnehin nix verloren
- SRPForward und ShadowMapManager: Clip-Planes entfernt... das hatte auf aktuellen GPUs nicht mehr richtig oder gar nicht mehr Funktioniert - nun weis
  ich auch warum... weil das einfach nicht mehr Zeitgemäß ist.



>> 09.04.2010
[CO]
- SRPDeferredDOF für Tiefenunschärfe auf Basis von SRPDeferredGlow implementiert. (bis nach den Blur Schritt iss ja alles gleich bzw. kann gleich sein)
  Zwar wieder "Wiederverwendung durch Kopieren", aber ich kann mir gut vorstellen das man später z.B. noch einen "Bokeh Filter" hinzufügen will und dann
  ist man froh das SRPDeferredDOF ein in sich geschlossenes System ist.
  Wie schon beim DOF Effekt für Forward Rendering habe ich das so realisiert wie in http://ati.amd.com/developer/gdc/Scheuermann_DepthOfField.pdf beschrieben.
  Mittlerweile existieren einige DOF Verbesserungen wie z.B. in http://ati.amd.com/developer/siggraph08/chapter05-filion-starcraftii.pdf beschrieben,
  das kann ich ja später mal, vergleichbar zum SSAO, als weitere Variante Realisieren. Aber erstmal reicht was einfacheres das ich schonmal umgesetzt hatte,
  mir war es nur wichtig das wir zumindestens den gleichen DOF Effekt wie bisher weiter auch im neuen Scene Renderer nutzen können. (kann man ja schlecht
  vermitteln wieso auf einmal ein Feature das schon drinnen war nicht mehr geht nur weil man einen anderen Scene Renderer nutzt *g*)
  Standardmäßig schaut SRPDeferredDOF ob die aktuelle Kamera ein SNMPostProcessDepthOfField besitzt, wenn ja, so werden diverse Einstellungen von hier
  übernommen. Das finde ich weiterhin nett da DOF einfach eine Kamera Einstellung ist und es viel natürlicher ist wenn man das direkt im Scene Graph bei der
  Kamera Node einstellen kann.



>> 08.04.2010
[CO]
- Scene Renderer Schritte: Einige "VarChanged()" entfernt
- SRPPostProcessing: Motion Blur über Accumulation Buffer entfernt. Das wird zukünftig in seperaten Post Processing Komponenten über Render To Texture realisiert.
  (hab da schon Literatur dazu gehortet und das ist wirklich nicht sehr schwer *g*)



>> 06.04.2010
[CO]
- "SRPDeferredGlow" auf Basis von "HDRBloom" und "SRPDeferredGodRays" eingebaut (die Effekte sind sich ja recht ähnlich, auch wenn diese andere Eingabedaten
  nutzen und diese etwas anderst verarbeiten)
  Achtung: Da ich gerade selbst drübergestoplert bin und mich wunderte wieso da nix Glüht obwohl da doch eine Emissive Map ist... Emissive Maps allein erzeugen
  kein Glühen, das find ich weiterhin gut weil z.B. Himmel normalerweise nicht "Glühen" sollte. Für Glühen muss im Material der Parameter "Glow" genutzt werden
  der Standardmäßig auf 0 steht. 
- Neue Funktion "SRPDeferredGBuffer::IsColorTarget3AlphaUsed())". Wenn im Alpha Kanal von RT3 alles nur auf 0 steht, Glüht nichts - und in dem Fall braucht z.B.
  "SRPDeferredGlow" erst gar nicht mit der Arbeit anfangen denn das Ergebnis steht ja bereits fest: Es Glüht nix. *g*



>> 05.04.2010
[CO]
- "FullscreenQuad::Draw()" um zweiten Parameter erweitert über den man Einstellen kann wie viele Pixel gezeichnet werden sollen
- "HDRAverageLuminance" funktioniert nun wie es sollte... Code vereinfachungen bewirken immer wieder Wunder *g*
- "HDRLightAdaptation"-Komponente hinzugefügt die in "SRPEndHDR" dazu genutzt wird um die Helligkeit "weich" übergehen zu lassen
- "HDRBloom"-Komponente hinzugefügt, der Name sagt schon für was das ist. :D Auch hier muss Tone-Mapping gemacht werden... darum habe
  ich hier das eher Suboptimale "Wiederverwendung durch Kopieren" verwendet da die einzelnden Komponente möglichst in sich geschlossen sein sollten
  und auch in einem Render-Durchlauf soviel wie möglich abgearbeitet werden soll. (bestmögliche GPU-Auslastung)



>> 04.04.2010
[CO]
- "SRPEndHDR" in eigenes "HDR"-Verzeichnis verschoben, da kommt noch nen bischn was und ich hatte einfach die Befürchtung das es zu unübersichtlich wird wenn
  das, im Grunde in sich geschlossene Thema, nicht in einem eigenen Verzeichnis liegt.
- Während das HDR Tone Mapping vergleichsweise einfach ist und http://www.cs.ucf.edu/~reinhard/cdrom/ scheinbar tatsächlich *DIE* Literaturquelle schlichtweg
  für das ist, ist die Berechnung der benötigten "logarithmic average luminance" hingegen nicht ganz so einfach. Im Grunde ist das "Parallele Reduktion" - also
  genau das was ich in meiner Bachelorarbeit mit OpenCL bis zum Abwinken verwendet habe. Das über eine reine Grafik-API zu realisieren ist allerdings kein wirkicher
  Spaß. Während ich gestern zahlreiche Möglicheiten der Berechnung durchprobierte, die alle einfach nicht zufriedenstellend waren, hab ich mich dazu entschlossen
  einen scheinbar recht weit verbreiteten Weg zu wählen der in \url{http://developer.download.nvidia.com/SDK/9.5/Samples/DEMOS/Direct3D9/HDR_FP16x2.zip}
  beschrieben wird. Zwar läuft das Beispiel bei mir nicht - aber das ist *genau* die Vorgehensweise die ich sehr häufig gesehen habe, und das NVIDIA Beispiel
  ist denk ich eine recht Seriöse "Literaturquelle". Es gibt zwar noch mehr NVIDIA Beispiele die das nutzen, aber hier ist das am schönsten zu Erkennen was
  genau abläuft. (die anderen Bespiele haben irgendwie ziemlich zerstruppelten Code *g*)
  Die Berechnung liegt in der seperaten Komponenten Klasse "HDRAverageLuminance" damit "SRPEndHDR" nicht zu ausufernd wird und die einzelnen Themenbereiche
  für bessere Übersichtlichkeit getrennt voneinander sind. Leider ist da noch irgendwo der Wurm drin und ich komm gerade nicht drauf das da schiefläuft -
  man könnte ja meinen so eine kleine Summenbildung wäre schnell gemacht... brrr



>> 03.04.2010
[CO]
- "SRPEndHDR" Scene Render Schritt hinzugefügt. Dies ist eine Ableitung von "SRPEnd" und zeichnet nicht einfach direkt so das HDR Bild in den LDR Buffer,
  sondern führt "Reinhard Tone Mapping" wie in http://www.cs.ucf.edu/~reinhard/cdrom/ beschrieben aus. Ebenfalls wird hier auch eine Gamma-Korrektur
  durchgeführt.



>> 02.04.2010
[CO]
- "PostProcessing" aus dem "SceneRenderer"-Verzeichnis losgelöst und in das Grundverzeichnis geschoben. Post-Processing *kann* zwar unmittelbar mit durch
  Scene Rendering erzeugte Daten wie GBuffer zusammenhängen, ist im Allgemeinen aber eine davon unabhängig Sache. Nur ganz konkrete fest in das Scene Rendering
  integrierte Dinge wie SRPDeferredGodRays bleiben im "SceneRenderer"-Verzeichnis. "PostProcessing" wird denke ich demnächst noch um diverse kleinere Hilfs-Komponenten
  erweitert die z.B. in "SceneRenderer" genutzt werde. Viele Aufgaben wie z.B. Gauß-Filter wiederholen sich ständig - das aber *nur* als reine Effect-Datei zu
  realieren ist irgendwie doof und umständlich.
- FullscreenQuad hinzugefügt, das wird ständig in der gleichen Form benötigt :D
- SRPDeferredGBuffer bietet eine FullscreenQuad Instanz an die alle anderen Render Schritte nutzen können
- Folgende Klassen nutzen nun direkt FullscreenQuad und werden dadurch ein Stück kompackter: SRPDeferredAmbient, SRPDeferredDepthFog, SRPDeferredEdgeAA,
  SRPDeferredGodRays, SRPDeferrerSSAO, SRPDeferredHBAO, SRPDeferredHDAO
- "SRPWireframes" in "SRPDebugWireframes" umbenannt
- "SRPHierarchies" in "SRPDebugHierarchies" umbenannt
- "SRPSceneNodeIcons" in "SRPDebugSceneNodeIcons" umbenannt
- "SRPSceneNodeNames" in "SRPDebugSceneNodeNames" umbenannt
- "SRPContainerScissorRectangles" in "SRPDebugContainerScissorRectangles" umbenannt
- Die umbenannten Scene Render Schritte für Debugging sind nun von der neuen Abstrakten Basisklasse "SRPDebug" abgeleitet... damit müsste dann wirklich immer
  klar sein das diese Render Schritte nur für Debugging gedacht sind, und z.B. bei ausgelieferten Produkten weggelassen werden können
- "SRPDeferredGBufferVisualisation" in "SRPDeferredGBufferDebug" umbenannt, zwar ist diese Klasse nicht von "SRPDebug" abgeleitet, ist aber trotzdem nur
  für Debugging da
- SRPDeferredGBuffer: Support für neue Material-Parameter: "DisplacementMap" & "DisplacementScale" & "DisplacementBias" -> Vertices werden einfach anhand
  einer Texture verschoben. Für sich allen natürlich nicht wirklich nett, macht erst wirklich Sinn mit Tessellation - aber im Grunde kann man beides unabhängig
  betrachten und darum hab ich das nun schonmal eingebaut. (da Tessellation so oder so noch mit rein *muss*)



>> 01.04.2010
[CO]
- SRPDeferredGBuffer: Fresnel Reflection wurde noch nicht ganz richtig berechnet, der Material-Parameter "IndexOfRefraction" gibt an in welches Material
  übergegangen wird... es fehlte aber noch von welchem Material aus übergegangen wird - hier habe ich nun Luft (IOR=1.0) eingestellt. Derzeit ist der Wert
  fest, weis nicht ob das Sinnvoll ist auch das noch Einstellbar zu machen.
- SRPForward und SRPFixedFunction hinzugefügt, die Basisklassen für die entsprechenden Render-Schritte
- Neue grundliegende Scene Render Schritte: SRPBegin und SRPEnd. Habe vieles aus "SceneRenderer::DrawScene()" nach SRPBegin verschoben. Dieser neue Render
  Schritt sollte immer ganz am Anfang der Render-Pipline stehen und setzt dann ein paar grundliegende Render-States wie z.B. ob alles in Wireframe gezeichnet
  werden soll. SRPEnd sollte ganz am Ende der Render-Pipeline stehen und kann z.b. dann noch ein kleines Logo auf den Bildschirm malen oder wenn in eine
  Texture gerendert wurde den Inhalt über ein Fullscreen-Quad darstellen. Es ist allerdings nicht "Verboten" das jemand diese Scene Render Schritte woanderst
  hinschiebt, das geschieht dann aber in Eigenverantwortung. Wow, das wundert mich ziemlich das ich das nicht schon früher so gemacht habe,
  denn das bietet sich wirklich an und passt super ins Design und macht alles viel universeller. Beispielsweise kann man nun auch Dinge wie ob im
  Wireframe gezeichnet werden soll im Debug-Dialog bei den Scene Renderer Optionen einstellen - denn da es nun in SRPBegin liegt und das nur ein ganz normaler
  Render-Schritt fügt sich das alles gut ins Gesamtsystem ein.
- "EngineDebugConfig"-Konfiguration: "WireframeMode" und "PointMode" entfernt, dies ist nun eine "SRPBegin"-Einstellung. Ebenfalls die Konsolen-Befehle
  "points" und "wireframes" in "SNConsoleBase" entfernt. Juhu, so langsam kommt da Ordnung rein und die einzelnden Komponenten sind sauber voneinander getrennt
  ohne das alles mögliche Kreuz und Quer verteilt ist. Will man Scene Render Einstellungen wegspeichern oder über ein schickes Ingame GUI ansteuerbar machen,
  ist das Aufgabe einer *höheren Instanz*.
- "SceneRenderer": "NoScissorRectangles" entfernt, so Dinge sollten nur noch in Scene Render Schritten gemacht werden, das ist sonst nur eine künstliche
  Einschränkung des Systems
- "SRPBegin": Auf wunsch wird ab hier in eine Texture gerendert, dabei gib es Double Buffering support :D (PostProcessor muss noch angepasst werden)
- "SRPEnd": Wenn "SRPBegin" in eine Texture rendert, wird hier das Ergebnis in das urspüngliche Render Target über ein Fullscreen-Quad gezeichnet
- SRPDeferredEdgeAA funktioniert nun, die Ergebnisse sind aber eher bescheiden und mit der Lupe zu suchen. Das Bild wird zwar minimal ruhiger, an "richtiges"
  Hardware Anti-Aliasing kommt das leider nicht ran.
- SRPDeferred Implementationen reichen sich nun gegenseitig den Tiefen Buffer rüber damit alle den gleichen Tiefen Buffer nutzen. Nun klappt alles wieder wie
  früher und z.B. Partikel werden durch Objekte verdeckt die beim GBuffer füllen gezeichnet wurden.
- SRPWireframes: Neues Flag: "UseDepth", damit wird der Tiefen Buffer genutzt so das Linien verdeckt werden - Standardmäßig bevorzuge ich persöhnlich aber
  auch Linien hinter Objekten zu sehen... damit kann ich z.B. sehen welche Objekte gerade wirklich gezeichnet werden.
- Neuer Scene Render Schritt "SRPDeferredDepthFog" für einfachen "traditionellen" Tiefenbasierenden Nebel, sieht aber trotzdem nett aus :D



>> 31.03.2010
[CO]
- Das Verzeichnis "SceneRenderer" liegt nun auf der gleichen Verzeichnis-Ebene wie "Scene". Zwar nutzt "SceneRenderer" intensiv "Scene", ist aber im Grunde
  ein eigenständiges System und zu verschachtelte Ordner-Strukturen sind nicht wirklich übersichtlich.
- Das Verzeichnis "DeferredRendering" in "Deferred" umbenannt... da dieses Verzeichnis im "SceneRenderer" Verzeichnis ist, fügt "Rendering" keinen
  weiteren Informationsgehalt hinzu *g*
- "ShaderLighting" Scene Renderer Schritte in ein Verzeichnis Namens "Forward" verschoben
- "Basic" und "BasicLighting" Scene Renderer Schritte in ein Verzeichnis Namens "FixedFunction" verschoben
- "SRPShaderX" Scene Renderer Schritte in "SRPForwardX" umbenannt. (Shader ist wirklich nix aussagend hier) "ShaderLighting.sr" lass ich aber vom Namen
  her, das ist nicht soo dramatisch da es nur eine "Einkaufsliste" darstellt und sich so die Änderungen in Grenzen halten.
- "SRPBasicX" Scene Renderer Schritte in "SRPFixedFunctionX" umbenannt (Basic ist wirklich nix aussagend hier, Scene Renderer Dateien nicht umbenannt)
- SRPDeferredGodRays & SRPDeferredGBuffer: Kleine Optimierung: Wurde in Color Target 3 nix geschrieben, iss der Inhalt schwarz... und schwarzes Zeug wirft
  keine God-Rays und Glüht auch nicht, also kann man direkt diese Post-Processing Schritte automatisch auslassen.
- SRPDeferredEdgeAA hinzugefügt das eine in http://http.developer.nvidia.com/GPUGems3/gpugems3_ch19.html beschriebene Technik für Kanten-Erkennung verwendet.
  Anhand der Kanten kann man dann Samples in der Umgebung eines Pixels mischen um eine Kantenglättung zu erzielen. Hier sieht man auch wieder gut das
  16 Bit für Tiefe wirklich hart an der Grenze ist. Der Effekt ist derzeit im Code noch deaktiviert da der letzte Schritt noch nicht realisierbar ist -
  das mischen der Samples... denn dafür müsste ich das Bild als Texture vorliegen haben, derzeit wird aber noch direkt so gerendert. Das ist eines der
  nächsten Dinge die ich anpacken werde da dies ebenfalls für andere Effekte benötigt wird und es generell Sinnvoller ist direkt alles in Fließkommazahlen
  Texturen zu rendern. Der GBuffer nutzt ja bereits Fließkommazahlen Texturen, das erzeugen des finalen Bildes erfolgt derzeit aber noch in R8G8B8 - was
  für eine Verschwendung. *g*
- SRPDeferredGodRays: "DisableBlending"-Flag hinzugefügt, damit kann man kontrollieren wie der Effekt gerade wirklich aussieht
- SRPDeferredGodRays: "DisableAlphaTest"-Flag hinzugefügt, damit kann man in Kombination mit "DisableBlending" kontrollieren welche Teile des Bildes vom Effekt
  beeinflusst werden... ansonnsten ist die Performance mit aktiviertem Alpha-Test etwas (minimalst :) besser da kostspieliges Blending reduziert werden kann.



>> 30.03.2010
[CO]
- Wie ich gestern zufällig herausfand kennen Cg, HLSL und GLSL ein Schlüsselwort Namens "discard", (texkill) damit werden die Berechnungen für ein aktuelles
  Fragment abgebrochen - aber noch wichtiger, das Fragment wird komplett verworfen, also nicht gezeichnet. DAS ist genau das was ich schon ein paar mal gebraucht
  hätte, und darum dann so Hacks wie den "Alpha Test Trick" gemacht hatte mit dennen ich mich aber nie so ganz wohl fühlte da diese schnell nach
  hinten losgehen können und man den realen Wertebereich dadurch einschränkte. Mit "discard" ist das kein Thema, merkwürdig das ich nicht schon früher
  darüber gestolpert bin. Habe den "Alpha-Trick" überall rausgenommen und durch "discard" ersetzt - viel besser so! :D
  Das wird laut Dokumentation von allen Shader-Profilen unterstützt... ist aber nicht der Fall! Erstmal passierte nix und die Fragmente waren immer noch da,
  nachdem ich von "glslf" auf "arbfp1" umgeschaltet hatte ging "discard" wie es sollte. Na toll, ein weiterer Punkt auf meiner Liste der gegen die zukünftige
  Nutzung von Cg spricht. Damn, mittlerweile sind da einige Punkte auf dieser *gegen Cg*-Liste die wirklich wichtig wären. Ok, sobald ich mit den Deferred
  Scene Renderer Arbeiten soweit durch bin, muss ich wohl mal schaun ob ich PLRenderer so Erweitern kann das man auswählen kann welches interne Shader-System
  man nutzt. So könnte man z.B. sagen "Ich will intern GLSL nutzen", und dann muss man GLSL Codes statt Cg-Codes übergeben, wenn alles klappt würde aber
  das Restliche Interface gleich bleiben. Da führt wohl kein Weg mehr vorbei, aber um Glück ist das nicht total Dringend so das ich mich erstmal um schicke
  und moderne Grafik kümmern kann bevor ich mich dran mache Innereien umzubauen. :D
- "SRPDeferredGodRays": "God Rays" wie in http://http.developer.nvidia.com/GPUGems3/gpugems3_ch13.html beschrieben eingebaut... das war genauso einfach wie
  es aussah, es dauerte länger nette Einstellungen für die Parameter zu finden. Der Effekt kann die Optik nochmals verbessern, ohne das der Effekt an sich
  sonderlich kompliziert ist oder superviel Performance schluckt.
- Zum Performance testen habe ich im "SRPDeferredLighting" Fragment Shader anstatt des Alpha-Tests zum verwerfen von Fragmenten die nicht von der Lichtquelle
  beeinflusst werden, mal das "discard" Shader-Schlüsselwort verwendet. Im Grunde ist der Code so etwas kompakter und "schöner", die Performance war
  Interessanterweise aber etwas schlechter als wenn ich den Alpha-Test nutze. Kann gut sein das sobald "discard" verwendet wird, irgendwelche GPU internen
  Optimierungen deaktiviert werden. (meine GPU: "ATI Mobility Radeon HD 4850") Also bleib ich bei Alpha-Test und verwende "discard" nur für den Texture
  Alpha-Test da ich dann gleichzeitig auch noch einen Wert in den Alpha-Kanal schreiben kann ohne das sich das mit dem Alpha-Kanal beißt.



>> 29.03.2010
[CO]
- SRPDeferredGBuffer: Neuer Material Parameter: "ReflectionMap"... fand bei der Gelegenheit auch direkt einen Fehler in der Cg-Dokumentation: Die zwei ersten
  Parameter werden dort vertauscht. (auch wenn etwas weiter unten die Formel gezeigt wird die wieder stimmt *g*)
  Anhand der PixelLight Standard Cube-Map "DefaultCubeMap.dds" habe ich die Cube-Reflektionen überprüft, das scheint nun alles korrekt rotiert zu sein.
  (das was man an Reflektionen sehen kann dazu einfach mit den einblendbaren Welt-Koordinatenachsen überprüfen)
  Für 2D-Reflektionen wird nun klassisches "Spherical Environment Mapping" verwendet ohne irgendwelche merkwürdigen Hacks. Ich habe das auch direkt im
  alten Scene Renderer "SRPShaderAmbientMeshes_FragmentShader.h" ausgebessert.
- Der Material-Parameter "HorizonMap" wird vom Deferred Scene Renderer nicht unterstützt. Genutzt haben wir das eh nie und wirklich toll damit zu arbeiten
  ist es auch nicht - viel zu Umständlich. Für einen gleichen Effekt kann man im neuen Renderer nun z.B. SSAO aktivieren.
- Habe mich an 'Virtual Position' versucht, einer kleinen in http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter09.html beschriebenen Erweiterung für
  Parallax Mapping so das z.B. projezierte Texturen und Shadow Mapping ebenfalls von Parallax Mapping beeinflusst werden - ohne das sieht das dann nicht so
  richtig dolle aus da die projezierten Dinge dann scheinbar "über den Vertiefungen schweben". Das sieht wirklich sehr nett aus und ist einfach einzubauen...
  allerdings muss 'Virtual Position' auch bei der Shadow Map erzeugung berücksichtigt werden. Hatte zum Testen mal was *eingehackt* und es ging - allerdings
  sollte ich vorher wohl ein vernümpftiges Shadow Mapping System Refeactoring machen da es sonst zuviele unschöne Änderungen werden. Das System muss eh
  mal überabeitet werden, das war nur mein *allererster Versuch* damit - aber das sollte ich als eigenständigen Arbeitsschritt machen, sonst wird das alles
  zuviel auf einmal. *also schweren Herzens nach hinten geschoben*



>> 28.03.2010
[CO]
- SRPDeferredGBuffer: "Float32" ist Standardmäßig nicht mehr gesetzt. Ich habe mir das nun in mehreren Szenen gaaanz genau angeschaut, also unterschied zwischen
  16 Bit und 32 Bit Fließkommazahlen... der einzige Unterschied war bei SSAO Verfahren zu sehen. 16 Bit Tiefe ist zwar schon fast kritisch, aber merkwürdigerweise
  konnte ich nun keine so großen Artefakte mehr sehen wie noch vor ein paar Tagen -> wenn dann noch SSAO Blur an ist merkt man fast keinen Unterschied. Einen
  Performance unterschied merkt man allerdings schon...
- SRPDeferredGBuffer: Neue Material Parameter: EmissiveMap und EmissiveMapColor
- SRPDeferredGBuffer: Neue Material Parameter: LightMap und LightMapColor
- SRPDeferredLighting: Wenn ich das richtig verstanden habe, sollte Ambient Occlusion *normalerweise* nur für Ambient Lighting genutzt werden, nicht für gerichtete
  Lichter. (Jens hat mir das im Chat bestädigt, er als Grafiker musses am besten Wissen *g*) Daher ist das Flag "NoAmbientOcclusion" nun als Standard gesetzt.
- SRPDeferredGBuffer: Neue Material Parameter: Glow und GlowMap -> Haben derzeit noch keine Sichtbare Auswirkung da noch der entsprechende Glow-Blur Render Schritt
  fehlt (über SRPDeferredGBufferVisualisation kann man aber sehen das der GBuffer Inhalt bereits passt)
- SRPDeferredGBuffer: Neue Material Parameter: IndexOfRefraction, FresnelReflectionPower und ReflectionColor für Fresnel Reflektion
- Der Material-Parameter "ReflectionMapColor" heißst zukünftig "ReflectionColor". Das macht nun Sinn das unabhängig von Reflection Maps zu sehen da man auch
  Fresnel Reflections ohne Reflection Maps machen kann. Die Scene Renderer haben derzeit alternativ noch "ReflectionMapColor" drinnen damit alte Daten erstmal
  weiter nutzbar sind. Es ist zwar immer sehr gefährlich nach einer Zeit einfach so Namen zu ändern, aber für immer und Ewig sich dann über Namen ärgern ist
  auch nicht wirklich toll.
- "DeferredRendering.sr" in "Deferred.sr" umbenannt, ist kürzer und "sr" steht ohnehin für "Scene Renderer"
- SRPDeferredGBuffer: Neue Material Parameter: ReflectivityMap und Reflectivity
- Der Material-Parameter "ReflectivityMap" ist zukünftig nur noch ein Graustufenbild, was anderes macht bei einer *korrekten* Reflektion-Berechnung keinen Sinn
- Der Material-Parameter "ReflectionNormalMapping" wird im Deferred Scene Renderer nicht unterstützt, das macht hier einfach keinen Sinn. Beim alten Renderer
  hatte ich das im Grunde nur aus Performancegründen eingebaut, da ich beim neuen Renderer allerdings den korrekten Normal Vektor einfach so schon habe, kann
  ich den direkt nutzten. (es wäre sogar umständlicher das so zu machen das nur für Reflektionen kein Normal Mapping verwendet wird *g*)



>> 27.03.2010
[CO]
- SRPSceneNodeIcons & SRPSceneNodeNames: Neue Variable "MaxDrawDistance" die einen Standard-Wert von 20 hat... alle Elemente die weiter entfernt sind werden
  ignoriert. Gerade bei großen Szenen wird es ohne eine solche Längenbeschränkung sehr schnell, sehr unübersichtlich.



>> 26.03.2010
[CO]
- Eine weitere SSAO-Implementation hinzugefügt: "SRPDeferredHDAO". "High Definition Ambient Occlusion" (HDAO) ist im ATI Radeon SDK beschrieben.
  (http://developer.amd.com/Downloads/HDAO10.1.zip)... "Tolles großes DirectX 11 Feature!", PAH! (gather4 ok, aber das können ATI Karten schön länger soweit
  ich weis und HDAO kann das nutzen, muss es aber nicht... also ein DirectX 11 Feature ist das nicht wirklich, auch wenn man das sooo oft auf tollen News
  Seiten liest *g*)
  HDAO und HBAO sind derzeit scheinbar recht beliebte Verfahren für SSAO. Ich wollte einfach mal zwei unterschiedliche Ansätze ausprobieren - und beide erzeugen
  recht unterschiedliche Ergebnisse. HDAO sieht schon irgendwie teils *Comic like* aus während HDAO gerne *kriselt* wenn man es nicht *vermatscht*. HBAO scheint
  etwas flotter zu laufen, frisst aber ebenfalls mächtig viel Leistung. Desweiteren sind zwei Implementationen auch ein netter *Proof Of Concept* der zeigt
  das das Scene Rendering System recht einfach um weitere Techniken erweitert werden kann.
- SRPDeferredSSAO kümmert sich nun um Blur und beinhaltet einige recht universelle Parameter, die von SRPDeferredSSAO abgeleiteten Klassen müssen sich nun also
  nur noch ausschließlich um das erzeugen des AO kümmern
- SRPDeferredLighting: Ambient Occlusion und dynamischer Echtzeitschatten werden nun nicht mehr beide mit der Lichtfarbe multipliziert, sondern nur das kleinere,
  sprich, dunklere von beiden. Bisher bisher gab "Dunkel und Dunkel = noch Dunkler", ich denke aber nicht das dies so ganz korrekt war. *g*



>> 25.03.2010
[CO]
- SRPDeferredGBuffer: DrawRec(): Mesh-Teil in "DrawMesh()" ausgelagert um die Übersichtlichkeit zu fördern
- SRPDeferredGBuffer: "TwoSided" Material Parameter Support läuft nun
- Zukünftig gibt es neben dem "LightMap" Material Parameter noch einen Parameter Namens "AmbientOcclusionMap". Als ich "AO" zum ersten mal hörte und mir die
  Texturen anschaute dachte ich mir "numei, das sind halt einfache Graustufen Lightmaps, also kann man das genauso gut direkt in den LightMap-Parameter packen".
  Das ist Beleuchtungstechnisch so allerdings nicht ganz korrekt. LightMaps stellen *fertig Ausgeleuchtete Daten* dar, also Licht und Schatten. AOMaps hingegen
  beinhalten ledeglich *Verdeckungsinformation*, sprich, wie stark ein Texel durch die unmittelbare Umgebung verdeckt, und dadurch abgedunkelt wird. AOMaps sollten
  folglich auch neben dem Ambient Schritt beim Beleuchtungsschritt berücksichtigt werden, daher ist eine Trennung der Daten sinnvoll. AOMaps haben zudem nur eine
  Komponente statt 3, können daher prinzipiell Platzsparender Abgelegt werden - derzeit hat PixelLight aber noch keinen Texture Kompressions Support für diese
  Formate. Über die OpenGL Erweiterungen GL_ARB_texture_compression_rgtc & GL_EXT_texture_compression_latc kann man auch 1 oder 2 Komponenten Bilder komprimieren.
  Das gabs früher als ich die Texture Kompression einbaute noch nicht, wird scheinbar aber aber mittlerweile von allen aktuellen GPUs unterstützt. Da diese neuen Texture
  Kompressionen für HeightMaps, AOMaps, NormalMaps und und und eingesetzt werden könnten, hab ich mir Support dafür bereits auf meinen Plan geschrieben - damit
  müsste man den Speicherverbauch nochmal absenken können + Ladezeiten verbessern. Das kommt dann gerade Szenen die AOMaps nutzen zugute - bisher nutzte Jens
  immer ausschließlich AOMaps und nie LightMaps. Wenn eine GPU die Formate nicht unterstütz, müssen die On-The-Fly dekomprimiert werden - aber das ist denk
  ich akzeptabel. Man könnte fast sagen *selbst schuld wer 5 Jahre alte GPUs nutzt*, wenigstens läufts dann dort auch noch, wenn auch bei weitem nicht so
  optimal wie auf aktuellen GPUs... aber aktuelle Features nicht zu nutzen um Resourcen zu schonen, wäre schon fast Fahrlässig. *g*
- "SRPBasicLightingSolidMeshes", "SRPBasicLightingTransparentMeshes", "SRPBasicSolidMeshes", "SRPBasicTransparentMeshes": "AmbientOcclusionMap" Support
  eingebaut... jedoch ist die Implementation etwas eingeschränkt: Entweder kann "LightMap" verwendet werden, oder "AmbientOcclusionMap", nicht beides
  gleichzeitig. Ist bereits eine "LightMap" da, wird eine eventuell ebenfalls vorhandene "AmbientOcclusionMap" ignoriert. Rein Technisch gesehen wäre es
  möglich beide Map-Typen gleichzeitig zu nutzen, allerdings müsste ich dann über PLRenderer freier Texture-Koordinaten Texture-Stages zuordnen können,
  was derzeit nicht geht. Derzeit ist das fest verdrahtet das "Texture Stage 0" "Texture Koordinaten 0" nutzt, "Texture Stage 1" "Texture Koordinaten 1"
  und so weiter. Ich hatte mir in den letzten Jahren schon mehrmals überlegt das freier Einstellbar zu machen - aber irgendwie würde das zu kompliziert werden.
  (unter Nutzung von Shadern ist das alles ohnehin kein Thema mehr) Aber ich denke das reicht so, bisher haben wir eh immer noch "AOMaps" genutzt.
- SRPShaderAmbientMeshes: "AmbientOcclusionMap" Support eingebaut. Hier geht "LightMap" und "AmbientOcclusionMap" auch gleichzeitig. Ebenfalls gibts einen
  "AmbientOcclusionFactor" Material Parameter über den man den AO Einfluss noch etwas regeln kann. Ich habe das anhand der "Cabin" Demo Szene getestet.
- SRPShaderLightingMeshes: "AmbientOcclusionMap" & "AmbientOcclusionFactor" Support eingebaut. Achtung, dadurch kann es sein das Szenen nun Dunkler wirken
  als zuvor... aber das ist korrekt -> Ambient Occlusion bedeutet ja "Da scheint nix oder nur wenig hin".
- SRPDeferredGBuffer: "AmbientOcclusionMap" & "AmbientOcclusionFactor" Support eingebaut, damit wird auch direkt beim GBuffer Füllen, falls erwünscht, der
  Alpha Wert mit einem vorberechneten statischen Ambient Occlusion Wert gefüllt. Achtung, sollte z.B. "SRPDeferredHBAO" aktiviert sein, überschreibt dieses
  die Ambient Occlusion Werte mit neuen Werten! Es geht also entweder statisches AO, oder dynamisches AO, aber nicht beides. Das müsste aber ok sein. Damit kann
  man nun sehr schön durch "SRPDeferredHBAO" ein/ausschalten den Unterschied zwischen statischem und dynamischem AO begutachten.
- SRPDeferredGBuffer: Habe hier meinen kleinen Alpha-Trick eingebaut den ich schon im alten Scene Renderer für DOF nutzte... im Alpha Kanal von RT0 wird
  Ambient Occlusion gespeichert, Alpha kann aber auch dazu dienen das die GPU ein Fragment über Alpha Test verwirft. Ich will beides haben, das geht über
  den erwähnten Trick halbwechs ordentlich. *g* (wäre doof eine Komponente komplett wegzuwerfen nur weil man eventuell einen Alpha Test mal braucht)
  Das ist natürlich nur für statische Ambient Occlusion Maps in Zusammenhang mit Alpha-Test relevant. Dadurch wird AO nie *ganz* schwarz sondern man verliert
  20% der möglichen Dunkeltheit. Ich denke/hoffe allerdings nicht das dies total dramatisch ist - denn wie gesagt, nur für Alpha Test eine gesamte Komponente
  opfern wäre etwas heftig.



>> 24.03.2010
[CO]
- SRPDeferredHBAO: "Cross Bilateral Filter" wie in "NVIDIA Direct3D SDK 10 Code Samples"
    (http://developer.download.nvidia.com/SDK/10.5/direct3d/Source/ScreenSpaceAO/doc/ScreenSpaceAO.pdf)
  beschrieben eingebaut. Da man auf verschiedenste Arten Blur einfügen kann, überlegte ich zuerst das irgendwie als seperaten Render Schritt zu machen... aber
  das wäre denk ich dann zu umständlich geworden zumal SRPDeferredHBAO und SRPDeferredMrHBAOBlur ohnehin dann sehr eng hätten zusammenarbeiten müssen. Dann lieber
  alles direkt zusammen in einem gemeinsamen übersichtlichen Scene Renderer Schritt. Das Ergebnis landed weiterhin im GBuffer RT0 Alpha Kanal - alle anderen
  Scene Renderer Schritte interessiert das also nicht im geringsten wie AO bereichnet wird, oder ob überhaupt. Bei aktivierten Blur wird HBAO zuerst in einen
  Zwischenschritt in ein eigenes Render Target gerendert, darauf wird dann Blur entlang der x-Achse angewand. Anschließend wird das ganze nochmal entlang
  der y-Achse "verwaschen" und dann im GBuffer abgelegt.
- SRPDeferredHBAO: "NumberOfDirections" von 16 auf 8 gestellt, mit Blur sieht das immer noch ok aus und braucht deutlich weniger Rechenleistung. "AORadius"
  von 1 auf 0.5 gestellt, das kompensiert etwas die "NumberOfDirections" Einstellung und sieht besser aus... 1 Meter Durchmesser für AO pro Punkt ist immer
  noch recht viel. Jens wird dann herumexperimentieren dürfen welche Default-Einstellungen für *übliche* PixelLight Szenen am besten sind, sprich, Szenen die
  sich an "1 Einheit = 1 Meter" halten.
- SRPDeferredHBAO: "ResolutionScale" hinzugefügt. Im NVIDIA Beispiel nannten die das "Half-Res AO", AO wird in einer kleineren Auflösung berechnet und dann
  hochskaliert... die Qualität leidet darunter natürlich sichtbar, aber gleichzeitig wird die Performance sehr schnell, sehr viel besser... das ist also eine
  weitere Option wo man Geschwindigkeit vs. Qualität abwägen kann/muss.
- ... SRPDeferredHBAO: "NumberOfDirections" wieder auf 16 gestellt... lieber erstmal akzeptable Qualität damit man sehen kann obs noch irgendwo inakzeptable
  Grafikfehler gibt...
- SRPDeferredGBuffer: Neues Flag "Float32". Ist das Flag gesetzt, so wird in Render Targets mit 32 Bit Floating Points gerendert, ansonnsten in Render Targets
  mit 16 Bit Floating Points. In einem Test in FullHD hatte ich mit 32 Bit 52 FPS, mit 16 Bit hingegen 64 FPS. 32 Bit bleibt erstmal Default da scheinbar 16 Bit
  nicht ausreichend sind für die Tiefe, beim HBAO sieht man mit 16 Bit Artefakte. (kann nur die Tiefeninformation sein :)
  Bei den heutigen GPUs scheint es möglich zu sein, dass beim MRT jedes Render Target ein anderes Texture Format hat - das könnte dieses Problem lösen. Farben
  könnten dann mit 8 Bit pro Komponente gespeichert werden, und die Tiefeninformation mit 32 Bit. *muss in der Richtung mal etwas forschen*
- SRPDeferredHBAO: Nach einer kleinen Änderung in RendererOpenGL kann ich hier nun auch in Render Targets mit einer Komponente Rendern was total ausreichen ist.
  Hier wird nun fest TextureBuffer::L8 verwendet - 1 Byte pro Pixel ist absolut ausreichend, die feineren Abstufungen die 16 oder gar 32 Bit bringt sieht man nicht
  da am Ende wieder ein 8 Byte pro Pixel Bild auf dem Bildschirm erscheint. *g*
- SRPDeferredHBAO: Die Variante die Normalen Vektoren nutzt und dadurch noch Detalierter wirkt läuft nun sauber. Die z-Achse der Normale musste Invertiert werden...
  der Beispielcode von NVIDIA war DirectX, das erklärt das wohl. Das muss ich mir nochmal genauer anschaun, mag ich ja gar nicht wenn da mal was invertiert wird,
  an anderer Stelle aber nicht. (das schlägt irgendwann zurück...)



>> 23.03.2010
[CO]
- SRPDeferredLighting: Support für Schatten bei Point-Lichter (inklusive Softshadows)
- Die Deferred Scene Renderer Schritte nutzen nun alle "glslf" statt "arbfp1", so kann kann ich mir relativ sicher sein das auch Dynamic Branching funktioniert
  das im Beleuchtungsschritt an einigen Stellen verwendet wird. => Wenn festgestellt wird das ein Pixel nicht beleuchtet wird, kann der Rest des Shaders komplett
  übersprungen werden, bei alten Shader-Profilen ging soetwas noch nicht. (alle Shader mussten Gnadelos von oben nach unten durchlaufen)
- SRPDeferredLighting einige Flags spendiert. Einige dieser Flags sind hauptsächlich für Debuggen gedacht, und daher habe ich das so einfach wie möglich umgesetzt -
  ich glaube nicht das der Compiler immer in der Lage ist dann einfacheren Code zu erzeugen, das ist hier aber auch unwichtig. Der Cg Compiler scheint allerdings
  recht gut zu sein... wenn ich z.B. "NoSpecular" setze, wird "RenderTargetTexture2" scheinbar komplett wegoptimiert obwohl ich im Shader selbst da total schlampig
  bin und alles drinnen lasse, und einfach nur z.B. die Specular Farbe mit einem festen Wert überschreibe. Versuch ich dann "RenderTargetTexture2" von außen zu setzen,
  so bekomme ich "CG ERROR : "The parameter used is invalid."" als Fehler - sprich, das scheint komplett wegoptimiert worden zu sein.
  Beispielsweise kann man das Flag "NoSpecular" nutzen um zu sehen wie sich Specular auswirkt und/oder ob das so ok ist Grafisch. Diese Flags sind also hauptsächlich
  für Programmierer und Grafiker als Hilfestellung gedacht... und für Präsentationszwecke wenn man schrittweise Demonstrieren will wie das fertige Bild
  zustande kommt. *g*
- SRPDeferredAmbient einige Flags spendiert
- SRPDeferredLighting "NoShadowLOD"-Flag hinzugefügt, ist das gesetzt, so sind die Shadow Maps immer voll auflösend. Fürs erste ist das Flag immer als Default gesetzt
  damit man Qualitativ hochwertige Bilder bekommt. (zudem scheint die Auswirkung auf meinem neuen Notebook nicht wirklich mehr so groß zu sein wie noch auf meinem alten)
- SRPDeferredGBuffer Flags aktualisiert
- SRPDeferredLighting: Berechnungen für Positionen die nicht im Licht Radius sind, werden nun frühzeitig abgebrochen (und durch Dynamic Branching müsste der Fragment
  Shader dann *wirklich* frühzeitig abbrechen :)
- SRPDeferredLighting: Schreibt nur in RGB, Alpha wird nicht beschrieben (Renderer::SetColorMask())
- SRPDeferredLighting: Führt nun einen Alpha-Test durch, wenn ein Fragment frühzeitig das Program verlässt, z.B. weil sich ein Fragment außerhalb des Licht Radius
  befindet, so wird eine 0 rausgeschrieben und der Alpha-Test verwirft das Fragment. Dies bedeutet das auch kein Alpha-Blending stattfinden muss - dies schont
  die Füllrate etwas. Will man sehen ob das klappt, so muss man nur bei einer "Early Escape"-Stelle "OUT.color.rgb = 1" schreiben so das Weiß rausgeschrieben wird
  wenn ein Fragment verworfen wird... sieht man nun viele weiße Stellen, weis man das Alpha-Test nicht geklappt hat. *g*



>> 22.03.2010
[CO]
- SRPDeferredLighting: Support für Directionale Lichter
- SRPDeferredLighting: Support für projektive Point Lichter
- SNPointLight zeichnet im Debug Modus das Scissor Rectangle für das Point Licht
- Parallax-Default Wert ist nun 0.04 statt 0.03, dies ist ein Wert den man häufiger in der Literatur sieht
- SRPDeferredLighting: Support für Spot-Lichter mit Kegel (weicher übergang ins Dunkel oder schlagartiger übergang ins Dunkel). Die Implementation lief sofort...
  was wohl daran liegt das ich das ich den Über-Shader nun strickt Hierarisch aufbaue. Das Konzept sieht man besonderst schön bei Spot-Lichtern, schrittweise
  kommen weitere Eigenschaften dazu, ist es kein Spot-Licht, so kann man das alles direkt komplett vergessen. Das mag zwar immer noch ziemlich heftig aussehen
  mit all den Definitionen, aber das ist bei Über-Shadern nunmal so. Dafür muss man keine zig Shader immer wieder komplett von neuen Programmieren und dann
  Gefahr laufen das hier mal ein Fehler ist, dort mal was abweicht etc. Ein weiterer Vorteil ist, das die übersetzten Shader wirklich nur das drinnen haben
  was gerade wirklich benötigt wird, sehr wichtig gerade wenn man etwas höhrere Bildschirmauflösungen noch flüssig haben mag. Von der Perspektive aus sind finde
  ich Über-Shader immer noch die richtige Wahl. Wenn man das, soweit das möglich ist, gut Struktriert und Kommentiert und sehr behutsam am Shader arbeitet, dann
  geht das auch ganz gut. Vorallem auf Lokalität sollte man achten, daher hab ich nun zweimal "LightDirection" drinnen, einmal für Direktionale-Lichter, einmal
  für Spot-Lichter. Das mag auf den ersten Blick merkwürdig erscheinen, auf den zweiten Blick ist das denke ich aber besser lesbar. Dadurch das nun die ganzen
  Material & Geometry Dinge nur noch beim GBuffer füllen in einem seperaten Schritt abläuft, ist das auch nichtmehr soviel geballter Code auf einer Stelle -
  das entschärft das ebenfalls etwas. :D
- SRPDeferredLighting: Support für projektive Spot Lichter (ohne Rückprojektion :)
- Ohschande, ich bekam gerade beim hinzufügen von Shadow Mapping in SRPDeferredLighting den VC-Compilerfehler
    "error C2026: string too big, trailing characters truncated"
  ... hm, dann muss ich wohl die Tabs am Ende rausnehmen so das jede Anweisung direkt mit \n\ beendet wird. Das verschlechtert zwar etwas die Übersichtlichkeit,
  ich wüsste aber nicht wie man das sonst besser machen könnte. Die Shader wieder zu lose herumfahrenden Dateien wollen wir sicherlich nicht machen da wir uns
  vor einiger Zeit ja dazu entschlossen haben das die dll's möglichst alles was diese zum laufen brauchen mitbringen sollten so das man keine xxx "Datenpackete"
  benötigt.
- SRPDeferredLighting: Support für Schatten bei Spot-Lichter (inklusive Softshadows). Schatten für Point-Lichter komplettiere ich morgen - bin nun einfach
  zu müde für nochmal Denkarbeit. *gähn*



>> 21.03.2010
[CO]
- Shader Profile in "SRPDeferredHBAO::GetFragmentShader()" von "arbfp1" auf "glslf" umgestellt... und es geht! Mit dem Profile sind *echte Schleifen*
  möglich so das SSAO nun endlich vernümpftig aussieht. Interessant das der Vertex Shader "arbvp1" bleiben kann, ich hätte nicht gedacht das dies in Cg
  nun so problemlos klappt, das hatte ich ja vor Jahren schonmal ausprobiert und da ging nix so richtig. Mittlerweile ist sogar die Cg Dokumentation
  brauchbar so das man in "CgReferenceManual.chm" Details über die GLSL-Profile nachlesen kann.
  Als ich das Vertex Shader Profile auf "glslv" stellte, bekam ich zwar keinen Compiler fehler, das Ergebniss war allerdings, dass das Bild um die y-Achse
  vertauscht war + noch skaliert so das es pixlig wirkte. Merkwürdig, entweder ein Compiler Bug oder ich mache da irgendetwas nicht "Standard konform". Dann
  bleibt Vertex Shader eben auf "arbvp1".
  Eine weitere kleine Merkwürdigkeit stellte sich im Fragment Shader für ABAO ein. An einer Stelle müsste es "for (float d=0; d<g_NumDir; d++) {"
  lauten, damit bekomme ich aber nur einen weißen Bildschirm. Stelle ich auf "for (float d=0; d<g_NumDir-1; d++) {" um gehts. Erhöhe ich anschließend
  "g_NumDir" um eins gehts immer noch - das kann also keine Shader Limitierung sein. Merkwürdig.
- Die anderen Scene Renderer Schritte wie Beispielsweise "SRPWireframes" gehen nun auch zusammen mit den Deferred Scene Renderer Schritten -
  die Verwendung von "cRenderer.ResetTransformStates();" war schuld da hier dann alle möglichen Transformationen zurückgesetzt wurden. (was zudem unnötig war)
- SRPDeferredGBuffer: NormalMap- und DetailNormalMap-Support eingebaut (+ auch für DXT5_xGxR)
- Komplett neue Material-Parameter für SRPDeferredGBuffer: NormalMapBumpiness + DetailNormalMapBumpiness, damit kann man die "Höhe" der Normal Maps beeinflussen.
  (xy des Normal Vektors wird einfach nur damit Multipliziert *g*) Das hatte ein Grafiker vor Jahren mal angefragt, mit dem alten Scene Renderer wäre das aber
  total umständlich geworden da diese neue Information dann in zig Render Schritten hätte berücksichtigt werden müssen - beim Deferred Renderer muss das nur noch
  beim GBuffer füllen berücksichtigt werden und nun geht das ok. Der Parameter ist auch gar nicht mal so dumm da dies das Aussehen deutlich beeinflussen kann und
  man so endlich etwas Kontrolle darüber hat wie die Detail Normal Map "gemischt" wird.
- Komplett neuer Material-Parameter für SRPDeferredGBuffer: DetailNormalMapUVScale, damit kann man Einstellen wie die Detail Map Texture Koordinate berechnet wird.
  Bisher war "4" fest eingestellt, jetzt da dies nur noch beim GBuffer füllen berücksichtigt werden muss ist das auch kein totaler Overhead das beinflussbar zu machen.
  (was im Grunde ziemlich wichtig ist!)
- SRPDeferredGBuffer: Parallax Mapping eingebaut... jaaaa, auch das läuft komplett beim Füllen des GBuffers ab - mittlerweile liebe ich Deferred Rendering, das macht
  alles soooo schön einfach und universell! *g*



>> 20.03.2010
[CO]
- "SRPDeferredHorizonBasedSSAO" in "SRPDeferredHBAO" umbenannt da man diese Technik scheinbar im Allgemeinen mit "HBAO" abkürzt
- Alle Deferred Rendering Komponenten sind nun von "SRPDeferred" abgeleitet
- Neue Funktion "SRPDeferred::GetVertexBuffer()" -> man braucht hier desöfteren ein Fullscreen Quad, das ist ein Vertex Buffer der direkt passende
  Daten enthält. Der Buffer kann allerdings auch für andere Dinge genutzt werden wenn sich das mal anbietet.
- SRPDeferredHBAO rendert nun in den bisher noch ungenutzten Alpha Kanal von RT0 des GBuffers. Das aktuelle Render To Texture System ist noch etwas
  ungeschickt/veraltet, daher fügte ich erstmal dort die Funktion "SurfaceTextureBuffer::SetMaxColorTargets()" ein um sagen zu können "Bitte in 1
  Render Target Rendern". Macht man das nicht, will das System hier noch in 3 Texturen Rendern, aber nur eine wird gesetzt -> nix geht.
  Glücklicherweise wollte ich AO ohnehin in RT0 im Alpha Kanal ablegen, das Render Target kommt derzeit direkt mit SurfaceTextureBuffer so das es
  funktioniert... hätte ich z.B. in RT1 rendern wollen, tja, das wäre dann derzeit nicht gegangen. Anhand der Situation kann man schön sehen das
  es höchste Zeit wird das "Render To Texture"-System mal grundliegend zu überarbeiten damit es Flexibler wird.
- "SRPDeferredGBufferVisualisation" kann nun AO visualisieren
- "SRPDeferredAmbient" hinzugefügt, lässt sich mit dem alten "SRPShaderAmbientMeshes" vergleichen und dient dazu Ambient "Beleuchtung" zu erzeugen.
  Die Farbe wird derzeit über "Albedo * AmbientColor * AO" berechnet, mal schaun ob da noch etwas hinzukommt.
- "SRPDeferredLighting" auf Basis von "SRPDeferredAmbient" begonnen. Das Ergebnis wird wie bei "SRPShaderLightingMeshes" über den aktuellen Framebuffer
  Inhalt geblendet.
- "VisNode::GetWorldViewMatrix()" hinzugefügt, das erleichtert etwas die Arbeit in den Scene Renderer Schritten wenn man alle Daten direkt abrufen kann
- "SRPDeferredLighting": Einfachste Point Lichter gehen nun, es sollte nicht so schwer sein die restlichen Lichttypen zu implementieren



>> 19.03.2010
[CO]
- DeferredRenderingSSAO nochmal neu angefangen da Ansätze einfach zu kompliziert waren. (Hauptsächlich die Rekonstruktion von 3D View Space Positionen)
  Ich hab nun erstmal "Horizon-Based Ambient Occlusion" aus den "NVIDIA Direct3D SDK 10 Code Samples" portiert:
    http://developer.download.nvidia.com/SDK/10.5/direct3d/Source/ScreenSpaceAO/doc/ScreenSpaceAO.pdf
  Soetwas kann man schlecht in einem Tag selbst *erfinden*, und dafür sind ja diese Beispiele von NIVIDA da + diese Implementation liefert die besten
  und schnellsten Ergebnisse die ich bis jetzt gesehen habe. (und ich hab mir in letzter Zeit *viele* Lösungsansätze angeschaut) Desweiteren werden viele
  Probleme so gelöst das diese *schön* gelöst sind, also möglichst einfach. Mit meinem aktuellen Cg Profile auf meiner ATI Karte musste ich allerdings
  dynamische Schleifen raus... und dann die Schleifendurchläufe total runterschrauben damit ich über kein Instruktionslimit komme. Das wird nun also einer
  der nächsten Schritte sein - rausfinden wie ich über Cg ein modernes GLSL Profile mit echten Schleifen und keinem Instruktionslimit nutzen kann. (Shader 3.0>=)
  Aber das aktuelle System läuft, der härteste Schritt iss also erledigt! *schweiß von der Stirn wisch*
- "DeferredRenderingGBuffer" in "SRPDeferredGBuffer" umbenannt
- "DeferredRenderingGBufferVisualisation" in "SRPDeferredGBufferVisualisation" umbenannt
- "DeferredRenderingSSAO" in "SRPDeferredSSAO" umbenannt
- "DeferredRenderingLighting" in "SRPDeferredLighting" umbenannt
- Die einzelnden Deferred Rendering Komponenten sind nun von SceneRendererPass abgeleitet (daher die Umbennungen :). Ich konnte bisher noch keinen Grund finden
  der dagenspricht die einzelnen Komponenten wirklich als Render Schritte so zu behandeln. Das hat den großen Vorteil das man sehr einfach bestimmte Komponenten
  durch andere ersetzen kann, und noch wichtiger, man kann die Parameter der Render Schritte wie gehabt sehr bequem über das RTTI verändern. So kann man z.B. über
  das Debug-GUI von PLEngine an den SSAO-Einstellungen herumdrehen und sieht sofort die Auswirkungen. "SRPDeferredGBuffer" stellt die wichtigste Komponente
  bei Deferred Rendering da, diese MUSS vorhanden sein. Andere Komponenten wie z.B. "SRPDeferredSSAO" holen sich die erste gefundene Instanz von
  "SRPDeferredGBuffer" und Arbeiten damit. Es könnte natürlich mehrere Instanzen von "SRPDeferredGBuffer" haben, ich wüsste aber nicht für was man
  das brauchen könnte... daher halte ich das System einfach. "SRPDeferredGBufferVisualisation" schreibt einfach so über alles war bisher im Farbbuffer
  steht... Overdraw, aber das ist hier total egal weil das nur für Debugging und Visualierung da ist und so ists am einfachsten. :D
- Über "SRPDeferredGBuffer::GetRenderTarget()" kann man nur noch die Texturen bekommen in die gerendert wurde, über einen Index kann man bestimmen welche RT.
  Dies ist direkt "TextureBufferRectangle" statt "TextureBuffer" da RT hier eigentlich immer "Rectangle" sein sollten - daher muss man das nicht umständlicher
  machen als es ist. :D
- "SRPDeferredGBuffer" & "SRPDeferredGBufferVisualisation": Die lineare Tiefe im View-Space wird nun direkt so gespeichert ohne das vorher zu
  normalisieren -> In "SRPDeferredSSAO" wird die 3D-Position recht einfach rekonsturiert. "SRPDeferredGBufferVisualisation" Normalisiert das dann
  damit man was sehen kann. :)
- Die einzelnden Deferred Rendering Komponenten sind nun in "DeferredRendering.sr" eingetragen. "SRPDeferredRendering" entfernt.
- Neue Funktion "SceneRendererPass::GetFirstInstanceOfSceneRendererPassClass()" (ja, wieder superlanger Name *g*)
- "SRPDeferredSSAO" in "SRPDeferredHorizonBasedSSAO" umbenannt und von abstrakter Basisklasse "SRPDeferredSSAO" abgeleitet (es gibt die verschiedensten Ansätze
  für SSAO)



>> 18.03.2010
[CO]
- SRPDeferredRendering & DeferredRenderingGBufferVisualisation: Albedo wird rausgeschrieben und kann visualisiert werden
- SRPDeferredRendering & DeferredRenderingGBufferVisualisation: Normal Vektor (View Space) wird rausgeschrieben und kann visualisiert werden
- SRPDeferredRendering & DeferredRenderingGBufferVisualisation: Lineare Tiefe (View Space) wird rausgeschrieben und kann visualisiert werden
- SRPDeferredRendering & DeferredRenderingGBufferVisualisation: 3-Komponent Normal Vektoren werden nun über das in
    http://aras-p.info/texts/CompactNormalStorage.html#intro - "Method #5: Cry Engine 3"
  beschriebene Verfahren im GBuffer als 2-Komponent Normal Vektoren gespeichert, und später wieder in 3-Komponent Normal Vektoren zurückgerechnet.
- SRPDeferredRendering: Die Alpha-Komponente von RT0 erhält nun den Alpha Wert aus DiffuseMap, dadurch wird Alpha Test möglich. Dies bedeutet aber
  gleichzeitig das im Grunde diese Komponente *praktisch gesehen* im GBuffer unbenutzt bleibt. Es können natürlich Alpha Werte drinnen stehen,
  aber nur wenn diese durch den Alpha Test nicht vorher verworfen wurden.
- SRPDeferredRendering & DeferredRenderingGBufferVisualisation: Specular Color und Specular Exponent wird rausgeschrieben und kann visualisiert werden
- "SNCamera::GetViewportCorners()" weiteren Parameter hinzugefügt... bis jetzt wurde intern fest "m_fZNear" verwendet. Für Deferred Rendering
  kann man diese Funktion aber für die Rekonstruktion einer 3D Position ebenfalls gebrauchen, daher sollte die *Tiefe* frei Einstellbar sein.
- Der erste Anlauf mit DeferredRenderingSSAO läuft nun, sieht zwar noch nicht wirklich schick aus - aber es läuft. Morgen werd ich wohl nochmal viel
  über SSAO Recherieren und viel Experimentieren damit das halbwechs nett aussieht.



>> 17.03.2010
[CO]
- Deferred Rendering angefangen. Das gesamte Scene Rendering findet in SRPDeferredRendering statt, so passt das gut in die bisherige Rendering
  Pipeline und man wird weiterhin beispielsweise Wireframe oder Icons *drüberrendern* können. SRPDeferredRendering hingegen unterteilt sich
  in weitere Subkomponenten. In der Dokumentation "PLDeferredRendering" werde ich parallel festhalten wie ich was gemacht habe bzw. für
  welche Algorithmen und Vorgehensweisen ich mich entschieden habe. (ohne soetwas könnte die Übersichtlichkeit schnell weg sein :)
- DeferredRenderingGBuffer stellt den GBuffer da und wurde auf Basis von SRPShaderAmbientMeshes erstellt. Hier werde ich ebenfalls wieder sogenannte
  Über-Shader nutzen (ifdef) damit das Füllen des GBuffers möglichst Effizient ist und die Performance von der komplexität des jeweils aktuellen
  Materials abhängt.
- DeferredRenderingLighting wird sich um die Beleuchtung und das Zusammenstellen eines "Sichtbaren Bildes" anhand der GBuffer-Daten kümmern
- DeferredRenderingGBufferVisualisation dient dazu GBuffer Inhalte zu Visualisieren, so kann man sich hierüber bespielsweise die gespeicherten
  Normalen-Vektoren anzeigen lassen. *lustig bundes Bild*
  Das hätte man auch direkt in DeferredRenderingGBuffer miteinbauen können, aber ich denke diese Klasse wird auch ohne das umfangreich genug werden.



>> 15.03.2010
[CO]
- "RenderApplication::NotifyClose()" ist eigentlich unnötig und die Einstellungen des Hauptfensters sollte man dort schon gar nicht wegspeichern
  da es nicht garantiert ist das man hier landed. In "RenderApplication::NotifyDestroy()" landed man andererseits immer, daher werden nun hier
  wichtige Einstellungen weggespeichert - bevor dann ab hier damit begonnen wird die Komponenten "herunterzufahren".
- "RenderApplication::OnDeInit()" zerstört nun das Hauptfenster bevor es weitergeht. Das Hauptfenster ist mit dem Renderer Context verbunden,
  daher ist es wichtig das man die Komponenten in einer vermümptigen Reihenfolge abbaut. Wenn "RenderApplication::NotifyDestroy()" aufgerufen
  wird, existiert also im allgemeinen der Render Context noch und daher kann man von hier aus sich dann auch noch wichtige Renderer Betreffende
  Dinge wegspeichern, und z.B. auch noch korrekt ermitteln ob das Fenster im Vollbild Modus war. Ist der Renderer Context weg, kommt man nicht
  mehr an diese Vollbild-Information da "SurfaceWindow" dann bereits weg ist das diese Informationen verwaltet. Der Trick ist es also immer
  vernümpftige Aufbau- und Abbau-Reihenfolgen einzuhalten.



>> 14.03.2010
[CO]
- An die Änderungen des Konfigurations-Systems angepasst. An einigen Stellen nutze ich momentan "PLCore::Application::GetApplication()",
  dies sollte aber bei Zeiten raus da die einzelnen System-Komponenten nichts mit "Application" zu tun haben sollten. (es wäre zuviel gewesen
  direkt bei diesem Refactoring-Schritt *alles* mitzumachen)
- "Config" aus "PLRenderer" nach "PLEngine" verschoben und in "RendererConfigGroup" umbenannt
- "RenderApplication": Neue Virtuelle-Methode: "OnDisplayMode()"
- "RenderApplication::OnCreateRendererContext()" nutzt nun die in der Konfiguration eingestellte Grafik-API
- "TextureQuality", "TextureMipmaps" und "TextureCompression" liegen nun in "PLEngine::RendererConfig" statt wie vorher in "PLMesh::MeshConfig"



>> 14.09.2009
[CO]
- "SRPShaderLightShafts" ist nun endlich wieder soweit lauffähig. Ein kleiner Texture Projection fehler ist noch
  drinnen - aber wenigstens sieht man nun wieder was. :D
- Die Shader von "SRPShaderLightShafts" liegen nun nicht mehr in "Standard.zip" sondern werden direkt mit in den
  Code eingebunden



>> 13.09.2009
[CO]
- "SNMBillboardCylindrical" & "SNMBillboardSpherical": Die Scene Node rotation hat nun wieder wie früher eine
  auswirkung auf Billboards (damit kann man z.B. leicht schräge Lichtstrahlen realisieren wie das im Dungeon der
  Fall ist :)



>> 12.09.2009
[CO]
- "SNTerrain::LoadHeightMap()" an PLGraphics angepasst



>> 22.08.2009
[CO]
- SNCamera: Fügte einen "View Rotation Offset" hinzu damit eine Kamera in eine Richtung rotiert sein kann, aber
  tatsächlich über den View in eine andere Richtung "schaut". Dieser Offset kann z.B. von einem Head Tracker System
  angesteuert werden.



>> 14.08.2009
[CO]
- "BasicSceneApplication": "SetCamera()" ist nun virtuell da abgeleitete Klassen bisher oft noch eine spezielle
  Interaktions-Klasse besitzen die ebenfalls eine aktuelle Kamera benötigt - und wenn man hier die Kamera nicht
  immer ebenfalls setzte ging einiges nicht. Daher nun am besten gleich virtuell damit abgeleitete Klassen die
  aktuelle Kamera auch in weiteren Anwendungs abhängigen Komponenten setzen können.



>> 02.08.2009
[CO]
- Neuer Scene Query "SQByName": Listet alle Scene Nodes auf deren Name einem gegebenen Regulären Ausdruck
  entsprechen
- Neuer Scene Query "SQByClassName": Listet alle Scene Nodes auf deren Klassen Name einem gegebenen Regulären
  Ausdruck entsprechen
- "SQEnumerate" berücksichtigt keine Zellen Portale mehr, das macht wie ich finde nicht wirklich viel Sinn da
  es sich hier eher um eine Anfrage auf den Scene Graph handelt und um keine Räumliche Anfrage
- "SNParticleGroup": Flag "SceneNodeSpaceParticles" hinzugefügt da es bei einigen Partikel Effekten besser ist
  wenn diese rein im Scene Node Space positioniert werden (z.B. bei PLParticleGroups::PGImage)



>> 31.07.2009
[CO]
- "SceneNode::GetAbsoluteName()" so abgeändert das vorne immer "Root" steht und nicht der Name des Root Scene
  Containers... also so wie es im Methoden Kommentar schon beschrieben wurde...



>> 07.07.2009
[CO]
- "BasicSceneApplication::GetScreenshotFilename()": "sFileFormat" wurde nicht verwendet so das immer als "tga"
  gespeichert wurde. Standardformat hier ist nun "png" da dieses trotz stellenweise sehr guter Komprimierung
  verlustlos komprimiert. (verwendet dazu prädiktion & deflate)
- "BasicSceneApplication::SaveScreenshot()": Beide gleichnamigen Funktionen verhalten sich nun bei "sFilename"
  identsich



>> 08.06.2009
[CO]
- "SRPShaderAmbientMeshes::DrawRec()" & "SRPShaderLightingMeshes::RenderLightRec()": Hier war ein dummer Bug bei
  "TwoSided" drinnen so das dieser Zustand nicht korrekt funktionierte wenn ein Mesh aus mehreren Geometrien mit
  dem gleichen Material bestand.



>> 28.05.2009
[CO]
- PLEngine: "SRPShaderAmbientMeshes": Glühen für Transparente Dinge hinzugefügt. Transparente Dinge die nicht glühen
  werden mit deaktivierten Alpha Kanal schreiben gezeichnet - also wie gehabt. Transparente Dinge die glühen werden
  mit Alpha Kanal schreiben gezeichnet.



>> 21.05.2009
[CO]
- "SNText" in "SNText2D" umbenannt und von neuer Abstrakten Basisklasse "SNText" abgeleitet
- "SNText3D" hinzugefügt mit dessen hilfe man "flachen 3D Text" frei in der Szene platzieren kann... darüber kann
  man z.B. einfache Texte an Info Tafeln machen. Hängt man an den Text einen z.B. "SNMBillboardSpherical" Scene
  Node Modifier, so bekommt man einen Text der immer "in die Kamera schaut" aber trotzdem ein 3D Objekt mit z-buffer
  Test ist und "kleiner" wird wenn man sich räumlich davon entfernt.
- "SNText3D" hat immer eine räumliche Höhe von 1 und ist somit unabhängig von der "Schrift größe" die hier nur die
  "Schrift Qualität" definiert. Wäre das anderst, wäre es recht schwer 3D Text immer korrekt in der Szene zu plazieren
  und die "Scene Node Skalierung" korrekt zu nutzen wie bei jeder anderen Scene Node auch.
- "SNText3D" lässt sich nun auch mit einem netten Hintergrund unterlegen. Bei "SNText2D" hab ich das derzeit nicht
  eingebaut da man statt "SNText2D" auch das richtige "GUI" nutzen kann und sollte um mehr Kontrolle zu haben.
- "SNLine": Ob die Linie transparent gezeichnet wird sollte vom Alpha Wert in der Fabe abhängen und nicht davon ob
  z-buffer Test an oder aus ist. Das gleiche in "SNLineBox".



>> 20.05.2009
[CO]
- Billboard Scene Nodes "SNBillboard", "SNBillboardCylindrical" und "SNBillboardSpherical" entfernt. "Billboard"
  ist zukünftig ein Scene Node Modifier. ("SNMBillboard", "SNMBillboardCylindrical" und "SNMBillboardSpherical")
  Dies hat den Vorteil das man verschiedene Dinge, z.B. auch in einer 3D Szene frei platzierten Text zum Billboard
  machen kann ohne das sich komplizierte Ableitungshierarchien ergeben und man "Billboard" für alle möglichen
  Scene Node Typen immer wieder neu implementieren muss.
    SNMBillboard
    -> SNMBillboardCylindrical
    -> SNMBillboardSpherical
  Die Billboard Scene Node Modifier sind derzeit so realisiert das diese auf bestimmte Draw-Events hören und dann
  die aktuelle World-Matrix ändern. Das funktioniert so allerdings derzeit noch nicht für z.B. Meshes... da die
  Scene Renderer hier noch keine Events abfeuern + im Zusammenspiel mit Shadern wird es etwas Tricky. Hier muss ich
  noch ein wenig Üblerlegen bis ich was finde das für alles geht. Aber auf jedenfall geht derzeit soviel wie
  "vorher" und insgesammt finde ich die Lösung über Scene Node Modifier sehr nett da vielseitig Einsetzbar.
- "SNBitmap" in "SNBitmap2D" umbenannt und von neuer Abstrakten Basisklasse "SNBitmap" abgeleitet
- "SNBitmap3D" hinzugefügt das im Grunde nur ein Rechteck im Raum ist und eine räumliche Ausdehnung von 1 hat -
  ACHTUNG, die alten Billboards hatten eine räumliche Ausdehnung von 2!
    SNBitmap
    -> SNBitmap2D (per Default 2D Position, kann auf Wunsch aber auch auf 3D position, "größe" immer gleich)
    -> SNBitmap3D (nur 3D position, "größe" Sichtabhängig)
-> Um das zu erreichen was früher "SNBillboardSpherical" machte kann man nun in einer Szene z.B. folgendes tun:
    <Node Class="SNBitmap3D">
        <Modifier Class="SNMBillboardSpherical" />
    </Node>
   Ist natürlich etwas mehr Schreibaufwand, aber um einiges Universeller. So kann man über "SNBitmap3D" z.B. lustig
   flache 2D Bäume in die 3D Szene setzen. Oder mit "SNMBillboardSpherical" sogar ein 3D Mesh immer in die Kamera
   schaun lassen. :)
   Ich habe das alles auch im zusammenspiel mit verschachtelten Scene Containern mit unterschiedlichen
   Transformationen getestet und ging alles.



>> 12.05.2009
[CO]
- "SNSpotLight" ist nun von "SNPointLight" abgeleitet. Das sieht so für mich einfach "natürlicher" aus und macht
  einem das Leben an ein paar Stellen etwas einfacher da ein "Spot Light" nur eine etwas erweiterte Variante eines
  "Point Light" ist.



>> 07.05.2009
[CO]
- "SRPShaderDepthMeshes": Die hier genutzten Shader kommen nun nicht mehr aus "Standard.zip" sondern liegen direkt
  in "PLEngine.dll"



>> 06.05.2009
[CO]
- "SNMMeshJoint" ändert direkt Skeleton Werte und der Mesh Handler bekommt davon natürlich nix mit und weis nicht
  das das Mesh nun aktualisiert werden muss. Daher wird nun "MeshHandler::MeshUpdateRequired()" aufgerufen wo
  nötig.



>> 28.04.2009
[CO]
- "SNMMeshMorph": Änderte den Default Wert von "Weight" von "1.0" auf "0.0"... "1.0" ist einfach ein total
  unpraktischer Wert da dadurch ein "Mesh Update" (demnächst) erzwungen wird sobald "SNMMeshMorph" angehängt wird
  was definitiv nicht gut ist.



>> 27.04.2009
[CO]
- "BasicSceneApplication::LoadScene()": Hier sollte man wirklich nach dem zerstören der alten und vor dem Laden der neuen
  Szene dem Scene Context die möglichkeit geben "klar Schiff zu machen". Wird dies nicht getan kann es z.B. zu Namenskonflikten
  mit dynamisch erzeugten Resourcen kommen... in einem Projekt war dies der Fall: Es gab bereits eine Dynamische Texture mit einem
  bestimmten Namen, die Szene wurde erneut geladen und danach war die Texture "weis" (Material Thematik :) was daran lag das die
  neue Dynamische Texture "<name>_0" hies da "<name>" bereits belegt war - und zwar von der alten Szene.
  Die Problematik "Resourcen der alten Szene entladen", "neue Szene hat gleiche Resourcen und es muss nochmal alles neu geladen werden"
  muss auf einer anderen Ebene stattfinden - z.B. durch ein Intelligentes Resourcen Cache-Management innerhalb der Resourcen Manager.



>> 26.04.2009
[CO]
- "RenderApplication" von PLRenderer nach PLEngine verschoben
- "SRPShaderVolumetricFogMeshes" & "ShadowMapManager": Die hier genutzten Shader kommen nun nicht mehr aus
  "Standard.zip" sondern liegen direkt in "PLEngine.dll"
- "SCStaticCamera" aus PLEngine entfernt da dies schon seit langem nicht mehr korrekt läuft und im Grunde komplett
  überdacht werden müsste. Da diese Funktionalität allerdings nicht wirklich wichtig ist hab ich das erstmal komplett
  raus... besser als "Leichen" im Projekt zu haben. :D



>> 15.04.2009
[CO]
- "SRPShaderAmbientMeshes" & "SRPShaderLightingMeshes": Die meisten hier genutzten Shader kommen nun nicht mehr aus
  "Standard.zip" sondern liegen direkt in "PLEngine.dll". Das wollte ich nun schon seit einer ganzen weile mal ausprobieren
  da die Shader hier im grunde 'nur' für diesen Scene Renderer Schritt auf die GPU ausgelagerter Code darstellen der NUR
  in diesem Scene Renderer Schritt vernümpftig genutzt werden können. Funktioniert sehr gut und die Realisierung ist denke
  ich auch nicht soo grausam, nur auf Syntax Highlighting muss man hier nun verzichten.
- "SceneNode::Delete()" hatte ich bei der "SceneContainer" umstellung sehr ungeschickt angepasst... denn sobald man eine
  "SceneNode" von "SceneContainer" entfernt gibt "GetSceneContext()" NULL zurück und dann wurde eine "SceneNode" IMMER
  sofort gelöscht wodurch man leider schnell in Teufelsküche kommt. :/



>> 10.04.2009
[CO]
- "SceneNode": "m_sIcon" bekommt nun immer standardmäßig einen statischen String zugewiesen... das geht einfach flotter



>> 02.04.2009
[CO]
- Neue "Picking::PerformPicking"-Variante die Picking nur innernalb einer gegeben Scene Node macht
  (*Mesh Picking*)
- "Picking::PerformPicking" für Scene Nodes um weiteren optionalen Parameter erweitert über den man
  bestimmen kann welche Geometrien berücksichtigt werden sollen



>> 27.03.2009
[CO]
- "SceneContext" hat nun auch eine "MeshManager"-Instanz



>> 25.03.2009
[CO]
- "GuiPL" bekommt im Konstruktor nun eine "RendererContext"-Instanz, "FontPL" und "ImagePL" wissen nun zu welchen "GuiPL"
  diese gehören und kommen darüber an den "RendererContext"
- "PostProcessManager" muss man nun im Konstruktor den zu nutzenden "RendererContext" übergeben
- Die Uralt Klasse "PL" endlich entfernt :D
- "SNMMouseLookController" & "SNMMouseOrbitingController" & "SNMMoveController": SpaceMouse berücksichtigte noch kein
  'Achsen vertauschen'



>> 18.03.2009
[CO]
- "SceneGraph" in "SceneContext" umbenannt, diese Klasse wird nun schrittweise Umgeformt...
- "SceneContext" ist kein Singleton mehr, dem Konstruktor muss man einen "RendererContext" übergeben. Ein "SceneGraph" sammt
  seiner Daten ist also "RendererContext" abhängig - das stimmt zwar nicht für die Basis-Klassen, aber in den abgeleiteten
  Klassen hat man oft Referenzen auf Meshes, Texturen etc. und wollte man das hier "RendererContext" unabhängig machen würde
  das ziemlich unhandlich und chaotisch werden. Das mag zwar eine "Einschränkung" sein, in der Praxis sollte das allerdings
  nicht schlimm ins Gewicht fallen und löst viele Design-Probleme. ("PL::GetRendererContext()" etc.)
- "SceneApplication" hat nun eine eigene Instanz von "SceneContext"
- "SceneContainer" weis nun zu welchem "SceneContext" es gehört, "SceneNode" hat ein "GetSceneContext()" dazu bekommen
- "SceneHierarchy", "SceneHierarchyNode" und "SceneQuery" um "GetSceneContext()" erweitert damit man nicht selbst per Hand
  sich da ranhangeln muss (wäre zwar möglich, aber auf dauer einfach nur lästig)
- "ShadowMapManager" ist kein Singleton mehr, "SceneContext" hat eine "ShadowMapManager"-Instanz. "Initialize()" entfernt,
  der zu nutzende Renderer muss nun im Konstruktor übergeben werden. "DeInitialize()" entfernt.
- "SceneRendererManager" um "GetSceneContext()" erweitert
- "SceneRendererPass" um "GetSceneContext()" und "GetRenderer()" erweitert
- "VisManager" ist kein Singleton mehr, "SceneContext" hat eine "VisManager"-Instanz.



>> 13.03.2009
[CO]
- "SNMesh": Läd nun standardmäßig Meshes nicht mehr wenn die Scene Node beim start unsichtbar ist. Über das neue Flag "LoadAtOnce"
  kann man allerdings erzwingen. Sobabld "GetMeshHandler()" aufgerufen wird, wird das Mesh automatisch geladen. Das "müsste"
  keine Probleme machen solange man nicht umbedingt die richtige Scene Node Bounding Box auch für unsichtbare Scene Nodes braucht
  die standardmäßig aus dem Mesh ermittelt wird... daher ist es empfehlenswert das die Bounding Box direkt mit in der Szene steht.
  (der 3ds Max Exporter macht das derzeit nicht mehr, kommt aber wieder)



>> 12.03.2009
[CO]
- "SPScene::OnPaint()" setzte nicht in allen Fällen den sehr unschönen 'Globalen Zeiger auf gerade aktive Kamera', und schon gabs Probleme
  mit Post Processing und RenderToTexture. Das hier ist nur ein weiteres 'Pflaster', das muss alles nochmal sauber überarbeitet werden.
  (sollte nicht ZU schwer werden da man nun weis wie was wo :)



>> 08.03.2009
[CO]
- "SCRenderToTexture": Neben "NoRecursion" ist nun auch "NoCulling" standardmäßig gesetzt ("sicherer" als Default-Einstellung)
- Die Scene Node Modifier Implementationen berücksichtigen nun endlich wieder den "Active"-Zustand. Dies hab ich nun so realisiert das
  Event Handler "Disconnected" werden sobald ein Scene Node Modifier inaktiv wird und beim Aktive werden sich wieder "Connecten".



>> 01.03.2009
[CO]
- "SNMPostProcess": Neue virtuelle Funktion "SetParameters()": Statt in "VarChanged()" sollte man nun immer die Post Process Parameter in
  dieser neuen virtuellen Funktion setzen. Diese Funktion wird dann von "SRPPostProcessing::Draw()" aufgerufen damit der Post Process mit
  den im Modifier eingestellten Werten Arbeitet.



>> 28.02.2009
[CO]
- "SNMPostProcessGlow": Upsala, es gibt keinen Parameter namens "GlowScale" sondern der muss "BloomScale" heißen



>> 21.02.2009
[CO]
- 'SNCamera::GetProjectionMatrix()' muss man nun einen Viewport übergeben damit das getrennt von aktuellen Renderer Einstellungen ist,
  gleiches bei 'SNCamera::GetFrustum()' und 'SNCamera::GetFrustumVertices()'. Ganz prall find ich das momentan noch nicht, ist aber schonmal
  ein Stück besser als vorher.



>> 19.02.2009
[CO]
- 'SRPShaderAmbientMeshes': Es werden nur noch 'Glow' Material Parameter berücksichtigt wenn gerade der Glow
  Post Process aktiv ist
- 'SRPShaderAmbientMeshes': Glow geht nun auch zusammen mit Alpha-Test, ähliche realisierung wie bei DOF
- 'SRPShaderAmbientMeshes::GetVertexShader()' muss auch wissen ob gerade ein Alpha Test gemacht werden soll...
  denn dann darf NIE die Diffuse Map einfach so ignoriert werden



>> 18.02.2009
[CO]
- 'PickingResult': 'GetWrappedTextureCoordinate()' hinzugefügt das immer Texture Koordinaten zurückgibt die im
  0..1 Intervall liegen



>> 16.02.2009
[CO]
- 'MousePicking': Hört nun auf 'EventDestroy' vom Fenster und Kamera und setzt die Zeiger intern wenn nötig
  auf NULL... sonst kommt man schnell in Teufelsküche...



>> 12.02.2009
[SB]
- GraphicsPL: DrawTiledImage() um Flags erweitert, über die z.B. nur in X oder Y Richtung gekachelt werden kann. Das habe ich
  hier recht übel eingehackt, so dass in eine Richtung gekachelt werden kann und in der anderen immer das gesamte Bild auf die
  angegebene Größe gestreckt wird. Nur so kann man mit den gleichen Draw-Aufrufen sowohl mit also auch ohne Rectangle-Texturen
  das gleiche Ergebnis erzielen (ansonsten wird z.B. in eine Richtung gekachelt, was gar nicht gewünscht ist, weil die Größe
  anders ist als in der ursprünglichen Rectangle-Textur).



>> 10.02.2009
[CO]
- Für 'Picking' eigene Klassen geschrieben:
  - 'Picking'-Klasse bietet im Grunde nur 'PerformPicking()' an um einen 'Raycast/Traceline' auf die Szene auszuführen
  - 'PickingResult'-Klasse speichert 'PerformPicking()'-Ergebnisse so das man im Nachhinein recht einfach an 'alle'
    Picking Daten kommt + weitere Hilfsfunktionen wie z.B. 'GetTextureCoordinate()' um die getroffene Texture
    Koordinate zu ermitteln.
  - 'MousePicking'-Klasse für 'Maus Picking'



>> 09.02.2009
[CO]
- 'SNClear' um Flags erweitert damit man auch nur bestimmte Komponenten des Framebuffers löschen kann



>> 08.02.2009
[CO]
- Interfaces diverser Scene Node Modifier erweitert



>> 07.02.2009
[CO]
- 'SNMCameraZoom' Scene Node Modifier hinzugefügt da man diese Funktionalität schon in 2 Projekten nutzt (was wohl heist das es wohl noch
  häufiger gebraucht wird :)



>> 04.02.2009
[CO]
- Neuer Post Process Scene Node Modifier 'SNMPostProcessGlow' direkt in PLEngine da mit 'SRPShaderAmbientMeshes' 'verdrahtet'. Dieser
  Effekt ist fast identisch mit 'PLPostProcessEffects::SNMPostProcessBloom', nur das im speziellen 'BrightPass.cg' noch die RGB-Farbe mit
  dem Wert im Alpha Kanal multipliziert wird damit nicht 'glühende' Dinge schwarz werden.
- 'SRPShaderAmbientMeshes' kennt neuen 'Glow' Material Parameter und muss sich um das korrekte füllen des Alpha Kanals kümmern...
  erstaunlicherweise funktionierte meine Idee wie ich diesen Effekt möglichst einfach einbauen kann auf anhieb... brrr...
- 'SRPShaderAmbientMeshes' kennt neuen 'GlowMap' Material Parameter -> damit kann man wenn nötig noch Einstellen wo was wie stark 'Glüht'



>> 03.02.2009
[CO]
- 'SNMOrbiting': 'Pan'-Variable hinzugefügt, 'SNMMouseOrbitingController' ändert nun zum Panning diese neue Variable
  anstatt 'Offset'



>> 01.02.2009
[CO]
- 'SNMesh': 'DebugShowTangents' & 'DebugShowBinormals' & 'DebugShowNormals' umsortiert damit es x/y/z=u/v/w=rot/grün/blau entspricht was
  recht gängig zu sein scheint (und sich auch leicht merken lässt :D)



>> 31.01.2009
[CO]
- Wie von Stefan vorgeschlagen gibt "SceneContainer::Get("")" nun nicht mehr 'die aktuelle Scene Node' zurück sondern 'NULL'. Will man
  'die aktuelle Scene Node' haben muss man nun "SceneContainer::Get("This")" schreiben - ich suchte nach Stellen die angepasst werden müssen,
  fand aber praktisch keine und ich wüsste auch nicht wann ich 'Get("")' bewusst eingesetzt hätte. (ist ja auch eher nur zur 'Vollständigkeit'
  da und hat in der Praxis meist weniger Anwendung :)



>> 26.01.2009
[CO]
- Tiefenunschärfe scheint nun auch auf NVIDIA Karten gut zu funktionieren... dazu musste ich den 'Alpha Reference'
  Wert allerdings auf einen viel größeren Wert stellen da NVIDIA Karten scheinbar weniger Genauigkeit für den Wert
  haben.
- 'PostProcessor::DrawResult()': Den Hack der die Grafikfehler an Rändern vertuschen soll erstmal wieder rausgenommen
  da man dann als Seiteneffekt ein leicht verschobenes Bild hat was dann natürlich zu 'Picking-Fehler' führt. Da muss
  ich mir wohl was anderes Einfallen lassen...



>> 25.01.2009
[CO]
- SceneApplication: Der Debug Modus ist standardmäßig aktiviert damit Entwickler gleich von Anfang an soviel Support wie möglich bekommen
- 'GraphicsPL::Print()': Zentrierung wurde beim Text Hintergrund noch nicht berücksichtigt
- 'PLEngine::SNMAnchor::NotifyPositionRotationUpdate()' unterstützt nun auch Nodes in verschiedenen Containern



>> 24.01.2009
[CO]
- Scene Renderer: Strukturierte die Codes für dynamische Shader erzeugung nochmal neu damit das überschauberer wird
- SNLoadScreen: Ist nur ein Bild vorhanden, so ist dieses bereits nach 10% Ladefortschritt voll sichtbar
- 'SceneApplication::SetDebugModeEnabled()': Stellt nun auch das Log entsprechend ein
- 'EngineGeneralConfig' -> 'DebugMode' entfernt, das macht man nun besser über 'SceneApplication::SetDebugModeEnabled()'
- 'SNMPositionKeyframeAnimation' & 'SNMRotationKeyframeAnimation' & 'SNMScaleKeyframeAnimation' nutzen nun komplett die neue
  'PLGeneral::Chunk'-Klasse um die Daten intern zu halten



>> 23.01.2009
[CO]
- 'GuiPL::CheckMouseIn()': Hier war noch ein ziemlich doofer Bug - es wurde nur die sichtbarkeit von Fenstern
  geprüft, aber nicht ob deren Parents und deren Parents etc. ebenfalls sichtbar sind.



>> 23.01.2009
[SB]
- ExtendedSceneApplication: m_pSceneContainer in m_pPickSceneContainer umbenannt. Da man letztlich seine eigene
  Applikation von ExtendedSceneApplication ableitet, sollten die Namen aller Member möglichst eindeutig sein.
  Wenn z.B. ein Programmierer in seiner eigenen Klasse nach der aktuell geladenen Szene sucht, wird er dabei
  auf m_pSceneContainer stoßen und sich dann wundern, dass dies die falsche Variable ist (man sieht es am
  Kommentar und daran, dass die Variable private ist, aber das ist alles mit unnötiger Verwirrung verbunden).
  Daher habe ich das umbenannt, damit keine Verwechslungsgefahr mehr mit m_cSceneContainerHandler besteht.



>> 22.01.2009
[CO]
- 'SNMRotationKeyframeAnimation': Hier werden nun 'alle' Quaternion komponenten gespeichert da das errechnen
  der letzten Komponente nicht in 100% der Fälle 100% korrekt funktioniert.
- 'SNMPositionKeyframeAnimation' & 'SNMRotationKeyframeAnimation' & 'SNMScaleKeyframeAnimation' nutzen nun die neue
  'PLGeneral::Chunk'-Klasse um die (sehr schnell sehr viele!) Keys möglichst schnell einladen zu können.



>> 21.01.2009
[CO]
- SceneNode: 'GetCommonParent()' in 'GetCommonContainer()' umbenannt
- SceneNode: 'GetRootNode()' in 'GetRootContainer()' umbenannt. Diese Funktion gibt nun einen Zeiger statt eine Referenz zurück da
  es zukünftig wohl möglich sein wird das eine Scene Node in keinem Scene Container ist. (im Augenblick noch unmöglich was ich eigentlich
  recht nett finde)



>> 19.01.2009
[CO]
- 'SNMRotationKeyframeAnimation' speichert nun x & y & z komponenten von rotations Quaternions (w-komponente kann man einfach errechnen :)...
  keine Ahnung was ich mir damals dabei dachte hier Euler Winkel (ich denke da man/ich das besser lesen kann *g*) zu speichern, soetwas macht
  einfach nur Probleme - gerade bei Animationen!



>> 18.01.2009
[CO]
- 'SRPShaderAmbientMeshes::DrawRec()': 'EyePos' wurde nicht korrekt berechnet
- 'ShadowMapManager::RenderDistanceRec()': Schatten nutzen nun die gleiche Cull Mode wie der Rest



>> 12.01.2009
[CO]
- 'SNMPositionPath': 'GetGraphPath()' hinzugefügt



>> 11.01.2009
[CO]
- 'SceneContainer::GetTransformMatrixTo()': Multiplikations-Reihenfolge der Matrizen war nicht ok was zu fehlerhaften Ergebnissen führen
  konnte. Baute desweiteren einen Test ein falls man von 'diesen Container in diesen gleichen Container' will + ein Abbruchkriterium falls
  'dieser Container' nur ein einfaches Kind des 'anderen Container' ist. (Performance optimierung)
- 'ExtendedSceneApplication::PerformPicking()': Stellt nun sicher das die 'maximum' Entfernung unter keinen Umständen überschritten wird



>> 09.01.2009
[CO]
- 'ImagePL::SystemLoadImage()': 'Image.plfx' entfernt, 'Image'-Materialien haben nun also standardmäßig keinen
  Effekt so das die GUI komplett selbst zu entscheiden hat welche Renderer Einstellungen zu nutzen sind.
  (also 'Parameter'-Ansatz wie bei unseren Scene Renderern)
- 'GraphicsPL::DrawImage()': Hier gibts nun zwei Fälle:
  - Ein Material hat einen speziellen Effekt -> Der Benutzer hat volle kontrolle über die Renderer Einstellungen
  - Ein Material hat keinen speziellen Effekt -> Es werden default Renderer Einstellungen genommen + es wird nach
   'DiffuseMap' im Material gesucht und als Textur verwendet... sobald diese Texture einen Alpha Kanal hat wird
   automatisch 'Blend' aktiviert... oder generell Alpha Blending wenn das im GUI gerade aktiv ist.
- 'ExtendedSceneApplication': 'PerformMousePicking()' kann man nun eine maximum Picking Entfernung mitgeben



>> 07.01.2009
[CO]
- BasicSceneApplication::SetCamera(): Es wird nun automatisch die aktuelle Kamera 'eingefrohren' und die neue
  Kamera wird 'aufgetaut'. Desweiteren wird auch die Kamera im Scene Painter gesetzt. Das müsste die Nutzung
  der Application Klasse nochmal etwas vereinfachen.



>> 07.01.2009
[SB]
- 'BasicSceneApplication::MakeScreenshotFilenameRecommendation()' in 'BasicSceneApplication::GetScreenshotFilename()' umbenannt.
  Bitte wirklich mal auf dieses wahnsinnigen Namen verzichten - sowas macht es nicht einfacher, sondern schwieriger für den User.
- 'BasicSceneApplication::SaveScreenshot()' kann nun auch ohne Namen aufgerufen werden, dann wird selbständig ein neuer Dateiname
  ausgewählt. Dies ist wohl das, was man meistens haben will.



>> 03.01.2009
[CO]
- 'SRPShaderAmbientMeshes' & 'SRPBasicLightingTransparentMeshes' & 'SRPBasicTransparentMeshes' kennen neue Material-Parameter:
  'SrcBlendFunc' & 'DstBlendFunc' -> Wenn 'Opacity' kleiner als '1' ist kann man hierüber die Blend-Funktionen einstellen.
- 'SRPShaderAmbientMeshes' & 'SRPBasicLightingTransparentMeshes' & 'SRPBasicTransparentMeshes': Für Transparente Materialien den
  Alpha Test deaktiviert da dies dann meist sehr merkwürdig aussah



>> 01.01.2009
[CO]
- SNMesh: 'DeInitFunction()' sollte natürlich Implementiert sein da die virtuelle 'MeshDeInitFunction()'-Funktion vom SNMesh Desktruktor aus
  nicht mehr in abgeleitete Klassen gehen kann.
- 'BasicSceneApplication::SaveScreenshot()' in 'BasicSceneApplication::MakeScreenshotFilenameRecommendation()' umbenannt... diese Funktion
  macht 'nur' einen Vorschlag für einen passenden Screenshot Dateinamen
- 'BasicSceneApplication::SaveScreenshotAs()' in 'BasicSceneApplication::SaveScreenshot()' umbenannt
- Eine zweite 'BasicSceneApplication::SaveScreenshot()'-Funktion hinzugefügt... diese Rendert nochmals in ein neues Render Target wodurch
  man Screenshots von 'prinzipiell' beliebiger größe Anfertigen kann - 'praktisch' nur durch die Hardware eingeschränkt... maximale
  Rectangle Texture größe... hab hier gerade bis zu 8192x8192 große Screenshots gemacht, das reicht denk ich für viele Fälle gerade so aus. *g*



>> 31.12.2008
[CO]
- 'SNMOrbiting': 'GetDistance()' ruft intern nun 'NotifyPositionRotationUpdate()' auf wenn die Entfernung noch nicht berechnet wurde



>> 30.12.2008
[CO]
- 'ExtendedSceneApplication' um einige weitere Picking-Funktionen erweitert
- 'ExtendedSceneApplication::NotifySceneNode()' Implementation weiter Performance-Optimiert: Bevor der Aufwändige Dreiecks-Test gemacht wird
   teste ich nun die Entfernung zum Scene Node Bounding Box Schnittpunkt gegen die aktuelle nahste Entfernung... wenn sich hier herausstellt
   das schon der Schnittpunkt zur Bounding Box weiter weg ist als das bisher am nähesten gefundene können wir davon ausgehen das keines der
   Dreicke näher ist und daher können wir dann den kompletten Aufwändigen Test überspringen. Im 'Schiffsbrücke'-Projekt hab ich durch diesen
   kleinen Trick nun in meinem Testfall 116 FPS statt 102 FPS.
- 'ExtendedSceneApplication': Die Picking Funktionen können nun auf Wunsch auch die Entfernung zur Scene Node zurückgeben
- 'ExtendedSceneApplication::PerformMousePicking()': Wenn die Maus außerhalb des Hauptfensters ist wird kein Picking durchgeführt
- 'SceneApplication': 'IsDebugModeEnabled()' & 'SetDebugModeEnabled()' hinzugefügt -> Darüber lassen sich 'allgemeine' Debug Features
   aktivieren/deaktivieren



>> 27.12.2008
[CO]
- BasicSceneApplication: Hält nun beim Laden nach einem 'Ladebilschirm' ausschau, sobald einer gefunden wurde wird der Bildschirm regelmäßig
  aktualisiert
- 'ExtendedSceneApplication' hinzugefügt das von 'BasicSceneApplication' abgeleitet ist und komfortable Picking-Funktionalität hinzufügt...
  wollte diese Funktionalität nicht noch in 'BasicSceneApplication' mit reinstopfen da diese Klasse langsam auch etwas voller wird. Diese
  Klasse wird noch erweitert.



>> 25.12.2008
[CO]
- 'SRPShaderAmbientMeshes': 'ZWriteEnable'-Flag spendiert, üblicherweise nutzt man 'SRPShaderDepthMeshes' um den z-Buffer zu füllen -
  wenn man allerdings nicht Füllraten sondern Geometry FPS-limitiert ist, so kann es nicht schaden zu versuchen 'SRPShaderDepthMeshes'
  wegzulassen und direkt 'SRPShaderAmbientMeshes' auch in den Tiefenpuffer schreiben zu lassen - wenn man sehr komplizierte Ambient
  Berechnungen hat kann das natürlich wiederum zum Füllratenflaschenhalz werden da dann Fragmente eventuell berechnet werden nur um
  daraufhin wieder überzeichnet zu werden. *g*



>> 21.12.2008
[CO]
- 'SRPShaderAmbientMeshes::Draw()': Beim 'Transparente Dinge zeichnen'-Schritt wird NICHT in den Alpha-Kanal geschrieben da eventuel z.B.
  DOF dort seine Informationen abgelegt hat. Nun sehen Transparente Dinge bei DOF nicht mehr 'milchig' aus... hoffentlich gibt das nicht
  irgendwann an anderer Stelle dann Probleme mit bestimmten Blend-Modi...
- 'SRPShaderDepthMeshes': Wie in 'SRPShaderAmbientMeshes' ein 'TransparentPass'-Flag hinzugefügt + in 'ShaderLighting.sr' einen entsprechenden
  Render Schritt vor dem Zeichnen Transparenter Dinge eingebaut. 'SRPShaderDepthMeshes' versteht nun den neuen Material-Parameter
  'OpacityOcclusion' den man setzen kann wenn das Transparente Polygon trotzdem in den ZBuffer schreiben soll - bei einem Projekt das PixelLight
  nutzt wurde soetwas angefragt damit sich Transparente Polygone nicht 'verwirrend gegenseitig aufhellen'. *g*
- 'SRPShaderAmbientMeshes': DOF klappt nun auch problemlos mit Alpha Test zusammen... der Alpha Test findet nun im Shader statt und wenn der
  Alpha Wert einen bestimmten Wert unterschreitet wird nichts in den Framebuffer geschrieben so das im Alpha Kanal dan auch keine falschen
  DOF Werte stehen. :D (wäre das nicht so, so würde dieser Trick hier nicht funktionieren)
  Wow, hätte nie gedacht das ich das jemals korrekt hinbekommen würde - 'ein Wert', zwei Bedeutungen. *g*
  -> Alpha<AlphaReference -> festen ganz kleinen Wert rausschreiben so das die GPU für uns das Fragment 'wegwirft'
  -> Alpha>AlphaReference -> einen DOF Wert rauschreiben... da größer als AlphaReference der GPU wird das Fragment 'behalten'
- 'SNMesh::LoadSkin()'-Implementation überarbeitet



>> 15.12.2008
[SB]
- SNMMouseOrbitingController noch etwas überarbeitet:
  - Rotate, Zoom und Pan können über Flags jeweils auf die Maustasten Left/Right/Middle/None gelegt werden.
  - Für die mittlere Maustaste kann entweder die 'echte' 3. Maustaste gedrückt werden, oder die linke und rechte Maustaste zusammen.
  - PanSpeed war in der Standardeinstellung auf 0. Das ist blöd, weil man sich dann wundert, warum nichts passiert, obwohl man
    z.B. das Flag PanMiddleMouseButton hinzugefügt hat. Der Wert sollte daher im Standard auf 1.0 stehen, wenn man kein
    Panning als Standard haben will, sollte einfach das Flag weggelassen werden.
- Steuerung über den SpaceNavigator in SNMMouseLookController, SNMMoveController und SNMMouseOrbitingController eingebaut :-)



>> 14.12.2008
[CO]
- SQCull::TraverseNode(): Entfernung zur Kamera muss auch berechnet und gespeichert werden (für Sortieren nach Tiefe) wenn ein Knoten
  keine Maximale Sichtbarkeits Entfernung hat
- ShadowMapManager::UpdateShadowMaps(): Shadow Map größe verdoppelt - das sieht einfach besser aus auch wenns mehr Füllrate schluckt
- SRPShaderAmbientMeshes: Im Shader wird nun das übergebene Alpha mit dem Alpha der Diffuse Map multipliziert anstatt das die Diffuse Map
  das Alpha einfach so überschreibt
- DOF ist wieder lauffähig... und auf meinem neuen Notebook auch wirklich brauchbar so das ich Shader Einschränkungen rausnehmen konnte :D



>> 13.12.2008
[CO]
- SNMMouseMoveController: Über das Maus-Rad kann man sich nun nach vorne/hinten bewegen
- BasicSceneApplication: 'SaveScreenshot()'-Funktion hinzugefügt... direkt aus PLSceneViewer da man diese Funktionalität immer wieder braucht
  und die Implementation meistens identisch ist
- BasicSceneApplication: 'LoadScene()'-Funktion hinzugefügt... direkt aus PLSceneViewer da man diese Funktionalität immer wieder braucht
  und die Implementation bis jetzt fast immer identisch war


>> 12.12.2008
[CO]
- SNMMouseOrbitingController: 'Pan' hinzugefügt das standardmäßig aus ist
- SNMRotationFixRoll: Interpoliert nur noch wenn 'Speed' >0 ist
- SNMOrbiting: Hat nun auch direkt 'SNMRotationFixRoll' Funktionalität eingebaut



>> 08.12.2008
[CO]
- SceneApplication::OnUpdate(): Es ist sehr sinnvoll ZUERST den Scene Graph zu aktualisieren und DANACH zu
  zeichnen - sonst kann es sein das der erste sichtbare Frame einen unerwünschten Zustand hat.



>> 07.12.2008
[CO]
- SPScene::OnPaint(): 'SNCamera::GetContainer()' kann natürlich auch NULL zurückgeben, iss zwar sehr unwahrscheinlich - allerdings hatte ich
  gerade so eine Situation und dann gabs natürlich einen Crash wenn man nicht auf NULL prüft. Brrr...
- SNMDeactivationOnTimeout: Wird 'Timeout' gesetzt wird auch der interne Timer zurückgesetzt (erscheint mir als Sinnvoll)



>> 06.12.2008
[CO]
- SceneContainer: Neue Funktion: 'GetTransformMatrixTo()': Ermittelt eine Transform Matrize die von 'diesem Container' in 'den anderen Container' umrechnet
- 'SNCellPortal::GetWarpMatrix()' nutzt nun direkt 'SceneContainer::GetTransformMatrixTo()'
- 'SCRenderToTexture': Standardmäßig wird kein Stencil-Buffer mehr angefordert. Brauchen wir derzeit nicht + das kostet Speicher + kann
  Probleme mit Render To Texture machen wenn kein Format gefunden werden kann das mit FBO geht und intern auf PBuffer umgesprungen werden muss.



>> 05.12.2008
[CO]
- SceneNode: 'GetCommonParent()'-Funktion hinzugefügt die den gemeinsamen Scene Container zweier Scene Nodes ermittelt - falls dieser existiert



>> 03.12.2008
[SB]
- "LoadLibsFromRuntime" aus der Engine-Config in die PLCore-Config verschoben.



>> 29.11.2008
[CO]
- Neuer Scene Node Modifier 'SNMOrbiting' der für speziell für Orbiten ist ohne das man bereits vorhandene Scene Node Modifier kombinieren muss
  (was natürlich weiterhin möglich ist!) was unerwünschte Seiteneffekte zur Folge haben kann. (z.B. das sich die Entfernung zum Ziel durch
  herumbewegen verändert obwohl die Entfernung gleich bleiben 'sollte')
- Neuer Scene Node Modifier 'SNMMouseOrbitingController', sehr ähnlich zu 'SNMMouseLookController', aber von 'SNMOrbiting' abgeleitet + man kann
  über das Maus-Rad die Entfernung zum Ziel einstellen



>> 28.11.2008
[CO]
- SQCull::TraverseNode(): Der Entfernungs-Tests kommt nun vor dem aufwändigeren Frustum test
- GuiDebugScene & GuiDebugSceneRenderer: Der Klassen-Inspector wird nun standardmäßig rechts unten statt links unten platziert...
  so muss man dieses Fenster nicht ständig herumschieben wenn man die FPS im Auge behalten will...
- GuiDebugScene: Im Titel des Klassen-Inspector werden nun noch einige Informationen angezeigt



>> 26.11.2008
[CO]
- 'SCUnknown' hinzugefügt. Ist im Grunde das gleiche wie 'SNUnknown' nur für Scene Container anstatt Scene Nodes.
- 'SNMUnknown' hinzugefügt damit wir alle Typen beisammen haben
- 'SceneLoaderPL': Unbekannte Scene Nodes, Scene Container oder Scene Node Modifier werden nun durch 'SNUnknown', 'SCUnknown' oder
  'SNMUnknown' ersetzt - sind also in der eingeladenen Szene so das z.B. unbekannte Scene Nodes weiterhin als Kamera Ziel dienen können.



>> 22.11.2008
[CO]
- 'SRPShaderAmbientMeshes' Scene Renderer Pass kennt nun einen neuen Parameter Namens 'IndexOfRefraction' der für Fresnel Reflection
  genutzt wird. In den Shadern ist dies momentan nur auf Vertex Ebene Implementiert (Normal Maps haben also keinen Einfluss) - sieht aber auch so
  schon ganz ordentlich aus.



>> 21.11.2008
[CO]
- SNMMeshAnimation: Wenn 'Speed' 0 ist wird die Animation nicht abgespielt, sprich, ist überhaupt nicht aktiv und hat somit
  keinerlei Einfluss auf das Mesh.



>> 20.11.2008
[CO]
- SRPShaderAmbientMeshes & SRPShaderLightingMeshes: 'Two Sided Lighting'-Support verbessert. Bis jetzt wurden auch 'doppelseitige'
  Materialien direkt in einem Schritt gezeichnet und im Vertex Shader dynamisch die Vertex Normalen in abhängigkeit zur Kamera
  'geflippt'... das funktioniert auch ganz gut solange man planare Oberflächen hat - aber sobald man nicht mehr alles auf einer Ebene
  hat und sich mehrere Dreiecke einen Vertex teilen kommt man in teufelsküche da dann zwangsläufig immer eine Vertex Normale falsch
  sein muss und es zu 'dunklen Umrissen' kommen kann. (was wirklich sehr unschön aussieht)
  'Two Sided' im Shader 'flipped' nun nur noch die Vertex Normalen und dann muss man zwei Zeichenaufrufe machen... hat aber zum Glück
  fast keine State Changes + auch wie gehabt keinen extra Overdraw. :D (der extra Aufwand hält sich also in Grenzen - mehr oder weniger)



>> 09.11.2008
[CO]
- SQCull: Experimentellen Support für 'SNAntiPortal' eingebaut ('Occlusion Culling')
- Bugfix: SQCull::TraverseNode(): Jetzt gehen auch Directionale Lichter ohne das man das 'NoCulling'-Flag setzen muss



>> 08.11.2008
[CO]
- 'SNPortal' in 'SNCellPortal' umbenannt und von 'SNPortal' abgeleitet
- Von 'SNPortal' abgeleitetes 'SNAntiPortal' hinzugefügt. Dieses dient als 'Verdecker' anstatt als 'Fenster'... die Implementation
  der Klasse ist recht einfach gehalten da die Basisklasse 'SNPortal' alles nötige bereits mitbringt. Hauptarbeit hat hier also das
  Sichtbarkeitssystem das 'SNAntiPortal' als zusatz Information nutzen kann um zu bestimmen was gerade Sichtbar ist und was nicht.



>> 07.11.2008
[CO]
- SRPShaderLightingMeshes: Support für Directionale Lichtquellen eingebaut... war so einfach wie schon gedacht + die Shader
  sind weniger komplex da kein Licht Richungsvektor dynamisch berechnet werden muss und die Helligkeit auch immer gleich bleibt. :D



>> 02.11.2008
[CO]
- SceneContainer: 'EventLoadProgress'-Event hinzugefügt das von z.B. Scene-Loadern regelmäßig aufgerufen werden sollte um den
  Lade-Fortschritt nach außen mitteilen zu können. Es würde sich fast anbieten dieses Event nach 'PLGeneral::Loadable' zu verschieben
  damit dies für 'alles Ladbare' verfügbar ist... da Events aber erst in PLCore hinzukommen und 'Loadable' momentan noch in PLCore
  liegt geht das gerade noch nicht.
- SceneContainer::Add(): Ruft nun 'cNode.EventContainer.Emit()' auf
- SNLoadScreenBase & SNLoadScreen: Nutzen nun nicht mehr die alten 'PL Load Progress'-Funktionen sondern hören auf das
  'EventLoadProgress'-Event ihres Parent-Container
- PL: GetLoadProgress(), SetLoadProgress(), GetLoadProgressUpdate(), SetLoadProgressUpdate() entfernt
- BasicSceneApplication: Hört auf 'EventLoadProgress'-Event der 'konkreten'-Szene und ruft 'OnUpdate()' auf so das ein Lade-Bildschirm
  regelmäßig aktualisiert wird... habe das aber erstmal Auskommentiert da dadurch die Ladezeit 'immer' länger wird egal ob ein
  Lade-Bildschirm vorhanden ist oder nicht, und ist keiner vorhanden sieht man dann auch die Scene Nodes beim Laden aus dem nichts
  auftauchen.



>> 27.10.2008
[CO]
- SNMMoveController & SNMMouseMoveController: 'Speed' herausgenommen und 'DefaultSpeed' zu 'Speed' gemacht... das war einfach zu
  umständlich
- SNMMouseMoveController & SNMMouseLookController: Nahm den Faktor '0.3' raus... stattdessen ist das nun direkt der Default Wert



>> 25.10.2008
[CO]
- *Achtung, nicht abwärtskompatible Änderung* Machte heute endlich die seit längerem angedachte & besprochene SNCamera & SNSpotLight
  Änderung... Wir verwenden wie OpenGL das 'Rechte Hand Koordinaten System' bei dem die 'View-Matrix' entlang der negativen z-Achse
  'schaut'. Alles gut soweit bis PLEngine... sobald der Scene Graph ins Spiel kommt macht diese 'negative z-Achse' statt 'positive z-Achse'
  leider alles ein wenig unhandlich da man dann z.B. im Falle von PLEngine::SNMRotationTarget einen 180° y Rotations Offset hinzufügen muss,
  im Falle von SNMMoveController Bewechungs Achsen vertauschen muss etc. Man kann nicht einfach so in diesem Falle Modifier anhängen
  und direkt loslegen, sondern muss dann im Falle von Kamera & Spot-Licht erstmal noch einige Werte per Hand ändern was alles wie
  gesagt 'unnatürlich' macht auch wenn es 'konsistent' ist zum genutzten Koordinaten System. 'Nach außen hin' ist das zwar so nun
  viel netter zu verwenden, ist aber ein 'bruch' in den Konventionen des gewählten Koordinaten Systems - (auch wenn dieser sich total lohnt :)
  daher habe ich dieses Verhalten in den entsprechenden Klassen recht genau Dokumentiert.
  Passte alle Szenen entsprechend an - denn bei den alten Szenen sind nun SNCamera & SNSpotLight Scene Nodes um 180° um die y-Achse verdreht.



>> 24.10.2008
[CO]
- PLEngine::SNMRotationTarget::GetTargetPosition(): Ist "Target" leer, passiert nun nix mehr - es macht hier keinen Sinn eine Rotation zum
  'Scene Node Modifier Owner' zu machen :D
- GuiDebugScene::OnCommand(): Wird an eine Scene Node ein Modifier angehängt befindet sich die Scene Node nun immer noch wie man es
  erwarten würde im Debug Modus



>> 18.10.2008
[CO]
- GuiDebugScene::OnCommand(): Beim Klonen von Scene Nodes werden nun auch die Modifier mitkopiert



>> 14.10.2008
[CO]
- SNDirectionalLight: 'Range' herausgenommen da für diesen Licht-Typus sinnfrei *positionsloses licht*



>> 12.10.2008
[CO]
- SceneApplication: Wie besprochen gibt 'OnCreateRootScene()' nix mehr zurück sondern setzt 'direkt' in der Funktion
- BasicSceneApplication: 'OnCreateSceneContainer()' in 'OnCreateScene()' umbenannt + diese Funktion gibt wie besprochen nix mehr
  zurück sondern setzt 'direkt' in der Funktion
- BasicSceneApplication: 'GetSceneContainer()' in 'GetScene()' und 'SetSceneContainer()' in 'SetScene()' umbenannt damit konsistent
  mit 'OnCreateSceneContainer()' in 'OnCreateScene()' änderung.
- BasicSceneApplication: 'OnPopulateSceneContainer()' wie von Stefan gewünscht entfernt. In 'OnCreateRootScene()' wird nun üblicherweise
  direkt ein 'Scene'-Container erzeugt, in 'OnCreateScene()' wird dieser dann 'gefüllt'.



>> 11.10.2008
[CO]
- SceneApplication: Fürs erste Debug-Dialog ansteuern hier eingebaut
- SNConsoleBase::RegisterCommand() arbeitet nun mit 'PLCore::Functor'
- SceneApplication::OnCreateSceneGraph() hat nun eine Default-Implementation. Hier wird wie gehabt auch eine 'SNConsole'-Instanz
  erzeugt + 'Beenden' & 'Debug Dialog Öffnen' Befehle werden nun erst hier eingetragen da diese mit am Application-Framework hängen.
- SceneApplication: 'SceneGraph' in 'RootScene' umbenannt
- RenderApplication::OnCreateMainWindow(): Hier gibts nun eine etwas unschöne Situation: Einerseits ist es sehr übersichtlich in 'OnInit()'
  'OnCreateMainWindow()' etc. aufzurufen, andererseits gibts im Falle von RenderApplication nun das Problem das 'OnCreateMainWindow()'
  ein Render-Fenster erzeugt, der RendererContext aber erst 'später' erzeugt wird. Daher wird nun in 'OnCreateMainWindow()' hier
  'OnCreateRendererContext()' aufgerufen bevor das Render-Fenster erzeugt wird - etwas unschön, wüsste aber gerade nicht wie es anderst
  gehen sollte - allemal besser als wie vorher in 'OnRun()' diese 'OnCreateMainWindow()' Funktionen aufzurufen finde ich das aber immer noch.



>> 06.10.2008
[CO]
- RendererApplication von PLEngine nach PLRenderer verschoben
- SPDefault: von PLEngine in PLRenderer verschoben
- SceneApplication::OnInit() hinzugefügt das Mesh & Shadow Map Manager initialisiert, das passierte bis jetzt in RendererApplication -
  konnte da nun aber definitiv nicht bleiben.
- SceneApplication::OnUpdate() hinzugefügt das erstmal noch 'PL::Update()' aufruft
- SceneApplication::OnCreateRendererContext() hinzugefügt
- SceneApplication::OnExit() hinzugefügt



>> 05.10.2008
[CO]
- BasicSceneApplication: Ruft in 'OnInit()' 'ChangeIntoAppDirectory()' auf
- Application: 'Render' Application kann man nun als Parameter den zu verwendenten Surface Painter übergeben, dadurch spart man sich
  an vielen Stellen 'OnCreatePainter()' nochmal selbst zu implementieren
- SceneApplication & BasicSceneApplication können als Parameter eine einzuladende Szene bekommen, momentan noch nicht implementiert



>> 04.10.2008
[CO]
- SNMPositionPath: Über das 'NodeIndexProgress'-Flag kann man den Modifier nun in den 'alten'-Pfad Modus zurücksetzen... 'Progress' wird
  dann nicht als 'Fortschritt auf dem Pfad', also 0-1 interpretiert, sondern wieder als 'Knoten Index'. Beide Vorgehensweisen haben ihre
  Existensberechtigung. Über 'Percentage Along The Path' bewegt sich immer alles gleich schnell, unabhängig davon wie weit nun zwei Knoten
  des Pfades auseinander sind - das ist weiterhin nun die Standardeinstellung da es mir so herum am Sinnvollsten erscheint und in 3ds Max
  ebenfalls so ist. Die Implementation ist allerdings noch nicht 'final' und 'CatmullRomCurve' wird auch noch nicht unterstützt... die
  Implementation ist intern etwas aufwändiger als beim einfachern 'Node Index'. Bei 'Node Index' kann man bewusst oder unbewusst einfluss
  auf die Bewegungsgeschwindigkeit auf dem Pfad nehmen indem man Knoten mal enger oder mal weiter auseinander setzt - oft ist das aber
  gar nicht erwünscht.



>> 28.09.2008
[CO]
- SQCull::TraverseNode(): Zum berechnen der 'nächstgelegenen Kamera Position' wird nun nur noch der Mittelpunkt der 'Container
  Space Axis Aligned Bounding Box' genommen statt wie vorher noch Box Vertices - das Ergbniss war einfach nie sonderlich prall
  und das machte die Implementation nur unnötig aufwändiger.
- Im Experimentellen Shadow Map Manager noch Experimentelles Shadow Map LOD eingebaut. Ist eine Lichtquelle weiter weg vom
  Betrachter so ist diese kleiner - das spart Füllrate und beschleunigt die Sache spürbar ohne das es direkt wirklich auffällt wenn
  man nicht genau drauf achtet. Alles wie gesagt noch Experimentell da ich hier erst noch Erfahrung sammeln muss wie man was am besten
 (hier ist vorallem Performance superwichtig!) realisieren kann.
- SceneNode: 'Shadow'-Flag entfernt und durch 'CastShadow' & 'ReceiveShadow' ersetzt, sprich, man kann nun Einstellen ob eine Scene
  Node Schatten werfen und empfangen kann - getrennt. Das schwirrte mir nun schon länger durch den Kopf - und als Tim anfang des
  Praktikums nebenbei mal fragte ob wir 'Receive' und 'Cast'-Shadow aus 3ds Max heraus unterstützen zeigte mir das, das es wirklich
  sinnvoll ist hier eine feinere Unterscheidung zu machen.



>> 27.09.2008
[CO]
- SRPShaderDepthMeshs Scene Renderer Pass hinzugefügt der nur Tiefeninformationen schreibt, SRPShaderAmbientMeshs schreib nicht mehr
  in den Tiefenpuffer. Das fügt zwar wieder einen kleinen 'Overhead' hinzu, ist allerdings die 'ratsame Vorgehensweise', also erstmal
  NUR einmal den Tiefenpuffer zu füllen was GPUs auch besonderst schnell können da dafür optimiert. Bringt jetzt gerade also noch weniger,
  wird aber zukünftig was bringen wenn man hier dann den Tiefenpuffer nach diesem Schritt in eine Texture wegspeichert. (DOF, SSAO etc.
  brauchen diese Daten!) Zusätzlich wird dieser Scene Renderer Schritt wohl auch mit 'Dynamic Occlusion Culling' zusammenarbeiten müssen,
  und dann hilft diese Umarbeitung diese Sache übersichtlicher zu machen. :D
- ShadowMapManager: "Opacity", "TwoSided", "DiffuseMap" & "AlphaReference" Material Parameter werden nun unterstützt
- In den Scene Renderer Schritten die mit Shadern arbeiten werden Shader Profile nun direkt mit angegeben, "arbvp1" für Vertex Shader,
  "arbfp1" für Fragment Shader. Das läuft auf NVIDIA und ATI Karten + so sind nun einige Grafik Bugs auf meiner NVIDIA Karte bei benntec
  verschwunden - ansonnten wurde z.B. bei Fragment Shader "CG_PROFILE_GPU_FP" als Profile genommen was bei ein paar Shadern
  irgendwie probleme machte. "arbfp1" etc. sind allerdings OpenGL Profile, für D3D9 heisen die wieder anderst - wüsste allerdings nicht wie man
  das universeller machen könnte, an dem Punkt hier muss man dann im Falle des Falles einfach eine Rendering ATI unterscheidung machen. :/
- Bei Shader Scene Renderer Pass Implementationen ein paar Namen vereinfacht... z.B. statt 'GetAmbientEmissiveFragmentShader()' nun nur noch
  'GetFragmentShader()' - da hier ein Render Schritt normalerweise nur einen 'auf die GPU ausgelagerten Code' hat ist das aussagekräftig genuch. :D
- PostProcessLoaderPL::LoadV1(): "[TODO] Check floating point texture formats - at the moment, they are terrible ssslllooww" entfernt da ich
  das mittlerweile dank entsprechender Hardware *Notebook tätschel* richtig testen kann.



>> 25.09.2008
[CO]
- SceneNode::ForceUpdate(): Funktion herausgenommen da noch nie verwendet + das mit 'Update' kommt demnächst komplett aus SceneNode
  heraus da nur wenige Scene Nodes wirklich Update brauchen und daher momentan sehr viel unnötiges gemacht wird
- SceneNode: 'RecalculateAABoundingBox' in 'RecalculateContainerAABoundingBox' umbenannt
- SceneNode: 'RecalculateAABoundingBox' hinzugefügt + 'GetAABoundingBox()' arbeitet nun fast genauso wie 'GetBoundingSphere()' -> wenn
  die Bounding Box also aktualisiert werden muss kann man über eine virtuelle Funktion die Bounding Box den eigenen Anforderungen
  entsprechend neu berechnen. Dadurch werden an einigen Stellen endlich umständliche 'UpdateBoundingBox()'-Funktionen unnötig und
  die Bounding Box wird ERST DANN aktualisiert wenn diese erst wirklich das nächste mal benötigt wird. :D
- Entfernte einige "InitFunction() & DeInitFunction()", wäre super wenn wir auf Dauer alle davon rausbekommen könnten und überall voll
  auf "erzeugen wenn benötigt" setzen können



>> 24.09.2008
[CO]
- "SNMMouseLookController" ist nun von "SNMRotation" abgeleitet da es 'nur' Rotation ändert
- "SNMMouseMoveController" & "SNMMouseMoveController" sind nun von "SNMPosition" abgeleitet da diese 'nur' Position ändern
- SNMRotationFixRoll::NotifyUpdate(): Kleine Optimierung: Man kann direkt 'GetZAxis()' vom Quaternion nehmen und muss hier nicht
  über eine 3x3 Matrize gehen :D



>> 22.09.2008
[CO]
- SNMMeshAnimation: Um 'Frame'-Variable erweitert, stellt man 'Speed' auf '0' so kann man damit sehr einfach bestimme Animation-Frames
  setzen was gerade zum Testen recht hilfreich ist
- SNMesh::UpdateFunction(): Die Bounding Box bei Skeleton Animation wird nun erstmal nur durch die Joint Positionen berechnet - hatte
  nun einfach zu viele Test Animationen wo das aktuelle berechnen überhaupt nicht gut ist... auf die Dauer müssen wirklich Joint
  Bounding Boxes her. :/



>> 12.09.2008
[CO]
- GraphicsPL: Der Render-State 'BlendEnable' wird nur aktiviert wenn wirklich Blending nötig ist (Füllrate)



>> 10.09.2008
[CO]
- Neue Scene Node Modifier: SNMPositionKeyframeAnimation, SNMRotationKeyframeAnimation & SNMScaleKeyframeAnimation -> damit lassen
  sich recht einfach Keyframe-Animationen für Scene Nodes realisieren
- SNMPositionPath: Neue 'Interpolation'-Variable über die man eingestellen kann wie Interpoliert wird



>> 07.09.2008
[CO]
- ImagePL::SystemLoadImage(): Es wird kein "GuiPL/" mehr hinzugefügt
- SNConsole::DrawPost(): Unterstreichung und Cursor passen nun bei jeder Fenstergröße



>> 05.09.2008
[CO]
- An 'BasicLighting.sr' Scene Renderer Schritten weitergearbeitet -> nun wird auch 'SpecularColor' und 'SpecularExponent' übernommen



>> 30.08.2008
[SB]
- PL::UpdateEmbedded() hinzugefügt ( aka PL::Update2() :-D ). Diese Methode macht haargenau das gleiche wie Update(), nur
  verarbeitet sie keine Gui-Nachrichten. Wenn die Engine in irgend eine andere Applikation, wie z.B. einen Webbrowser oder
  eine andere Gui wie Qt oder WxWidgets eingebunden wird, muss man davon ausgehen, dass diese Applikation bereits die Nachrichten
  vom System abfragt und verwaltet. Wenn PL das nun auch nochmal tut, kommt sich das natürlich füchterlich ins Gehege und die
  Applikation verliert Nachrichten oder reagiert nicht mehr, weil sie z.B. auf neue Nachrichten wartet etc. Darum muss
  die Nachrichtenverwaltung in diesem Falle immer der übergeordneten Applikation überlassen werden, dann läuft das Plugin
  auch flüssig, blockiert nicht das System oder das Beenden der Applikation etc. :-)



>> 28.08.2008
[CO]
- RenderApplication: Nutzt für aktuelle 'Fullscreen'-Einstellung zurück in die Konfiguration schreiben nun ein 'OnClose'-Event
  so das das Fenster zu diesem Zeitpunkt noch zu 100% sicher da ist



>> 27.08.2008
[CO]
- RenderApplication::OnExit(): Schreibt die aktuelle 'Fullscreen'-Einstellung zurück in die Konfiguration so das dies beim nächsten
  Neustart wieder die gleiche Einstellung ist
- SRPShaderVolumetricFogMeshs & SRPShaderLightingMeshs: Beleuchtungs Bugfix: Relativ zueinander liegende Daten wurden teils noch
  nicht korrekt gesetzt... merkte ich bei einer aktuellen Szene in der Scene Nodes in einem weiteren Container liegen und das Licht
  sich 'eine Ebene darüber' befindet



>> 24.08.2008
[CO]
- Wo sinnvoll 'Win32' zu 'Windows' gemacht da für 32 Bit als auch für 64 Bit
- 'PL::CreateFrame()' entfernt
- 'PL::IsInitialized()' entfernt
- 'Frame' entfernt
- 'PL::ScanFSArchives()' private gemacht
- 'PL::InitRenderer()' private gemacht



>> 23.08.2008
[SB]
- GraphicsPL: signed/unsigned Fehler behoben. Ein Fenster kann durchaus negative Positionswerte haben (z.B. -1, -1), diese wurden
  dann aber nach uint32 gecastet wodurch das Fenster in der PLGui in manchen Fällen nicht mehr sichtbar war. 



>> 21.08.2008
[CO]
- SNBitmap: Neues Flag: 'Background' -> Ist dieses Flag gesetzt wird die Bitmap über 'DrawPre()' statt über 'DrawPost()' gezeichnet und
  landet damit im Hintergrund
- Neuer Scene Node Modifier: "SNMMouseMoveController", ähnlich wie "SNMMoveController" nur für Maus-Achsen Steuerung anstatt über Tasten
- Neuer Scene Node Modifier: "SNMDeactivationOnTimeout": Deaktiviert die 'Besitzer Scene Node' nach einem gegeben Timeout



>> 20.08.2008
[SB]
- GuiPL: Bei allen Grafikoperationen wird nun das Blending aktiviert, da dies zuvor immer irgendwo deaktiviert
  wurde und dann transparente Fenster plötzlich nicht mehr transparent waren.
- GuiPL: Fenster können nun auch insgesamt transparent werden, so wie es in der Windows-Gui mit dem layered-Flag auch
  möglich ist. Das ergibt recht nette Effekte, wenn man ein Fenster ingesamt mit seinem gesamten Inhalt langsam
  ein- oder ausblendet. In diesem Fall müssen alle Grafikoptionen, die zu dem Fenster gehören, und auch alle Unterfenster
  mit der entsprechenden Transparenz gezeichnet werden, weshalb dieser Wert nun in GraphicsPL gespeichert wird und mit
  allen Farben verrechnet wird. Die Transparentwerte des aktuellen Fensters und die aller übergeordneten Fenster werden
  miteinander multipliziert (normaler Weise ist dieser Wert 1.0). Das ist zwar alles etwas kompliziert, funktioniert
  aber bereits sehr gut. Falls es irgendwie besser geht oder ich eine einfachere Lösung übersehen habe, würde ich mich
  über Kommentare freuen.



>> 15.08.2008
[CO]
- PL::InitEngine(): Fügte hier noch ein 'ScanPlugins()' für das Anwendungs Grundvereichniss ein. Dies ist nötig wenn
  man z.B. alle Plugins mit in den Grundordner packen will beim Anwendungen rausgeben um VC9 dll & Manifest Probleme
  zu umgehen. (hatte das heute direkt benötigt)



>> 10.08.2008
[CO]
- 'm_bMouseCursor' in 'GuiPL' entfernt da überflüssig



>> 09.08.2008
[CO]
- SceneNode & SceneQuery Event Namen an PLGui3-Style angepasst



>> 08.08.2008
[SB]
- GraphicsPL::Print(): Hier wurde der Area-Offset zweimal hinzuaddiert, so dass letztlich der Hintergrund eines Textes
  an der falschen Stelle erschien.
- FontPL: Font-Name und Height sind bereits in der Basisklasse definiert und sollten daher nicht nochmal zusätzlich
  gespeichert werden. Ausserdem wurden die Attribute der Basisklasse so überhaupt nicht gesetzt, so dass z.B. der Name
  des aktuell geladenen Font nicht abgefragt werden konnte.



>> 08.08.2008
[CO]
- GuiDebugScene: 'ClassView'-Dialog wird nun erst dann sichtbar wenn man auch wirklich dort was bearbeiten kann
- GuiDebugTexture: Momentan ist das speichern von Texturen noch nicht Implementiert, daher machte ich den 'Speichern'-Button
  hier erstmal unsichtbar
- SceneRenderer::SetRenderTarget(): Nur wenn der Scene Render Pass auch aktiv ist darf das Render Target verändert werden...



>> 07.08.2008
[CO]
- SceneNode::ProcessMessage() & SceneContainer::SendMessage(): Entfernt da nicht wirklich prall und brauchbar, das sollte man
  mittlerweile lieber über z.B. Events machen



>> 06.08.2008
[CO]
- SRPSceneNodeIcons: Neuer Parameter 'Size' zum Ändern der Icon größe
- SRPSceneNodeNames: Neuer Parameter: 'Font', 'FontSize', 'FontScale' und 'FontColor'



>> 04.08.2008
[SB]
- SNMMoveController: Habe hier die Steuerung über Cursortasten, zusätzlich zu WSAD, hinzugefügt. Gerade für Simulatoren und
  Visualisierungen, wo die User nicht unbedingt an Games gewöhnt sind, wird oftmals die Steuerung über Cursortasten erwartet.
  Ich denke es kann nicht schaden, zur Zeit einfach beides anzubieten, später wird das sowieso konfigurierbar.



>> 04.08.2008
[CO]
- SNPortal: Auf neue Event Klasse umgestellt - bind() ist hier noch nicht einmal wirklich nötig da man auch hier auch ohne die
  'Ereigniss Quelle' auskommt. Meine erste 'Overkill' Lösung, also
    m_cInformedOnContainerHandler(Functor<void>(bind(Functor<void, SceneNode*>(&SNPortal::InformedOnContainerPositionRotationScale, this), this))) 
  Um die 'Ereigniss Quelle' mitzuschicken klappte nun allerdings nach Stefans EventHandler Änderung ebenfalls. Das einzige was
  immer noch nicht wollte war
    Functor<void, SceneNode&>
  Also eine Referenz statt Zeiger übergeben. (= Compilerfehler)
  Aber da hier in SNPortal eine deutlich einfachere Lösung möglich war, nahm ich natürlich diese. SNPortal hat einen anderen
  EventHandler als die 'Ziel Zelle', und schon brauchen hier hier keine 'Ereigniss Quelle' mehr. :D
- PLEngine::SNMRotationTarget & PLEngine::SNMAnchor & SNSpotLight & SNCamera konnten durch den neuen EventHandler nun vereinfacht werden (ein
  EventHandler für mehrere Events)



>> 03.08.2008
[SB]
- Analog zu SNKeyValue auch noch einen Modifier SNMKeyValue hinzugefügt, für den Fall, dass man einer bestehenden Node noch
  beliebige weitere Informationen hinzufügen will. Hatte ein konkretes Problem mal testweise so gelöst, falls das total
  unnötig ist oder man das gleiche schon anders lösen kann, ist dieser Modifier schnell wieder entfernt :-)



>> 02.08.2008
[CO]
- SimpleSceneApplication in BasicSceneApplication umbenannt, fügt Dinge wie 'konkrete Szene' und 'Szene Kamera' hinzu



>> 26.07.2008
[CO]
- SceneContainer: Standard mäßig sind hier nun alle 'Draw Flags' gesetzt da ein Container oft dazu genutzt wird Nodes
  zu 'gruppieren' und man sich dann wundert wieso z.B. kein SNText sichtbar ist...
- SPScene::OnPaint(): So geändert das 'rekursive' gerendert wird - das wird sich auf jedenfall nochmal ändern, aber es
  erfüllt die aktuellen Anforderungen.



>> 18.07.2008
[CO]
- SceneLoaderPL & SkinLoaderPL & SkyLoaderPL & TerrainLoaderPL & PostProcessLoaderPL & SceneRendererLoaderPL: Um Format
  Versions Informationen erweitert



>> 05.07.2008
[CO]
- RenderApplication: 'GetPainter()' und 'SetPainter()' setzen fürs erste den Painter des Hauptfensters - alles andere macht hier momentan
  keinen Sinn. Man kann sich dann überlegen ob man eventuell die 'Surface <-> Painter'-Verbindung auflöst so das man einen Painter für
  mehrere Surfaces gleichzeitig nutzen kann. Aber das wäre zuviel auf einmal das sofort jetzt anpacken zu wollen - erstmal lieber behutsam
  die Umstellung auf die Application Klassen vornehmen. :)



>> 04.07.2008
[CO]
- RenderApplication: 'OnUpdate()'-Funktion hinzugefügt die einmal pro Update-Loop ausgeführt wird. Im Kommentar ist beschrieben das diese
  Funktion nur in Ausnahmen verwendet werden sollte wenn es nicht möglich ist mit Events, Timern etc. zu arbeiten.



>> 03.07.2008
[CO]
- RenderApplication: 'OnCreateRenderer()' in 'OnCreateRendererContext()' umbenannt und Implementiert (wenn auch gerade auskommentiert)
- RenderApplication: 'OnCreateMainFrame()' Implementation nutzt nun 'PLRenderer::Frame' anstatt 'PLEngine::Frame' (das bei zeiten rauskommt)



>> 27.06.2008
[CO]
- RenderApplication: In 'OnInit()' wird 'die Engine' initialisiert, in 'OnExit()' De-Initialisiert
- SceneApplication: Ersetzte 'SceneNode' mit 'SceneContainer' da sonst derzeit alle Scenen nur aus einer einzigen Scene Node bestehen können *g*



>> 22.06.2008
[CO]
- 'PLENGINE' und 'PLENGINEVERSION' Definitionen entfernt



>> 21.06.2008
[SB]
- GetRuntimeDirectory von PLEngine nach PLCore verschoben.



>> 31.05.2008
[CO]
- Shadow Mapping für 'SNPointLight' funktioniert nun ganz ordentlich. Allerdings gibt es derzeit noch irgendwo im Zusammenhang mit den Shadern
  einen willkürlichen Crash - solange ich das nicht ausgebessert habe, hab ich diese Schatten weiterhin deaktiviert.
- Shadow Mapping für 'SNPointLight': Ok, kein wunder das es Crashte... im Scene Renderer wurde an einer Stelle auf ein Spot-Licht gecastet
  da eine kleine Abfrage fehlte, nun gehts. Selbst mit den derzeit sehr 'blockigen' Schatten sieht das schon recht nett aus - auch wenn das für
  viele Lichtquellen auf einmal mit Schatten noch langsam ist da eine 'Verwaltungs-Logik' noch fehlt. Später sollten dann nicht alle sichtbaren
  Schatten in jedem Frame aktualsiert werden etc... ich denke wenn soetwas erstmal drinnen ist müsste die Performance ganz ok sein.



>> 22.05.2008
[CO]
- SceneNode: 'DebugNoInformListeners' in 'DebugNoDrawEvent' umbenannt
- SceneQuery von Listener auf Events umgestellt. SceneQueryListener entfernt.
- SceneQuery: 'PerformQuery()' hat nun keine Parameter mehr. 'Recursive' wird über ein Flag gesetzt.
- PL::GetRuntimeDirectory() nutzt nun PLGeneral::Registry anstatt direkt Win32-Funktionen



>> 20.05.2008
[CO]
- SceneNode von Listener auf Events umgestellt. Dadurch steigt der Speicherbedarf einer Scene Node zwar 'etwas', aber dafür ist die Klasse nun von
  einer anderen Klasse weniger abgeleitet + die Events sind viel einfacher und universeller nutzbar + in den meisten Fällen wohl etwas Performanter
  da nicht mehr 'alle bei jeder Aktion' benachrichtig werden sondern nur noch die die sich für ein bestimmtes Event registriert haben - das sollte
  das 'etwas mehr Speicher', das nicht wirklich ins Gewicht fällt, wohl definitiv ausgleichen. :D
- SceneNodeModifier: 'IsInitialized()' heraus genommen da unnötig. Im Konstruktor 'weis man' das die RTTI Variablen noch nicht automatisch gesetzt
  wurden und eine Scene Node ruft 'InformedOnInit()' vom Scene Node Modifier auf nachdem die RTTI Variablen auf die übergebenen Parameter gesetzt
  wurden - ab da weis man also das die Einstellungen passen... meistens braucht man noch nicht einmal diese Funktion zu nutzen.



>> 18.05.2008
[CO]
Altes Input System:
- IsMouseInWindow() & GetMousePosX() & GetMousePosY() heraus genommen und alle Projekte entsprechend angepasst. Wo man derzeit die Maus Position
  benötigt wird das nun über das GUI abgefragt. Auch noch keine wirklich tolle Lösung aber hauptsache das alte Input System wird an weniger Stellen
  genutzt.
- SetMousePos() heraus genommen das nur noch in PLSampleInGameGui verwendet wurde. In diesem Beispiel wird nun erstmal das Win32 'SetCursorPos()'
  genutzt da ich keine andere Lösung finden konnte die momentan besser wäre.
- Das alte Input System nun endlich komplett aus PLEngine entfernt *der ältesten Komponente hinterherwink*
Sonstiges:
- 'Window'-Klasse aus PLEngine entfernt da diese Klasse nun Sinnfrei geworden ist
- 'GuiDebug'-Unterordner in 'Guis' entfernt da es abzusehen ist das in diesen Ordner nicht mehr Klassen kommen werden, eher Klassen auf andere
  Projekte verteilt werden so das der 'Guis'-Ordner irgendwann ganz verschwindet



>> 16.05.2008
[CO]
- Diverse Debug Dialoge nutzen nun die neue Renderer Klasse 'PreviewWindow' für eine einfache Kamera-Steuerung, dadurch wird der Code deutlich kompakter
- "SceneLoaderX" in neues "PLDefaultFileFormats"-Projekt verschoben



>> 12.05.2008
[CO]
- GuiPL::SystemProcessMessages(): Es fehlten Abfragen ob das Fenster überhaupt aktiv und sichtbar ist, nur dann darf man natürlich Maus Informationen
  durchgeben...



>> 10.05.2008
[CO]
- SNConsoleBase: Seit der umstellung auf das neue Input System hatte man regelmäßig 'schrott' in der Konsolen Befehlseingabe stehen wenn man
  die Konsole öffnete. Ich schaute mir das gerade mal genauer an und merkte das 'PLInput::Button::IsHit()' auch dann noch 'true' zurückgibt
  wenn der Button schon lange nicht mehr gedrückt ist... und da ich bei der Konsole in 'ProcessKeyMessage()' alle Tasten abfrage bekam ich
  dann 'leichen' zurück. Dieses Verhalten war für mich unerwartet. Wenn das aber so völlig ok ist sollten wir zumindestens bei 'PLInput::Button::IsHit()'
  noch ein kleines Kommentar einfügen so das keiner sagen kann 'ja aber wohler soll ich das denn wissen das es so ist?'. :D
- SNConsole::UpdateFunction(): Das letzte Zeichen wurde 'verschluckt'
- SRPPostProcessing: Kleinere Umbauten damit das auch funktioniert wenn z.B. die Szene gerade mehrmals in verschiedene Texturen gerendert wird... das
  ist momentan definitiv noch nicht wirklich gut, läuft nun aber wenigstens wieder soweit.



>> 09.05.2008
[CO]
- SNCamera: Default Werte verändert: 'ZNear' von '0.1' auf '0.01' und 'ZFar' von '10000' auf '1000' gesetzt -> Mich störte das nun schon mehrmals
  das 'zu früh vorne Abgeschnitten wurde'... gerade wenn man mal nah ran will um Details zu sehen. :D
- Ich schaute mir das 'zerstören' von Scene Node nochmal an... das ist etwas Tricky da es nicht zu jedem beliebigen Zeitpunkt 'sicher' ist eine Scene
  Node einfach so aus dem System "herauszureißen". So wie es nun ist ists zwar immer noch nicht richtig schick aber auf jedenfall stabiler so das
  man auch in "PLSampleCharacterAnimation" keinen Crash beim Beenden mehr hat was natürlich einen unmöglichen Eindruck hinterlässt... das ist auf
  jedenfall eine Sache die wir später beim Scene Graph Refactoring nochmal ganz genau anschaun müssen.



>> 02.05.2008
[CO]
- SRPShaderLightingMeshs::RenderLightRec(): Lichter können nun 'durch' ein Portal scheinen, also von der Zelle in der sich das Licht befindet 'durch'
  das Portal in die andere Zelle. Dafür muss momentan das Licht zeitweise in die andere Zelle positioniert werden... diese Lösung find ich noch
  nicht ideal da hier am Licht herumgefummelt wird was beim reinen 'Rendern' nicht sein sollte. Aber dies war erstmal die einfachste Lösung so
  das es 'erstmal endlich geht'. 'Anderst herum' geht es derzeit noch nicht, also das 'durch' ein Portal Licht aus einer anderen Zelle 'in'
  die Zelle 'leuchtet' in der sich das Licht nicht wirklich befindet. Da muss ich mir noch eine praktikable Lösung einfallen lassen.
  In 'SRPShaderVolumetricFogMeshs::DrawVolumetricSphereFogRec()' das gleiche.
- SRPShaderAmbientMeshs: So erweitert das dieser Scene Renderer Pass auch für einen Transparenten Pass verwendet werden kann... denn ich hatte
  keine Lust SRPShaderAmbientMeshs zu kopieren und dann nur ein paar kleine Stellen zu ändern. Nun kann man auch für Transparente Dinge z.B.
  'Reflection Normal Mapping' nutzen was recht nett aussieht...
- Bei den Scene Renderer Pass Implementationen etwas Bugfixing betrieben
- Und noch ein dämlicher Crash weniger... der Debug Dialog wird nun beim Beenden automatisch immer geschlossen



>> 01.05.2008
[CO]
- SceneRendererPass: Texture Filtering Dinge hier herausgenommen da nicht jeder Scene Renderer das braucht und das daher schon zuviel in der
  Basis Klasse ist. Ich habe ein weilchen überlegt ob ich eine 'zwischenklasse' machen sollte - hab mich dann aber doch dagegen entschieden
  damit die Klassen Hierachie klein bleibt + mir viel auch kein vernümpftiger Name für eine 'Zwischenklasse' ein. Daher ist diese Funktionalität
  direkt in die Scene Renderer Pass Implementationen verschoben die das benötigen.
- In jedem einzelnen Scene Renderer Pass steht nun in der Klassen Dokumentation was für Material Parameter verarbeitet werden können. Ordnete
  bei der Gelegenheit auch gleich die verschiedenen Parameter neu an so das zusammengehörendes zusammen ist... das wuchs ja immer wieder weiter. :D
- Flags von Scene Renderer Pass Implementationen neu geordnet damit das wieder soweit Einheitlich ist
- SRPShaderAmbientMeshs: Neue Flags zum aktivieren/deaktivieren von Reflektionen
- SRPShaderLightingMeshs: Flags aufgeräumt
- SQCull::GetOcclusionQueryResult(): Musste hier einen 'Time out'-Hack einbauen da in 'PLSampleScene' merkwürdigerweise auf einmal die Query-Ergebnisse
  praktisch nie verfügbar sind... da muss ich bei Zeiten mal im Detail schaun was da los ist...
- Config: 'EngineDebugConfig': 'ShowSceneNodeNames' herausgenommen da dies nun universeller geht, 'ShowBoundingBoxes' und 'UpdateFrustum' rausgenommen
  da schon lange 'tot'
- Weitere Stellen auf das neue Input System umgestellt + einen großteil des alten Input Systems 'heraus gerissen'
- 'GuiPL::SystemConvertToCharacter()' und 'SNConsoleBase::ProcessKeyMessage()' nutzten 'PL::Input.ConvertToCharacter()'. Da das neue Input System
  derzeit keine solche Funktialität bietet habe ich hier direkt OS Code verwendet und entsprechende [TODO] eingefügt (hauptsache das alte Input System
  wird nicht mehr verwendet...)
- 'EngineInputConfig' ersatzlos entfernt



>> 30.04.2008
[CO]
- 'SRPBasic', 'SRPShader' entfernt da dies 'nur' reine Zwischenklassen waren um deutlich zu machen zu welchem 'Scene Renderer' diese gehören.
  Da dies mittlerweile noch ein stück 'lockerer' ist sollte soetwas denke ich nicht mehr nötig sein.
- SceneRendererPass: 'DebugFlags' heraus genommen da nirgends verwendet und es auch mittlerweile abzusehen ist das soetwas nicht verwendet wird...
  dafür sollte man spezielle 'Debug'-Scene Renderer Pass Klassen schreiben.



>> 29.04.2008
[CO]
- SPScene: 'GetDefaultSceneRenderer()' und 'SetDefaultSceneRenderer()' eingefügt. Nun hat man zwar wieder soetwas hier drinnen... aber immer
  zu erzwingen das in jeder Kamera ein korrekter Scene Renderer eingetragen ist wäre auf Dauer wohl zu umständlich und fehleranfällig.
  Normalerweise setzt man nur einmal diesen Default Scene Renderer... aber wenn man will kann man nun pro Kamera einen anderen Scene Renderer
  wählen. Denkbar wäre nun also z.B. ein Demo der 'Basic.sr' und 'ShaderLighting.sr' in einem Bild als vergleich nebeneinander stellt. *g*
- Über den Debug Dialog kann man nun Scene Renderer manipulieren, der Dialog ist zwar defintiv noch Verbessungsfähig, aber das grundliegendste
  geht :D
- SRPSceneNodeNames: Per Default werden nun keine absoluten Scene Node Namen mehr gezeigt da dies sehr schnell sehr unübersichtlich wird. Über
  das neue Flag 'AbsoluteNames' kann man jedoch auf absolute Namen umschalten.
- SRPShaderLightingMeshs: Das 'SoftShadow'-Flag ist nun als Default immer gesetzt. Damit sieht es zwar immer noch nicht perfekt aus, aber um längen
  besser und die Performance sinkt auf meinem Notebook nicht mehr soooo dramatisch wie früher.



>> 27.04.2008
[CO]
- SNText: Schrift und Schrift größe lassen sich nun Dynamisch einstellen
- SNCamera: Neues Flag: 'FlipY': 'Spiegelt' an der Y-Achse
...
Eigentlich wollte ich heute nichts mehr machen - aber warum auch immer beschäftigte sich mein Hirn mit 'Scene Renderer irgendwie von außen
konfigurierbar machen' obwohl ich das wie gesagt ja eigentlich gar nicht wollte. (ich glaub ich habe heute mal wieder zuviel Kaffee gedrunken,
das wird sich morgen sicherlich wieder bemerkbar machen :/) Auf einmal sah ich eine verrückte aber sehr Interessante Möglichkeit vor meinen
Augen wie man 'Scene Renderer irgendwie von außen konfigurierbar machen' kann. Hier die einzelnen Schritte die sich einfach so vor mir ausrollten:
- Man könnte Scene Renderer Schritte ähnlich wie die Post Processing Schritte als Scene Node Modifier an eine Kamera hängen... aber irgendwie wäre
  das umständlich da man dann jedesmal all diese Scene Renderer Pässe immer und immer wieder einhängen muss und da diese dann 'komplett getrennt'
  wären könnte man auch nicht so einfach 'bitte diese Grafischen Einstellugen nutzen'-Optionen in z.B. einer konkreten Anwendung realisieren. Ganz
  nebenbei haben ein paar Scene Renderer Schritte intern ein paar eigene Resourcen, alles in allem nie 'wirklich wirklich viel' - aber das muss doch
  nicht sein...
- wenn ich einen 'Scene Renderer' zu einer 'Resource' mache kann man die einzelnen Renderer Schritte dann z.B. in einer XML Datei speichern/laden...
- wenn eine Kamera auf eine 'Scene Renderer Resource' verweist die verwendet werden soll beim Rendern anstatt 'Scene Renderer Pass Modifier'
  anzuhängen...
- man kann seine eigenen Scene Renderer total universell in XML zusammenstückeln und sogar auf die einzelnen Variablen der Scene Renderer Schritte
  zugreifen...
- man kann von z.B. 3ds Max aus universell einen Scene Renderer für Kamera einstellen indem man eine Scene Node Variable setzt anstatt einen
  'Scene Key' nimmt, diese dumme ComboBox im Dialog 'könnte' dann also endlich raus...
- jede Kamera kann einen anderen Scene Renderer nutzen... das könnte praktisch werden...
- den ich sogar zur Laufzeit nicht nur Manipulieren, sondern komplett austauschen kann...
- wenn ich im Debug Dialog einen weiteren Tab einfüge für 'Scene Renderer Resourcen Ansicht' kann ich über den Debug Dialog direkt an den Scene
  Renderer Variablen zur Laufzeit dynamisch drehen und kann sogar die Scene Renderer anderst zusammenstückeln, laden und speichern...
- für verschiedene Systeme kann man dann verschiedene Scene Renderer 'vorkonfigurieren' und als XML Dateien ablegen...
- generell wird 'Scene Renderer' überschaubarer da dies keine 'großen festen brocken' mehr sind sondern man das nun wirklich nur noch als eine
  Menge von losen Scene Renderer Schritten betrachten muss... 
... DAS isses! Diese Lösung hat alles was ich mir schon länger Vorstellte aber nicht 'sauber und universell aber trotzdem einfach zu verwenden'
realisieren konnte. Mich störte das ohnehin schon länger das man sooo viele coole Optionen in den Scene Renderer Schritten hat aber 'von außen'
einfach nicht damit herumspielen kann ohne über C++ gehen zu müssen. Da mich schwer Interessierte ob das wirklich was Taugt legte ich die aktuelle
DotNet Übung aus der Vorlesung wieder weg und öffnete im bereits offenen Visual Studio PLEngine um das direkt mal auszuprobieren - im Grunde
für einen 'einfachen schnellel Test' keine großen Änderungen da die Scene Renderer Schritte bereits voll Modular sind und 'SRShaderLighting' etc.
im Grunde nur noch das 'fest zusammengepuzzelt' anbieten:
- Scene Renderer zu einer 'Resource' gemacht, Scene Renderer Manager (liegt 'erstmal' in SceneGraph) und Scene Renderer Handler hinzugefügt
- 'SRBasic', SRBasicLighting' und 'SRShaderLighting' entfernt die von 'SceneRenderer' abgeleitet waren, es gibt nun also NUR noch 'SceneRenderer'
- Scene Renderer Loader hinzugefügt und das was früher in 'SRBasic', SRBasicLighting' und 'SRShaderLighting' über C++ definiert war in XML-Dateien
  mit den Namen 'Basic.sr', BasicLighting.sr' und 'ShaderLighting.sr' gespeichert (liegen in 'Standard.pak/Data/SceneRenderer/') die
  'Standard-Konfigurationen' darstellen.
- SPScene: 'GetSceneRenderer()' und 'SetSceneRenderer()' entfernt (störte dort ja schon seit längerem... *g*)
- SNCamera: 'GetSceneRenderer()' und 'SetSceneRenderer()' hinzugefügt + eine RTTI Variable Namens 'SceneRenderer'
- SPScene::OnPaint() holt sich nun den Scene Renderer von der genutzten Kamera... ist keine Kamera da sieht man nun nix mehr, eine Kamera ist nun
  also 'Pflicht'! (auch für 2D 'rendern')
... nur ein paar Minuten arbeit und es funktioniert ganz wunderbar! Wenn ich morgen keine Vorlesungen hätte und es nicht bereits 22 Uhr wäre
(warum müssen so Ideen immer Nachts kommen!?) würde ich diese Arbeiten direkt komplettieren.
Dann muss ich es eben in den nächsten Tagen 'in freien Minuten' komplettieren - ich kann es jedenfalls kaum erwarten an den Scene Renderer Schritten
zu 'drehen' und 'sofort' die Änderungen sehen zu können und dann kann ich auch endlich mal wieder all die Debug Informationen anguckn die über
Scene Renderer Schritte gezeichnet werden können. (Icons, Wireframes, Scene Node Namen etc...)



>> 25.04.2008
[CO]
- 'PL'-Klasse: GetNativeGui() entfernt und wo es verwendet wurde durch PLGui::GuiManager::GetInstance()->GetSystemGui() ersetzt
- 'PL'-Klasse: GetDefaultFont3D() ersatzlos entfernt da es bis jetzt nirgends genutzt wurde
- 'PL'-Klasse: GetDefaultFont2D() entfernt und wo es verwendet wurde durch den neuen Font Manager im Renderer Context ersetzt
- SNMesh: Neues Debug-Flag: 'DebugShowWireframe' -> ist dieses Flag gesetzt so wird im Debug Modus das Drahtgitter über das Mesh gezeichnet
- SRPLightEffects::Draw(): Bei der Berechnung von 'pLightEffect->fFactor' konnte es passieren das durch '0' geteilt wurde. Habe daher hier eine
  Sicherheits abfrage eingebaut und zuckte zusammen als ich dann die Dungeon-Szene startete... statt '93 FPS' wurde mir auf einmal '120 FPS'
  angezeigt. Ich machte ein paar mal die Änderung wieder raus und rein weil ich es nicht so recht fassen konnte - aber tatsache, durch diese
  'Division durch 0' welche natürlich übel ist und nie passieren sollte sackte die Performance extrem ab. Wow. (da spielen sicherlich
  verschiedenste ungünstige Situationen zusammen da dann in der Variable ein 'ungültig' steht und damit weitergearbeitet wird :)
  Ich habe hier bei 'Draw Billboard' auch das '*0.3' herausgenommen da dadurch die Korona von Lichtern sehr unschön schlagartig verschwinden
  konnte. Dafür rechne ich nun bei 'pLightEffect->fFactor' eine Potenz mit rein damit die 'Helligkeit' schneller abfällt was etwas besser aussieht.
- 'PL'-Klasse: Neue Funktion: CloseDebugDialog(): Schließt den Debug Dialog -> der Scene Viewer nutzt diese Funktion um vor dem Laden einer neuen
  Szene sicherzustellen das der Debug Dialog geschlossen ist... denn dieser bekommt derzeit nix mit das sich etwas geändert hat und dann bekommt
  man schonmal einen üblen Crash wenn man dann im Szene-Tab auf etwas der 'alten' Szene klickt. (und Florian passiert das natürlich immer mal wieder *g*)
  Anstatt da nun groß herumzubasteln muss diese 'Zwischenlösung' erstmal reichen bis man da eine 'richtige Lösung' hat. (sprich, das sich das GUI
  'irgendwie automatisch' aktualisieren kann)



>> 19.04.2008
[CO]
- SNClear & SNLoadScreen: 'ClearColor', 'Alpha' ist nun so wie es gängig ist als Default ebenfalls auf 0



>> 18.04.2008
[CO]
- Wie besprochen Sound-Dinge komplett aus PLEngine herausgenommen und Komponenten nach PLSound verschoben. Für weitere Details siehe PLSound-Diary.



>> 17.04.2008
[CO]
- PLEngine::SNMAnchor: Angehängte Nodes 'wandern' nun per Default mit durch z.B. Portale



>> 12.04.2008
[CO]
- PLPhysics::SNMPhysicsCharacterController: Steuerung wie gewünscht auf 'shooter like' umgestellt



>> 11.04.2008
[CO]
- SNMPostProcess: Neue Funktion: 'GetParameter()': Darüber kommt man recht bequem an einen bestimmten Post Process Parameter
- SNMPostProcess: Neue Funktion: 'GetParameters()': Gibt alle Post Process Parameter anhand eines Namens zurück so das man recht bequem
  an diese Parameter ran kommt
- SceneNodeListener: Neue virtuelle Funktion: IsListening(): Darüber kann abgefragt werden ob dieser Listener über Ereignisse Informiert
  werden soll. Die Standard-Implementation gibt immer 'true' zurück. 'SceneNodeModifier' überschreibt diese Funktion und gibt jeweils
  abhängig von 'IsActive()' 'true' oder 'false' zurück. Somit werden nun also die Listener Funktionen nicht mehr aufgerufen wenn ein
  Modifier gerade 'Inaktiv' ist und damit entfallen die meisten 'IsActive()'-Test in den Scene Node Modifier Implementationen was die
  Sache einfacher und weniger Fehleranfällig macht. :)
- SceneNode::SetFlags(): Musste die Implementation leider etwas komplizierter machen da man korrekt mitbekommen muss wie sich 'Active'
  und 'Visible' ändert, daher benötigt man derzeit auch 'm_nFlagsT' um diesen Status wechsel überhaupt korrekt feststellen zu können.
  (das aktuelle RTTI ändert direkt so das man sich den alten Zustand selbst wegsichern muss um dann vergleichen zu können)
  Das direkte setzen von Flags ist nur bei 'Active' und 'Visible' problematisch da hier noch zusätzliche Arbeiten erledigt werden müssen
  wenn sich etwas an diesen Einstellungen ändert.
- SceneNodeModifier: Neue virtuelle Funktion: 'InformedOnFlags()': Wird aufgerufen wenn sich die Flags eines Scene Node Modifiers ändern...
  so können auch von 'SceneNodeModifier' abgeleitete Klassen davon etwas mitbekommen und falls nötig darauf reagieren.



>> 10.04.2008
[CO]
- SRBasic & SRPBasicLighting: 'EmissiveColor' und 'DiffuseColor' Material Parameter werden nun unterstützt - das trickse ich einfach über die
  globale Ambient Farbe. *g*



>> 05.04.2008
[SB]
- Klassen für das neue Application-Framework hinzugefügt: RenderApplication, SceneApplication, SimpleSceneApplication,
  SampleApplication.
- Neuer SurfacePainter: SPDefault. Dieser Painter soll von RenderApplication als Default benutzt werden, damit man wenn man
  eine unveränderte RenderApplication benutzt, gleich etwas zu sehen bekommt. Habe erstmal nur das Dreieck-Sample kopiert,
  später sollten wir hier irgendwas mit dem PL-Logo machen (irgendwie animieren halt).



>> 05.04.2008
[CO]
- SNSky: 'SkyFilename' zu 'Filename' gemacht da dies hier Aussagekräftig genug ist



>> 24.03.2008
[CO]
- SRShaderLighting: Support für 'None Uniform Scale'-Beleuchtung eingebaut. Einige Berechnungen habe ich vom 'Object Space' in den 'World Space'
  verschoben da es durchaus praktisch ist Objekte zu haben die nicht bei jeder Achse gleichmäßig Skaliert sind - gerade wenn man viel mit 'Instanzen'
  von Meshs etc. arbeitet... und schon wird in so einem Falle aus einer Sphere im 'World Space' ein Ellipsoid im 'Object Space' und die Berechnungen
  würden einfach unmöglich umständlich werden. *g*
  Das war übrigens auch das Beleuchtungsproblem in der Dungeon-Demo Szene, genauer gesagt im Weinkeller. Anfangs hatten die Säulen eine nicht
  gleichmäßige Skalierung, da dies aber in 3ds Max zu 'beheben' war machte ich das vor einigen Tagen auch. Allerdings kann es wie oben erwähnt durchaus
  praktisch sein so 'wild' herumskalieren zu können + man muss sich nun nicht mehr Fragen wieso die Beleuchtung so 'merkwürdig' aussieht falls man
  'aus versehen' mal nicht gleichmäßig Skaliert hat. (im 3ds Max Scene Exporter Log stehen in so einem Fall weiterhin entsprechende Hinweise) Trotzdem
  sollte so eine ungleichmäßige Skalierung eher die Ausnahme bleiben und vermieden werden wo immer möglich da es sicherlich noch andere Stellen gibt
  wo soetwas mal Programmiertechnisch 'umständlich' werden kann.



>> 23.03.2008
[CO]
- SRShaderLighting: Support für 'Two Sided Lighting' eingebaut. Damit kann man nun recht sorglos 'TwoSided' nutzen ohne das man das Problem
  hat das nur eine Seite korrekt Beleuchtet wird obwohl beide Sichtbar sind. :D (im Vertex Shader wird wenn nötig einfach die Vertex Normale
  'umgedreht')



>> 20.03.2008
[CO]
- SNBillboard: Um 'PositionOffset' erweitert, wird bereits in der Dungeon-Szene bei den Flammen der Kerzen verwendet



>> 08.03.2008
[CO]
SRShaderLighting:
- Support für weiteren Material Parameter eingebaut: 'ReflectionNormalMapping', ist das aktiviert, so werden eventuell vorhandene Normal Maps
  auch für Reflektionen verwendet... sieht 'sehr' nett aus, kostet aber natürlich zusätzliche Performance. War schwer mit mir am kämpfen was
  die 'Standard Einstellung' ist, an oder aus. Ich entschied mich für 'an' da es einfach optisch wirklich ein großer Unterschied ist und
  sicherlich das ist was auch ein Grafiker erwartet, also das die Normal Maps gleich direkt für alles 'natürlich' genutzt werden.
  Falls ich nix übersehen habe, so kann dieser Scene Renderer nun ALLES an Parametern nutzen was der 3ds Max Scene Exporter derzeit
  rausschreiben kann + noch etwas mehr das nicht wirklich im FX-Shader im 3ds Max Viewport realisierbar ist. :)
  Nun "müsste" Jens eigentlich auch 'die kratzer bei den Plakaten' in der UBahn-Szene realsieren können... also ich denke ich könnte das und
  werde es eventuell auch mal später ausprobieren wenn mir keiner zuvor kommt... bitte kommt mir zuvor! *g*



>> 06.03.2008
[CO]
- Neuer Scene Node Modifier: SNMPositionLinearAnimation: 'Bewegt' einfach nur - im zusammenspiel mit 'Look To' kann man damit allerdings einiges
  anstellen... :)



>> 03.03.2008
[CO]
SRShaderLighting:
- "ReflectionColor" in "ReflectionMapColor" umbenannt da diese Farbe 'nur' im zusammehang mit einer Reflection-Map funktioniert - im 3ds Max
  FX-Shader hieß der Parameter bereits korrekt
- Support für weitere Material Parameters eingebaut: 'DiffuseColor', 'LightMapColor', 'EmissiveMapColor'



>> 01.03.2008
[CO]
- SRBasic & SRBasicLighting & SRShaderLighting unterstützen einen neuen Material Parameter Namens 'AlphaReference' der für Semi-Transparente
  Texturen genutzt wird



>> 23.02.2008
[CO]
- "Authenticity" (Firma + Schlüssel) herausgenommen da wir das bei Open Source nicht mehr brauchen :D



>> 31.12.2007
[CO]
- SNSpotLight::DrawDebug(): Visualisiert nun auch den 'inneren' Licht-Kegel, falls vorhanden



>> 23.11.2007
[CO]
- SRPShaderLightingMeshs::RenderLightRec(): Die Abfrage für 'SpecularColor' war noch nicht ganz korrekt +
  'Parallax' ist nun wie in der Dokumentation beschrieben als Default '0.03'



>> 19.10.2007
[CO]
- Einige 'const' eingefügt



>> 13.10.2007
[SB]
- Zum Ermitteln des PixelLight-Runtime-Verzeichnisses wird nun keine Umgebungsvariable mehr verwendet, sondern in der Registry
  nach den Keys "HKEY_LOCAL_MACHINE\\SOFTWARE\\PixelLight\\PixelLight-SDK" oder "HKEY_LOCAL_MACHINE\\SOFTWARE\\PixelLight\\PixelLight-Runtime"
  gesucht.
- Der Übersicht halber wurde das Suchen des Runtime-Pfades in eine eigene Methode verschoben.



>> 13.10.2007
[CO]
- GuiPL::SystemProcessMessages(): Die Verarbeitung von Tasten verhält sich nun wie die vom OS... gerade wenn man eine Taste
  gedrückt hielt machte das vorher einige Probleme und so langsam störte mich das richtig.
- GuiPL::SystemCreateTimer(): Hier wird nun wieder 'ThreadTimer' anstatt eines OS-Timers verwendet da dies mittlerweile
  scheinbar problemlos funktioniert - ich konnte jedenfalls keine Performance unterschiede oder so mehr feststellen.



>> 05.10.2007
[CO]
- SNMRotationLinearAnimation: 'RotVelocity' in 'Velocity' umbenannt, weniger ist mehr :D



>> 22.09.2007
[CO]
- SQCull etwas geflickt damit auch eine Szene geht in der die Zellen selbst in einem übergeordneten Kontainer liegen... dies
  wird z.B. bei der Kabiene benötigt damit man sich 'über Physik herum bewegen kann'... denn dafür müssen die Zellen selbst
  in einem Physik-Kontainer liegen. Das sollte 'natürlich' alles absolut universell sein, aber ganz ohne ist diese Thematik
  leider nicht - diese Komponente muss man bei Zeiten nochmal überarbeiten und wo möglich vereinfachen + in weitere
  Teil-Komponenten zerlegen. Aber jetzt im Augenblick war es mir NUR wichtig das erstmal verwendbar ist. :)



>> 20.09.2007
[CO]
- Hat man in einem Material mal keine Diffuse Textur, so wird nicht mehr die Standard Textur genommen sondern gar keine
  da dies durchaus nicht unüblich ist mal keine Diffuse Map zu haben.
- Neuer Szene Renderer Schritt: 'SRPHierarchies': Zeichnet NUR Hierachien von Kontainern (Debugging)
- SceneHierarchy: 'm_nMaxLevel' und 'nMaxNumOfNodeItems' sind beide als Standard '16' - das müsste ein guter Wert sein,
  auf jedenfall wurden damit die Hierachien in meinen Tests nie ZU komplex
- GuiDebugGeneral: Die Buttons werden nun im Dialog zentriert... das sieht etwas Aufgräumter aus :D
- GuiDebug: Der 'General'-Tab liegt nun ganz rechts. Als erstes ist der 'Scene'-Tab eingetragen da zumindestens ich in 99%
  der Fälle den Debug-Dialog öffne um etwas an der Szene zu drehen :D



>> 19.09.2007
[CO]
- Alle Szene Renderer kennen nun noch diese neuen Material-Parameter:
  - "Opacity": Ist dieser Float-Wert kleiner als 1 so handelt es sich um ein Transparentes Material. Diese Transparenz hab
    ich erstmal sehr einfach gehalten, also noch keine 'Misch'-Einstellungen und keine berücksichtigung von Beleuchtung.
  - "TwoSided": Damit kann man das Backface-Culling ein/ausschalten. Dieser Begriff + Option ist etwas sehr gängiges + das
    müsste eigentlich reichen... ich glaube im Material Einstellbar zu machen 'welche' Seite gezeichnet wird wäre zuviel...
    das kann man immer noch über eigene Effekte machen wenns warum auch immer umbedingt sein muss. :D
  -> Dank dieser neuen Einstell möglichkeiten kann man bereits recht passables 'Glas' in der Kabiene realisieren. :D



>> 18.09.2007
[CO]
- SNParticleGroup::ParticleGroup: pRot von Matrix3x3 auf Quaternion umgestellt da kompakter



>> 17.09.2007
[CO]
- Alle Projekte von PLBool auf bool zurückgestellt (siehe PLBase Diary-Entrag von heute)



>> 15.09.2007
[CO]
- Die Sphere(n) einer SceneNode wird nun über PLMath::Sphere angesprochen anstatt über einen 'einfachen' Radius. So muss diese
  Sphere nicht umbedingt im Zentrum der Scene Node liegen sondern kann auch außerhalb sein... so wie es bei den Bounding Boxes
  ebenfalls ist. Dadurch haben diese Spheren meistens einen VIEL kleineren Radius wodurch die entsprechenden Tests die mit dieser
  Sphere gemacht werden sehr viel Effektiver werden... das bringt vorallem in z.B. Jens Kabine einiges da dort praktisch kein
  Mesh einer Node seinen Mittelpunkt im Mittelpunkt der eigentlichen Scene Node hat sondern meistens dieses Mesh weit weg vom
  Mittelpunkt ist. Da muss ich wirklich nochmal ein Wörtchen mit Jens reden, denn 'so extrem' sollte nicht sein. *g*
  Klar ist allerdings das das Mesh 'verschoben' sein muss wenn dieses z.B. um einen bestimmten Punkt rotieren soll... wie
  Beispielsweise eine Tür eben normalerweise sich beim öffnen NICHT um ihren Mittelpunkt dreht. :D
  Dieser Sphere-Problematik war ich mir schon seit langem bewusst, ich war mir allerdings nicht absolut sicher ob wir da wirklich
  wirklich der Sphere eine 'eigene' Position geben müssen - aber gerade Jens Kabiene zeigt deutlich das man nicht drum herum
  kommt. Die Verwendung dieser Sphere wird durch die eigene Position zum Glück allerdings nicht wirklich aufwändiger, teils
  sogar einfacher da man z.B. einigen 'PLMath::Intersect'-Funktionen diese fix und fertige Sphere direkt so durchreichen kann.
- SceneNode: GetBoundingSphere() & GetContainerBoundingSphere() berechnen nun nicht mehr direkt selbst die Sphere sondern
  rufen stattdessen gleichnamige virtuelle Funktionen auf. Die Standard Implementation berechnet die Sphere wie gehabt anhand
  der Bounding Box, aber für z.B. SNPointLight ist diese Sphere dann größer als nötig was dazu führt das mehr 'beleuchtet' wird
  als tatsächlich der Fall ist... also Performance im nichts verschwindet. Man hätte natürlich auch 'Set'-Funktionen für
  die Sphere(n) einführen können, das hätte die Sache allerdings zum einen komplizierter gemacht und zum anderen 'gefährlicher'...
  denn dieses Sphere hat 'in etwa' den gleichen Raum wie die Bounding Box einzunehmen - davon wird einfach überall ausgegangen
  und ohne diese Festlegung wäre die Sphere sinnfrei.
  Im Fall von z.B. SNMesh 'umschließt' die Sphere die Bounding Box, im Falle eines Lichtes liegt die Sphere 'in' der Bounding
  Box. Könnte man nun diese Sphere 'von Außen' total frei setzen, liese sich zu leicht zuviel Unfug damit treiben. Wenn jemand
  die Funktionen extra selbst Implementiert nur um die Sphere dann mit Schrott zu füllen... nun, solchen Leuten ist einfach nicht
  zu helfen. *g*



>> 14.09.2007
[CO]
- SNMesh: Neue Debug-Flags: 'DebugShowTangents' & 'DebugShowBinormals' -> Damit kann man sich die Tangent und Binormal Vektoren
  Visualisieren lassen
- SNEngineInformation::DrawPost(): Größenverhältnisse angepasst so das z.B. die einblendbaren Koordinaten Achsen genau
  '1 Einheit' lang sind.
- EngineDebugConfig: Neue Einstellung: 'NormalScale' -> Damit lässt sich Einstellen wie 'lang' Normalen Vektoren bei
  Visualisierungen sind. Standard-Einstellung ist '0.1' damit das bei '1 Einheit = 1 Meter' passt, wer andere Maßstäbe nutzt
  muss das selber anpassen.
- GuiDebugScene::OnCommand(): Wird aus der Szene-Darstellung etwas entfernt, so wird der 'Besitzer' dieses entfernten Elementes
  automatisch selektiert. Damit geht z.B. das löschen eines alten Modifiers und das anschließende hinzufügen eines neuen flotter
  von der Hand. :D
- SNProjectivePointLight: 'ProjectedMaterial' hat als Default-Wert nun 'DefaultCubeMap.dds' (liegt in 'Standard.pak')
  damit man sofort nach dem Einfügen der Node etwas sehen kann.



>> 13.09.2007
[CO]
- InputHandler::Update(): Wird eine unregelmäßigkeit im Timing festgestellt, so wird dies hier berücksichtigt damit es z.B.
  keine ZU extremen 'Sprünge' gibt. Diese Lösung hier ist defintiv nicht die beste, tut aber momentan ihren Job.
- SNMesh: Über das Flag 'NoAutomaticBoundingBox' kann man unterdrücken das automatisch die Mesh Bounding Box der Scene Node
  zugewiesen wird.



>> 05.09.2007
[CO]
- Nahm in den Scene Renderer Pass Implementationen [TODO] wie z.B.
    // Draw the portal itself (maybe there are for instance some debug information to draw)
    pSceneNode->DrawSolid(cRenderer);
  heraus. Bis jetzt war ich mir da unsicher wo/wann/ob diese Funktionen aufgerufen werden sollten - durch die strickte
  Trennung in einzelnde Render Schritte ist das jedoch nun endlich klar wo das hingehört... NICHT beim Meshs zeichnen
  sondern jeweils in getrennte Render Schritte - da ist das aufrufen dieser Funktionen vergleichsweise unproblematisch
  da der User sich selbst drum kümmern muss das jeweils alle Render States korrekt sind und wir ihm nicht versprechen können
  das jederzeit dieses oder jenes gerade Eingestellt ist. z.B. 'SRPSolidFunctions' ist also ein 'Free For All' Render Schritt
  der dadurch jedoch nicht sonderlich Performant ist da sich ständig Render States unkontrolliert ändern können. Wo immer
  es also geht sollte man wie gehabt auf die Verwendung dieser 'Draw'-Funktionen verzichten und stattdessen lieber ein
  Mesh erzeugen das die Scene Renderer universell nutzen können... außer diese verwenden Materialien mit Effekten - dann kann
  das leider auch nicht so ohne weiteres universell verarbeitet werden, aber da lässt sich nix dran ändern. Wer viel Kontrolle
  über alles haben will, muss auf der anderen Seite halt alles selbst machen ohne das ihm die Szene Renderer das automatisch
  abnehmen können. Die Szene Renderer Schritte wie z.B. 'SRPShaderLightingMeshs' können einfach erst ihre Muskeln richtig
  spielen lassen wenn diese 'nur' Mesh & Material Information bekommen ohne absolut fest gesagt zu bekommen wie alles zu
  verarbeiten ist.
- Scene Renderer Pass Implementationen noch etwas aufgeräumt, das waren gestern recht viele Code bewegungen. :D
  Jeder Render Schritt hat seine eigenen 'Einstellungen/Optionen', ein Scene Renderer weis nix davon da man ansonnsten die
  Abstraktion wieder aufweichen würde. Hat nun natürlich den Nachteil das man nicht mehr ganz sooo einfach z.B. über den
  PLGui Class Inspector alle Scene Renderer RTTI Variablen ändern kann.
- NUR 'SceneRenderer' darf auf die Draw-Funktion eines Render Schrittes zugreifen, wäre das nicht so, müsste man diese Funktion
  public machen und das wäre definitv nicht gut da man dann damit eine menge unfug treiben könnte und die Funktion z.B.
  außerhalb eines Zeichenvorganges aufrufen könnte was zu einem ziemlichen Chaos führen könnte. Abgeleitete Scene Renderer
  müssen 'DrawPass()' nutzen um einen Render Schritt zeichnen zu können - diese Funktion ist protected damit diese nicht von
  jedem beliebigen Punkt aus aufgerufen werden kann.
-> Diese ganzen Umbauten waren zwar sehr viel Fleißarbeit, aber es hat sich definitiv gelohnt da die Sache nun wieder halbwechs
   überschaubar geworden ist und man keine (oder zumindestens weniger :) > 1000 Zeilen Monster vor sich hat. Dann iss das nun
   bereit etwas erweitert zu werden - denn einige Dinge fehlen noch, vorallem korrekte behandlung von Transparenten Dingen,
   automatisches Shader LOD oder noch ein paar Shader Featurers wie einstellbare 'DiffuseColor'. (was Ardi scheinbar vermisst
   aber nicht missen will :)



>> 04.09.2007
[CO]
SceneRenderer:
- Da die Scene Renderer so langsam ziemlich umfangreich werden, vorallem SRShaderLighting das ich schon vor geraumer Zeit
  in weniger schicke einzelnde Dateien aufteilte, machte ich mich heute endlich mal dran diese in etwas handlichere
  Teile zu zerlegen bevor ich weitere neue Dinge hinzufüge. Die Idee mit einzelnen 'Scene Render Passes', also ähnlich wie
  bei 'Effect Pass', schwirrte mir schon lange im Kopf herum, wollte damit aber noch etwas warten bis sich genug Code
  angesammelt hat so das ein solches System wirklich Sinn macht. Im Grunde arbeiteten die einzelnen Scene Renderer bereits
  in einzelnen 'Render Schritten', die aber noch direkt in den jeweiligen Implementationen eingebaut waren und dort aufgerufen
  wurden.
  In der neuen 'SceneRendererPass'-Klasse findet jeweils eine recht genau definierte 'Zeichen Operation' statt wie z.B.
  'nur Ambient, Emissive etc.', 'nur pro Licht Beleuchtung', 'nur Wireframes zeichnen' etc. Dabei sollte jeder Scene Renderer
  Pass soweit wie möglich in sich selbst abgeschlossen sein, also nix vom Scene Renderer, anderen Pässen etc. wissen müssen.
  'Er/Sie/Es' bekommt gesagt was zu zeichnen ist und erledigt dann seinen Job so gut wie möglich - so kann man komplexe Render
  Vorgänge in handhabbare Stückchen zerlegen + muss bestimmte Zeichen Vorgänge nicht mehrmals in verschiedenen Scene Renderern
  abermals Implementieren so wie das bis jetzt beim 'Emissive Rendering Pass' in SRBasic und SRBasicLighting der Fall war.
  Anfangs wollte ich das 'absolut' Dynamisch halten mit den Render Pässen. Also das der User beliebig die Reihenfolge ändern
  kann, neue Schritte hinzufügt etc.... bis auf wenige Ausnahmen wäre das sogar möglich gewesen. Allerdings würden diese
  Ausnahmen nicht wirklich in dieses 'komplett Dynamisch'-Konzept passen da diese, wenn auch nur sehr wenig, mit dem jeweiligen
  Scene Renderer 'interagieren' müssen.
  Ein gutes Beispiel hierfür ist z.B. der Render Schritt welcher 'Licht Effekte' wie Lens Flares zeichnet. Diese Licht Effekte
  können 'verdeckt' werden und werden dadurch schwächer oder verschwinden ganz - dafür ist Dynamisches Occlusion Culling nötig.
  (Tiefenwert über eine Funktion direkt aus dem Framebuffer auslesen ist NUR unter OpenGL möglich, und selbst dort nicht zu empfehlen!)
  Zwar könnte man das alles in einem Rutsch durchdrücken, Effizient wäre das aber nicht wirklich da man auf die Occlusion Culling
  Ergebnisse der GPU warten müsste... und das warten zieht die Performance leider ziemlich in den Keller -> man verschenkt
  Rechenzeit mit Däumchendrehen. Daher wird dieser Render Schritt im Grunde in zwei Schritten ausgeführt. Der eine 'startet'
  nur die Sichtbarkeitstests nachdem der Tiefenbuffer durch einen anderen Pass gefüllt wurde. Der zweite Schritt findet dann
  etwas später statt wenn z.B. Transparente Dinge in der Zwischenzeit gerendert wurden und es dann sehr wahscheinlich ist das
  die Ergebnisse der GPU direkt abrufbar sind. Das lief alles so bereits schon ab, wollte das nur nochmal Erwähnen damit
  klar ist wieso ich das mit den Render Schritten so Realisiert habe wie es nun ist.
- Nahm den spezialisierten Scene Renderer 'SRPostProcess' heraus - das gefiel mir schon seit längerem nicht mehr da dies
  im Grunde nur ein 'Render Schritt' ist. Hierfür gibt es nun einen Scene Renderer Pass der ähnlich wie das oben erwähnte
  Beispiel mit dem Scene Renderer etwas Interagieren muss. Konkret muss einmal das 'Render Target' umgeschaltet werden,
  und nachdem der Framebuffer korrekt 'bunt eingefärbt' wurde, wird in einem zweiten Aufruf das konkrete Post Processing
  (oder 'Composing' wie man das auch nennt) durchgeführt. Das gefällt mir so nun deutlich besser + ganz spezielle Post
  Processing Effekte lassen sich so auch besser realiseren... z.B. 'Refraction', wo bestimmte Geometrien nochmals über
  das Bild gezeichnet werden und den Framebuffer Inhalt über einen Shader 'verzerren'. Kann z.B. für 'Glas' oder
  'Hitzeflimmern' verwendet werden wenns erstmal Implementiert ist... da Jens so einen Effekt uuuuummmbedingt für die
  Transperenten Wände der Dusche in der 'Kabiene'-Demo Szene braucht, werde ich das wohl demnächst mal endlich Einbauen...
  dann müsste aber so langsam alles gehen was er will. *g*
-> Diese ganzen Änderungen sehen auf den Blick nach großen komplett Umbauten aus... aber im Grunde war das nur Code herum
   schieben! Großartig an den Implementationen geändert hab ich nix, wäre nicht gut zuviel in einem Arbeits Schritt zu
   machen.



>> 03.09.2007
[CO]
SRShaderLighting:
- 'Reflectivity' in 'ReflectionColor' umbenannt
- 'Shininess' in 'SpecularColor' umbenannt, zum einen stimmt das nun mit den anderen Steuerbaren Farben überein + wir haben
  einen mehrdeutigen Begriff weniger. Denn der Begriff 'Shininess' wird wie es aussieht nicht wirklich einheitlich verwendet...
  oft liest man jedoch das "Gloss/Shininess/Specular Power" alles für das gleiche steht, also den 'Exponenten'. Aber auch
  nicht immer, (selbst innerhalb von 3ds Max gibts da unstimmigkeiten!) als ich googelte gabs auch schonmal in Shadern Variablen
  Namens 'specularPower' die am Ende einfach direkt 'multipliziert' wurde, also nur dazu diente festzulegen wie stark Specular
  ins Ergebniss mit einfließt. (0..1)
  In den letzten Tagen schrieb ich u.a. für 3ds Max einen fx-Shader der (bereits fast) alles kann was auch der SRShaderLighting
  Scene Renderer kann - man damit also eine optimale 'Vorschau' hat und nicht bei jeder kleinen Material Änderung prüfen muss
  wie das 'In PixelLight' aussieht. 'Ardworx' (alias 'Ardi' :) machte sich netterweise gleich über diesen Shader her und
  spielte damit herum... das erste was als Feedback kam war, das sich 'Gloss' nicht wie erwartet verhielt... und dann folgte
  erstmal das hin und her bis jedem klar war was man mit diesen oder jedem Begriff meint... über krücken wie 'unscharfes Highlight'
  *guckste Screenshot, das mein ich mit 'unscharf', guckste das kleine Video das ich gerade gemacht hab, das sieht mans
  besser*
  Ich werde im nächsten Semester auf jedenfalls mal das AWFP 'Digitale Photographie' belegen. Dort wird u.a. mit Photoshop
  gearbeiten das auch Jens & Co. nutzen + diverse Begriffe werden durchgekaut - könnte hilfreich sein. :D
  Daher nun nochmals eine Änderung der Namen einiger Variablen damit das möglichst eindeutig ist + ich werde einen kleinen
  Begriffs-Glossar (mit vielen bunten Bildern *g*) bei den 3ds Max Scene Exporter Tutorials beilegen damit möglichst erst keine
  solchen Unklarheiten entstehen und erst nach Stunden herumfummeln und probieren klar wird das man etwas missverstanden hat.
  (das alles auszujungeln war leider ziemlich Zeitintensiv)
- 'Gloss' in 'SpecularExponent' umbenannt, also da kann nun wirklich nix mehr dran mißverstanden werden... Exponent ist einfach
  ein Exponent ist ein Exponent ist ein... Und was 'Specular' heißt sollte auch für jeden klar sein. *g*
  (wollte das zuerst 'SpecularPower' nennen bis ich beim googeln etwas fand wo wie oben erwähnt das total anderst verwendet
  wurde)



>> 29.08.2007
[CO]
- SRShaderLighting: Bei 'Volumtrischen Nebel' muss der Alpha-Wert einer Diffuse Map berücksichtigt werden wenn vorhanden -
  macht man das nicht, sieht man die Stellen die man durch die Alpha Map eigentlich nicht sehen sollte. (was logisch ist
  da gleiche Thematik wie bei Beleuchtung)
- SceneNode::Delete() & SceneContainer::UpdateFunction(): Bis jetzt wurde in 'SceneNode::Delete()' üblicherweise NUR bekannt
  gemacht das diese Scene Node nun übern Jordan geht, das passierte allerdings 'verzögert' beim nächsten Aufruf von
  'SceneContainer::UpdateFunction()'. Weis nicht mehr genau warum wir das damals so machen, auf jedenfall ist das ziemlich
  problematisch da man dann z.B. beim durchlaufen des Containers vor einem Update diese 'tote Node' ebenfalls nochmal bekommt
  auch wenn man das gar nicht mag. Das könnte man zwar durch herumtricksen wohl verhindern, aber irgendwie wäre das mehr
  aufwand als es Wert wäre. Es sprich im Grunde nix (mehr) dagegen Nodes sofort zu löschen. Zur Sicherheit wird dabei allerdings
  weiterhin das 'Ich bin Tot'-Flag gesetzt + die Node wird deaktiviert da Scene Node Listener über das Ableben Infomiert
  werden und man so herum weniger Unfug mit dem virtuellen Leichnahm treiben kann. *g*
  -> Machte diese Änderung gerade wieder rückgängig... weis nun wieder warum so umständlich: Es kann gut sein das eine Node
     gelöscht wird während diese gerade in einer Liste abgearbeitet wird, und dann stimmt diese Liste natürlich nicht mehr...
     darum dieses umständliche Löschen in einem seperatem Schritt...
- SceneNode::Delete() & SceneContainer::UpdateFunction(): Zweiter Versuch: Entfernte das löschen von Scene Nodes aus
  SceneContainer::UpdateFunction(). SceneNode::Delete() trägt sich in der SceneGraph-Liste bei 'zu löschenden Nodes' ein, das
  passt hier besser rein und macht weniger Probleme als wenn man das in SceneContainer::UpdateFunction() macht. Sobald
  SceneGraph::Cleanup() aufgerufen wird, werden die Nodes wirklich gelöscht. Das passiert automatisch einmal pro Frame an einer
  unkritischen Stelle + der Uer kann es wenn nötig selbst anfordern... so wie es z.B. beim Debug Dialog benötigt wird
  wenn eine Scene Node gelöscht wird. (war der Grund für diese Änderung) Die Lösung gewinnt zwar sicherlich keinen Schönheitspreis,
  ist so herum aber zumindestens schonmal deutlich besser als zuvor.



>> 28.08.2007
[CO]
- SNMRotationLinearAnimation: Variable 'RotVelocity' hat nun einen anderen Default-Wert damit man sofort eine Wirkung sieht
  sobald man diesen Modifier an eine Node anhängt
- Machte 'Ambient Color' der Szene Renderer von Color4 zu Color3, Alpha ist hier absolut unnötig. Der 'Render State' Names
  'AmbientColor' im PLRenderer ist allerdings weiterhin RGBA da die Renderer API's das können und man da nix an Funktionalität
  wegnehmen sollte.
- 'SRShaderLighting': 'ReflectionFactor' hat keinen Alpha Wert mehr da dieser unnötig ist
- SNFog & SNLight: 'Color'-Variable von Color4 in Color3 geändert da man hier kein Alpha benötigt
- SRShaderLighting: Support für 'Semi-Transparent Textures' eingebaut. Hat eine Diffuse Map einen Alpha Kanal, so wird
  der Alpha-Test aktiviert damit bestimmte Stellen des Materials 'durchsichtig' (NICHT zu verwechseln mit Blending/Transparenz! :)
  sind. Das ist der Grund für die oberen Änderungen von Color4 zu Color3 bei bestimmten Komponenten - denn entgegen einiger
  Dokumentationen sieht es so aus das der Alpha-Test NACH dem Fragment Shader ausgeführt wird, sprich, die Shader haben
  Kontrolle über den Alpha-Test, aher macht z.B. Alpha bei Lichtern wirklich keinen Sinn da dies etwas grundsätzlich verschiedenes
  ist. :) (3ds Max & Co. haben für Licht Farben z.B. auch nur RGB, von daher iss das wohl 'standard')
  Is natürlich irgendwie doof, denn zum einen muss so ein Fragment auch Beleuchtet werden das durch den Alpha-Test dann sowieso
  übern Jordan geht + da der Alpha-Test den Alpha Kanal nutzt, kann man hier nicht so einfach z.B. DOF-Infos im Framebuffer
  ablegen obwohl dieser Kanal im Grunde 'frei' für soetwas ist. Iss wohl der Preis den man zahlen muss durch diese 'universellen'
  Fragment Shader.
  Kurzum: "Depth Of Field" geht nicht wirklich so ohne weiteres mit "Alpha Test" zu kombinieren, man ist gezwungen über
  z.B. "Multi Render Targets" diese DOF infos Parallel in eine andere Textur zu schreiben. :(
- SRShaderLighting:
  - 'ReflectionFactor' in 'Reflectivity' umbenannt, wie gehabt ein einfacher float-Wert 'über die gesammte Oberfläche' bestimmt
    wieviel von 'ReflectionMap' (könnte man auch 'EnvironmentMap' nennen, blieb aber bei dem Namen) in die Farbe miteinfliest
  - Neuer Map Typ: 'ReflectivityMap': Damit lässt sich 'Reflectivity' über eine Control Map steuern, bestimmte stellen können
    also mehr von 'ReflectionMap' haben als andere
  -> Damit müsste endlich das Thema 'Du, wir brauchen aber ganz dringend Metall Shader' erledigt sein, mal schaun was Jens
     jetzt noch außer den Transparenten Dingen für Glas so alles fehlt *g*
  - Die Begriffe 'Specular' und 'Gloss' waren vertauscht. Über 'Gloss' stellt man ein wie 'steil' die Kurve des Specular
    Highlight ist. Ein sehr kleiner Wert lässt alles 'fettig' aussehen, ein großer Wert erzeugt punkt artige Hightlights.
    'Specular' ist ein Wert zwischen 0-1 der angibt wie stark das Specular Hightlight ins Ergebniss mit einfließt.
  - Über den Alpha Kanal der Specular Map kann man Gloss einstellen
  -> Auf dem Server in meinem Screenshots Ordner sind aktuelle Bilder (Ordner 5: agusturinn_1.jpg - agusturinn_9.jpg) einer
     Test Szene anhand ich diese Shader Effekte durchteste. Das Modell fand ich übrigens per Zufall (ok, ich suchte nach
     GENAU soetwas :) auf http://www.poopinmymouth.com/3d/3d.htm... mittlerweiles sieht das in PL fast wie die gerenderte
     Vorlage aus und in Bewegung ist das extrem Eindrucksvoll... und läuft sogar noch recht gut auf meinem kleinen Rechner.
     Übrigens war genau dieses Modell der Grund wieso ich das mit der Normal Map Kompression 'vorgezogen' habe, denn die
     Datenmengen sind schon ziemlich krass... für die kleine Szene die man auf den Bildern sieht sind bereits 25 MB
     im Textur Speicher - und dabei iss alles komprimiert! :D



>> 26.08.2007
[CO]
- GuiDebugScene::UpdateSceneView(): Merkt sich nun das gerade Ausgewählte und versucht nach dem Update der Liste dieses
  wieder automatisch auszuwählen + neu erzeugte Dinge werden automatisch Ausgewählt ... das ist etwas das mich nun schon
  mehrmals etwas störte da man gerade beim Testen viel mit diesem Debug-Dialog Teil arbeitet. Jetzt lässts sich damit wesentlich
  flotter und bequemer arbeiten. :D ('scrollt' allerdings leider noch nicht automatisch)
- Default Wert der 'Range'-Variable der Lichter ist nun 1 anstatt 0, so sieht man normalerweise sofort was wenn man z.B.
  über den Debug Dialog ein neues Licht erzeugt hat.
- 'PLConsoleCommandDebugDialog': Gibt man in der Konsole 'debugdialog' ein, so wird nun die Konsole automatisch geschlossen...
  in 99% der Fälle hatte ich per Hand die Konsole danach wieder geschlossen weil ich z.B. die Szene etwas bearbeiten wollte.
- SRShaderLighting: Support für Normal Map Kompression hinzugefügt



>> 24.08.2007
[CO]
- PL::InitEngine(): Hier wird die gewählte Sprache nun auch direkt geladen... ist natürlich weiterhin nur Flickwert, es
  geht jetzt aber wenigstens *g*
  (z.B. in PLSamples in 'Data/Misc' eine Datei Namens 'PixelLight_German.loc' erzeugen und dort Texte 'eindeutschen'...
   im 'PLDocs'-Repository ist unter 'PLBase/examples' seit längerem eine Beispiel-Datei)



>> 23.08.2007
[CO]
- 'Terrain' aus PLEngine in das neue 'PLExperimental'-Projekt verschoben das im 'Lab'-Repository liegt. Diese Terrain
  Implementation ist derzeit rein Experimentell und sollte daher nicht in PLEngine liegen - das gefiel mir schon seit sehr
  langem nicht mehr. 'Terrain2' wurde nun in 'Terrain' umbenannt und ist die derzeitige 'offizielle' Terrain Implementation
  die zwar absolut nix besonderst ist, aber funktioniert und soweit 'sauber' ist.



>> 21.08.2007
[CO]
- SNMDraw ist eine Basis-Klasse für Modifier die versprechen NUR etwas auf/über die Node zu zeichnen ohne diese zu
  verändern. (z.B. könnte man später soetwas wie 'Einschuss Löcher' über einen davon abgeleiten Modifier realisieren)
- SNMRectancle in SNMDrawRectangle umbenannt und von SNMDraw abgeleitet
- SNMLight in SNMLightRandomAnimation umbenannt und in PLSceneNodes1 verschoben da dies etwas 'sehr' spezielles ist



>> 20.08.2007
[CO]
- SNMRotation ist nun nur noch eine Basis-Klasse für Modifier die versprechen NUR Rotation zu verändern. Das bisherige
  SNMRotation heißt nun SNMRotationLinearAnimation und ist von SNMRotation abgeleitet... liegt weiterhin direkt in PLEngine
  da dies recht universell ist.
- SNMScale ist nun nur noch eine Basis-Klasse für Modifier die versprechen NUR Skalierung zu verändern. Das bisherige
  SNMScale heißt nun SNMScaleRandomAnimation und ist von SNMScale abgeleitet... diese Klasse liegt allerdings in PLSceneNodes1
  und nicht in PLEngine da dies etwas 'sehr' spezielles/eingeschränktes ist.
- SNMPosition ist nun nur noch eine Basis-Klasse für Modifier die versprechen NUR Position zu verändern. Das bisherige
  SNMPosition heißt nun SNMPositionRandomAnimation und ist von SNMPosition abgeleitet... diese Klasse liegt allerdings in
  PLSceneNodes1 und nicht in PLEngine da dies etwas 'sehr' spezielles/eingeschränktes ist.
- SNMPath in SNMPositionPath umbenannt da NUR die Position der Scene Node verändert wird
- SNMMoveRotation in SNMRotationMoveDirection umbenannt da NUR die Rotation der Scene Node verändert wird
- SNMMoveToTarget in SNMPositionMoveToTarget umbenannt da NUR die Position der Scene Node verändert wird
- SNMFixRoll in SNMRotationFixRoll umbenannt da NUR die Rotation der Scene Node verändert wird
- SNMTargetRotation in PLEngine::SNMRotationTarget umbenannt da NUR die Rotation der Scene Node verändert wird
- Neue Scene Node Modifier Basis Klasse: SNMMesh -> Für Modifier die NUR Mesh Dinge ändern. SNMMeshAnimation, SNMMeshJoint
  und SNMMeshMorph sind davon abgeleitet.



>> 19.08.2007
[CO]
- SRBasic Konstruktor und Destruktor sind endlich privat. Bis vor kurzem griff 'PLSamplePostProcess' da noch etwas sehr
  unschön ein da ich nicht wusste wie sich das halbwechs ok lösen lies - durch die Post Processing Änderung iss das aber
  endlich Geschichte. :D



>> 15.08.2007
[CO]
- SceneNodeModifier: Neue Funktion: SetActive(): Merkte gerade das diese Funktion noch fehlte - nun isses konsistent zu
  SceneNode. :)
- SNMPath Variablen Namen vereinfacht



>> 09.08.2007
[CO]
- Nachdem mir diese Idee nun schon recht lange im Kopf herumschwirrte fragte ich heute Jens was er davon halten würde wenn
  Post Processing so ablaufen würde, das man an die Kamera 'Post Processing Scene Node Modifier' anhängen kann um Effekte
  zu aktivieren... er war recht begeistert von der Idee und meinte 'Das läuft in Max ähnlich ab!'. Ok, Beständigung das
  es so geändert werden sollte. :D
  Zukünftig ist in den Scene Renderern Post Processing standardmäßig immer eingeschaltet - macht aber nix wenn an der
  gerade verwendeten Kamera kein Post Processing Modifier hängt. Ist dies jedoch der Fall, werden diese 'Effekt Modifier'
  nacheinander vom 'Post Processor' abgearbeitet um ein finales Bild zu erzeugen.
  Dieser 'Post Processor' besteht aus Code der früher direkt im 'Post Process Manager' lag. Dies 'trennte' ich nun so das
  der Manager 'nur' eine ansammlung von Post Process Effekten ist die einen 'fertigen' vordefinierten Effekte representieren
  - kann wie gehabt direkt über einen Loader eingeladen werden.
  Im Grunde braucht man nur 'SNMPostProcess' zu verwenden und kann dann über einen Dateinamen wie gehabt so einen Effekt
  angeben. Allerdings benötigen einige Effekte wie 'old film' animierte Parameter um ihre volle pracht zu entfalten. Dies
  ist nun aber kein Problem mehr da man einfach von 'SNMPostProcess' ableitet und einen spezialisierten Post Process
  Modifier erstellt der das animieren der Parameter übernimmt. Im Grunde wie 'PostProcessOldFilm' damals, aber das gefiel
  mir nie sonderlich gut da es irgendwie 'quer stand'. Im Grunde ist es zu empfehlen das 'jeder' Post Process Effekt so
  einen eigenen Modifier hat (da iss Jens natürlich auch voll dafür *g*) damit man z.B. ganz bequem in einem Editor oder
  dem Debug Dialog diesen Effekt auswählen und anhängen kann ohne erst noch einen Dateinamen angeben zu müssen und da
  natürlich zu 'wissen' DAS es so einen Effekt gibt.
  Um die Sache richtig mächtig zu machen sollte man zudem dann in diesen spezialisierten Modifiern alle veränderbaren Effekt
  Parameter direkt ans RTTI anstöppeln. Damit kann man nun endlich auch direkt über z.B. den Debug Dialog zur Laufzeit an
  den Effekt Parametern 'drehen' wodurch sich teils ganz andere Effekte ergeben können. Kurzum, das System ist so nun um
  einiges Eleganter als das vorher wo im Grunde nur der Coder an den Parametern drehen konnte.
  Auch konnte ich nun viele eher unschöne 'Zwischenlösungen' in Sachen Post Processing entfernen. So braucht z.B. der 3ds Max
  Scene Exporter keine extra Post Processing Dinge mehr zu berücksichtigen - das kommt nun automatisch 'for free' durch die
  Modifier. In PLSceneViewer nahm ich ebenfalls alles Post Process spezielle raus, vorallem die 'Schlüssel-Information' welcher
  Post Processing Effekt verwendet werden soll ist nun überflüssig.
  (z.B. <Node Class="SNKeyValue" Key="PostProcess" Value="Cartoon.pp" />)
  Zwar kann man in PLSceneViewer dadurch nicht mehr wie vorher im ingame-Dialog einfach Post Process Effekte auswählen, das
  ist denk ich aber nicht wirklich Dramatisch da man das immer noch (nur halt universeller) über den Debug Dialog machen kann
  + noch wichtiger, der Viewer Code wird schlanker.
- In PLEngine direkt liegt derzeit 'nur' ein spezieller Post Process Modifier Namens 'SNMPostProcessDepthOfField' der zum
  aktivieren und ansteuern eines 'Tiefenunschärfe'-Effektes dient. Dieser Effekt MUSS hier liegen da dieser im Gegensatz
  zu den anderen Effekten zusätzliche Bild-Informationen braucht die ein Scene Renderer liefern muss damit das klappt.
  Derzeit unterstützt nur 'SRShaderLighting' diesen Effekt der wenn DOF aktiv ist in den Alpha Kanal des Bildes im Ambient
  Render Pass noch 'blur' Informationen ablegt die dieser DOF Effekt verarbeitet. So eine extreme spezialisierung durch
  'build in Effekte' lässt sich leider nicht immer vermeiden, passt aber nun wenigstens noch ins Design da dies für den
  User nach außen hin trotzdem 'nur' ein Modifier ist. Die Daten für diesen Effekt liegen direkt in 'Standard.pak'.
- Legte in PLPlugins ein neues Projekt Namens 'PLPostProcessEffects' an. In diesem Projekt liegen nur Post Processing Scene
  Node Modifier die man an Kameras 'anhängen' kann. Die Daten dieses Projekts liegen in 'PLPostProcessEffects.pak', also dort
  wo schon immer diese Post Process Daten lagen - nur das dies nun besser passt. Das sind wirklich nur rein optionale Dinge.



>> 07.08.2007
[CO]
- SceneRenderer::SetRenderTarget() liefert nun PLBool zurück damit man mitbekommen kann wenn das wechseln des Render Targets
  fehlschlug. Überall wo SetRenderTarget() vom Renderer oder SceneRenderer verwendet wird, wird nun sauber abgefragt ob
  der wechsel gut ging - denn das kann durchaus mal fehlschlagen.
- SRPostProcess::SetRenderTarget() besser strukturiert + bessere Fehlerbehandlung... hier konnte es zu einem Crash kommen
  wenn gerade ein Post Process aktiv war und das Fenster minimiert wurde.



>> 04.08.2007
[CO]
- SNSpotLight & SNProjectiveSpotLight: Durch die nun an der y-achse gespiegelten Texturen (also relativ gesehen zu dem wie
  es vorher war *g*) war eine Trennung zwischen 'Shadow'-Matrize und 'Textur'-Matrize nötig. Das ist allerdings nicht
  wirklich dramatisch da eine solche Trennung spätestens mit dem Implementieren verschiedener Shadow Mapping Algorithmen
  nötig geworden wäre - denn viele Algorithmen modifizieren die 'Shadow'-Matrize.



>> 01.08.2007
[CO]
- SNLoadScreen: Neues Flag spendiert: 'NoImageBlend': Darüber kann man das überblenden der Bilder deaktivieren



>> 31.07.2007
[CO]
- Neuer Scene-Loader: SceneLoaderX: Kann 'x'-Dateien als Szenen einladen, dabei wird die 'XProcessor'-Hilfs Klasse aus
  PLMeshs verwendet (siehe Eintrag oben :) so das der Implementations-Aufwand relativ gering war.
-> Ganz nebenbei hab ich während den Arbeiten wieder so einige Bugs und unvollständige PL Dinge gefunden, lohnt also immer
   wieder 'was neues anzufangen' um bestehendes zu Prüfen. :D



>> 30.07.2007
[CO]
- SceneNode: Neue Funktion: SetTransformMatrix(): Setzt direkt eine Transform Matrix
- SceneContainer: 'Filename'-Variable aus der Loadable-Basis Klasse ans RTTI angestöppelt damit man auch 'von Außen' einen
  Container laden kann. Somit kann man nun auch direkt über z.B. das PL-Scene Format Szenen aus anderen Dateien 'einbetten'.



>> 23.07.2007
[CO]
- Einige Zeiger auf Referenzen umgestellt



>> 21.07.2007
[CO]
- Einige Zeiger auf Referenzen umgestellt



>> 29.05.2007
[CO]
- Komplettierte die Änderung vom 19.05.2007 ('m_nDebugFlags'-Variable von SceneNode ans RTTI angestöppelt) soweit. Nun
  haben diverse Nodes Debug Informationen die man ein/ausblenden kann - ziemlich hilfreich. :)
- SNMesh nutzt nun die Debug-Flags von SceneNode anstatt das nochmal selbst zu implementieren
- In InputHandler::Reset() geflickt: 'm_bFirstLoop' wird nun auch noch zurückgesetzt. Dadurch verschwindet z.B. wenn ein
  Fenster den Fokus bekommt das schlagartige springen der Kamera wenn diese gerade durch die Maus gesteuert... etwas das
  mich fast in den Wahnsinn trieb. *g*



>> 25.05.2007
[CO]
- SceneNodeModifier: 'm_sSceneNodeClass' RTTI Variable 'read only' gemacht
- Konsole: 'debugmode'-Befehl zu 'setloglevel' gemacht und implementiert
- Konsole: 'dlist'-Befehl zu 'bulkylist' gemacht, so kann man 'debugdialog' das ich selbst häufiger nutze über
  Autovervollständigung noch etwas zügiger eingeben
- Load Screen Nodes liegen nicht mehr in einem eigenen Ordner, das ist unnötig wegen diesen zwei Dateien... es werden
  bestimmt nicht so bald mehr werden :)



>> 20.05.2007
[CO]
- Speicherleck in SNConsole::UpdateFunction() beseitigt: Der Win32-File Handle wurde nicht wieder geschlossen
 (lustig das dies bis jetzt noch nicht aufgefallen war :)



>> 19.05.2007
[CO]
- SurfacePainter + davon abgeleitete Klassen durchgeschaut und wo nötig Destruktoren hinzugefügt + bestimmte Dinge 'protected'
  oder gar 'private' (wo z.B. nicht weiter abgeleitet werden können soll) gemacht so das die Sichtbarkeit soweit korrekt ist
- SceneNode: 'CustomFlags' entfernt da unnötig da nur sehr begrenzt und wenig universell einsetzbar. Will man zusatz-Infos
  in Nodes haben, muss man das entweder in abgeleiteten Klassen selbst implementieren - oder eleganter und universeller:
  Man hängt einfach einen Modifier an der eventuell einfach nur zusatz-Infos bereithält.
- 'm_nDebugFlags'-Variable von SceneNode ans RTTI angestöppelt. Wir hatten uns zwar vor x-Jahren mal dagegen entschieden -
  allerdings ärgerte ich mich nun schon einige mal darüber das ich Debug Informationen im z.B. Debug Dialog nicht ändern
  konnte oder entsprechende Funktionalitäten in z.B. den Editoren recht umständlich und wenig flexibel per Hand coden
  musste. Das ist alles viel eleganter und universeller wenn das direkt wie alles andere auch übers RTTI läuft - und man
  kann wenn solche Informationen nie gezeigt werden sollen (damit z.B. Spieler in Games darüber nicht schummeln können) das
  immer noch intern deaktivierbar machen wenns soweit ist.
  Diese Variable ist zudem nun anstatt 'uint8' 'uint32' da auch abgeleitete Klassen dort neue Flags hinzugefügen können und
  dies auch tun. Mit der 'CustomFlags' Änderung zusammen benötigt eine SceneNode nun zwar 2 Byte mehr Speicher, aber ich
  denke das überlebt man. *g*
  Sollten die Flags irgendwann in einer abgeleiteten Klasse mal nicht mehr reichen, man also insgesammt dann über 32
  verschiedene Einstellungen hat - so muss man dort dann einfach wenn nötig 'ExtendedFlags' oder so selbst hinzufügen.
  (über 32 Flags würden zudem z.B. den Flags-Dialog ziemlich unübersichtlich machen)
- Fügte beim SceneNode Interface beim 'Protected data'-Teil noch ein Kommentar hinzu. Diese Dinge sollten nie direkt von außen
  geändert oder verwendet werden da oft intern das 'Lazy Evaluation'-Schema verwendet wird wo jederzeit 'genau' bekannt sein
  muss welche Einstellung welche Werte haben - derzeit sind diese nur protected damit man über die RTTI Makros in abgeleiteten
  Klassen Default-Einstellungen ändern oder z.B. neue Flags hinzufügen kann. Sobald wir das eleganter gelöst haben sollten
  diese Daten sofort private werden. Das gleiche bei SceneNodeModifier. Schaute zur Sicherheit gleich alle Projekt durch um
  sicherzustellen das diese 'Regel' eingehalten wird. Ich weis, ist nicht sonderlich 'schön' oder 'sicher', derzeit gehts
  aber leider nicht anderst.
- SNConsoleBase: 'debug'-Befehl herausgenommen da dies über die Konsole mittlerweile etwas zu umständlich ist - dafür ist
  der beqeumer zu verwendende Debug Dialog da.



>> 18.05.2007
[CO]
- SNMRectangle: 'DepthTest' zu Flag gemacht
- SNCoordinateAxis: 'DepthTest' zu Flag gemacht
- SNParticleGroup: 'PointSprites' & 'UseGlobalColor' zu Flags gemacht
- SNPoint: 'DepthTest' zu Flag Namens 'NoDepthTest' gemacht + 'NoPos3D' hinzugefügt
- SNCamera: 'UseZFar' zu Flag namens 'NoZFar' gemacht
- SCStaticCamera: 'DeactivateCameras' & 'DebugCameras' zu Flags Namens 'NoDeactivateCameras' & 'NoDebugCameras' gemacht



>> 17.05.2007
[CO]
- GuiDebugTexture::Initialize() & GuiPL::CheckMouseIn() & GuiPLWindow::SystemSetZPos() nutzen intern nun List-Iteratoren
  was hier natürlich besser ist
- GuiPLWindow::SystemDestroyWindow(): Implementation war nicht ok
- GuiPLImage::SystemLoadImage(): Hier fehlte das speichern des Bild-Namens... was zu einem Speicherleck führte und es wurde
  immer und immer mehr Speicher reserviert
- Einige 'using namespace PLRenderer;' eingefügt
- SNBitmap::DrawPost() berücksichtigt nun auch Rotation & Scale so das man dadurch noch mehr Möglichkeiten hat
- SNBitmap: 'Pos3D' & 'Center' zu Flags gemacht
- SNLine: 'Pos3D' & 'DepthTest' zu Flags Namens 'NoPos3D' und 'NoDepthTest' gemacht
- SNLineBox: 'Pos3D' & 'DepthTest' zu Flags Namens 'NoPos3D' und 'NoDepthTest' gemacht
- SNLineGrid: 'DepthTest' zu 'NoDepthTest' Flag gemacht
- SNText: 'Pos3D' & 'DepthTest' zu Flags Namens 'NoPos3D' und 'NoDepthTest' gemacht
- SNSound: 'Stream' & 'Loop' & 'StartPlayback' zu Flags Namens 'Stream', 'NoLoop' und 'NoStartPlayback' gemacht



>> 11.05.2007
[CO]
- Transformer Scene Nodes zu Modifier gemacht und in 'Transform Gizmo' unbenannt. Das wollte ich nun schon seit geraumer
  Zeit mal ausprobieren da dies so herum irgendwie sinniger ist - und es klappt sogar ziemlich gut so das man auch wunderbar
  kombinieren kann - z.B. einen Position UND Rotation Transform Gizmo Modifier gleichzeitig anhängen. :)
  Hab mal zum damit herumspielen in 'MiniDungeon.scene' Lichtquellen und/oder anderen Objekten so nen 'Transform Gizmo'
  angehängt und dann direkt mit der Maus herum bewegt - wow, das ist verdammt cool! Nur noch etwas an diesen Modifiern feilen
  damit diese so komfortabel wie möglich zu bedienen sind, dann iss das eine sehr universelle und feine Sache. :)



>> 10.05.2007
[CO]
- Sortierte ins Diary so richtig alte Einträge aus "PLSDK/internal/old_diaries.zip" ein



>> 09.05.2007
[CO]
- Alte Diary Einträge von ab "21.03.04" einsortiert



>> 06.05.2007
[CO]
- Etwas an den SNTransformer-Scene Nodes geschraubt



>> 29.04.2007
[CO]
- Neue Scene Node: PLEngine::SNHelper: Ich überlegte schon seit geraumer Zeit ob ich diese Scene Node hinzufügen sollte, denn im Grunde
  ist es das gleiche wie SNUnkown, also praktisch ein 'Dummy' der nix macht - aber als 'Hilfs'-Scene Node verwendet werden kann
  um z.B. aus grundliegenden Scene Nodes/Modifiern nette Dinge zu basteln. (siehe z.B. Marble Madness Beispiel-Szene :)
  Ein gutes anwendungs Beispiel ist ein zusammenwirken von 'PLEngine::SNMAnchor' und 'SNMTargetRotation': Will man z.B. Die Kamera immer
  zum Helden schaun lassen nutzt man 'SNMTargetRotation', was aber nun wenn der Nullpunkt des Helden bei den Füßen ist? Immer
  nur die Füße anstarren? *g*
  Für soetwas kann man wunderbar eine 'Hilfs'-Scene Node einsetzen: 'PLEngine::SNMAnchor' wird genutzt um eine 'Hilfs'-Scene Node am
  Kopf zu 'befestigen' die sich mit der Scene Node, oder gar mit einem Joint eines von dieser verwendeten Skeletons mitbewegt.
  'SNMTargetRotation' 'schaut' dann zu dieser 'Hilfs'-Scene Node anstatt zum Helden selbst.
  Der einzige 'Unterschied' zwischen PLEngine::SNHelper und SNUnknown ist also die übliche Verwendungsart. PLEngine::SNHelper wird genutzt um
  ausdrücklich nur als 'Hilfs'-Scene Node verwendet zu werden, 'SNUnknown' repräsentiert hingegen eine 'Unbekannte'-Scene Node
  - wenn z.B. etwas beim Import in PL, oder beim Export aus Max einer Szene ein Node-Typ unbekannt ist. Zur Sicherheit sollten
  solche Nodes dann nicht einfach ignoriert werden da diese durchaus das 'Ziel' von z.B. 'SNMTargetRotation' sein könnten.
- SNMTargetRotation & SCStaticCamera: Entfernte 'TargetOffset', 'TargetJoint' und 'TargetJointOffset' Variablen da man das
  mittlerweile problemlos über 'PLEngine::SNMAnchor' + 'PLEngine::SNHelper' realisieren kann ohne bestimmte Funktionalitäten in einem oder
  jedem (!!) anderen Modifier erneut zu implementieren. Ganz nebenbei kann man sich so nun auch dieses 'Ziel' über
  Debug-Funktionalität Visualisieren lassen so das man genau sehen kann 'wo' dieser Punkt ist was recht hilfreich ist + dieses
  'Ziel' kann man locker mehrmals von verschiedenen Stellen aus nutzen ohne jedesmal Offsets etc. von neuem einstellen zu
  müssen... mir fallen eigentlich nur Vorteile bei dieser recht einfachen und universellen Lösung ein. *g*
- SNSound: 'Stream' Variable hinzugefügt und 'm_sSoundFilename' in 'm_sSound' umbenannt



>> 28.04.2007
[CO]
- Fing mit dem ShadowMap-Manager an. Für's erste verschob ich den ShadowMap Code aus SRShaderLighting in den ShadowMap-Manager
  den ich Schrittweise ausarbeiten werde.
- GuiDebugScene::~GuiDebugScene(): Hier muss beim 'unselektieren' natürlich geprüft werden ob's eine Scene Node
  oder ein Scene Node Modifier ist
- Neuer Scene Node Modifier: SNMMoveToTarget: Bewegt eine Scene Node zu einer Ziel Position
- SNMFixRoll: 'm_fSpeed'-Variable wurde warum auch immer nicht verwendet, korrigiert
- SceneNode::SetFrozen(): Flags waren vertauscht, korrigiert
- GuiDebugScene: 'Use Camera'-Button herausgenommen da dieser mittlerweile nicht mehr ins Konzept passt und daher auch seit
  geraumer Zeit nicht mehr Implementiert war - z.B. PLSceneViewer bietet dafür eine eigene Option und in konkreten Anwendungen
  muss das jeder bei bedarf selbst Implementieren.
- SNMPath::InformedOnUpdate() nutzt nun 'MoveTo()' anstatt 'SetPosition()', das ist 'sicherer' so herum (Portale etc.)
- SNSound: 'Volume' & 'Pitch' RTTI Variablen Minimum auf 0 gesetzt
- SNSphereFog: 'Range' ein Minimum verpasst, 'Volumetricy' hingegen kann weiterhin negativ sein - gibt einen lustigen Effekt *g*



>> 26.04.2007
[CO]
- SceneLoaderPL eine kleine Lade/Speicher Statistik spendiert



>> 21.04.2007
[CO]
- Nochmal eine Wagenladung 'return' und 'continue' entfernt, vorallem in den Scene Renderern sieht das nun sehr lustig aus,
  ist aber denk ich trotzdem etwas 'Übersichtlicher'... zudem werd ich hier später wenn möglich Aufgaben weiter Aufteilen.



>> 20.04.2007
[CO]
- SNParticleGroup.h: 'Float2'-Typedef entfernt
- Die Klasse 'Particle' ist nun in 'SNParticleGroup' eingebettet da dieses hierzu gehört



>> 14.04.2007
[CO]
- SceneLoaderPL::LoadRec(): Hier muss natürlich auch noch über 'PL::IsShutDown()' geprüft werden ob das Programm nicht während
  dem Laden 'terminiert' werden soll - man kann ja bei einem Ladebildschirm jederzeit den Frame einfach so schließen *g*
- PL::Update(): Wird dieses Funktion aufgerufen obwohl sich die Engine gerade 'beenden' soll, so liefert die Funktion nun
  sofort 'false' zurück ohne irgend etwas zu machen
- PL::InitEngine(): Nur wenn die Config-Variable 'EngineGeneralConfig->DebugMode' auf '1' steht wird Log Level hier auf
  Debug gestellt



>> 13.04.2007
[CO]
- Einige 'return' entfernt



>> 08.04.2007
[CO]
- 'using namespace' Änderungen, dort wo das alte Input System verwendet wird gabs natürlich wieder OS Namenskonflikte :/



>> 07.04.2007
[CO]
- SceneLoaderMap & SceneLoaderProc in das neue PLPlugins Projekt 'PLPlugins_idSoftware' verschoben
- Neuer Scene Node Modifier: SNMMeshJoint: Damit lässt sich gezielt ein Joint über das Szene Format manipulieren. In
  der Beispiel-Szene 'SceneNodeModifiers.scene' wird dieser Modifier dazu genutzt das einer der Soldaten mit dem Kopf ein
  Ziel 'verfolgt', zwar ist die Implementation noch nicht komplett, aber er klappt bereits erstaunlich gut und ist vorallem
  halbwechs universell. :)



>> 05.04.2007
[CO]
- SNCamera: Flags 'InvCullMode' und 'UseClipPlane' hinzugefügt da ich diese für die Wasser Scene Node Implementation
  in PLSamples benötigte. Ob das später so in der art drinnen bleibt weis ich nicht - auf jedenfall ermöglicht es wie man
  sehen kann nun noch mehr einfache Anwendungsmöglichkeiten.



>> 04.04.2007
[CO]
- Header-Änderungen + Codes noch hier und da etwas aufgeräumt



>> 02.04.2007
[CO]
- Fing mit den Header-Änderungen an



>> 20.03.2007
[CO]
- PL::GetSoundManager(): Sound wird erst dann Initialisiert wenn das zum ersten mal benötigt wird, ist das nie der Fall,
  so wird auch nie Initialisiert. :)



>> 16.03.2007
[CO]
- Bugfix: PL::InitEngine(): 'FirstRun' Config Einstellung wurde nicht aktualisiert



>> 13.03.2007
[CO]
- Weiter am Input System herum gehackt damit es wieder unter Linux Übersetzbar ist... igh, so langsam kann ich das Teil
  wirklich nicht mehr sehen da es nun auch noch das schöne Header Design schrottet da ab der Verwendung des Input
  Systems sofort wieder OS Header reinflutschen die natürlich wie üblich gleich eiftig herumzicken. :(
  Ich brauchte sehr viele anläufe bis ich das mit den OS Defines endlich so hin gefummelt hatte das es ging.
  Diese Hacks sind natürlich nur auf das Input System beschränkt, da wollte ich nicht wieder anfangen alle Projekte
  mit Define-Hacks zuzumüllen. *g*



>> 05.03.2007
[CO]
- SNSpotLight: 'Aspect' + 'ZNear' RTTI Variablen hinzugefügt



>> 03.03.2007
[CO]
- SNProjectiveSpotLight: Verschob die Texture Matrix in SNSpotLight, denn für z.B. Shadow Mapping benötigt man diese natürlich
- SRShaderLighting: Shadow Mapping wieder fitt gemacht, das z-fighting ist allerdings leider noch ein echtes Problem



>> 01.03.2007
[CO]
- InformedOnDrawPost() etc. von SceneNodeListener bekommen auch noch den Sichtbarkeits-Knoten + verwendeter Renderer übergeben
- Neuer Scene Node Modifier: SNMRectangle: Zeichnet ein Rechteck um die dazugehörende Scene Node - eine weitere nette Anwendung
  von Scene Node Modifiern :)



>> 22.02.2007
[CO]
- SNConsole::UpdateFunction(): Machte das einlesen der Log-Zeilen übersichtlicher und sicher vor Buffer Überläufen



>> 16.02.2007
[CO]
- Der neue Loadable Manager Dialog kann von der Konsole oder vom Debug Dialog aus geöffnet werden



>> 11.02.2007
[CO]
- Auf VC 2005 umgestellt



>> 02.02.2007
[CO]
- SNMTargetRotation: Ändert sich die Position der besitzenden Scene Node, so wird die Rotation derer nun ebenfalls aktualisiert,
  dadurch verschwindet ein sehr unschönes 'zittern' wenn dieser Modifier 'vor' einem Positions ändernden Modifier ausgeführt
  wird. Diese Lösung gefällt mir zwar nicht wirklich, aber momentan wüsste ich nicht wie man soetwas besser machen könnte.
  Eventuell fällt uns später ein geschickteres Modifier System ein welches solche Fälle ebenfalls behandeln kann.
- SNMMoveController: Entfernte den Rotations-Steuerungsteil in diesem Modifier. Zukünftig kann man darüber 'nur' noch die
  Position ändern, für das ändern der Rotation gibts bereits seit längerem 'SNMMouseLookController'. Passte alle Projekte
  entsprechend an. Orbiter Kameras nutzen z.B. 'nur' SNMMoveController, denn das ändern der Rotation 'per Hand' führt
  üblicherweise zu einem unschönen 'zittern' da der 'SNMTargetRotation' Modifier ebenfalls die Rotation aktualisiert.
- 'SNMMouseLookController' um die Flags 'NoLeftMouseButton' und 'NoRightMouseButton' erweitert damit man die Steuerung im
  Zusammenhang mit z.B. 'SNMMoveController' besser einstellen kann
- Bugfix: InputHandler::InputHandler(): 'm_SMouse.nMouseWheelDeltaSet' wurde nicht Initialisiert
- GuiPL::SystemCreateTimer(): Hier sollten wir am besten erstmal einen Timer vom 'Naive-Gui' anfordern da der Thread-Timer
  'sehr' langsam ist. Sobald solche Timer ins Spiel kommen ruckelt es bis zum geht nicht mehr aufgrund der nötigen
  Synchronisation... dadurch ist so ein Timer für diese Anwendung leider derzeit unbrauchbar. (in z.B.
  PLSampleCharacterAnimation viel das auf) Eventuell fällt uns für 'PLGui::ThreadTimer' irgendwann eine geschicktere
  Implementation ein durch die man diese blockierende Synchronisation irgendwie 'lockern' kann.



>> 28.01.2007
[CO]
- VC Projekt-Dateien wie besprochen in die jeweiligen Grundordner verschoben



>> 27.01.2007
[SB]
- CMake Projektdateien für alle PLEngine-Projekte hinzugefügt 



>> 19.01.2007
[CO]
- SRShaderLighting: 'Spot Cone' Funktioniert nun, damit kann man auch Spot Lights ohne Projezierte Textur machen



>> 17.01.2007
[CO]
- Bugfix: Neue Funktion SceneGraph::IsNodeTouched(): Prüft ob eine Node gerade bereits verarbeitet wurde. An einigen Stellen
  wie z.B. in SQCull darf man nicht einfach SceneGraph::TouchNode() nutzen. Dort muss man zuerst prüfen ob die Node bereits
  verarbeitet wurde, dann ob diese zu verarbeiten ist und erst DANN wird diese als 'verarbeitet' markiert.
  Mir ist durchaus klar das dieses aktuelle Konzept nicht Multithreading-Safe und 'schön' ist. Da können wir später gemeinsam
  schaun wie man das noch besser machen kann. Die Thematik ist auf jedenfall nicht ohne... vorallem da unser System so krass
  flexibel ist, z.B. gilt es auch endlos-Schleifen zu erkennen und zu vermeiden wenn z.B. ein Portal durch ein Portal sichtbar
  ist und durch dieses Portal wieder das andere. (wenns *wirklich* total dumm läuft kann das schonmal passieren! :)
  Auch ist die 'eine Zelle kann durch mehrere Portale gleichzeitig gesehen werden'-Thematik nicht ohne. Zeichnet man dann
  die Zelle bzw. alle 'durch mindestens eines der Portale sichtbaren' Nodes nur einmal, aber über ein 'zusammen gefasstes'
  Scissor Rectangle, oder zeichnet man jeweils 'nur' das was über ein aktuelles Portal sichtbar ist mit der Gefahr Nodes
  doppelt zu zeichnen... derzeit machen wir das letztere da es so irgendwie 'schöner/einfacher' ist, und das 'überzeichnen'
  von Fragmenten ist recht selten, das doppelte zeichnen von Nodes an sich kommt jedoch schonmal bei vielen sichtbaren
  Portalen häufiger vor. Wie gesagt, wenns soweit ist sollten wir uns das gemeinsam alles nochmal genau anschaun.



>> 12.01.2007
[CO]
- Bugfix: GuiPL::SystemProcessMessages(): 'nKey' muss signed sein
- Bugfix: Input::IsKeyPressed(): Bei "Check input handler" wurde 'false' statt '-1' zurückgegeben
- Bugfix: SceneNode::GetBoundingSphere(): In der Berechnung wurde direkt auf die Bounding Box zugegriffen... es ist aber
  ratsam dies IMMER über z.B. die Funktion GetAABoundingBox() zu machen damit die Bounding Box falls nötig aktualsiert wird.
- Bugfix: SceneNode::GetBoundingSphere() und SceneNode::GetContainerBoundingSphere() berechneten den Radius falsch was darin
  endete das der Radius immer zu klein war. (es wurde der in der Box liegende und nicht der Box einschließende Radius berechnet :)
  Die GetBoundingSphere()-Funktionen nutzt nun direkt die neue PLMath::AABoundingBox::GetEnclosingRadius() Funktion während
  in GetContainerBoundingSphere() das leider weiterhin per Hand berechnet werden muss.
- Bugfix: SceneNode::SetRotation(): Hier muss natürlich auch noch das 'RecalculateContainerBoundingSphere'-Flag gesetzt
  werden da sich eventuell die größe der Container Space Sphere ändert
- SceneNode::DrawDebug(): Visualisiert nun auch die Bounding Sphere
- SRShaderLighting::OnDraw(): RenderLighting() Verwendung nach z.B. PrepareLightEffects() -> so hat die GPU etwas mehr Zeit
  um z.B. zu Prüfen ob eine Licht Korona gezeichnet werden soll. (Occlusion Query)
- SRShaderLighting: Falls es sich um ein Spot-Licht handelt wird nun die zu Beleuchtende Scene Node zusätzlich noch gegen
  den Licht-Frustum geprüft, und erst wenn auch dieser Test gut ging wird die Scene Node wirklich beleuchtet.
  (potentiell weniger zu verarbeitende Scene Nodes = im schnitt etwas bessere Performance :)



>> 05.01.2007
[CO]
- SNSpotLight: 'NoCone'-Flag von 'SNProjectiveSpotLight' nach 'SNSpotLight' verschoben
- SRShaderLighting: Implementierte Support für den Licht-Kegel aus SNSpotLight -> ist noch nicht funktionsfähig, glich aber
  an da Jens ein aktuelles SDK will in dem "SRShaderLighting verwendet die LightMaps nun genauso wie z.B. SRBasic"
  funkt.



>> 04.01.2007
[CO]
- SNCamera: Die Kamera Klasse arbeitet intern nun vergleichbar zu SNSpotLight, also nach dem 'Lazy Evaluation'-Schema.
- SNSpotLight::UpdateBoundingBox(): Hier wird nicht mehr einfach nur der Licht Radius verwendet, sondern die Frustum Vertices
  was zu einer kleineren Bounding Box führt. :)
- SRShaderLighting verwendet die LightMaps nun genauso wie z.B. SRBasic



>> 03.01.2007
[CO]
- GuiPLGraphics::DrawGradientBox() Implementiert: GuiPLGraphics hat nun einen eigenen Vertex Buffer, daher veränderte ich
  GuiPL::SystemCreateGraphics() und GuiPL::SystemReleaseGraphics() damit nicht xx mal pro Frame ein GuiPLGraphics Object
  sammt Vertex Buffer erzeugt und wieder zerstört wird, sondern nur etwas neues erzeugt wird wenn gerade nichts altes mehr
  frei ist. Die Implementation von DrawGradientBox() ist fast identisch mit der entsprechenden Renderer Funktion, nur die
  Vertex Farben werden hier je nach Winkel entsprechend Berechnet... dabei klappte die 'Farb-Rotation' sogar besser als
  erwartet. Die Farben werden einfach einmal Horizontal, und einmal Vertical berechnet und danach gemischt - fertig. :)



>> 22.12.2006
[CO]
- An ein paar Stellen wurde der Element Typ von Index Buffern nicht korrekt gesetzt da die Anzahl der Indices, und nicht
  die Anzahl der Vertices verwendet wurde... aber der Typ gibt natürlich den größten speicherbaren Vertex Index an. :)
- Nahm einige Code Umformungen vor (hauptsächlich bei for-Schleifen) um die Lesbarkeit zu erhöhen



>> 19.12.2006
[CO]
- SCMirror: Ersetzte die Variable 'TextureStage' durch 'DynamicMap'. Anstatt direkt eine Textur Einheit anzugeben wird nun
  nur noch der Material Textur Parameter benannt in dem die Dynamische Textur landen soll... das passt viel besser zum
  Material System. :)



>> 17.12.2006
[CO]
- SNLoadScreen: Gibt die verwendeten Materialien frei sobald diese nicht mehr benötigt werden



>> 16.12.2006
[CO]
- Nahm die 'Unload' Funktionalität aus den Debug Dialogen heraus da dies mittlerweile in der ResourceManagerDialog Basis
  Klasse universell gehandhabt wird



>> 15.12.2006
[CO]
- SRShaderLighting:
  - Da während dem Render-Prozess an verschiedenen Stellen mehrmals pro Frame bestimmte feste Strings erzeugt und danach
    wieder zerstört wurden machte ich diese Strings zu statischen Privaten Variablen von SRShaderLighting
  - Die dynamisch zusammengestellten Shader haben nun besser lesbare Namen



>> 09.12.2006
[CO]
- Fügte an einigen Stellen 'pRenderer->SetFontSize()' und 'pRenderer->SetFont2D(PLEngine::PL::GetDefaultFont2D())' ein da
  man nie weis was gerade Eingestellt ist...



>> 08.12.2006
[CO]
- Neue Scene Node: SNLineBox: Zeichnet eine Linien Box. Wird derzeit in den Editoren als 'Farblicher Rahmen' mißbraucht wenn
  ein Viewport gerade selektiert ist. :)
- Neue Scene Node: SNLineGrid: Zeichnet ein 2D Linien Netz, wird bereits in den Editoren genutzt



>> 02.12.2006
[CO]
- PL: LoadFSSettings() und SaveFSSettings() entfernt da der Loadable-Manager in PLGeneral nun eine entsprechende Funktionalität
  bereitstellt.



>> 01.12.2006
[CO]
- Stellte die 2 Terrain Scene Nodes (die später noch komplett überarbeitet werden müssen) auf das Loadable-System um



>> 30.11.2006
[CO]
- Post Process Loader + Implementation für unser eigenes Format hinzugefügt



>> 25.11.2006
[CO]
- Sky Loader + Implementation für unser eigenes Format hinzugefügt
- Skin Loader + Implementation für unser eigenes Format hinzugefügt



>> 24.11.2006
[CO]
- Alle Projekte an das Loadable-System angepasst



>> 17.11.2006
[CO]
- Neue Scene Nodes: SNCoordinateAxis ist eine abstrakte Basis Klasse zur Visualisierung eines Koordinaten Systems. Davon
  gibt es die Implementationen SNCoordinateAxisRotation welches die Rotation zeigt (Scene Node lag früher in PLSampleSceneNodes)
  und die Implementation SNCoordinateAxis3D welche Räumliche Achsen direkt in der 3D Szene anzeigt. Da man die Visualisierung
  des Koordinaten Systems an verschiedenen Stellen (u.a. auch in den Editoren) immer wieder braucht, sind solche Scene Nodes
  direkt in der Engine denk ich recht sinnig.



>> 12.11.2006
[CO]
- Stellte die Konsole auf die String Klasse um und räumte die mittlerweile recht alten Codes etwas auf



>> 10.11.2006
[CO]
- SNMesh: Die Bounding Box von Animierten Meshs wird nun korrekt aktualisiert... auch die Bounding Box von Ragdolls werden
  somit korrekt aktualisiert. (in 'PhysicsMouseInteraction.scene' verschwindet das Ragdoll nicht mehr :)



>> 09.11.2006
[CO]
- SCRenderToTexture: Bugfix: Hier fehlte bei den Flags die Definition von 'NoRecursion' -> War verantwortlich für die
  'Grafik Bugs' in PLSampleInGameGui.
- SRBasicLighting: Arbeitet nun mit lokalen Light Stacks anstatt eines globalen... damit klappt das auch im zusammenspiel
  mit Rekursionen besser. (die Implementation ist trotzdem noch im höchsten maße Experimentell! :)
  -> Nun wird die Teekanne in z.B. 'Mirror.scene' bei bestimmten Blickwinkeln nicht mehr 'dunkel'.



>> 08.11.2006
[CO]
- SNLoadScreen um Einstellungen erweitert ob/wie der Bildschirm gelöscht werden soll



>> 04.11.2006
[CO]
- SNBitmap: Bugfix: War die Bitmap im '2D'-Modus, so wurde diese nicht korrekt platziert da die World Matrize nicht
  zurückgesetzt wurde
- PL::InitRenderer() & GuiPLFont::SystemCreateFont(): Bei der 'Schrift' wird die Textur Qualitäts-Einstellung ignoriert



>> 03.11.2006
[CO]
- EngineGeneralConfig: 'MaxTimeDifference' und 'FPSLimit' Einstellungen hinzugefügt damit man diese wichtigen Timer Einstellungen
  auch 'von außen' vornehmen kann. Da die Config den Wert nochmal selbst speichert bekommt man momentan leider wie auch bei
  ähnlichen Stellen 'inkonsistente' Einstellungen wenn jemand z.B. direkt die Timer Funktionen zum ändern dieser Werte
  nutzte. Hier wäre eine art von 'mapped RTTI variable' nett welche anstatt die Variable selbst zu speichern nur als 'RTTI interface'
  für diese Variable dient. Über VarChanged() kann man bereits problemlos aktuelle Variable Werte dem Grundsystem korrekt mitteilen,
  nett wäre es, wenn es auch anderst herum ginge - das im Falle einer 'mapped variable' eine entsprechende Virtuelle Funktion
  aufgerufen wird welche den Wert zurückgeben soll anstatt den Wert einer Variable direkt zurückzugeben. So könnte ich als
  User diese 'Get'-Anfrage direkt an das zugrunde liegende nicht RTTI System weiterleiten.
- EngineGeneralConfig: 'Language': Die zu verwendende Sprache, ist dieser String leer, so wird die aktuelle System Sprache
  verwendet. (das System ist noch nicht komplett implementiert)
- PL::InitEngine(): Nahm die speziellen Win32 Funktionen zum einstellen der Main Thread Priorität heraus. In EngineGeneralConfig
  befinden sich zwei neue weitere Optionen über die man die Main Thread Priorität einstellen kann - dies läuft nun über die neuen
  PLGeneral::Thread-Funktionen.



>> 31.10.2006
[CO]
- SRBasic: Beim Emissive Pass Polygon Offset aktiviert um eventuelle z-fighting Probleme zu veringern
  (Jens meinte die Emissive Maps würden bei ihm nicht bzw. nicht korrekt dargestellt...)



>> 29.10.2006
[CO]
- Machte ein paar kleine Änderungerungen damit man wieder einen korrekten Ladebildschirm nutzen kann. Einfach z.B.
  'SNLoadScreen' in eine Szene möglichst 'am Anfang' einfügen, der Rest geht dann automatisch. (siehe 'PhysicsPlayground.scene')
- SNLoadScreen: Um ein paar weitere Einstellmöglichkeiten erweitert



>> 28.10.2006
[CO]
- Neuer Scene Node Modifier: SNMMouseLookController: Damit kann man über die Maus die Scene Node Rotation beeinflussen



>> 27.10.2006
[CO]
- Passte PLMesh::EffectLoader, PLMesh::MeshLoader, PLMesh::SkeletonAniLoader und PLEngine::SceneLoader an das neue Loader
  System an.



>> 25.10.2006
[CO]
- SRBasic & SRBasicLighting: Support für EmissiveMap eingebaut



>> 24.10.2006
[CO]
- SRBasic & SRBasicLighting: Support für LightMap & ReflectionMap eingebaut da dies von Jens & Tim angefordert wurde.
  (war zum Glück auch keine große Sache :) Baute desweiteren dort ein das man die einzelnen Map-Typen deaktiveren kann -
  was zum LightMap auf korrektheit Prüfen sehr nützlich ist. Auch hat dieser Szene Renderer nun ebenfalls 'AmbientColor'.



>> 21.10.2006
[CO]
- Reflection Mapping MUSS natürlich im World und NICHT im Objekt Space gemacht werden da ansonnsten die CubeMap mit der
  'Umgebung' druff nicht passt - hatte mich gestern schon gewundert wieso ich y/z Komponenten in meinem Beispiel vertauschen
   musste. *g* Fügte desweiteren einen 'ReflectionFactor' hinzu damit man einstellen kann wieviel Reflektiert wird.
- SceneNode: Neues Flag: NoLighting -> Damit kann man Beleuchtung für diese Scene Node verhindern, ist vorallem im zusammenspiel
  mit 100% Reflektion nützlich. Das klappt natürlich Rekursiv - man kann also auch die Beleuchtung gesammter Teil-Szenen
  damit 'unterdrücken'.
- SRShaderLighting um Lightmap Support erweitert da dies für die UBoot Szene benötigt wird. Dies ist die denkbar einfachste
  Implementation und reicht für's erste auch, aber sobald man auch 'Instanzing' nutzen will muss man das noch etwas erweitern.



>> 20.10.2006
[CO]
- SRShaderLighting: 2 Bugs gehoben:
  - DepthBias wurde fehlerhaft in der Config ausgelesen
  - Die falschen Materialien wurden zum Zeichnen von Meshs verwendet: Zuerst wird geprüft ob das Mesh überhaupt ein Material
    hat, anschließend werden alle Materialien durchgegangen und jeweils die Geometrien mit diesem Material gezeichnet... und
    hier gabs ein übles phuibah!... denn es wurde zum Zeichnen IMMER das erste Material verwendet welches vom ersten Test her
    ermittelt wurde - gut das Jens aufgefallen ist das da etwas nicht stimmte. :)
- SNMesh: Berechnet die BB des Meshs nun NUR noch wenn das Mesh gerade keine korrekte BB hat, dadurch muss die BB nicht zig
  mal neu berechnet werden.
- SRShaderLighting um 'ReflectionMap' erweitert da dies von Jens & Tim angefragt wurde (für diese UBoot Brücke :)



>> 19.10.2006
[CO]
- SNMesh: Kann nun weitere Debug-Informationen zeichnen lassen wenn die Node selbst gerade im Debug Modus ist... In
  PLSampleCharacterAnimation kann man sich nun wieder u.a. das Skelett einzeichnen lassen.



>> 14.10.2006
[SW]
Alle Projekte: finale version für das visibility attribute feature vom gcc.



>> 11.10.2006
[SB]
Wieder diverse Anpassungen:
- Überbleibsel aus einem alten Merge-Error aus dieser Datei entfernt
- Unnötigen [DEBUG]-Kommentar entfernt
- PLLOCAL entfernt - dieses Makro nutzen wir nicht!
- Eingefügte Konstruktoren und Destruktoren mit Kommentaren versehen und in die richtige Reihenfolge gebracht



>> 11.10.2006
[SW]
Alle Projekte: Die projekte verwenden das neue visibility feature vom gcc, wenn vorhanden.



>> 04.10.2006
[CO]
- An ein paar Stellen (ColorX & VectorX) "String::Format(" durch ".ToString()" ersetzt



>> 28.09.2006
[CO]
- PL: Neue Funktion: GetNativeGui() -> Ersetzt die statische Gui-Instanz damit man den Gui Header nicht ÜBERALL einbinden muss.
  Da in diesem Gui Header u.a. PLGraphics::Color3 benötigt wird hätte man ansonnsten überall noch PLGraphics Include Pfade
  setzen müssen - ob man das nun wirklich brauchte oder nicht.



>> 25.09.2006
[CO]
- PLEngine auf PLBool umgestellt



>> 16.09.2006
[CO]
- Neue Scene Nodes: SNBillboard Basis Klasse + SNBillboardSpherical & SNBillboardCylindrical Implementationen



>> 15.09.2006
[CO]
- SceneNode: Neues Flag: 'NoCulling': Ist dieses Flag gesetzt, so wird für diese Node keine Sichtbarkeitsbestimmung
  durchgeführt so das diese Node immer 'Sichtbar' ist wenn diese Sichtbar ist. ;-)
- Neue Scene Node: SNBitmap: Damit kann man Bitmaps über das Scene System einbringen, z.B. für ein kleines Logo auf dem
  Bildschirm. :D (Bitmaps haben als Default keine Sichtbarkeitsbestimmung)



>> 14.09.2006
[CO]
- Beseitige Warnungen die erscheinen wenn der Compiler auf Warnungs-Level 4 gestellt wird



>> 13.09.2006
[CO]
- Dort wo PLRenderer::Buffer::Lock verwendet wird sollte immer mit angegeben werden was für Operationen auf dem Buffer stattfinden
  werden so das der Renderer intern das möglichst geschickt handhaben kann. Fügte dort wo das noch nicht der Fall war jeweils
  einen entsprechenden Lock-Typ ein... der jedoch wirklich nur als 'Verwendung-Hinweis' zu verstehen ist. Gibt man 'Read' an
  kann man trotzdem noch Schreiben, aber eventuell nicht mehr ganz sooo Performant - das hängt von einigen Faktoren ab. :)



>> 02.09.2006
[CO]
- SNEngineInformation: Wie von Jens gestern gewünscht kann man nun über die Bild-Hoch/Bild-Runter Tasten beim Profiling
  durchschalten wenn dieses aktiv ist. (er mochte das nicht das man immer die Konsole zum durchblättern öffnen muss *g*)
  Sollte das mit den Tasten irgendwann/wo mal Konflikte geben, kann man das immer noch etwas ändern so das man z.B. Strg
  dabei gedrückt halten muss.



>> 25.08.2006
[CO]
- VisContainer: Container & Portale müssen sich beim 'Sichtbarkeits-System' korrekt abmelden. Daher ist VisContainer nun
  ein Scene Node Listener und reagiert entsprechend sobald ein Container oder Portal über den Jordan geht.
- EngineGraphicConfig: SlopeScaleDepthBias & DepthBias zum Debugging hinzugefügt - so kann Jens selbst an diesen Werten
  drehen während das Zeug läuft und schaun bei welchen Einstellungen die Beleuchtung bei ihm ok ist... mit etwas Glück
  hilft das für's erste etwas. :)



>> 23.08.2006
[CO]
- PLEngine::SNMAnchor::UpdateAttachedNode(): Flags Abfrage war noch nicht ok.



>> 14.08.2006
[CO]
- Config: 'EngineGeneralConfig' um 'LogFormater' und 'LogFormaterParameters' erweitert damit man von außen diese Dinge
  einstellen kann.



>> 13.08.2006
[CO]
- SRShaderLighting: Machte die 'Cell Map' Erweiterung von gestern noch etwas universeller: Es gibt nun für Diffuse, Specular
  und Edge 'Ramp Maps' über die sich das Beleuchtungsverhalten noch etwas kontrollieren lässt. (klassische 'control maps' eben :)



>> 12.08.2006
[CO]
- SRShaderLighting: Da Jens bereits ein paar mal ansprach das er beim Soldaten gerne Cell Shading nutzen möchte erweiterte
  ich diesen Szene Renderer noch um eine 'Cell Map'. Ist diese Map in einem Material vorhanden, wird automatisch 'Cell Shading'
  verwendet was das Ergebniss Cartoon like aussehen lässt. Im Beleuchtungshader wird dann einfach die Diffuse Beleuchtung
  als Textur Koordinate dieser Cell Map verwendet wodurch sich dann die Beleuchtung ändern lässt - so das diese z.B. 'blockig'
  aussieht und keinen weichen Verlauf mehr hat. So langsam zeigt sich wie extrem mächtig dieses Shader System ist, denn neue
  'Material Features' lassen sich *sehr* einfach einfügen.



>> 09.08.2006
[CO]
- PLEngine::SNMAnchor: Flags hinzugefügt so das man die übernahme von Position und/oder Rotation deaktivieren kann... vorallem das mit
  der Rotation deaktivierbar machen ist sehr sinnig...



>> 08.08.2006
[CO]
- PostProcessManager: Es ist unnötig die Render Targets nach jedem Effekt wechsel zu zerstören, sollte sich am Textur Format
  etwas geändert haben, so werden diese Render Targets automatisch neu erzeugt.
- SceneContainer::Load(): Während eine Szene eingeladen wird, wird der Timer nun pausiert um eventuelle Timing Probleme zu
  vermeiden.



>> 06.08.2006
[CO]
- 'Light Shafts' hinzugefügt. Dieser ziemlich coole (und recht einfach zu realisierende :) Licht-Effekt baut auf
  SNProjectiveSpotLight auf und fügt einfach ein paar weitere Einstellmöglichkeiten hinzu. Wie üblich ist es dann Job
  eines Szene Renderers das beste daraus zu machen. :)



>> 31.07.2006
[CO]
- SNMTargetRotation um die Variable 'TargetJoint' erweitert so das man zu einem bestimmten Joint der Target Scene Node schaun kann.
- PLEngine::SNMAnchor um getrennte Offsets für Joints erweitert.



>> 28.07.2006
[CO]
- Fügte wie Stefan es Vorschlug in EngineGeneralConfig 'LoadLibsFromRuntime' hinzu damit man das laden von Libs aus dem Runtime
  SDK Verzeichniss komplett unterbinden kann. Gibt man Päckchen heraus, so sollte man dies auf 'false' setzen damit es keine
  Versionskonflikte mit einem eventuell auf einem anderen Rechner Installierten PL SDK gibt. Standard ist jedoch 'true',
  es ist schlimmer wenn etwas nicht gefunden wird als wenn man 'nur' Warnungen beim Start wegklicken muss. :)
  Dieser ganze 'Engine Initialisierungs Vorgang' ist aber keineswechs als Final anzusehen, später muss das viel Flexibler
  werden.



>> 26.07.2006
[CO]
- Ab sofort kommt man über das neue Singleton 'SceneGraph' an die Wurzel der Szene, und nicht mehr über PL::GetRootSceneContainer()
  was mir noch nie gut geviel - das war ja eh nur als Zwischenlösung gedacht bis das System an sich steht und man den Überblick
  hat. Jetzt ist das endlich stimmig. :)
- Überarbeitete die Counter-Geschichte in den Scene Nodes. Hin und wieder und vorallem wenn man Hierarchien durchläuft muss
  man Nodes als bereits Abgearbeitet 'markieren', ansonnsten kann es vorkommen das ein und die selbe Node mehrmals verarbeitet
  wird weil diese in z.B. verschiedenen Hierachie Nodes ist. Die alte Counter-Implementierung war dabei leider etwas fehleranfällig.
  Da ich allerdings bei jeder Szene Verarbeitung keine Liste speichern will mit bereits besuchten Nodes und dann jedesmal
  in dieser Liste schaun muss ob die Node bereits drinnen ist oder das mit HashMaps oder weis der Teufel was lösen will,
  entschloss ich mich dafür weiterhin eine 'globalere' Lösung zu verwenden. Dies ist zwar nicht 'multithreading save', allerdings
  ist das gesammte Scene System dies nicht und es 'sicher' zu machen wäre sehr viel Arbeit und an ein paar Stellen sicherlich
  auch gar nicht so ohne weiteres Möglich... der Nutzen steht also im krassen Gegensatz zu der Arbeit die man beim Coden UND
  zur Laufzeit reinstecken muss.
  Daher auch die heute hinzugefügte SceneGraph Klasse, da wird das mit den Countern Zentral Verwaltet ähnlich wie beim VisManager.
  Dort gibt es die drei kleinen Funktionen StartProcess(), TouchNode() und EndProcess(). Auf die Scene Node Counter selbst hat
  man KEINEN Zugriff mehr. Dieses Implementation ist nun um einiges 'sicherer' als die alte da wirklich alles von einer Stelle
  aus Verwaltet wird. Ich finde diese Lösung ziemlich gut da diese superflott & universell ist... und für unsere Zwecke auch völlig
  ausreichend ist. Die einzelnden 'Globalen Counter' der Scene Queries durfen nun gehen.
  Bei SQCull geht dieses Konzept allerdings leider NICHT immer ganz auf, denn hier kann eine Scene Node sehr wohl 'mehrmals'
  Sichtbar sein, zwar nicht innerhalb eines Containers, aber durch verschiedene Portale die in einen gleichen Container zeigen.
  Allerdings muss dieser Teil sowieso nochmal etwas überarbeitet werden.



>> 25.07.2006
[CO]
- SCMirror: Beim setzen der Dynamischen Textur ist es zur Sicherheit ratsam auch die Textur Matrize auf einen bekannten Wert zu
  setzen.



>> 24.07.2006
[CO]
- Neuer Scene Node Modifier SNMMoveController: Der Code stammt aus SNCamera und dient dazu eine Node über die Maus 'bewegen'
  zu können. Hauptsächlich wird dieser Kontroller wohl für 'freie Kameras' verwendet werden die zudem nicht mit der Physik
  Interagieren, also keine Kollisionsabfragen etc. besitzen. Nahm wie gestern bereits bei SNMFixRoll den entsprechedenden
  Code aus SNCamera heraus. Nun ist endlich der ganze unnötigt Balast in SNCamera draußen. Spezielles Verhalten kommt über
  Modifier hinzu - so wie das auch sein muss. :)
- SceneNode: Neues Flag 'Frozen': Ist dieses Flag gesetzt, wird eine Node nicht aktualisiert, ist aber sichtbar. Im Max
  Szene Exporter hatte ich mir bereits überlegt ob wir so ein Flag brauchen, denn bis jetzt wurde eine Node als 'Inactive'
  gesetzt wenn diese in Max 'Frozen' war... aber nach den Kamera Änderungen von vorhin kann man dieses Flag wirklich sehr gut
  brauchen. Beispielsweise in PLSampleInGameGui wird die Kamera 'eingefrohren' sobald das Ingame Gui bedient wird, früher wurden
  hier die Kamera Flags geändert die es so nun aber nicht mehr gibt, daher läuft dies nun über dieses neue Frozen-Flag ab.



>> 23.07.2006
[CO]
- Neuer Scene Node Modifier SNMFixRoll: Der Code stammt aus SNCamera und dient dazu eine Rotation entsprechend eines gegebenen
  Up-Vektors auszurichten. Nahm diesen Code dafür aus SNCamera heraus - als Modifier ist das um vieles universeller & mächtiger. :)



>> 19.07.2006
[CO]
- Neue Scene Node: SNUnknown: Für 'unbekannte' Scene Nodes. Der 3ds Max Scene Exporter kann solche Scene Nodes Exportieren,
  die zwar keine bekannte Funktion haben, aber eventuell ein 'Ziel' sind auf das eine andere Node 'schaut'... darum ist es
  nicht sehr Ratsam solche Nodes einfach beim Export zu ignorieren.



>> 18.07.2006
[CO]
- GuiDebug::GuiDebug: Der Debug Dialog wird nicht mehr zentriert sondern rechts oben plaziert, so hängt dieser Dialog nicht
  mehr störend ins Bild wenn man ihn mal offen lässt um z.B. Nodes herumzuschieben.


>> 15.07.2006
[CO]
- Shader Scene Renderer so erweitert das man die Textur Filterung auswählen kann. So lässt sich auch z.B. 4x Anisotropic auswählen
  wodurch Texturen bei Mipmapping wenn man sehr 'schräg' draufschaut nicht mehr so 'matschig' aussehen - allerdings kostet dies
  natürlich Performance. In einem meiner Tests gings von 47 ohne Anisotropic auf 28 mit 16x Anisotropic runter... also ein
  nicht gerade kleiner Unterschied.



>> 14.07.2006
[CO]
- Am Shader Scene Renderer weitergearbeitet, u.a. ist die Height Map nun seperat und nicht mehr im Alpha Kanal der Normal
  Map gespeichert was spätestens dann zu Problemen führen würde wenn man versucht Normal Map Kompression zu verwenden. Für
  Grafiker müsste das so auch einfacher zu handhaben sein. Im Material lässt sich nun einstellen wie 'glänzend' ein Material
  sein soll. (shininess/specular power)
- Ich entschloss mich dazu innerhalb von Shadern bei Uniform Parametern immer mit einem Großbuchstaben anzufangen - so passt
  dies besser mit den Effekten & Materialien zusammen wo ebenfalls immer mit einem Großbuchstaben angefangen wird, und zum anderen
  erkennt man dann innerhalb der Shader sofort das es ein Uniform Parameter ist. Den Rest in den Shadern lies ich aber so von
  der Formatierung her da dieser Style für Shader recht gängig ist.
- Dort wo noch die alte HashTable verwendet wurde auf die neue HashMap umgestellt



>> 09.07.2006
[CO]
- SNPortal::GetWarpMatrix(): Das berechnen der 'Warp'-Matrize universell gemacht. Zuerst rechnet man in den 'root space' um,
  und von dort aus in den 'target cell space'. Eine andere eventuell geschicktere Lösung viel mir nicht ein, und das klappt so
  bereits in dem Physik Body Modifier und in SNMTargetRotation von festern recht gut.
- SQCull::TraverseNode: Zum Portal Scissor Rectangle wird nun immer 1 Pixel hinzugefügt um eventuelle unschöne Grafikfehler
  zu veringern wenn mal Rechenungenauigkeiten sichtbar werden.
- Erzeugte seit langem mal wieder die Doxygen Doku und behob Kommentar Fehler die angemeckert wurden
- SCRenderToTexture & SCMirror an Surface Painter angepasst. SCRenderToTexture::DrawDebug() Zeichnet den aktuellen 'Textur Inhalt'
  als 'Bitmap' auf den Bildschirm, zwar kann man auch über den Textur Tab des Debug Dialogs in die Textur 'reinschauen', eine etwas
  größere Darstellung ist jedoch recht nett. Wie man auf die art einzelne Cube Map Seiten anschaun kann weis ich noch nicht,
  da muss ich mich erst noch Informieren ob, und wenn ja wie das funktioniert.



>> 08.07.2006
[CO]
- Passte Post Processing + alle entsprechenden Effekte an die Material System Änderungen vom letzten Monat an. Rendern in
  'floating point' Texturen ist bei mir momentan aufs grausamste Langsam, liegt hoffentlich nur zum größten Teil an meiner
  alten GPU. Ändert man in PLSamplePostProcess die Fenster größe zu oft oder wechelt häuftig den Effekt, kommt es momentan
  noch zu Problemen - das mit den in Texturen Rendern muss ich mir wohl bei Zeiten im Renderer nochmals anschaun und diese
  Probleme beseitigen. *never ending story*
- SNMRotation das mit 'rotiere in Bewegungsrichtung' in eigenes SNMMoveRotation verschoben, SNMTargetRotation hinzugefügt
  welches immer 'zum Ziel' hin rotiert. (soetwas war/ist bis jetzt fest und wenig universell in SNCamera implementiert)



>> 07.07.2006
[CO]
- SceneRenderer: Neue Funktionen PrepareLightEffects() und DrawLightEffects(). Nachdem der Z-Buffer mit korrekten Werten gefüllt
  ist, (üblicherweise nach DrawSolid()) sollte man PrepareLightEffects() aufrufen welches Occlusion Queries für Lichter mit
  'Effekten' (lens flares, corona, blend) erzeugt um zu prüfen ob und wie stark ein Effekt sichtbar ist. Nach DrawTransparent()
  sollte man DrawLightEffects() aufrufen um die Lichteffekte, falls nötig zu zeichnen - mit etwas Glück sind die Ergebnisse zu
  diesem Zeitpunkt bereits vorhanden so das man nicht darauf warten muss. Das passt so nun viel besser in die 'Render Pipeline'
  als früher wo die Lichter selbst diese 'Effekte' zeichneten... das ist einfach Job eines Scene Renderers der das viel besser
  handhaben kann.



>> 06.07.2006
[CO]
- VisNode: GetVisRootContainer() hinzugefügt damit man ohne Umwege direkt an die Wurzel des Sichtbarkeitsbaumes kommen kann.
- Scene Node Modifier Klassen: 'Inactive'-Flag wird berücksichtigt
- Neue Scene Nodes: SNString & SNKeyValue: Experimentielle 'Data'-SceneNodes - sprich, diese Nodes halten nur Daten, sind aber
  keine 'Renderable'-Nodes. SNKeyValue wird bereits in PLSampleContainer verwendet um über eine Szene-Datei den zu verwendenden
  Scene Renderer und einen eventuellen aktiven Post Processing Effekt einstellen zu können. Diese Infos wurden vorher
  in SceneLoaderPL::LoadRec() abgefragt, waren aber eher Experimentiell und nicht wirklich universell & brauchbar. Wird eine
  Szene eingeladen, 'sucht' PLSampleContainer nun über SQEnumerate nach 'SNKeyValue' und wenn etwas gefunden wird, so werden
  diese Einstellungen berücksichtigt. Dies ist nun total universell - und wohl ein weiteres Argument das für die von Stefan
  vorgeschlagene abstraktion des SceneGraph, so, das man dort auch reine 'Data-Nodes' halten kann.
- SceneRenderer::DrawSceneNodeIconsRec: Hier muss von hinten nach vorne gezeichnet werden damit die Icons sich nicht unschön
  überzeichnen. Das gleiche bei Portal-Rendering, zuerst das 'hinter' dem Portal zeichnen, anschließend das Portal selbst falls
  nötig.



>> 05.07.2006
[CO]
- Entfernte SQRender und fügte eine neue abstrakte SceneRenderer Basis Klasse hinzu. Die Grundidee hinter SQRender war zwar
  recht nett, also 'Scene, Render dich selbst' - aber in der Praxis leider etwas umständlich und nicht sooo übersichtlich.
  Daher trennte ich nun die Scene Renderer komplett von dem eigentlichen SceneGraph. Als 'Eingabe' bekommt so ein Scene
  Renderer NUR den zu verwendenden Renderer + einen Sichtbarkeitsbaum, Dinge wie z.B. in welche 'Oberfläche' gerade gezeichnet
  wird müssen hier nicht bekannt sein. An alle weiteren zum Rendern benötigten Informationen kommt man wie vorher auch recht
  einfach über den Sichtbarkeitsbaum - die Änderungen der Scene Renderer waren minimal da diese bereits nur Infos aus dem
  Sichtbarkeitsbaum verwendeten.
  SPScene um Kamera & Root & Scene erweitert. Weis nicht ob das mit SPScene so wie es momentan ist schon halbwechs optimal ist,
  aber wir kommen der Sache auf jedenfall näher. Um die Implememtation erstmal einfach zu halten hab ich noch keinen
  'SceneRenderer Manager' hinzugefügt. SPScene kann man nun also als SurfacePainter<->SceneGraph<->SceneRenderer-Verbindung ansehen.
-> Die Tools muss ich noch an diese Änderungen anpassen...



>> 03.07.2006
[CO]
- SQCull::TraverseNode(): Da Lichter gerade bei Shader Intensiven Scene Renderern einen großen Einfluss auf die Performance
  haben, entschloss ich mich beim Culling noch speziell auf Lichter zu testen da diese Tests noch etwas 'genauer' gemacht
  werden können. Also Test auf den Licht Radius, und falls es ein Spot Light ist, wird zusätzlich noch geprüft ob der
  'Spot Cone' sichtbar ist. Wollte das zuerst irgendwie universell machen, also das eine SceneNode den Culling Prozess
  'kontrollieren/verfeinern' kann, lies das dann aber erstmal da dies wohl etwas umfangreichere Ändungerungen sind. Gerade
  bei Spot Lights ist die Wahrscheinlichkeit das zwar z.B. die AABB des Lichts sichtbar, aber der 'Spot Cone' nicht sichbar
  ist sehr groß. SNSpotLight berechnet und speichert die 'Frustum Vertices' wie üblich selbst sobald diese Daten benötigt werden.
- PL: GetDefaultSurfaceListener() wie von Stefan gewünscht entfernt. Auch bietet die Engine selbst nun keine möglichkeit mehr
  an einen minimal SceneGraph mit den normalerweise üblichen Nodes zu erzeugen - das MUSS nun der User komplett selbst machen.
-> Passte alles an die neuen SurfacePainter an was einiges an Fleißarbeit war. Stefans Vorschlag das mit den alten 'SurfaceListenern'
   noch etwas zu vereinfachen/umzubauen war definitiv eine sehr gute Idee, denn das ist nun einfacher & schöner zu bedienen. :)



>> 01.07.2006
[CO]
- SceneNode::DrawDebug() nutzt VisNode um gerade nicht Sichtbare Debug Texte zu ignorieren.
- SNSpotLight: Zeigt als Debug Information den Licht Frustum wieder korrekt an
- SQRender neue Funktion: DrawSceneNodeNames() -> Zeichnet alle Scene Node Namen, dabei werden keine Scissor Rectangles
  verwendet da man die Namen komplett sehen muss - ein abgeschnittener Name bringt reichlich wenig. ;-)
- SQRender neue Funktion: DrawSceneNodeIcons() -> Zeichnet alle Scene Node Icons, die neue Version vom Szene Editor muss
  dies dann nicht mehr selbst machen. Die Icons der Standard Scene Nodes liegen in 'Standard.pak'.
- SQPlaneSet, SQAABoundingBox, SQEnumerate, SQLine, SQPoint, SQSphere: Portal Teil Implementiert, durch die bereits gegebene
  'Warp-Matrize' war das sogar genauso einfach wie beim Container Fall. Noch sind diese Queries nicht in der Praxis ausprobiert
  worden, aber so müsste es theoretisch klappen. Ob man noch zusätzlich die 'Seite des Portals' prüfen muss, muss man dann
  sehen...
- Wie konkret man am besten verschiedene 'Effekte' in den Scene Renderern verwendet muss ich mir noch überlegen. Daher hab
  ich in SRBasic erstmal eine weniger schöne Lösung eingebaut damit alles soweit lauffähig bleibt. Das meiste läuft nun wieder
  recht ordentlich und die noch zu lösenden Szene Renderer Probleme werden weniger - so langsam nimmt das eine brauchbare
  Gestalt an. :)
- Neuer Scene Node Modifier: SNMMeshMorph: Hat eine Scene Node ein Mesh, so kann man hierüber Morph Targets ändern. Noch
  wird das Mesh jedesmal aktualsiert sobald es einen Animations Manager hat was aber unnötig ist wenn sich gerade nichts an
  Animationen, Morph Targets etc. geändert hat - den Mesh Handler werd ich später nochmal etwas überarbeiten müssen, denn gerade
  Skinning ist nicht ganz 'billig' und sollte wenn sich nichts geändert hat auch nicht durchgeführt werden.
- Neuer Scene Node Modifier: SNMMeshAnimation: Hat eine Scene Node ein Mesh, so kann man hierüber Animationen ändern - fürs
  erste hab ich nur das nötigste an Einstellmöglichkeiten eingebaut, das wird aber sicherlich noch erweitert. :)
  Durch diese zwei neuen Modifier lassen sich nun also auch endlich Animationen 'von außen' verwenden. Wenn man später etwas
  mit Skripten machen sollte erleichtert dies sicherlich die Sache da man dann eigentlich alles wichtige über das Scene System
  handhaben kann.
- SceneNodeModifier: Musste IsInitialized() Funktion hinzufügen damit man innerhalb von VarChanged() wie bei SceneNodes
  prüfen kann ob die RTTI Variablen bereits Initialisiert wurden... testet man nicht, kann es zu Problemen kommen...



>> 30.06.2006
[CO]
- 'SRBasic' ist nun wirklich absolut grundliegend und hat noch nicht einmal einfachste 'per vertex' Beleuchtung. Es wird also
  NUR Texturierte Geometry Dargestellt - gerade zum austesten des Scene Systems an sich oder zum Performance messen einer
  Szene recht hilfreich.
- Neuen Szene Renderer namens 'SRBasicLighting' hinzugefügt. Dies ist eine erweiterte Version von 'SRBasic' welche einfache
  'per vertex' Beleuchtung über die standard Renderer API Licht Funktionen (fix pass) durchführt. Im gegensatz zu 'SRShaderLighting'
  werden Lichter pro Objekt aktiviert und nicht Objekte pro Licht. (muss noch Implementiert werden) Daher ist die maximale Anzahl
  an Lichtern welche auf ein Objekt einwirken können durch die GPU/Renderer API limitiert - normalerweise werden gleichzeitig
  aktive 8 Lichter Unterstützt was mehr als ausreichend sein sollte da ja pro Objekt und nicht für die gesammte Szene. Objekte
  werden also NUR einmal gerendert, egal wie viele Lichter ein Objekt beleuchten. Daher haben nur die Vertex Einheiten der GPU
  was zu tun, die Fragment Einheiten hingegen schauen gelangweilt in der Gegend herum. ;-)
  Änderungen der Auflösung sollten normalerweise weniger starke FPS Änderungen nach sich ziehen wie es z.B. beim extrem Füllraten
  fressenden SRShaderLighting Szene Renderer der Fall ist. Nur bei Projektiven Lichtern müssen die Objekte natürlich mehrmals
  gerendert werden.
  Wir haben nun also 3 recht unterschiedliche Szene Renderer, von Steinzeitmäßig bis zu 'state of the art'. Das müsste für's
  erste reichen. Jeder Scene Renderer ist optimiert Scene Nodes mit bereitgestelltem Meshs möglichst flott Darzustellen, und im
  Falle eines komplexerem Beleuchtungssystem wie in SRShaderLighting ist hierdurch 'uniform lighting & shadowing' möglich. Jedoch
  ist es auch wie früher immer noch möglich das sich Scene Nodes 'selbst' zeichnen und dafür gibts in Scene Node die 5 Draw-Funktionen
  DrawPre(), DrawSolid(), DrawTransparent(), DrawDebug() und DrawPre() welche wie der Name jeweils andeutet nach jedem Render
  schritt bei Bedarf aufgerufen werden können. SQRender bietet gleich Funktionen an die das komplett für einen übernehmen so das
  man dies nicht in jedem Szene Renderer neu implementieren muss. Natürlich ist dort KEIN automatisches 'uniform lighting & shadowing'
  möglich und daher sollte man diese Funktionen wenn immer möglich NICHT verwenden sondern sich darauf verlassen das der jeweilige
  Szene Renderer die Meshs der Nodes korrekt auf den Bildschirm bringt. In SceneNode gibts entsprechende Flags, und NUR wenn ein
  entsprechendes Draw Flag gesetzt ist, sollte so eine Funktion aufgerufen werden. So kann ich als User beqeuem Draw-Funktionen
  'aktivieren/deaktivieren' und beispielsweise ein Szene Renderer kann prüfen wo welche Draw-Funktionen benötigt werden, und sollte
  mal überhaupt keine z.B. DrawDebug() Funktion aufgerufen werden, was wohl recht häufig der Fall ist, so kann dieser 'Render Schritt'
  komplett übersprungen werden was der Performance gut tut da ansonnsten der Sichtbarkeitsbaum IMMER nochmal zusätlich 5 mal durchlaufen
  werden müsste - und wenn das nicht sein muss, muss das wirklich nicht sein. ;-)
  Standardmäßig ist nur das DrawDebug-Flag gesetzt da es für diese Funktion bereits eine Implementation in SceneNode gibt, diese
  Funktion sollte aber nur aufgerufen werden wenn zusätzlich gerade ein Debug-Flag in der Node gesetzt ist. Ist aber alles Dokumentiert
  wann wo welche Funktion von außen aufgerufen werden sollte - hält man sich nicht daran, ist man selbst Schuld wenn etwas daneben geht...
  totale Narrenfreiheit kommt zwangsläufig mit solchen Gefahren daher und gerade beim Rendern muss man etwas heftigere Regeln aufstellen
  damit man noch eine halbwechs brauchbare FPS hat. Vor diesen ganzen Änderungen wurde z.B. in SRBasic IMMER DrawSolid() etc. verwendet,
  in der Dungeon Szene hatte ich dann an einer Stelle 30 FPS wo man nun über 100 hat, ist also ein 'minimaler' Unterschied. ;-) (Debug Version)
  Scene Nodes wie SNSky welche bestimmte Draw Funktionen Implementieren, sollten das jeweilge Draw-Flag als Standard gesetzt haben.
- SceneNode: Neues Flag 'Invisible' + Funktionen IsVisible() & SetVisible() welches genauso abläuft wie beim 'Inactive'-Flag.
  Wurde dieses neue Flag gesetzt, so ist eine Node zwar 'aktiv', wird aber nicht gezeichnet - das hatten wir früher schonmal
  drinnen und das ist denk ich recht Sinnig. 'Unsichtbare' und 'Inaktive' Nodes werden gleich erst gar nicht in einen Sichtbarkeitsbaum
  eingetragen.
- SNMRotation::InformedOnUpdate() verbessert: Zum einen stellte ich auf eine Rotations Matrize um da Vector3::GetRotationTo()
  in extremen Situationen eine seehr instabile Rotation erzeugte wodurch sich der Knoten wild herumdrehen konnte. Zum anderen wird
  die Rotation nur noch aktualsiert wenn der Positions unterschied groß genug ist, ansonnsten gibts auch hier ein sichtbares 'flackern'
  & 'wabern' wenn der Positions unterschied zu klein ist. Zuerst hatte ich mir nochmal die Mathe Klassen angeschaut, aber diese
  Probleme lassen sich wohl auf Rechenungenauigkeiten & spezielle Situationen zurückführen wo solche Probleme einfach leider
  auftreten - in den Fällen muss man dann schaun wie man das 'umgehen' kann.
- SceneNode::MoveTo() noch etwas verbessert: Der 'Kollisions Test' wird nun mit einer Sphere anstatt einer AABox durchgeführt
  da dies so weniger Probleme bereitet. Desweiteren 'springt' die Node nun minimal durch ein Portal, macht man dies nicht, kann
  es sein das der Bildschirm kurz 'schwarz' wird... doofe Probleme mit den Randfällen die ich noch nicht schöner lösen konnte.
- SceneNode: Die Funktion 'SetDrawn()' welche das 'Drawn'-Flag setzt das nach jedem Update zurückgesetzt wird lies ich erstmal drinnen.
  Jedesmal wenn man 'von außen' eine Scene Node zeichnet und nicht die Basis Implementationen der Draw Funktionen aufruft, sollte
  man per Hand SetDrawn() aufrufen um die Node zu informieren das diese in diesem Frame gezeichnet wurde. Diese Information kann
  man dann wie gehabt nutzen um z.B. gerade unsichtbare Partikel Effekte oder Skinned Meshs nicht zu akualisieren. Momentan wüsste ich
  nicht wie man das anderst lösen könnte...
- In SceneNodeListener neben InformedOnDrawDebug() die Funktion InformedOnDrawn() hinzugefügt welche aufgerufen wird wenn eine Scene
  Node in diesem Frame zum ersten mal gezeichnet wird. Die anderen Draw-Funktionen lies ich drinnen, denn so ist es z.B. auch Scene Node
  Modifier problemlos möglich Debug Informationen zu zeichnen - siehe SNMPath. :)



>> 29.06.2006
[CO]
- SNMesh::LoadMesh(): In der Abfrage ob Tangent Space Vektoren berechnet werden sollen fehlte ein Klammerpaar - daher wurde
  das Zeug eigentlich immer berechnet ob nun gewollt oder nicht was natürlich die Ladezeiten etwas verlängerte.
- Fürs erste recht einfachen rein internen 'Visibility Manager' hinzugefügt. Die gerade nicht verwendeten einfachen Sichtbarkeits
  Knoten welche früher pro Container in VisContainer::m_lstFreeNodes gespeichert wurden, werden nun 'global' in diesem Sichtbarkeits
  Manager verwaltet. Eventuell kann man das später so erweitern das gesammte Sichtbarkeits Teilbäume welche gerade nicht
  mehr benötigt werden dort reinverschoben werden - aber fürs erste müsste das einfache verwalten der einzelnen freien Knoten
  reichen. In der aktuellen Dungeon Szene hat man ca. maximal 100 solcher Sichtbarkeitsknoten die nun 'gemeinsam' genutzt werden,
  leichte 'ruckler' wenn Portale zu Zellen mit vielen Objekten zum ersten sichtbar werden sind nun nicht mehr so auffällig wie
  vorher.
- 'SRPerPixelLighting' in 'SRShaderLighting' umbenannt da dies irgendwie passender ist - zudem MUSS die Beleuchtung hier nicht
  zwanghaft 'per pixel' sein. Wird ein gaaanz einfacher Shader verwendet, so könnte es auch schonmal einfache 'per vertex'
  Beleuchtung sein.
- SceneNode: Nahm InformOnDestroy() etc. heraus. Da diese Funktionen NUR jeweils an einer Stelle in SceneNode verwendet wurden war
  es übersicherlicher die Listener gleich an Ort und Stelle zu informieren anstatt über eine extra Funktion zu gehen. SNPortal
  Implementierte einige dieser Funktionen selbst um Daten neu zu berechnen wenn sich etwas geändert hat... Zuerst überlegte ich
  mir ob man vielleicht SceneNode::SetPosition() etc. Virtuell machen sollte damit abgeleitete Klassen individuell darauf reagieren
  können und z.B. im Falle des Portals bestimmte Daten zu aktualisieren, enschloss mich daber dagegen da man so zuviel unfug
  Treiben könnte und das Verhalten von grundliegenden SceneNode Funktionen sollte IMMER gleich sein. Will man in abgeleiteten
  SceneNodes über z.B. eine Positions Änderung der Node Informiert werden, muss sich eine Node selbst zuhören. Auch SNPointLight &
  SNSpotLight hören sich selbst zu und das ist eigentlich ganz ok von der Verwendung her.
- SceneNode::SetAABoundingBox() ist nicht mehr virtuell, siehe oben. Jedoch entschloss ich mich direkt in dieser Funktion
  zu prüfen ob es sich um einen Container handelt. Wenn ja, so wird die Hierarchie gelöscht - das hier über Scene Node Listener
  zu lösen erschien mir als eeetwas zu umständlich... Nodes & Container haben eine sehr enge Beziehung zueinander, daher müsste
  das ok sein.
- SceneNode: Nahm DrawPreFunction() & DrawSolidFunction() & DrawTransparentFunction() & DrawPostFunction() heraus. Überlegte mir
  die restlichen Draw-Funktionen Funktionen in 'RenderX' umzubenennen, bliebt aber bei 'DrawX' da es irgendwie netter ist. Diese
  Draw-Funktionen sind Virtuell und standardmäßig NICHT Implementiert. Da diese Virtuellen Draw Funktionen in Szene Renderern nicht
  wirklich Effektiv & Universell verarbeitet werden können, sollte man wo immer es geht vermeiden diese Funktionen zu nutzen um
  selbst per Hand Dinge 'zeichnen' zu können. Der Node Draw Funktion wird auch der aktuelle Sichtbarkeitsknoten dieser Scene Node
  übergeben, soweit verfügbar - so kann ich als User dann z.B. die Kamera Position in 'diesem' Vektor Raum verwenden um z.B. den
  Abstand zur Kamera auszurechnen. Diese Draw Funktionen bekommen dann also aktuellen Renderer & aktuellen Sichtbarkeitsknoten -
  damit hat man alle Infos die man braucht. Ob eine Node gerade Sichtbar/aktiv ist sollte man in Draw Funktionen NIE prüfen, das
  ist Job von dem das diese Funktion aufruft. Fügte eine DrawDebug() Funktion hinzu welche NUR für Debug Informationen verwendet
  werden sollte und die eine Standard Implementation besitzt. Diese Funktion wird üblicherweise nach DrawTransparent() und vor
  PostDraw() aufgerufen.



>> 28.06.2006
[CO]
- SceneNode: Fügte eine 'OnContainer'-Informer Funktion hinzu so das man 'Zuhörer' darüber Informieren kann wenn SetContainer()
  aufgerufen wurde - z.B. wenn die Node durch ein Portal in eine andere Zelle 'ging'. SetContainer() wechselt wirklich NUR
  den Container in dem sich die Scene Node befindet, diese Scene Node wird also nicht in den anderen Vektor Raum umgerechnet,
  das muss der User selbst machen falls dies erforderlich sein sollte.
- SNPortal: Speichern ihre Portal Polygone nun ebenfalls im Container Space + eine 'Warp Matrize' welche von 'dieser Zelle'
  in die 'andere Zelle' umrechnet so das man bei 'übergängen' nur noch mit dieser Matrize multiplizieren muss. Diese Informationen
  werden wie üblich nur dann aktualsiert wenn sich etwas geändert hat. (was zur Laufzeit wohl sseeehr selten der Fall sein wird :)
  Auch SceneNode::MoveTo() verwendet nun diese Warp Matrix was die Sache recht einfach und universell macht da man sich keine
  Gedanken machen muss wie konkret die Zellen zueinander liegen, einfach die Warp Matrix nutzen und fertig. Auch der Fall das
  die Ziel Zelle NICHT direkt Räumlich 'hinter' dem Portal sitzt (Spiegel/Teleporter) ist damit abgedeckt. :)
- SQCull: Portal Teil etwas aufgeräumt und vereinfacht 



>> 27.06.2006
[CO]
- SNPointLight: Speichert Box Planes intern welche vorallem beim Per Pixel Lighting benötigt werden.



>> 26.06.2006
[CO]
- Verschob die Scene Nodes welche zum Grundligenden Szene System gehören direkt in den Szene Ordner... Portale & Zellen, Lichter
  und Kameras sind einfach dermaßen grundliegend und wichtig das ohne diese Nodes eine '3D' Szene kaum Sinn macht.
- Licht Scene Node komplett überarbeitet. SNLight ist nun 'nur' noch die Licht Basisklasse, davon abgeleitet sind SNPointLight,
  SNSpotLight und SNDirectionalLight. 'Point light' hätte man auch 'omnidirectional light' nennen können, dann hätte man aber
  entweder wieder abkürzen oder das lange Teil immer ausschreiben müssen, zudem wird im D3D SDK ebenfalls von 'point light' gesprochen,
  darum entschied ich mich für diesen Namen. Von Point & Spot gibts eine weitere Ableitung für Projective Texturing. Will man
  nur Lens Flare Effekte haben, kann man auch SNLight direkt verwenden. Sobald man einen bestimmten Licht Typ verwendet, so wird
  dieses Licht automatisch zum Beleuchten der Szene verwendet. Die Flare & Corona & Blend Materialien lassen sich nicht mehr
  pro Licht standardmäßig einstellen - diese Materialien sind einmal in einem Szene Renderer definiert. Sollte es aber doch
  mal vorkommen das ein Licht ganz spezielle Effekt-Materialien haben soll, so kann man SNEffectLight verwenden. Dieses 'Licht'
  Beleuchted nicht die Szene, sondern ist nur z.B. ein Lens Flare Effekt mit besonderem Material - will man auch die Szene
  Beleuchten, so muss man noch ein extra Licht erzeugen und diese zwei Licht Nodes 'zusammenhängen'. Da dies aber eher ein Sonderfall
  ist, geht das denk ich ok... auf jedenfall besser als zuviel meist nie verwendeten Balast in der Licht Basisklasse herumzuschleppen.
- Ein 'volumtisches Licht' haben wir nicht... für mich gehört das in die 'Nebel'-Schublade, denn diesen Volumtischen Nebel
  Effekt kann man auch locker ohne Diffuse Beleuchtung einsetzen und der Nebel kommt sowieso erst über einen eigenen Render
  Pass hinzu. SNFog ist 'nur' noch Basisklasse, davon ist SNSphereFog abgeleitet. Da 'Nebel' etwas besonderes ist um
  das sich das Szene System, speziell ein Szene Renderer kümmern muss, fügte ich in SceneNode eine IsFog() Funktion hinzu.
- Passte alle Projekte an diese Änderungen an
- SNSpotLight & SNProjectiveSpotLight: Projection, View und Texture Matrize sowie die Frustum Ebenen werden nun von diesem
  Licht Typ selbst intern bei bedarf berechnet und gespeichert. (lazy evaluation - wie in SceneNode)
  Die Szene Renderer nutzen diese Informationen nur und müssen das nicht mehr selbst berechnen.



>> 24.06.2006
[CO]
- SNTransformer Scene Nodes hinzugefügt. Diese stammen aus dem Scene Editor und wurden etwas überabeitet, sind aber noch
  weit weg von 'optimal'.
- SNObject in SNMesh umbenannt und die Shadow Volume Handler dort herausgenommen da dies zukünftig Job des Szene Renderes
  bzw. eines von diesem verwendeten Shadow Volume Managers wird. Variable 'm_sMeshFilename' in 'm_sMesh' umbenannt da es
  'nur' eine Mesh Resource des Mesh Managers ist. Meist wird das zwar ein Dateiname sein, muss es aber nicht. Das gleiche
  bei 'MaterialFilename'.
- SNPortal um die Flags NoSeeThrough & NoPassThrough erweitert. Das erstere kann für verschlossene Türen verwendet werden,
  das letztere für Spiegel wo man natürlich nicht in die Ziel Zelle latschen darf welche normalerweise die gleiche ist wie
  die in der das Portal selbst ist. Nutzt man NoSeeThrough für gerade verschlossene Türen, so kanns passieren das die Tür
  selbst auch verschwindet wenn diese in der Nachbarzelle liegt... da muss ich mir noch überlegen was man da am besten
  macht.



>> 23.06.2006
[CO]
- Neue Scene Nodes: SNLine & SNPoint: Zum Darstellen einer Linie bzw. eines Punkts... gerade für Debugging, Beispiele &
  Experimente recht hilfreich.



>> 21.06.2006
[CO]
- SRPerPixelLighting um 'Soft Shadows' erweitert. Ist zwar 'nur' die allereinfachste Technik namens 'fake PCF'
  (percentage-closer filtering), sieht aber immerhin gleich um einiges netter aus - bei mir ist's mit Soft Shadows nicht
  mehr möglich ALLE Shader Features zu aktiveren, das ist zu viel des guten für meine GPU. :( Verzichte ich auf Horizon
  Mapping läufts noch. Nun hab ich wenigstens die Sitation wo der Szene Renderer bestimmte Features nicht nutzen kann da die
  GPU das nicht mehr packt. Da werd ich nun noch einbauen müssen das dann automatisch Schrittweise Features ignoriert werden
  bis der Shader verwendbar ist. Soft Shadows sind derzeit nur für Spotlight Shadow Mapping verfügbar.
- VisNode um GetInverseWorldMatrix() und SceneNode um GetInverseTransformMatrix() erweitert. Ersteres braucht man sehr häufig
  z.B. im Per Pixel Lighting Szene Renderer und letzeres häufig in z.B. SQCull, darum sollte das so flott wie möglich gehen
  und nicht jeeedesmal wieder neu berechnet werden obwohl sich z.B. eine Scene Node NIE bewegt da diese eine 'statische Geometry'
  ist - die 12 Byte mehr sind das sicherlich wert. :)



>> 18.06.2006
[CO]
- SRPerPixelLighting: Da dieser Szene Renderer mittlerweile etwas umfangreicher ist, verteilte ich die Codes in verschiedene
  cpp Dateien für mehr Übersicht.



>> 16.06.2006
[CO]
- SRPerPixelLighting: Die erste Implementation für Spot Light Shadow Mapping funktioniert endlich. Noch sieht das natürlich
  nicht soo gut aus da dies der 'klassische Algorithmus' ist, der also keine speziellen Tricks verwendet um Grafikfehler zu
  vertuschen + die Schatten etwas weicher wirken zu lassen. Sobald der Szene Renderer alle gewünschten Features hat werd ich
  nochmal aufräumen damit es etwas übersichtlicher wird.



>> 15.06.2006
[CO]
- VisNode: Neue Funktion: GetWorldViewProjectionMatrix() gibt die World View Projection Matrize zurück. Da man diese vorallem
  im Per Pixel Lighting Szene Renderer recht häuftig mehrmals pro Frame braucht macht es Sinn diese nur einmal zu berechnen
  und dann in VisNode zur verfügung zu stellen.



>> 13.06.2006
[CO]
- SRPerPixelLighting: Vieles von dem was dieser Renderer können soll kann er mittlerweile bereits, ist aber noch ein ganzes
  Stück von 'nett' weg. Sobald ich halbwechs zufrieden damit bin schreib ich mehr zu diesem Szene Renderer.



>> 12.06.2006
[CO]
- Vor einigen Wochen verringerte ich den Speicherbedarf der SceneNode Klasse da diese Basisklasse damals zuviel Speicher
  verschlang. Dabei kam ich auf die 'clevere' Idee auch bei den Flags 'einzusparen'. Da jedoch einige der Flags auch über
  PL_VAR_FLAGS ans RTTI gekoppelt wurden welches 4 Byte Variablen erwartet, aber eine gegebene Flag Variable z.B. nur 1 Byte
  groß war produzierte dies natürlich zwangsläufig Bugs. Ärgerlich das ich das nicht gleich damals merkte sondern erst gerade
  per Zufall. Hm, vielleicht wäre es möglich zumindestens im Debug Modus dem RTTI ein paar Sicherheitsabfragen zu verpassen?
  Wenn es möglich ist den Speicherbedarf der z.B. PL_VAR_FLAGS übergebenen Variable zu prüfen (sizeof) und eine Warnung ins
  Log zu schreiben wäre super, denn das ist ein Fehler der superschnell passieren kann. Auch wäre es gut wenn das RTTI
  meckern würde wenn eine Klasse bereits eingetragen ist - diese Situation hatten wir ebenfalls schon einige male was dann
  ebenfalls zu 'Merkwürdigen Bugs' führte. :(
- DrawContainerScissorRectRec() von SRBasic in SQRenderer verschoben, diese Funktion ist universell Einsetzbar
- SQRenderer: Neue Debug Funktion: DrawWireframes(): Zeichnet 'über' das bereits im Framebuffer liegende die Wireframes der
  verwendeten Meshs.
- Fing damit an 'SRPerPixelLighting' komplett neu zu schreiben



>> 11.06.2006
[CO]
- SNObject: Neue Variable Namens 'Skin' hinzugefügt worüber man Materialien mit hilfe einer 'skin'-XML Datei 'austauschen' kann.
  Wir hatten vor Jahren schonmal soetwas drinnen (plm-Dateiendung) und ich brauchte es nun wieder um in der Beispielszene 
  'plfx_Effects.scene' dem Helm Modell ein anderes Material zuzuweisen. Da man recht häufig ein Mesh mit nur einem Material hat,
  kann man auch direkt ein Material angeben ohne über eine extra Skin-Datei gehen zu müssen.
- SNObject::LoadMesh(): Das berechnen von Zusatz-Daten wie z.B. Normalen etwas verbessert.
- GuiDebugEffect & GuiDebugMaterial: Resource Handler entfernt da unnötig



>> 09.06.2006
[CO]
- GuiDebugTexture aktualisiert
-> Fast alles läuft nun wieder wie vor dem überarbeiten des Material & Effekt Systems - argh, das war nun eine Woche arbeit und
   man 'sieht' keinen Unterschied! *g*
   Ich denke die Woche Arbeit hat sich definitiv gelohnt. Die Ladezeiten sind nun etwas geringer und auch der Speicherverbrauch
   da die Materialien an sich recht kompakt sind und die etwas aufwändigeren Effekte werden recht oft von mehreren Materialien
   genutzt. Aber noch viel wichtiger ist natürlich, das dieses System sehr viel einfacher zu verwenden ist als das alte und auch
   um einiges 'mächtiger' als dieses ist. Das meiste müsste nun auch 'nach außen hin' so ablaufen wie es sich die Grafiker vorstellen
   und Dinge wie 'Bump Mapping' lassen sich recht intuitiv einsetzen... einem Mesh ein Material mit Diffuse & Normal Map zuweisen,
   eine kleine Szene mit diesem Mesh und einem Licht erzeugen und schon sieht man was - noch einfacher gehts wohl kaum. :)



>> 05.06.2006
[CO]
- Passte alle Projekte an die Änderungen der letzten Tage an so das alles wieder soweit halbwechs ordentlich läuft. Wie gehabt
  verwenden Meshs, Partikel Effekte NUR Materialien, allerdings reicht es meistens völlig wenn man dann dort als Datei direkt
  einen Effekt oder eine Textur übergibt. Ein Material muss man eigentlich NUR anlegen wenn man z.B. die Default Parameter
  Einstellungen des verwendeten Effekts 'überschreiben' will.
  Den Szene Renderer 'SRPerPixelLighting' passte ich nicht an und schloss ihn erstmal vom Übersetzen aus. Hier lohnt das umstellen
  nicht da ich diese Klasse sowieso komplett neu schreiben werde sobald die Arbeiten am Material & Effekt System soweit abgeschlossen
  sind was hoffentlich in ein paar Tagen der Fall ist.
  Das aktuelle Effekt System ist größtenteils noch das was früher Material hies und hier muss ich noch einiges überarbeiten/sauber
  machen. Und generell ist vieles Material/Effekt betreffende noch nicht komplett fertig, also nicht wundern wenn etwas noch nicht
  geht oder merkwürdig/umständlich aussieht. Ich wollte nun einfach mal wieder die Codes angleichen bevor ich mich an die 'Details'
  mache.



>> 04.06.2006
[CO]
- Debug Dialog: Effects-Tab hinzugefügt



>> 01.06.2006
[CO]
- SNLight: Die 'Korona' etc. der Lichter sind nun korrekt platziert
- Lies alle Projekte nach häufigen Englisch Fehlern durchsuchen auf die mich Stefan vor geraumer Zeit hinwies, hauptsächlich
  'kown', 'were' und 'byself'.
- Schaute alle Stellen bei denen in Interfaces '-1' vorkommt durch und dort wo möglich änderte ich es (sammt Implementation)
  in <0 damit das etwas/allgemeiner Sicherer ist.



>> 30.05.2006
[CO]
- Szene Debug Dialog noch etwas verbessert



>> 28.05.2006
[CO]
- Etwas an SQCull weitergearbeitet... mittlerweile kann man die Dungeon Szene direkt aus Max Exportieren und mit hilfe von
  Portalen & Zellen recht Effektiv Darstellen. (fehlt 'nur' noch die Beleuchtung :) Etwas Probleme bereitet mir allerdings
  noch der Fall wenn es zu Endlosrekursionen kommt. (Portale ziemlich ungünstig platziert) Hier hab ich momentan einen Hack
  eingebaut damit das in dem Fall keinen Crash gibt.



>> 25.05.2006
[CO]
- SceneNode: Weitere RemoveModifier() Funktion hinzugefügt
- GuiDebugScene: Scene Debug Dialog um die Möglichkeit erweitert Scene Node Modifier zu bearbeiten + ein paar weitere
  Buttons hinzugefügt um Container zu Laden & Speichern und Container und/oder Modifier zu löschen.
- SceneNode: Name: Derzeit ist es leider ein problem das das RTTI Variablen automatisch IMMER selbst manipulieren darf...
  bei den Scene Nodes ist das leider tötlich da diese ihren Namen IMMER NUR durch SetName() ändern dürfen damit der Manager
  das konkrete ändern des Namens übernimmt - und wirklich NUR er. Da aber das RTTI bereits den Node Namen geändert hat wenn
  VarChanged() aufgerufen wird ist  
    // Name
    } else if (sVar == "Name") {
      SetName(m_sName);
  witzlos und Funktioniert zudem auch leider nicht. Denn der 'Node Resource Manager' (SceneContainer) übernimmt das ändern
  des Namens. Dazu sucht er jedoch erst nach der Node mit diesem Namen, findet dann natürlich aber nichts mehr da der Name
  bereits geändert wurde und daher schwirrt nun in der Namens Hash Map etwas ungültiges herum und auch der neue Name wurde
  NICHT regestriert was natürlich zwangsläufig zu schwerwiegenden Problemen führt. :(
  Base::VarChanged() müsste irgendwie so geändert werden das ich als User ZUERST über die gewünschte Änderung informiert werde,
  dann kann ich prüfen ob der neue Wert gültig ist und/oder ob es nötig ist die Änderung über eine spezielle Funktion wie 
  z.B. SetName() zu regeln, ist der neue Wert ungültig ODER wenn ich als User z.B. den neuen gewünschten Namen über SetName()
  gesetzt habe müsste ich z.B. über einen boolschen Rückgabewert von VarChanged() dem RTTI mitteilen das es NICHT selbst
  den neuen Wert setzen soll sondern ich als User mich bereits darum gekümmert habe. :)
  Genauso könnte es sein das man bestimmte Variablen je nach aktueller Situation gerade NICHT ändern darf/kann - das könnte
  der User dann ebenfalls frei entscheiden.
  Damit das Szene System in ungünstigen Fällen nicht crasht hab ich nun erstmal eine zusätzliche Namens Variable der Scene Node
  hinzugefügt welche vom RTTI geändert werden kann. Bei Änderungen setzte ich dann den konkreten neuen Namen selbst.



>> 23.05.2006
[CO]
- SceneContainer: Bisher wurde die Hierarchie direkt im Konstruktor erzeugt. Da jedoch zu diesem Zeitpunkt der Kontainer selbst
  nicht nicht korrekt initialisiert ist, z.B. die Bounding Box nicht vom RTTI auf den Default Wert gesetzt wurde hatte
  die Szene Hierarchie immer standardmäßig eine Bounding Box welche nicht den gegebenen Default Werten entsprach. Daher
  wird die Hierarchie nun NUR in GetHierarchy() erzeugt - also 'on demand' wenn diese zum ersten mal benötigt wird. Wird
  die Bounding Box des Kontainers oder der Hierarchie Typ verändert, so wird die aktuelle Hierarchie NUR gelöscht. Sobald
  nun z.B. das Sichtbarkeits System die Hierarchie anfordert, wird bei bedarf eine neue angelegt und dann je nach bedarf
  geordnet... es wird also nie mehr gemacht als wirklich gerade angefragt wurde.



>> 22.05.2006
[CO]
- Stellen wo Tokenizer::Start() verwendet wird angepasst



>> 21.05.2006
[SB]
- Projekte an FS-Änderungen angepaßt



>> 18.05.2006
[SW]
- ein paar non-POD und eine redfine warnung gefixed.



>> 17.05.2006
[CO]
- SNParticleGroup: ForceUpdate-Flag hinzugefügt, ist dieses Flag gesetzt so sollten sich Partikel Effekte auch dann aktualisieren
  wenn diese gerade unsichtbar sind. Das ist zwar sicherlich nicht total optimal so, aber fürs erste reicht das völlig.
- Hm, im Projekt waren noch in SceneNodeModifiers die Physik Modifier drinnen obwohl diese Dateien nicht mehr im Engine
  Projekt liegen - korrigierte das. :)
- SceneContainer::Get() verbessert



>> 16.05.2006
[CO]
- An PLGeneral Änderungen angepaßt



>> 15.05.2006
[CO]
- Fehlerhafte -1 zuweisungen verbessert
- MaterialParameter.cpp: etwas umgebaut damit der gcc Compiler keine Warnung mehr ausspuckt
  (warning: deleting `void*' is undefined)



>> 14.05.2006
[SW]
- POD-warnung gefixed



>> 14.05.2006
[SB]
- An PLGeneral Änderungen angepaßt



>> 11.05.2006
[SB]
- An PLGeneral Änderungen angepaßt (DEFINE_GROUP entfernt, GetClasses())



>> 02.05.2006
[CO]
- SceneNodeModifier: Um 'Inactive' und 'Automatic' Flags erweitert.
- PL Hauptklasse um GetLoadProgress() & SetLoadProgress() erweitert, nahm dafür die entsprechenden Load Informer Funktionen
  aus der Scene Node + Scene Node Listener heraus, das passte hier irgendwie nicht so recht rein. Passte SNLoadScreen an.
- SNTerrain2: Speichert nun nur noch die Heightmap selbst, und nicht mehr auch noch das 'Bild' aus dem diese kam



>> 26.04.2006
[CO]
- SceneContainer: Neues Flag 'NoRecursion': Is dieses Flag gesetzt, so 'gehen' z.B. Scene Queries nicht 'in' diese Container.
  Das ist z.B. bei SCRenderToTexture nötig (dieses Flag ist hier auch Standardmäßig gesetzt) da es sich hier um eine eigenständige 
  Unterszene handelt welche NICHT mit der eigentlichen Szene vermischt werden darf. In diesem Fall ist z.B. SCRenderToTexture
  dafür verantwortlich alles weitere in eine Textur zu rendern.



>> 25.04.2006
[CO]
- SceneLoaderProc: Das verteilen der Lichter in Zellen klappt nun korrekt. Im 'proc' Format sind noch BSP Nodes die man dazu
  verwenden kann.
- SceneNode: Neue Funktion: MoveTo(): Ähnlich zu 'SetPosition()', prüft aber ob zwischen der alten und neuen Position ein
  Portal liegt. Ist dies der Fall, so 'geht' die Scene Node automatisch durch dieses Portal in eine andere Zelle. Obwohl
  dies erst eine erste einfache Test Implementation ist, klappt das schon recht ordentlich. :)
- SQCull: Auch die Kamera ist nun immer sauber in einer Zelle und kann problemlos durch Portale in andere Zellen 'gehen'.
  Hierbei entschied ich mich davon abzukommen das im Sichtbarkeits Baum 'absolute' Welt Koordinaten gespeichert werden.
  ALLE anderen Scene Container sind im Sichtbarkeits Baum nun immer relativ zum Container in dem die Kamera derzeit ist.
  Das hat zum einen den Vorteil das man weiterhin wie gehabt direkt die World Matrix an den Renderer übergeben kann und
  auch die View Matrix der Kamera nicht geändert werden muss. Aber viel wichtiger ist wohl, das man damit der zunehmenden
  Rechenungenauigkeit bei gigantischen Welten aus dem Weg geht. Hätte man am Ende gigantische Absolute Positionen, so wären
  die Rechenfehler sichtbar... herumspringende Grafiken etc. Hatte mal vor Jahren einen einfachen 'Sonnensystem' Simulator
  geschrieben, obman war das übel. ;-)



>> 24.04.2006
[CO]
- Neue Scene Queries: SQPoint gibt die Scene Nodes zurück in denen ein gegebener Punkt liegt. SQEnumerate listet alle
  Scene Nodes auf. SQSphere/SQAABoundingBox gibt alle Scene Nodes zurück die die Kugel/Axis Aligned Bounding Box 'berühren'. 
- SceneQuery::InformOnSceneNode() & SceneQueryListener::InformedOnSceneNode() um boolschen Rückgabeparameter erweitert.
  Wird 'true' zurückgegeben, so wird die Anfrage fortgesetzt, bei 'false' wird die Anfrage abgebrochen. Der User kann nun
  also jederzeit die Anfrage abbrechen wenn z.B. das gesuchte gefunden wurde.
- SceneNode: Neue Funktion: SetContainer() 'verschiebt' die Scene Node in einen anderen Scene Container. Noch wird Positions
  mäßig nichts verändert.
- SceneLoaderProc: Werden zusätzlich über eine 'map' Entities wie z.B. Lichter eingeladen, so werden diese gleich korrekt
  in Zellen verteilt... was aber nur solange gut geht wie sich die Bounding Boxes der Sektoren NICHT überschneiden, was aber
  in meiner Test Szene leider oft der Fall ist. Da muss ich noch schaun wie man das besser machen kann.



>> 23.04.2006
[CO]
- SceneNode: Da die Basisklasse des Szene Systems stolze 324 Byte wog machte ich mich daran diese Klasse etwas abzuspecken.
             Also hauptsächlich 'bool'-Variablen in Flags unterbringen wo wirklich NUR ein Bit belegt wird. Und Variablen
             nur so groß machen wie man diese auch wirklich benötigt.
  - Nahm die Variable m_bActive heraus, man kann eine Scene Node nun deaktivieren indem man ein 'Inactive'-Flag setzt,
    oder wie zuvor die Funktionen IsActive() & SetActive() verwendet.
  - Nahm die Variable m_bPerformPause heraus + die Funktionen GetPerformPause() & SetPerformPause(), da dies eine sehr
    spezielle Sache ist die nur sehr selten benötigt wird wie z.B. für eine Kamera die man auch wenn gerade alles Pausiert
    ist noch weiterhin bewegen kann. Stattdessen kann man das nun über ein 'NoPause'-Flag setzten falls man das mal braucht.
  - Machte die Variablen m_bInitialized, m_bForceUpdate, m_bDestroy und m_bDrawn zu Internen Flags
  - m_nDebugFlags & m_nFlags & m_nCustomFlags von uint32 zu uint8 gemacht. 8 Flags reichen für die Engine selbst absolut aus,
    wenn der User diese Flags noch zusätzlich für sich erweitert und es mal nicht mehr reichen sollte, so kann er ja seine
    abgeleiteten Klassen selbst um entsprechende zusätzliche Variablen erweitern. PL_VAR_FLAGS selbst geht zwar von int aus,
    also 4 Byte, aber das ist zum Glück kein Problem.
  - Entfernte die Variable m_pSceneRootNode. Die Funktion GetRootNode() ermittelt die Szene Wurzel nun selbständig, ist ja
    keine so große und aufwändige Sache und bis jetzt brauchen wir diese Informationen nicht wirklich.
  - Stellte die finale Transform Matrix (GetTransformMatrix()) auf Matrix3x4 um. Die letzte Reihe brauchen wir hier
    absolut nicht und so spart man Speicher (immerhin 12 Byte :) + Rechenoperationen.
  ... durch diese kleinen Änderungen ist die Scene Node Basis Klasse nun 292 Bytes (voher 324 Bytes, Byte ausrichtung ist 4)
  groß, zwar nicht wirklich ein Fliegengewicht aber schonmal besser als vorher. Wir sparen also ca 10% an Speicher pro Scene
  Node OHNE auf etwas verzichtet zu haben + natürlich weniger Rechenoperationen. Momentan wüsste ich nicht was man hier noch
  ändern könnte um das noch etwas kompakter zu machen. Aber ich denke das kann man erstmal so lassen, und eine kleine
  Performance verbesserung ist auch sichtbar, was will man mehr? :)



>> 22.04.2006
[CO]
- Scene Node: Nahm wie gestern mit Stefan im Chat besprochen GetInternalFlags() wieder heraus und fügte die Funktionen
  IsContainer(), IsCell(), IsPortal(), IsCamera(), IsLight() hinzu worüber man superschnell herausbekommen kann ob die Scene
  Node einer dieser Grundtypen ist. Intern wird weiterhin über Flags geprüft welcher Typ es ist. m_nInternalFlags von
  Scene Node ist nun private damit der User damit keinen Unsinn treiben kann. SCCell, SNLight, SNPortal und SNCamera
  mussten daher nun zu Freunden von SceneNode werden.
- VisNode wie mit Stefan besprochen um GetParent() erweitert. Der 'Vater' kann entweder VisContainer sein, VisPortal wenn
  dies eine Zelle ist welche durch das Portal gesehen werden kann oder NULL wenn dies die Wurzel ist.
- SceneLoaderProc: Kann nun optional auch die 'map' Datei welche zu der 'proc' Datei gehört berücksichtigen. Desweiteren
  schreibt der Importer auch ein paar Statistiken ins Log.



>> 21.04.2006
[CO]
Ich verbrachte die letzten Tage damit das Sichtbarkeits-System um Portale & Zellen zu erweitern. Das Ergebniss kann dann sehr
beqeuem über SQCull::GetVisContainer() zurückgeben werden. Hierbei handelt es sich um einen 'Sichtbarkeits-Baum' der derzeit
aus 3 Klassen (VisNode, VisContainer & VisPortal) besteht. Jeder VisContainer ist selbst ein Sichtbarkeitsknoten der zu
einer konkreten Scene Node verlinkt + Informationen wie deren absolute Weltposition bereithält so das man sofort diese Daten
Rendern kann ohne selbst noch viel herumrechnen zu müssen. VisContainer enthält 'Projektion Informationen', also wieviel
konkret auf dem Bildschirm zu sehen ist. Diese Information kann man dazu benutzen um ein Scissor Rectangle zu setzen so das
NUR Dinge innerhalb dieses Rechtecks auf dem Bildschirm gezeichnet werden. Desweiteren kann man eine von hinten nach vorne
sortierte Liste aller sich in diesem Kontainer befindenten Knoten anfordern. Ist dieser Knoten ein Kontainer, so kann man
weiter 'hinabsteigen'. Handelt es sich bei dem Sichtbaren Knoten um ein Portal kann man in die Ziel Zelle springen. Diese
Ziel Zelle kann dabei im eigentlichen Scene Graph 'über', 'neben' oder 'unter' dem aktuellen Scene Container liegen, aber
das braucht den User nicht wirklich zu Interessieren. VisPortal steht für eine Portal Scene Node welche in eine Zelle linkt
- die Zelle selbst ist ein normaler VisContainer und die Projektion Information wird von SQCull automatisch so eingestellt
das nur das durch das Portal sichtbare berücksichtigt wird. Intern wird dabei das Portal Polygon mit dem aktuellen Frustum
geclipped. Anschließend wird mit diesem neuen Polygon der Portal Frustum erzeugt der dann für die weitere rekursive
Sichtbarkeitsbestimmung der Ziel Zelle verwendet wird. So geht es dann durch jedes durch das Portal sichtbare Portal weiter
.. die Portale schränken also das zu Rendernde immer stärker ein. :)
Jeder VisContainer hat dabei seinen eigenen SQCull. Ist eine Zelle durch mehrere Portale gleichzeitig sichtbar, so gibt es 
im Sichtbarkeits-Baum auch mehrere VisContainer welche zu dieser Zelle linken und jedesmal einen eigenen SQCull haben.
Dies ist nötig da man durch ein Portal immer nur Teil des dahinterliegenden sehen kann. Damit auch noch soetwas wie Coherent
Hierarchical Occlusion Culling möglich ist, müssen diese Informationen dann auch von Frame zu Frame 'mitgenommen' werden können.
Die Verwaltung einzelner VisNodes innerhalb eines VisContainer ist hingegen recht Effizient, wird eine VisNode nicht mehr
benötigt, so wird diese einfach an eine Liste freier Nodes gehängt so das nicht immer neue Dinge erzeugt und alte zerstört
werden müssen. Diese Sichtbarkeits-Bäume werden erst dann erzeugt wenn diese zum ersten mal benötigt wurden. Später sollte
man das System noch so erweitern das Teilbäume wenn diese ein weilchen lang nicht mehr benötigt wurden automatisch wieder
gekillt werden um Speicher zu sparen was vorallem für große Welten wohl sinnvoll ist. In dem Fall könnten dann auch
bestimmte Scene Container des Scene Graphen gekillt werden und erst wieder nachgeladen werden wenn benötigt. Aber das ist
wirklich eine Herausforderung für später. :)
Eine Scene Node kann also durchaus mehrmals im gleichen Frame gezeichnet werden, aber das sollte im 'normalfall' nicht
so schlimm sein solange sich die Scissor Rectangles der verschiedenen Portale nicht überschneiden - kommt es zu einem solchen
unglücklichen Fall, könnte es zum Beispiel zu unschönen z-fighting kommen... dann kann man eigentlich nur noch dem für diese
Szene verantwortlichen Grafiker auf die Finger hauen und PHUI! sagen. ;-)
Der User selbst merkt aber von diesen etwas komplexeren internen Dingen absolut nichts. Das Interface des Sichtbarkeits-Baums
ist sehr einfach gehalten, trotzdem kommt man problemlos an sehr viele Infos - wenn man will. Zudem gilt hier das 'Nur Schaun,
NICHT Anfassen'-Prinzip. SQCull ist zuständig für das erzeugen dieses Baums und nur diese Klasse hat zugriff auf die Innereien.

Noch ist kein Portal-Übergang von Scene Nodes in andere Scene Container eingebaut und wie konkret man Lichter über dieses
System Managed ist auch noch nicht ausgearbeitet. Jedes Licht selbst muss hierbei dann auch 'durch' Portale scheinen können.
Directionale Schatten sind auch noch ein Problem, denn wenn ein Schattenwerfendes Objekt nicht sichtbar ist, heißst das ja
noch lange nicht das auch der Schatten unsichtbar ist - und bei Directionalen Schatten wird auch die 'länge' dieses Schattens
nicht eingeschränkt... Bei 'normalen' Schatten, also die durch Spheren Lichter erzeugt wurden braucht man diese Schatten ja
NUR innerhalb dieses Lichtradius zeichnen, von daher kein größeres Problem. Auch Portal-Spiegel, also sogenannte 'Virtuelle
Portale' sind noch nicht Implementiert. Die 'normalen' Portale werden in der Literatur öfters als 'Physical Portals' bezeichnet.
Ein paar Implememtations Herausforderungen gibts hier also noch. :)

SRBasic verwendet bereits dieses erweiterte Sichtbarkeits-System und anhand dessen kann man sehen das die Verwendung wirklich
Kinderleicht ist so das sich einzelnde Scene Renderer voll und ganz auf das eigentliche Rendern konzentrieren können, also
wie etwas konkret Dargestellt werden soll. Scene Nodes sollten NIE selbstständig die Welt Matrix des Renderers setzen, das
ist Aufgabe eines Scene Renderers.



>> 14.04.2006
[CO]
- Ich entschloss mich dazu im Szene System 'Scene Loader' einzuführen, also genau das gleiche wie bei Meshs, Bildern etc.
  SceneContainer ist dadurch gleich ein Stück schlanker und übersichtlicher geworden da das konkrete Laden & Speichern unseres
  XML Szene Formats nun in einem Scene Loader Namens 'SceneLoaderPL' geschieht. Ich frage mich wieso ich nicht schon früher
  auf diese Idee gekommen bin, denn es passt ganz wunderbar ins Design und macht das auch gleich wieder ein Stück mächtiger.
  Nun ist's z.B. absolut kein Problem mehr Support für diverse gängige Map Format zu implementieren. :()
  Wie bei diesen Loadern üblich kann man über SceneContainer::GetFormatList() eine Liste aller unterstützen Szene Formate
  anfordern. Bei Zeiten müsste man sich nur wirklich mal überlegen wie man das mit diesen 'Loadern' universeller machen
  kann, denn mittlerweile haben wir ja einige davon und es wäre nett da ein universelles Interface zu haben. :)
- Fügte einen 'proc' Scene Loader hinzu. 'proc' ist das Doom 3 Map Format in dem Zellen & Portale definiert sind, es war
  supereinfach zu Implementieren und nun hab ich endlich genug 'innenlevels' mit Zellen & Portalen zum ausarbeiten des
  Portals Systems. Fügte auch einen 'map' Scene Loader hinzu der aber noch nicht Implementiert ist, sobald das mit dem Portal
  System läuft werd ich das noch Implementieren. Zum einen ist das ein recht gängiges Map Format und zum anderen Interessiert
  mit das einfach wie genau das mit den Brushs in Polygone umwandeln funktioniert. Ob diese 2 'fremd' Formate später noch
  in der Engine liegen, können wir ja später entscheiden. Gerade um das Szene System zu Implementieren und zu testen
  sind diese Formate Optimal da es tonnen an Maps in diesen Formaten gibt + auch jede menge guter Map Editoren wie z.B.
  Quark (http://quark.planetquake.gamespy.com/) der zum einen Open Source ist und zum anderen extrem viele Map Formate
  unterstützt. Hab mir das mit diesen 'Maps/Levels' die ganze Zeit irgendwie aufwändiger vorgestellt, aber im Prinzip ist
  das wirklich ziemlich Primitiv und das spielt auch nett mit unserem Szene System zusammen da diese Maps eigentlich auch
  nur aus Scene Nodes bestehen. :)
  Da bei diesen Map Formaten alles in einem gemeinsamen World Space liegt, muss ich beim einladen alles relativ zu der Zelle
  machen in der sich die Objekte befinden.
- SceneContainer: CalculateAABoundingBox(): Die Bounding Box muss natürlich mit korrekten Werten initialisiert werden
- SceneNode: Die Debug Informationen werden nun korrekt relativ zum Scene Container Dargestellt
- SNPortal: Um Ziel Zelle + Portal Polygon + dieses Portal Polygon im Debug Modus Zeichnen hinzugefügt
... alles in allem funktioniert das mit dem Container Relativ schon ziemlich gut. Ich kann in meiner Test Szene nun Räume
herumschieben und alles darin 'bewegt' sich korrekt mit.



>> 13.04.2006
[CO]
- SRBasic: Verwendet nun SQCull
- Scene Container: DrawSolidFunction() & DrawTransparentFunction() herausgenommen -> Das Darstellen verschieder Scene Nodes
  darf zukünftig nur noch ein Scene Renderer machen.
- SceneContainer::Remove(): Prüft ob die Scene Node aus der Refresh Liste entfernt werden muss
- SceneQuery::PerformQuery(): Über einen Optionalen Parameter lässt sich einstellen ob Scene Container berücksichtigt werden
  sollen oder nicht. Standardeinstellung ist 'true'. Bei SQLine, und SQPlaneSet ist das mit den Scene Container berücksichtigen
  noch relativ einfach, bei SQRender und vorallem SQCull ist das leider etwas aufwändiger.



>> 12.04.2006
[CO]
- SceneNode: Benannte 'RecalculateFlags' in 'InternalFlags' um und fügte eine Funktion hinzu mit dem man diese Flags abfragen,
  aber NICHT von Außen ändern kann. Ich entschloss mich das 'WIP' Scene Node Klassen hier gleich ein Flag setzen damit man
  durch reine interne Flag Abfrage rausbekommen kann ob eine Scene Node z.B. ein Kontainer, eine Zelle oder ein Portal ist.
  Da diese speziellen Klassen zum Kern des Szene Systems gehören wäre es nicht so prall immer über das RTTI abzufragen ob
  meine Szene Node die ich mir gerade anschaue z.B. ein Container.
- Fügte dort wo angebracht noch geschützte Konstruktoren & Destruktoren ein. Es sollte z.B. NICHT möglich sein das man über
  new eine neue Kamera erzeugt und diese auch selbst über delete wieder Killt... das hat das Szene System zu übernehmen. :)
- SceneNode: SetActive(): Wenn eine Scene Node nicht aktiv ist, so wird diese aus der Hierarchie herausgenommen. Wird eine
  Scene Node aktiv, so wird diese zu der Hierarchie hinzugefügt.
- SceneContainer::Get(const char *pszName): Wie mit Stefan vor einiger Zeit besprochen ist nun der Name 'Parent' ebenfalls
  'Reserviert' und kann nicht der Name einer Scene Node sein. Um den Parent Container zu bekommen muss man nun 'Parent' statt
  '.' schreiben. Anstelle '.Node' nun 'Parent.Node'. Um den Parent vom Parent zu bekommen schreibt man 'Parent.Parent'. Steht
  irgendwo '.' am Anfang, so ist dies ein Fehler.
- Fing damit an ein neues Cell&Portal System zu Implementieren. 'SCCell' ist bis jetzt eigentlich nur ein einfacher Scene
  Container. 'SNPortal' ist eine Scene Node einer Zelle und führt in andere Zellen, Portale gehen bei uns nur in eine Richtung
  Will man also von der anderen Zelle wieder zurück in die vorherige, so benötigt diese ein Portal für die Gegenrichtung - dies
  scheint aber die gängige vorgehensweise zu sein... und damit lassen sich auch nett fiese Dinge machen wie z.B. ich komme von
  durch die Tür in einen Raum, geh ich aber durch die gleiche Tür zurück, so lande ich nicht etwa im vorherigen Raum sondern in
  einem total anderem. ;-)
  Eine 'große' Szene wird also bei uns üblicherweise aus einer 'Root Scene' bestehen welche nur aus Zellen besteht welche durch
  Portale verbunden sind. Größere Zellen (Scene Container:) wie z.B. eine Zelle welche ein Außenareal darstellt, können dann wie
  gehabt eine eigene Hierarchie haben um weiter räumlich zu unterteilen, das macht alles recht Flexibel. Größere Außenareale sollte
  man aber trotzdem noch in handhabbare Zellen aufteilen, eine gigantische interne Kontainer Hierarchie bringt niemanden sonderlich
  weit... und so könnte man dann auch einzelne Zellen Dynamisch nachladen/entfernen. Dieses System werde ich nun Schrittweise
  Implementieren. (alles auf einmal wäre etwas heftig :)



>> 11.04.2006
[CO]
- SQCull: Etwas an diesem Query gefeilt
- SNPhysicsWorld.h & SNPhysicsWorld.cpp den Prefix 'SC' verpasst da es sich hierbei ja um einen Scene Container handelt und
  wir hier diesen Prefix verwenden damit man das auf einen Blick erkennen kann.



>> 10.04.2006
[CO]
- SceneHierarchyNode: Fügte eine 'Touch'-Funktion hinzu. Sobald diese Funktion aufgerufen wird führt dieser Hierarchie Knoten
  wenn nötig eine Split/Merge-Operation durch. Anfangs wollte ich soetwas 'automatisch' machen lassen wenn z.B. die Bounding
  Box zurückgegeben wird, aber dann hatte ich so einen 'Update' einfach an zu vielen Stellen im Code was alles etwas
  unübersichtlich machte - und sicherlich auch nicht wirklich Optimal. Ich überlasse es nun dem Benutzer zu entscheiden wenn er
  es einem Knoten erlauben will sich zu reorganisieren wenn nötig. Wird z.B. bei einer Sichtbarkeitsbestimmung ein Hierarchie
  Knoten zum ersten mal in diesem Arbeitsschritt verwendet, so sollte man die Touch-Funktion aufrufen. Somit werden
  gerade nicht verwendete Teile einer Hierarchie komplett ignoriert, sprich, NUR das was wirklich benötigt wird wird eventuell
  Reorganisiert - soetwas nennt man 'lazy evaluation' soweit ich weis :) Da sich durch diese Touch-Funktion die maximale Anzahl
  an Hierarchie Knoten ändern kann, ist es vielleicht auch ganz gut das hier dem Benutzer zu überlassen, nach dieser Funktion sollte
  also jeder wenn nötig prüfen ob's nun mehr Knoten sind als sein eigener Temp-Array zum verwalten zusätzlicher Informationen
  pro Knoten derzeit halten kann. In dem Fall muss der Benutzer dann wenn nötig seinen Array vergrößern. Ohne diese Benutzer eigene
  Touch-Funktion wäre das etwas umständlich geworden. Hatte zuerst mit dem Gedanken gespielt soetwas wie einen 'Hierarchy
  Listener' hinzuzufügen der Informieren kann wenn sich z.B. die maximale Anzahl der Knoten geändert hat so das der Benutzer wenn
  nötig seine Arrays vergrößern kann, aber das wäre dann zu umständlich geworden.
- SceneNode: Neue Funktion: HierarchyRefreshRequired() -> Ändert sich die 'Scene Container Axis Aligned Bounding Box' durch z.B.
  eine positions Änderung, so wird nun diese Funktion aufgerufen welche der Scene Node ein Flag verpasst welches vermerkt das
  diese Scene Node in der Hierarchie aktualsiert werden muss. Zudem wird diese Scene Node dann im Scene Container in eine entsprechende
  Liste eingetragen. Wird die Szene Hierarchie dann das nächste mal benötigt, wird zuerst diese Liste abgearbeitet und die Hierarchie
  hierdurch aktualsiert. Würde SOFORT wenn z.B. SetPosition() aufgerufen wird eine Hierarchie aktualisierung durchgeführt werden,
  so müsste einiges (wie z.B. die Container Space Bounding Box) pro Frame mehrmals neu berechnet werden was unnötig ist. Eventuelle
  umstrukturierungen in der Hierarchie selbst werden sobald die 'Touch'-Funktion eines Hierarchie Knotens aufgerufen wird durchgeführt.
  Ändern sich Scene Nodes, arbeitet das Szene System diese Änderung also in zwei Arbeitsschritten ab:
  - 1: Scene Node wird markiert und beim nächsten mal wenn die Scene Container Hierarchie angeforderd wird, wird dieser Hierarchie
       mitgeteilt das sich diese Scene Node geändert hat. Durch diese 'verzögerte' Verarbeitung wird das mehrmalige neuberechnen
       diverser Dinge vermieden. Ansonnsten könnte schnell soetwas passieren: Positions änderung, Hierarchie aktualisieren, Rotations
       änderung, Hierarchie aktualisieren, Skalierungs änderung, Hierarchie aktualisieren... und das möglicherweise mehrmals
       bevor die Hierarchie dann überhaupt mal benötigt wird und das ganze 'bitte erst komplizierteres Zeug berechenen wenn wirklich
       benötigt'-Prinzip wäre futsch.
  - 2: Sobald ein Hierarchie Knoten z.B. bei der Sichtbarkeitsbestimmung 'angefasst' wird, wird die 'Touch'-Funktion dieses Knotens
       aufgerufen. In dieser Funktion wird dann wenn nötig eine Split/Merge Operation ausgeführt.
- Die Scene Queries rufen nun die 'Touch'-Funktion der Hierarchie Knoten auf. SQCull vergrößert falls nötig seine Arrays mit
  Zusatzinformationen pro Knoten.
- Arbeitete etwas an den konkreten Hierarchie Implementationen weiter. Wir haben pro Implementation 2 Klassen. Einmal die RTTI
  Szene Hierarchie selbst welche den Einstiegspunkt markiert, und dann noch eine Szene Hierarchie Klasse für die einzelnen Knoten.
  Da die entsprechende RTTI Klasse immer recht klein ist entschied ich mich dazu diese zwei Klassen in eine gemeinsame Datei
  zu packen damit alles übersichtlich beisammen ist und das nicht in einzelnde kleine Dateien zerrissen wird.
- SceneNode: Machte SetAABoundingBox() virtuell da z.B. ein Scene Container seine Hierarchie angleichen muss oder eine Physik Welt
  ihre größe wenn sich hier etwas ändert. Wollte das zuerst über Scene Node Listener machen, aber das war mir dann doch etwas
  zu umständlich & dämlich. :)
- SceneContainer: Überschreibt die Axis Aligned Bounding Box Default Einstellungen so das man hier bereits ohne etwas ändern
  zu müssen eine Bounding Box hat die oft für einfache Dinge ausreichend ist.
- Da das mit den überarbeiteten Szene Hierarchien nun zumindestens wieder so gut funktioniert wie vorher aktualsierte die Codes
  auf dem Server. Die Hierarchie Implementationen sind jedoch noch nicht fertig/sonderlich gut und auch ein paar andere Dinge
  wie das mit den Container in Container Dingen etc. ist noch nicht realisiert.
- SQCull: GetVisibleSceneNodes() gibt nun den Pool zurück, damit kann man mehr anfangen als 'nur' mit einem Iterator :)
... so, hab heute mal versucht 'mehr Deutsche Begriffe' im Tagebuch Eintrag zu verwenden da ich merkte das ich Deutsch und
Englisch immer recht stark mische. Aber für die meisten Dinge will ich gar nicht die Deutschen Begriffe verwenden da diese
teils soetwas von dämlich klingen und man dann oft erstmal gar nicht weis von was hier gerade gesprochen wird... und oft ist's
zumindestens für mich Hilfreich gleich z.B. 'Scene Node' zu schreiben statt 'Szene Knoten' da die gleichen Begriffe ja auch
direkt so in den Codes verwendet werden. :)



>> 09.04.2006
[CO]
- Scene Node: Die Object Space Axis Aligned Bounding Box ist nun ans RTTI gekoppelt, so kann man nun z.B. im Scene Editor
  die Bounding Box eines Scene Containers einstellen.
- SceneContainer:
  - Neue Funktion: CalculateAABoundingBox() -> Berechnet und setzt eine Bounding Box welche alle Scene Nodes
    des Containers einschließt.
  - Beim Laden & Speichern werden nun die RTTI Variablen des Containers in der Scene XML Node abgelegt. Die
    Klasse wird aber hier nicht abgelegt da es in dem Fall keinen Sinn hätte da die Klasse ja bereits fest ist wenn ein 
    Container etwas einladen soll. :)
  - Die verwendete Hierarchie ist nun ebenfalls ans RTTI angeschlossen so das man diese jederzeit sofort Ändern kann und
    die verwendete Hierarchie Klasse auch automatisch gespeichert & geladen wird. Dadurch wurde das extra 'Hierarchy'-XML
    Tag im Szene Format überflüssig.



>> 08.04.2006
[CO]
- Stellte die Scene Queries auf die neue Scene Hierarchy um
- Fügte Hierarchie SHList hinzu. Diese 'Liste' sollte aber wirklich nur in Ausnahmefällen verwendet werden - z.B. für die
  Scene Root, also diesen 'Scene' Teil der eigentlich 'Image Based' ist und wo man davon ausgeben kann das die verwendeten 
  Scene Nodes nicht wirklich Bounding Boxes haben. Da die ganzen Scene Queries NUR auf Scene Hierachien arbeiten, muss immer 
  zumindestens der Root Scene Container eine Hierarchie haben. Würde man es anderst machen, also das mal überhaupt keine 
  Hierarchie da ist, so müsste man wieder hier und da doofe eigentlich überflüssige Fallunterscheidungen machen.
  (ist eine Hierarchie da? Ok dann mach das so, ansonnsten nehm diese Lösung... und das überall, jedesmal... bbrrr)
- Scene Node um weitere Funktion erweitert: GetHierarchy(): Damit kann man sich die Hierarchie zurückgeben lassen in dem 
  sich diese Scene Node sich befindet.
- SQCull: Verwendet nun ein weiteres Bitset um sich zu merken welche Hierarchy Node KOMPLETT im Frustum ist, diese Information
  wird dann dazu verwendet um den Frustum Test der Child Nodes zu überspringen. Ist eine Node komplett im Frustum, so sind 
  die Child Nodes ja zwangsläufig ebenfalls im Frustum. Ist ein 'Blatt' komplett im Frustum, so weis man das alle darin 
  eingelinkten Scene Nodes ebenfalls im Frustum sind. Diese Bitset Abfragen sind deutlich weniger Aufwändig als Frustum 
  Tests, daher lohnte diese Optimierung. In meiner etwas extremen Test Szene mit 100000 Hierarchy Nodes hatte ich, wenn 
  komplett alles im Frustum war ohne Optimierung 9 FPS, mit 14, also eine Messbare Verbesserung. :)



>> 07.04.2006
[CO]
- Besprach heute im Chat mit Stefan etwas ausführlicher wie genau wir das mit dem Scene System alles handhaben wollen. 
  Da Stefan lieber beim begriff 'Hierarchy' bleiben möchte da eindeutiger, änderte ich das wieder in meinen aktuellen 
  Umbauten. Wir diskutierten eine ganze weile den Fall Terrain/Level Mesh, also wenn etwas an sich ein geschlossenes System 
  ist mit eigener räumlicher Aufteilung, aber trotzdem in eine gemeinsame Hierarchie eingebracht werden müsste damit Dinge 
  wie Occlusion Culling möglich sind. Stefan schlug vor, das ein Scene Container nicht zwangsläufig IMMER eine eigene 
  Hierarchie haben muss... hat ein Container keine eigene Hierarchie, so geht man solange die Parent Container hoch bis ein 
  Container mit Hierarchie gefunden wurde - dort linken sich dann die Scene Nodes ein. Desweiteren ist jede Node relativ 
  zu ihrem Container, bewegt man z.B. ein Haus (Container) so bewegen sich alle Objekte darin automatisch mit. Bei Physik 
  läuft es dann genauso ab wie mit der Hierarchie, bzw. das ist ja jetzt schon so. Es gibt normalerweise dann nur einen 
  Container der eine 'Physik Welt' ist, und alle Nodes fügen sich dort ein. Werden dann z.B. Positionen durch die Physik 
  geändert, so müssen diese Werte vom 'World Space' in den konkreten 'Container Space' umgerechnet werden. Wie besprochen 
  verpasste ich Scene Nodes noch ein 'Automatic'-Flag, also z.B. Terrain Patches erhalten dann so ein Flag beim erzeugen so 
  das diese Scene Nodes nicht mit gespeichert werden und auch in z.B. dem Scene Editor 'versteckt' werden.
  Eine konkrete Szene könnte dann also so aussehen: (inklusive Dinge wie Bildschirm löschen oder Gui Zeichnen :)

    - Scene Root (Scene container) [Hierarchie List]
      - Clear (Scene node)
      - Scene (Scene container) [Hierarchie Octree]
        - Sky Box (Scene node)
        - Terrain (Scene container)
          - Patch (Scene node, automatic)
          - Patch (Scene node, automatic)
          - Patch (Scene node, automatic)
        - Kiste (Scene node)
        - Jeep (Scene node)
        - Häuschn (Scene container) [Hierarchie ...]
          - Stuhl (Scene node)
          - Tisch (Scene node)
        - Stein (Scene node)
      - Engine information (Scene node)
      - Gui (Scene node)

  Jede Scene Node kann dabei nur in einer Hierarchie gleichzeitig sein. Der User kann die Hierarchie selbst nicht 
  manipulieren. Das System verwaltet sich also komplett selbst, man kann nur z.B. einstellen welcher Hierarchie Typ verwendet 
  werden soll. Ein Scene Container muss eine Bounding Box haben die alle ihre Scene Nodes einschließst.
  Da Scene Queries intern eventuell pro Hierarchie eigene zusätzliche Informationen speichern müssen ist es nötig das jede 
  Hierarchie Node eine eigene einzigartige ID hat. Da Hierarchie Nodes auch regelmäßig gelöscht und neu erzeugt werden 
  kombinierte ich diese zwei Dinge gleich: Die Hierarchie hat intern eine Liste von 'derzeit freien' Nodes, soll eine neue 
  Node erzeugt werden, so wird zuerst geprüft ob noch etwas in der Liste freier Nodes ist. Ist dies nicht der Fall, so 
  wird eine neue Node erzeugt. Man weis nun also immer wieviele Nodes gerade verwendet werden und was die maximale derzeitige 
  Anzahl ist und die ID's reichen immer von 0-max. Somit kann z.B. SQCull problemlos ein Bitset halten um die Sichtbarkeit 
  der Nodes im letzten Frame speichern oder HW Occlusion Queries zuweisen, die Node ID's sind hier also Indices auf einen 
  Array.
- Nahm ScenePVS, SMPortal heraus da mittlerweile total veraltet
- Nahm die Sektor Dinge aus SNObject heraus da total veraltet
- Nahm die alten Hierarchien heraus, derzeit gibts nur eine neue 'kd-tree'-Hierarchie
- Nahm SkeletonScene heraus da dieses in absehbarer Zeit nicht implementiert wird



>> 06.04.2006
[CO]
- SQCull: Nahm die Hash Table welche Hierarchy Nodes Occlusion Queries zuwies heraus. Da es immer genauso viele Occlusion 
  Queries geben sollte wie Hierarchy Nodes kann man gleich mit der internen ID der jeweiligen Node arbeiten.
- Benannte die Scene Hierarchien in Scene Trees um und überarbeitete diese damit alles Dynamischer & Effizienter wird. Nur 
  noch 'Tree' ist eine RTTI Klasse, quasi der 'Einstiegspunkt'. 'Tree Nodes' selbst sind recht einfach gehalten und 
  normalerweise kommt man als User NUR mit dem Tree-Interface selbst in Kontakt. Eine Tree Node kann mehrere 
  'Tree Node Items' enthalten welche zu den konkreten Scene Nodes linken. Eine Scene Node kann wiederum verschiedene dieser 
  Tree Node Items haben welche diese zu verschiedenen Tree Nodes linken. Im Optimalfall ist eine Scene Node nur in einer 
  Tree Node, aber wenn die Scene Node mal 'zwischen' Tree Nodes liegt, so bekommt jede Tree Node einen verweis auf diese 
  Scene Node. Da das System 'dynamisch' ist, also sich Scene Nodes die ganze Zeit bewegen können und dadurch der Scene Tree 
  immer wieder aktualsiert werden muss, entschied ich mich dafür in Tree Nodes, Tree Nodes Items und Scene Nodes direkte 
  Zeiger auf den 'vorgänger' und den 'nachfolger' zu halten als bereits bestehende Container Klassen zu verwenden. Das macht 
  die Sache etwas durchsichtiger und direkter... und da dieses System mit vielen Scene Nodes gleichzeitig herumjonglieren 
  muss ist hier weniger einfach mehr. :)
  Der Name 'Tree' ist irgendwie schicker da zum einen kürzer als 'Hierarchy' und zum anderen spricht man sowieso bei den 
  ganzen konkreten Implementationen von z.B. Quadtree, kd-tree etc. Ich entschied mich dafür das Scene Nodes nur in einem 
  Scene Tree gleichzeitig sein können, also in diesem Scene Tree des Parent Scene Node Containers. Dies vereinfacht die 
  Implementation enorm da die Nodes dann ganz konkret 'Wissen' in welchen Tree Nodes diese sind und so lässt sich der Scene 
  Tree leichter aktualisieren wenn sich die Bounding Box einer Scene Node verändert hat. Zudem müsste das auch wirklich 
  reichen und für alles wie beispielsweise Sichtbarkeitsbestimmung, Kollision etc. passen. Bei Kollisionen ist es dann 
  Aufgabe der Scene Nodes 'genauere' Kollsionen zu bestimmen - Scene Tree ist nur als übergeordnete und universelle Szenen 
  Aufteilung gedacht.



>> 05.04.2006
[CO]
- SceneQuery: Über das Flag 'OnSceneNode' lässt sich einstellen ob InformOnSceneNode() aufgerufen werden soll um eventuelle 
  Query Listener zu informieren oder nicht.
- SQCull:
  - Speichert nun alle als Sichtbar ermittelten Scene Nodes in einer Fast Pool Liste ab die man dann von außen durchlaufen 
    kann. Diese Liste ist dabei bereits so geordnet das das was der Kamera am nächsten ist vorne in der Liste steht. Über 
    GetVisibleSceneNodes() kann man sich einen Iterator auf diese Liste zurückgeben lassen.
  - Nahm 'DataPackage'-Struktur heraus welche InformOnSceneNode() übergeben wurde so das man die Entfernung zur Kamera 
    nicht nochmal selbst berechnen musste. Da man diese Entfernung nicht soo oft braucht, die Berechnung dazu recht einfach 
    ist und InformOnSceneNode() selbst nur noch in Sonderfällen verwenden sollte, ist das wirklich unnötig. :)
  - Wurde als Modus 'Previous' ausgewählt, so werden nun NUR NOCH bei bedarf die Scene Query Listener informiert, alles andere 
    bleibt wirklich gleich.
  - Änderte ein paar Namen wie z.B. 'SetRenderMode' in 'SetMode'
- SceneNode: Gibt man einer Scene Node das Flag 'CanOcclude', so kann diese Scene Node andere Scene Nodes 'verdecken'. Nur 
  'größere' Scene Nodes welche auch wirklich potentiell Dinge verdecken können sollten dieses Flag erhalten. Gibt man selbst 
  kleinsten Patronen Hülsen dieses Flag, so hat das Sichtbarkeits-System ganz schön was zu schaffen. :)
- Verschob das 'Shadow'-Flag von SNObject in Scene Node.



>> 03.04.2006
[CO]
- Räumte die Codes etwas auf: Leerzeichen, Tabs, ein paar auskommentierte Codes entfernt, ein paar [TODO] eingefügt
- Benannte 'SQRender' in 'SQCull' um, dieses Query ermittelt NUR was Sichtbar ist und was nicht. Also Frustum Culling, 
  Occlusion Culling etc. Bis jetzt wurden die Dinge auch gleich gerendert was aber nicht soo gut ist da dann die Aufgaben 
  nicht mehr klar Definiert sind. Zudem werden beim Occlusion Culling üblicherweise nur auserwählte Nodes gerendert wobei 
  hier zusätzlich noch ein vereinfachtes Mesh verwendet wird + NUR Tiefenwerte geschrieben werden. Diese Occlusion Meshs 
  sollten IMMER ins Orginial Mesh passen und nicht 'hinaushängen'... dann kann man den Tiefenbuffer auch direkt so zum
  'richtigen' Rendern weiterverwenden was vorallem bei etwas intensiveren Fragment Shadern vorteilhaft ist da durch den 
  bereits mit ein paar Tiefenwerten gefüllten Z-Buffer weniger Fragmente 'durchkommen'. Pro 'Viewport' sollte wie gehabt 
  jeweils ein EIGENER Scene Query für die Sichtbarkeit verwendet werden der so lange am Leben bleibt wie der Viewport 
  selbst. Dies ist vorallem wichtig wenn 'coherent' als Culling Modus ausgewählt wurde - hier werden dann Werte aus dem 
  letzten Frame verwendet um die Sichtbarkeitsbestimmung zu beschleunigen. Da HW Occlusion Queries assynchron sind sollte 
  man NICHT auf das Ergebeniss der Anfrage warten! ('StopAndWait'-Modus)
- Benannte 'SQSceneRenderer' in 'SQRender' um, das diese 'Anfrage' an die Scene geht sollte ja klar sein. ;-)
  Pro Viewport sollte jeweils ein eigener Scene Renderer verwendet werden da dieser eventuell je nach Implementation 
  jeweils Informationen aus dem aktuellen Frame zwischenspeichert. (siehe 'SQCull' oben, oder eventuell auch Progressive 
  Mesh Informationen)



>> 30.03.2006
[CO]
- SCMirror: Über die neue Variable 'TextureStage' kann man einstellen WO genau die Dynamische Texture gesetzt wird, damit 
  hat man im Material mehr variations Möglichkeiten.



>> 24.03.2006
[CO]
- SNRagdoll: Neue Funktionen: CloneBody() & CloneJoint(): Erzeugen eine Kopie von einem Körperteil/Gelenk. Desweiteren kann 
  man jetzt einstellen ob Gelenke an die Welt gebunden sein können oder nicht. Standardmäßig werden Gelenke nicht an die 
  Welt gebunden, dies ist eigentlich nur für den Ragdoll Editor sinnvoll damit das Ragdoll beim Testen nicht immer 
  wegfällt. :)



>> 23.03.2006
[CO]
- SNRagdoll: Neue Funktionen:
  - RemoveBodyAndJoint(): Löscht ein Körperteil + das damit verbundene Gelenk
  - AddBody() & AddJoint(): Fügt einen neuen Körper/ein neues Gelenk dem Ragdoll hinzu
- SCStaticCamera: Hier kann man nun ebenfalls einen Ziel Offset einstellen damit z.B. in PLSampleNewtonCharacterController 
  die Statischen Kameras nicht immer nur die Füße unseres Helden festhalten. ;-)



>> 22.03.2006
[CO]
- SNRagdoll: Neue Funktionen: RemoveBody(), RemoveJoint() -> zum Löschen von Körperteilen und Gelenken



>> 20.03.2006
[CO]
- SNObject: Neue Funktion: GetSkeletonJointWorldPosition(): Gibt die World Space Position eines Skeleton Joints zurück, 
  soetwas wird man wohl immer mal wieder brauchen, daher gleich die Funktion im Objekt. Wird bereits in 
  PLSampleNewtonCharacterController verwendet um zu ermitteln wie nah die Kamera am Kopf des Helden ist.
- Neuer Scene Node Modifier: PLEngine::SNMAnchor: Damit kann man Scene Node ganz einfach 'verlinken'. Man hängt einer Parent Scene 
  Node einfach so einen Modifier an dem man dann noch sagt welche andere Scene Node hier verlinkt wird + diverse weitere 
  Einstellungen wie Position & Rotation Offset etc. Die Implementation lässt sich sicherlich noch Optimieren, aber fürs 
  erste wollte ich die Implementation so einfach wie möglich haben.



>> 16.03.2006
[CO]
- SNCamera: UseZFar steht nun Standardmäßig auf 1, denn wird z-far Ebene nicht verwendet kann es hier und da zu Problemen 
  kommen wie z.B. beim Selektieren der Geometrien im Mesh Editor. Allerdings sollte man keine z-far Ebene verwenden wenn 
  man Shadow Volumes verwendet die unendlich weit ausgedehnt werden, denn in diesem Fall werden diese durch die z-far 
  Ebene 'geschnitten' und schon hat man ein offenes Volumes was zu Schatten Fehlern 'in der Ferne' führt.



>> 12.03.2006
[SW]
- Läßt sich nun unter linux wieder übersetzen, habe dabei ein paar "dumme" syntax-fehler behoben.



>> 12.03.2006
[CO]
- Konsole: Neue Debug-Befehle: coordinateaxis, xzplane, xyplane, yzplane -> Zum Toggeln der jeweiligen Debug Einstellungen



>> 11.03.2006
[CO]
- SNEngineInformation::DrawTransparentFunction(): Neben der Visualisierung des Koordinaten Systems im Ursprung wird nun 
  auch wie in den Editoren links unten eine kleine rotierte Version der Achsen angezeigt - das ist recht hilfreich zum 
  Orientieren. ;-)
- SCRenderToTexture::DrawSolidFunction(): Das Rendern in Cube Texturen an die Matrizen Änderungen angepasst - da die 
  Cube Texturen nun korrekt erzeugt werden, braucht man auch keinen doofen Hack mehr in Shadern wie z.B. CubeReflection.cg 
  welche Cube Texturen verwenden... war wirklich gut das die Matrizen Klassen gesäubert wurden so das man GANZ GENAU 
  voraussagen kann wie sich was rotieren wird... zumindestens bei einfachen Achsen Rotationen. Beispielsweise ist das 
  Rendern der y/-y Textur Seiten etwas Tricky da sich bei diesen Rotationen etwas verdreht - was aber völlig normal ist. :)
- SNCamera::DrawTransparentFunction(): Ist eine Kamera im Debug Modus, so wird der Frustum Visualisiert - so kann man 
  z.B. prüfen ob eine Kamera korrekte Einstellungen hat wenn man diese Kamera 'von Außen' anschaut. :)
- SCStaticCamera: Aktiviert/Deaktiviert 'seine' Kameras nun standardmäßig selbstständig, so müssen z.B. gerade nicht 
  verwendete Kameras nicht immer trotzdem aktualisiert werden. Desweiteren wird auch der Debug Modus der aktiven Kamera 
  standardmäßig automatisch gesetzt so das man, wenn SCStaticCamera im Debug Modus ist über eine andere Kamera beobachten 
  kann wie die Kameras automatisch das Ziel verfolgen und bei bedarf zu anderen Kameras umschalten.



>> 10.03.2006
[CO]
- SNConsoleBase::ProcessKeyMessage(): uint32 Umstell-Bug behoben



>> 06.03.2006
[CO]
- SNCamera: Zum berechnen der View Matrize wird nicht mehr LookAt() verwendet sondern direkt das Quaternion. Durch eine 
  total 'freie' Rotation verdreht sich die Kamera langsam, daher kann man in 'SNCamera::UpdateFunction()' Roll automatisch 
  korrigieren lassen. Bei Zeiten müsste die Kamera nochmal sauber aufgeräumt werden um z.B. verschiedene automatische 
  Steuerungen anzubieten. (oribten, beschränkte/freie Rotation etc...)



>> 03.03.2006
[CO]
- Shadow Volumes werden wieder korrekt dargestellt: Die Model View Projection Matrize welche dem Shader übergeben wurde 
  war nicht ok. (vertauschte Matrizen Multiplikation :)



>> 02.03.2006
[CO]
- Dort wo möglich werden nun die statischen Objekte von z.B. Quaternion verwendet statt neue Temporäre Objekte zu erzeugen



>> 28.02.2006
[CO]
- Ein paar Leerzeichen/Tabs verbessert



>> 25.02.2006
[CO]
- Alles an Quaternion Änderungen angepasst



>> 25.02.2006
[SB]
- Alles an PLGeneral Änderungen angepasst



>> 24.02.2006
[CO]
- Alles an PLGui Änderungen angepasst
- Stellte wie dort wo möglich/sinnig von globalen Definitionen auf Klassen abhängige enum Definitionen um. Beim Renderer 
  hab ich erstmal nichts gemacht da diese Umstellung dort eine größere Sache wird.



>> 23.02.2006
[CO]
- Alles an PLGeneral Änderungen angepasst
- SNSky: Wird wieder korrekt angezeigt



>> 22.02.2006
[CO]
- Die Haupt-Header der Projekte haben nun am Anfang des Namens wieder ein PL
- Doxygen Makefiles angepasst
- Alles an PLMath Änderungen angepasst



>> 21.02.2006
[CO]
- Alles an aktuelle PLMath Änderungen angepasst (ein paar Dinge sind noch nicht ganz ok)



>> 10.02.2006
[CO]
- Alles an Stack & PLMath Änderungen angepasst



>> 06.02.2006
[CO]
- Alles auf String::Format() umgestellt + dort wo möglich von %f auf %g umgestellt da dadurch nur das nötigste ausgegeben wird
- GuiPLGraphics: Kleinen uint32 Umstell Fehler behoben... hier können natürlich auch negative Werte kommen, SetupClippingArea() 
  ist dann für den rein Sichtbaren Bereich zuständig. (und hier darf nichts negatives kommen :)



>> 27.01.2006
[CO]
- Auf Namespaces umgestellt



>> 26.01.2006
[CO]
- An Renderer Änderungen angepasst



>> 23.01.2006
[CO]
- An uint32 Änderungen angepasst



>> 19.01.1006
[CO]
- Alles an PLMath & PLGui Änderungen angepasst



>> 18.01.2006
[CO]
- Alles an PLGeneral Änderungen angepasst



>> 13.01.2006
[CO]
- Stellte alle Projekte 'über' PLGui auf die neue String Klasse um - nur an den stellen wo String Variablen vom RTTI genutzt 
  werden wird noch die alte Klasse verwendet.



>> 06.01.2006
[CO]
- Neue Scene Node 'PLTSNText' für 2D & 3D Texte hinzugefügt... so kann man bestimmte Dinge in der Scene 'Beschriften' was 
  vorallem für Beispiel Scenen enorm praktisch ist. ;-)



>> 05.01.2006
[CO]
- Im Scene Unterordner gibts nun einen neuen Ordner Namens 'SceneNodeModifiers' in welchem sich ein paar praktische 
  Node Modifier befinden, z.B. um Positionen um einen Mittelpunkt Orbiten zu lassen, Rotationen automatisch zu ändern so das 
  Nodes automatisch rotieren können etc.. Auch gibts einen Modifier über den man Nodes auf einem automatisch auf einem Pfad 
  herumwandern lassen kann - sehr praktisch für automatische Kamerafahrten oder sich herumbewegende Lichter. 'PLTSNTool' ist 
  somit überflüssig und wurde entfernt, denn genau das lässt sich nun sehr viel flexibler über Node Modifiers regeln. :)
  Man kann mit hilfe dieser Modifier bereits etwas 'Leben' in seine Scene bringen, ohne gleich 'richtige' Skripte in z.B. 
  Lua schreiben zu müssen oder gar gleich einen c++ Compiler anwerfen zu müssen NUR um z.B. eine Node rotieren zu lassen.



>> 03.01.2006
[CO]
- Nahm die mittlerweile veralteten Pfade komplett aus der Engine, diese Sache befindet sich nun in PLMath.



>> 01.01.2006
[CO]
- Passte überall das aktuelle Jahr an, also von 2002-2006
- PLTPostProcessManager::DrawResult(): Der Tiefen Buffer wird hier nun ignoriert - ansonnsten kann es zu Grafik Bugs kommen.
- PLTSNParticleGroup: Da in meinen Tests das füllen von 'Managed' Vertex Buffer um einiges flotter war, (selbst wenn NUR 
  gefüllt und nie gelesen wird) machte ich den Vertex Buffer der Partikel wieder Managed. Optimierte CreateShapes() etwas.
- PLTSCRenderToTexture um Rendern in Cube-Texturen erweitert



>> 30.12.2005
[CO]
- Fand in den verschiedenen Projekten noch ein paar Stellen wo nun PLTString verwendet werden kann, und stellte entsprechend 
  um
- Die einzelnen Resource-Debug Dialoge werden nun erst Initialisiert wenn diese zum ersten mal Sichtbar werden - dies 
  beschleunigt vorallem im Debug Modus das 'erscheinen' dieses Debug Dialoges ganz erheblich.
- Debug Dialog: Fügte einen 'Scene'-Tab hinzu indem man wie früher im alten Entity-Tab Scene Änderungen vornehmen kann.
- 'PLConsole.mat' in 'standard.pak' verbessert: Dieses Material für den Konsolen Hintergrund wird nun in zwei Schritten 
  dargestellt damit die Konsole 'weich' ein/ausblenden kann.



>> 29.12.2005
[CO]
- PLTSNObject: Kann nun die Scene Node Bounding Box Dynamisch aktualisieren. Dafür merke ich mir die Orginal Bounding Box 
  des Meshs und der Joints. Zur Laufzeit kann man recht schnell die aktuelle Joint Bounding Box ermitteln - und das 
  berechnen der aktuellen Mesh (und damit Scene Node) Box kann man dann über Faktoren regeln da man weis wie sich die 
  Joint Box verändert hat. Somit passt nun immer die Scene Node Bounding Box bei Skinned Meshs. (und natürlich auch bei 
  Ragdoll:) Weis nicht ob das final auch in PLTSNObject bleibt, aber für's erste gehts so.



>> 21.12.2005
[CO]
- PLTSkyLayer: World Matrix & Material verbessert
- PLTSQRenderer::TraverseNode(): Befindet sich die Kamera IN einer Scene Node, so bekommt nun diese Node automatisch intern 
  eine höhere Zeichen Prirotität. Ist 'MaxDrawDistance' von Scene Node negativ, so wird dieser Wert anstatt der wirklichen 
  Entfernung verwendet... PLTSky hat z.B. hier Standardmäßig '-10000' was bewirkt das diese Node VOR allen anderen gezeichnet 
  wird was hier nötig ist... dies ist zwar noch keine Universelle Lösung, reicht aber bis jetzt völlig aus und ist nicht 
  sonderlich komplex.
- PLTSNParticleGroup hat nun keine eigene Bounding Box mehr - dies ist mittlerweile total überflüssig. Desweiteren wird nun 
  intern PLTFastPool zur Verwaltung der Partikel verwendet, damit geht das 'suchen' freier Partikel deutlich flotter und 
  man braucht theoretisch keine Partikel Limitierung mehr da eine Dynamische doppelt verkettete Liste verwendet wird. 
  Praktisch hab ich aber eine Limitierung drinen gelassen damit man die Anzahl der Partikel besser Kontrollieren kann und 
  auch die größen Vertex/Index Buffer sollten nicht ständig geändert werden.
- Erweiterte PLTSceneNode um ein 'Drawn'-Flag. Immer wenn die Scene Node gezeichnet wird, wird dieses Flag auf 'true' 
  gesetzt. Nachdem die Scene Node aktualiert wurde, wird dieses Flag wieder auf 'false' gesetzt. Über GetDrawn() kann man 
  somit nun z.B. in der Update Funktion herausfinden ob die Scene Node im letzten Frame überhaupt gezeichnet wurde... ist 
  dies nicht der Fall, kann man sich oft einiges an Arbeit sparen welche Grafische Dinge betreffen wie z.B. Partikel 
  Effekte, Skinned Mesh etc.. Dies ist bis jetzt die einzige halbwechs brauchbare Methode dafür die mir bis jetzt 
  eingefallen ist und es funktioniert auch recht gut. Die abgeleiten Scene Nodes müssen hier immer selbst entscheiden WIE 
  sie diese zusatz Information verwenden.
- PLTSNConsole::UpdateFunction(): Beim ein/ausblenden der Konsole wird nun der Zeit Skalierungs Faktor ignoriert - das 
  laangsame Ausblenden nervt. :)



>> 16.12.2005
[CO]
- Stellte überall wo es sinnvoll ist auf PLTString um.



>> 12.12.2005
[CO]
- PLTSQSceneRenderer: Um 'Flags' erweitert damit man z.B. festlegen kann ob Schatten gerendert werden sollen oder nicht, 
  z.B. kann man sich meistens oft wenn man Reflectionen/Refractionen Rendert Schatten ignorieren ohne das dies auffällt. 
  Natürlich steht es den konkreten Scene Renderern frei diese Flags zu verwenden oder nicht - z.B. kann wohl nicht jeder 
  Scene Renderer Schatten Darstellen, in dem Fall werden diese Einstellungen ignoriert.



>> 10.12.2005
[CO]
- PLTSNMirror heißt nun PLTSCMirror und wird von PLTSCRenderToTexture abgeleitet.



>> 09.12.2005
[CO]
- Stefan sprach vor 2 Tagen im Chat eine Universelle 'Render To Texture'-Scene Node an welche man dazu verwenden könnte 
  Teil-Scenen in eine Textur Rendern zu lassen. Ich Realisierte diese sehr gute Idee gerade und in der Praxis funktioniert 
  das wirklich prima. PLTSCRenderToTexture kann mit PLTSurfaceListener verglichen werden, hat also einen eigenen Scene 
  Renderer Query - vorallem wenn in einem solchen Query aktuelle Informationen von Frame zu Frame 'zwischengespeichert' 
  werden müssen wie es beim z.B. 'Coherent Occlusion Culling' nötig ist, ist es unumgänglich verschiedene Scene Renderer 
  Queries zu haben. PLTSCRenderToTexture kann dazu verwendet werden Dynamische Texturen von 'Überwachungs-Kameras' zu 
  Managen... oder für 'einfachere Dinge' wie z.B. das Rendern eines Guis in eine Textur. (für Dynamische Menüs bei Konsolen)
- In PLTSceneContainer::LoadRec() war noch ein kleiner Fehler welcher verhinderte das das Anhängen von Scene Node Modifiern 
  richtig funktioniert.
PLModel:
- PLTTextureManager & PLTTexture: Fügte die Möglichkeit hinzu eine bereits bestehende Renderer Texture Resource an den 
  Texture Manager zu 'binden'. Dies wurde nötig damit man die Dynamischen Texturen von z.B. PLTSCRenderToTexture bequem und 
  universell über das Texture System verwenden kann.



>> 08.12.2005
[CO]
- Neue Scene Node: PLTSNMirror: Die Scene wird von einer durch 'den Spiegel' veränderten Kamera in eine Textur gerendert 
  welche dann für den 'Spiegel' verwendet wird. Da der Spiegel ein Material hat kann man dem Spiegel auch über einen Shader 
  welcher die gerenderte Textur verwendet darstellen lassen.
- PLTSceneContainer: Implementiert die Funktionen Get() selbst da hier auch 'absolute Namen' möglich sind. Ich erlaube hier 
  auch Kombinationen wie z.B. '.MyNode' was einem 'MyNode' vom Parent Container zurückgibt oder wenn man 'Root' angibt 
  bekommt man die Root Scene Node welche man auch über PL::GetRootSceneContainer() bekommen kann. Vorallem '.MyNode' ist 
  in der Praxis praktisch wenn man weis das Node 'x' im Parent sitzt, hier aber nicht genau weis wie der Name es Parents 
  lautet oder wie gar der absolute Name ist. Verwirrt das jemanden, braucht er es nicht zu verwenden und gibt immer 
  umständlich den absoluten Namen an... und wenn sich Container Namen mal ändern, darf mal halt alle absoluten Namen ändern. 
  Weitere Details stehen in den Kommentaren zu PLTSceneContainer.
- PLTSceneNode: Bei SetName() wird geprüft ob der Name 'zulässig' ist, also kein '.' im Namen vorkommt und der Name selbst 
  darf nicht 'Root' sein. (außer für die Root Scene Node :) Weitere Details stehen in den Kommentaren zu PLTSceneNode.
  ... PLTSCStaticCamera und PLTSNCamera verwenden bereits kräftig diese Scene Node Namen. Wie man an 
  PLSampleNewtonCharacterController welches PLTSCStaticCamera verwendet sehen kann, funktioniert dieses Namens System recht 
  gut und ist auch einfach zu bedienen.
- PLTSceneNode: Neue Funktion: GetAbsoluteName() ermittelt den absoluten Namen der Scene Node und gibt diesen zurück. Jedoch 
  ist diese Funktion momentan noch nicht wirklich Performant... aber der Absolute Name soll hier auf jedenfall immer erzeugt 
  werden da das speichern des absoluten Namens umständlich wäre - denn jedesmal wenn einer der Parent Container seinen 
  Namen ändert, müsste man alle Absolute Scene Node Namen anpassen. (was ziemlich doof wäre :)



>> 07.12.2005
[CO]
- Nahm GuiPL aus der Klasse 'PL' heraus. 'Ingame Guis' laufen künftig NUR noch über die Scene Node 'PLTSNGui'. Dadurch kann 
  man auch mehre getrennte Ingame Guis haben. Verschob die PL Ingame Gui Klassen in das Scene System da das Ingame Gui nun 
  ein Teil des Scene Systems ist bzw. hierüber läuft.



>> 04.12.2005
[CO]
- PLTPostProcessManager::PerformSinglePostProcess(): NUR wenn der aktuelle Ausschnitt kleiner ist als der alte MUSS der 
  Buffer gelöscht werden damit keine Fehler an den Rändern sichtbar sind... nun müssen die Buffer nur noch in bestimmten 
  Situationen gelöscht werden, damit ging bei mir die FPS von 42 auf 47 hoch. :)



>> 03.12.2005
[CO]
- Machte die Statische Kamera Scene Node 'PLTSCStaticCamera' wieder fitt. Hierbei handelt es sich um einen Container welcher 
  diverse Kameras beinhaltet. Sobald die Update() Funktion aufgerufen wird sucht sich diese 'Statische Kamera' automatisch 
  eine passende Kamera aus ihren 'Kindern' aus. Der User muss dann nur noch diese 'auserwählte' Kamera abfragen - ob er 
  diese Kamera dann als die aktuelle Kamera welche zum Rendern verwendet wird verwenden will bleibt ihm überlassen.



>> 02.12.2005
[CO]
- PLTSceneQueryRender::TraverseNode(): Die Scene Nodes selbst werden nun ebenfalls Sortiert - in 
  PLSampleNewtonCharacterController verbesserte dies die Performance :)
- PLTSceneQuery::InformOnSceneNode(): Kann nun ein zusätzliches 'Daten Packet' übergeben werden. 'PLTSceneQueryRender' zum 
  Beispiel übergibt hier zusätzliche Informationen wie z.B. die kürzeste Entfernung der Scene Node zur Kamera - diese 
  Information welche im Scene Render Query bereits sowieso intern berechnet wird kann man dann z.B. dazu benutzen um das 
  LOD der Scene Node zu bestimmen. Zusätzlich wird jetzt auch der aufrufende Query übergeben.
- PLTSceneNode um eine 'Maximum Entfernung von der Kamera' für das Zeichnen erweitert, standardmäßig 0 was bedeutet das 
  die Scene Node IMMER gezeichnet wird. Jedoch sollte hier vom User vorallem bei 'Weitsicht' ein passender Wert eingestellt 
  werden. Zwar ist diese 'Entfernung' selbst nicht 'sicher' da auch die aktuelle Perspektive Matrix berücksichtigt werden 
  müsste, aber für's erste wollte ich das lieber so einfach wie möglich haben.
- PLTShadowVolume::NeedsCapping(): Implementierte den Test für Directionale Lichtquellen
- Änderte ein paar Klassen/Dateinamen bei den Scene Relevanten Dingen. Scene Nodes haben nun am Anfang immer 'SN', Scene 
  Container 'SC', Scene Node Modifier 'SNM', Scene Queries 'SQ', Scene Renderer 'SR' und Scene Hierarchien 'SH', so kann 
  man schon gleich am Klassen/Datei Name erkennen worum es sich hier genau handelt. Dies ist in der Praxis Praktisch ist da 
  wir mittlerweile ziemlich viele Klassen haben welche zudem noch an das RTTI 'angebunden' sind. Das waren jetzt zwar 
  ziemlich viele kleine Änderungen - aber ich denke es hat sich gelohnt. Bei der Physik hab ich nichts umgestellt da ich 
  diese sowieso demnächst etwas überarbeite.



>> 30.11.2005
[CO]
- Die letzten Tage hatte ich mich nochmal etwas intensiver mit Ragdoll beschäftigt. In der Engine liegt nun eine neue 
  Ragdoll Scene Node welche bestimmte Skeleton Joints des Modells von einer Physik Engine steuern lassen kann. Für ODE 
  & Newton gibts bereits spezielle Ragdoll Body & Joint Implementationen. Man kann hier sicherlich noch so einiges 
  verbessern/erweitern - aber ich denke diese aktuelle erste Ragdoll Implementation ist schon recht brauchbar.
  Auf PLTSNRagdoll::CreateRagdoll() bin ich besonderst stolz - denn ich brauchte ne halbe Ewigkeit um eine saubere Funktion 
  zu entwickeln welche anhand eines vorgegebenen Skeletons die Ragdoll Bodies & Joints erzeugt. Man muss quasi nur noch 
  ein paar Details wie z.B. Joint Limitierungen selbst einstellen - aber ein bereits automatisch erzeugtes Ragdoll
  Grundgerüst zu verändern ist sehr viel einfacher als ein Ragdoll komplett von null per Hand zu basteln! :)
  ... auf das übertragen der Physik Körper Rotationen auf ein Ragdoll Skelett für Skinning etc. bin ich noch weniger stolz... 
  irgendwie hab ich größte Probleme das korrekt hinzubekommen, vieles ist immer verdreht. :(
  ... insgesammt gibts also noch ein paar kleinere Dinge die am Ragdoll gemacht werden müssen bevor man es Problemlos 
  einsetzen kann - diese 'kleineren Dinge' sind irgendwie frustrieren da ich es bis jetzt noch nicht hinbekommen habe diese 
  sauber zu lösen. :(
- Da das aktuelle Terrain leider absolut nicht geneignet ist um mehrmals pro Frame gerendert zu werden, dies aber z.B. 
  für Reflektionen/Refractionen bei Wasser nötig ist, wühlte ich das alte Terrain wieder heraus und machte es fitt.
  Nun haben wir also erstmal zwei Terrains, einmal ein relativ komplexes mit LOD Morphing etc. und einmal ein nett 
  kleines und kompaktes Terrain mit normalem GeoMipmapping - welches aber super geeignet ist um mehrmals pro Frame gerendert 
  zu werden da keine Vertex & Index Buffer etc. jedesmal aktualisiert werden müssen. Irgendwann später wenn benötigt könnten 
  wir das Terrain ja nochmal etwas überarbeiten, aber fürs erste müsste es reichen.



>> 20.11.2005
[SB]
- Aufrufe von PLTContainer::Add() angepaßt
- Include <Log.h> eingefügt



>> 17.11.2005
[CO]
- Entfernte den Parameter 'Force' aus PLTSceneNode::Destroy() da ein sofortiges Löschen einer Scene Node recht schnell 
  recht problematisch werden kann.
- Wie vorhin im Chat besprochen, hab ich die Variablen Parameter bei Funktionen entfernt. Da dies im Prinzip überall wo 
  Strings übergeben werden praktisch wäre, es aber ein totaler Overhead wäre das überall einzubauen, ist dieses halb/halb 
  weniger schön. Über ein Temporäres PLTString Objekt kann man sich ebenfalls einen String zusammenbasteln und diesen dann 
  den Funktionen übergeben - zudem hat PLTString intern extra Abfragen so das es nie einen Buffer Overflow geben kann wie 
  es bei den alten Variablen Parameter Strings möglich war. (das war hier immer ein großes Risko)



>> 10.11.2005
[CO]
- PLTSceneContainer::Load(): Auch hier ist das setzen des Resourcen Namens beim Laden unerwünscht. Im z.B. Scene Editor habe 
  ich einen Container Namens 'EditedScene' welche die Scene Managed. Den Container ermittle ich hier teils anhand seines 
  Namens, und dieser wurde nun dank der Beseitigung diverser Bugs von oben beim Laden geändert was zu Problemen führt... wow, 
  das mit den Bugs ist ja heute wie ein Domino-Effekt, ist ein Bug gefunden und behoben fällt sofort der nächste...
  Ich denke bei den Resource Namen müssten wir mal schaun wie wir das handhaben wollen... bei Create() ists mit dem Namen 
  klar - aber wie wollen wir das Handhaben wenn die Load() Funktion der Resource aufgerufen wird? Das sicherste wäre wohl 
  hier NIE den Resource Namen beim Laden ändern zu lassen...



>> 04.11.2005
[CO]
- Default Font Material hinzugefügt welches immer verwendet wird wenn etwas 'geschrieben' werden soll



>> 31.10.2005
[CO]
- GuiPL::SystemUpdate(): Reagiert nun auf Tasten & Maus Rad
- Tauschte in GuiPL.pak und standard.pak die Bitmap Schrift gegen eine andere welche man etwas besser lesen kann.



>> 25.10.2005
[CO]
- Terrain-Format auf XML umgestellt



>> 24.10.2005
[CO]
- PL: LoadFSSettings() & SaveFSSettings() auf XML Format umgestellt
- PLTSkyLayer: Verwendet nun das RTTI, damit wurde das umstellen auf das neue XML Format deutlich einfacher ;-)



>> 17.10.2005
[CO]
- Arbeitete an PLTSRPerPixelLighting weiter, es funktioniert nun wieder so gut wie früher. Lud einen kleinen 
  PerPixelLighting + HDR + Bloom Test auf den Server: 'srv/files/PLServer/Team/Tests/Packs/hdrtest_051013.zip'



>> 14.10.2005
[CO]
- PLTParticleGroup: Hier gab es Probleme mit m_nParticles. Da diese Variable durch das RTTI frei geändert werden kann, darf 
  man NICHT davon ausgehen das dies die 'aktuelle' Anzahl der Partikel in m_pParticle ist. m_nNumOfParticles hält nun diese 
  'reale' Anzahl an Partikeln fest. (das Partikel System wurde ja bereits geschrieben lange bevor es das RTTI gab :)
- PLTSkyLayer: Verwendet jetzt einen Mesh Handler um sein Mesh zu 'speichern' - ansonnsten konnte es sein das z.B. nach dem 
  Laden einer Scene alle nicht verwendeten Daten wie z.B. Meshs entladen wurden... was hier dann ziemlich dumm kam da das 
  Mesh nicht 'wusste' das es hier gerade von einem Sky Layer verwendet wurde. ;-)
  ... PLTSky ist ja schon recht alt und wurde mehrmals umgestellt... da kann soetwas verpeiltes schonmal passieren...
- ... das gleiche wie oben bei PLTPhysicsCloth... woanderst wird anscheinend bereits immer korrekterweise ein Mesh Handler 
  verwendet.



>> 13.10.2005
[CO]
- Stellte ein aktuelles SDK zusammen. Vorher behob ich noch ein paar 'unschöne' Dinge, testete nochmal diverse Dinge etc. 
  Ich denke mit dem aktuellen SDK kann man bereits dank Scene Exporter & Scene Editor recht nette Dinge machen. Lud das 
  SDK + diverse Test Scenen & Test Modelle auf den File Server.



>> 06.10.2005
[CO]
- PLTFog: Fixiert PLeRFlagLockFogStates
- Fügte Main.cpp hinzu in welchem das Engine Plugin Module korrekt Implementiert wird so, das die darin definierten Klassen 
  nicht unter 'unbekannt' Aufgelistet werden :)
- Erweiterte Node & Node Listener um Funktionen welche aufgerufen werden wenn ein Lade Fortschritt bekannt gegeben wird. 
  Mir viel hier keine andere Lösung ein um z.B. im Scene Editor den Lade Fortschritt abfragen zu können - klassische 
  Callbacks sind ja quasi tabu. ;-)



>> 04.10.2005
[CO]
- GuiPL::RenderWindow(): Die konkrete Zeichenfläche darf nicht durch Clipping verändert werden da sich ansonnsten die 
  Elemente sehr unschön 'verschieben'. Das Clipping wird nur auf das Scissor Rectangle angewandt.



>> 02.10.2005
[CO]
- GuiPL::RenderWindow(): Arbeitet nun intern mit einer Prioritäts Warteschlange. RenderWindow() ist nun Performanter und 
  arbeitet korrekt. Das Ingame Gui ist zwar noch immer nicht Optimal - nun aber nen ganzes Stück fehlerfreier als zuvor. :)



>> 29.09.2005
[CO]
- Neue Scene Node: PLTPhysicsWorld ist eine Abstrakte Physik Welt - davon sind nun alle konkreten Physik Welten Abgeleitet. 
  Somit kann man alle verfügbaren 'Physik Plugins' bei Bedarf auflisten. (was in PLSamplePhysics benötigt wird :)



>> 10.09.2005
[CO]
- Neues Scene Hierarchie Plugin: PLTSceneHierarchySphereTree - ist Ideal für Scene mit vielen sich häuftig bewegenden 
  Objekten. Für nen Side-Scroller oder nen klassisches 3D Weltraum 'Baller-Spiel' Beispielsweise wohl die Ideale 
  Hierarchie. Die Hierachien KDTree, Octree und Quadtree müssen noch erweitert werden damit diese bei Scene Node Änderungen 
  ebenfalls die entsprechenden Teile Aktualisieren können - aber so Effektiv wie beim Sphere Tree wird das leider wohl dort 
  nicht gehen. (Implementation ist noch nicht komplett fertig)
- Scene Nodes um Funktionen erweitert welche den Radius der Bounding Sphere zurückgeben, intern werden nun Flags verwendet 
  um festzuhalten welche der 4 aktuellen Informationen bei Abfrage neu Berechnet werden müssen.
- Priorität aus PLTSceneNode entfernt da diese Funktionalität nun direkt von PLTResource bereit gestellt wird
- Da wir mittlerweile gut 50 Render States haben wird nun intern in SetRenderState() eine Art von Binärer Suchbaum verwendet 
  um so etwas extrem Situationen wo jedesmal alle anderen 50 States verglichen werden müssen entgegen zu wirken.



>> 04.09.2005
[CO]
- PLTShadowVolume verwendet nun das neue PLTShadowMesh welches ein extra Shadow Mesh welches auf Wunsch Optimiert sein kann 
  speichert. Zukünftig wird PLTShadowVolume und PLTShadowMesh wohl direkt in PLModel liegen - das gehört irgendwie da rein 
  und PLTShadowMesh kann dann direkt im Mesh File mitgespeichert werden.



>> 03.09.2005
[CO]
- PLTCamera um einige Dinge erweitert welche ich aus dem Renderer nahm. Derzeit gibts hier eine Statische Funktion mit der 
  man die aktuell gesetzte Kamera abfragen kann um z.B. Sichtbarkeits Tests machen zu können. Das ist erstmal die einfachste 
  Lösung. Im Prinzip braucht man beim Rendern die Scene IMMER diese Informationen: verwendeter Renderer, Kamera und eventuell 
  aktueller Surface Listener. Bei zeiten kann man da vielleicht was eleganteres ausdenken.
- An den Shadow Volumes weitergearbeitet. Shadow Volumes verwenden nun ein extra Shadow Mesh welches vorher erzeugt werden 
  muss. Dieses kann Optional gleich Optimiert werden, dann werden überflüssige Vertices entfernt - und das sind meist einige 
  da das Shadow Mesh nur Positionen braucht. Insgesammt gibts dadurch auch weniger Kanten und es verschwinden die lästigen 
  genauigkeits Fehler welche teils zu leichtem 'krieseln' des Schattens führten. Feilte & Optimierte an diversen Stellen. 
  Desweiteren implementierte ich noch einen minimal anderen Algorithmus welcher die Shadow Volumes KOMPLETT auf der GPU 
  erzeugen kann. Hat zwar hat dies den Nachteil das es sehr viel mehr zu verarbeitende Vertices & Dreicke gibt, aber so 
  spart man sich das ständige neu berechnen der CPU Silhouetten + hochladen der neuen Index Daten was insgesammt nen krasser 
  Flaschenhalz ist. Insgesammt sind dadurch die Shadow Volumes einigermaßen Flott - nur Füllrate fressen diese im Extremfall 
  leider immer noch recht viel... aber da lässt sich wohl wenig dran machen. Desweiteren sieht man bei diesen GPU Schatten 
  noch häufig 'krieseln' - das liegt wohl an den Rechenungenauigkeiten der GPU, denn hier gibts mehrere Vertices welche 
  auf den gleichen Positionen sind und jeweils von nem Vertex Shader verarbeitet werden muss, hab noch keine Idee wie ich 
  das verbessern könnte. :(
  Je nachdem welcher dieser beiden Techniken verwendet werden soll muss jeweils intern nen anderes GPU Shadow Volume Mesh 
  erzeugt werden. Für die Cap Indices der GPU Schatten musste ich mir etwas einfallen lassen wie ich diese so einfach wie 
  möglich rausbekomme. Animierte Meshs sind allerdings noch bei beiden Techniken ein kleines Problem. Bei der CPU Variante 
  muss man dann jedesmal die Ebenen neu berechnen und bei der GPU Variante muss man dem Shader diverse zusatz Informationen 
  übergeben so das der Vertex Shader dann jeweils die benötigte Ebene neu berechnen kann. Das eigentliche Shadow Mesh wird 
  momentan jedesmal direkt in PLTShadowVolume erzeugt - Zukünftig wird es eine extra Shadow Volume Mesh Klasse geben welche 
  auch direkt im Mesh Format mitgespeichert werden kann. Dann erzeugt man z.B. im ME einmal dieses auf Wunsch Optimierte 
  Mesh und gut ist. Hier ein Beispiel was diese Shadow Mesh Optimierung bei einem meiner Test Meshs brachte:
    Vertices ohne/mit Optimierung: 4643/3069
    Silhouette (einer bestimmten Licht Position) Ecken ohne/mit Optimierung: 2520/1663
    Silhouette (gleiche Licht Position wie oben) Ecken ohne Nachbar ohne/mit Optimierung :1443/14
    --> Ecken ohne Nachbar Performance fresser + Grafik Fehler wie 'krieseln', also das ein Pixel einmal im Schatten ist und 
        dann plötzlich wieder nicht + im Schlimmsten Fall Schatten wo keine sein sollten und keine Schatten wo welche sein
        sollten :)
  Die Shadow Volumes können nun auch die offenen Kanten Visualisieren lassen - da diese ganz erhebliche Grafik Fehler 
  verursachen können sollte es NIE offene Kanten geben!
  Legte in 'standard.pak' die Vertex Shader für die Shadow Volumes ab.



>> 26.08.2005
[CO]
- Neues XML Scene Format eingefügt and altes World Format entfernt



>> 25.08.2005
[CO]
- Überarbeitete PLTSRPerPixelLighting: Wie besprochen kann nun ein Scene Renderer die totale Kontrolle darüber haben wie 
  etwas gerendert wird. Die Scene Nodes & Materialen sind also nicht mehr zwangsläufig fürs konkrete Rendern verantwortlich - 
  wenn der Renderer ALLES selbst setzt/rendert diesen diese Dinge nun nur noch als 'hinweis' wie etwas Dargestellt werden 
  soll. PLTSRBasic ist wie gehabt sehr einfach und überlässt den Scene Nodes & Materialien die Kontrolle - so kann der User 
  selbst entscheiden wie etwas gemacht werden soll. Da PLTSRPerPixelLighting aber etwas komplexer ist geht das hier nicht 
  mehr und dieser Scene Renderer MUSS dem User die Hauptkontrolle entziehen. Bevor es ans Rendern geht werden zuerst einmal 
  die Sichtbaren Dinge ermittelt. Anschließent gehts in den Ambient Pass (depth lay down): Hier wird erstmal das Depth 
  Ambient Material des Renderers gesetzt. Anschließend werden alle sichtbaren Nodes durchgegangen, hat eine Node einen Mesh 
  Handler so ist diese Darstellbar. Nun wird das Mesh vom Renderer selbst gezeichnet - hat ein Material des Meshs eine 
  eigene Diffuse Textur so wird diese verwendet, ansonnsten die Default Texture des Renderer Ambient Materials. Bei der 
  Beleuchtung gehts ähnlich zugange: Alle sichtbaren Lichtquellen durchlaufen, je nach Lichttyp diverse Einstellungen 
  vornehmen, eventuell Stencil Shadows zeichnen und alle Nodes mit Mesh Handler mit diesem Renderer Material zeichnen.
  Hierbei wird wieder geprüft ob ein Mesh Material eigene Texturen mitbringt. Hat ein Mesh z.B. gar keine Textur, so wird
  die Renderer Material Standard Textur für eine ganz einfache Beleuchtung verwendet. Ist z.B. keine Normal Map vorhanden, 
  so wird ein Shader des Licht Types ausgewählt welcher kein Bump Mapping verwendet. Zudem kann der User in seinem Material 
  über die Parameter noch diverse Wünsche äußern wie z.B. das Environment Mapping verwendet werden soll. Der Scene Renderer 
  selbst verfügt über ne Art von Shader lib aus die er dann sich einen geeigneten Shader auswählt. Will man also das etwas 
  korrekt Beleuchtet wird etc. MUSS man mit Mesh Handler in den Scene Nodes arbeiten!



>> 02.08.2005
[CO]
- Beannte PLTNoise in PLTSound um. Früher mit der alten Sound Implementation gabs hier Namenskonflikte - dies ist aber
  mittlerweile nicht mehr der Fall.
- Neuer Abstrakter Scene Renderer PLTSRPostProcess der PLTSceneRenderer um Post Processing Effekte erweitert, da dies 
  recht universell ist braucht man es so nicht in jedem Renderer komplett neu Einzubauen.



>> 25.07.2005
[CO]
- PLTSceneNode ist nun ein Informer und Informiert Listener wenn sich Position, Rotation, Skalierung oder die AA Bounding Box
  geändert hat. Klassische Listener sind z.B. die Hierarchien in denen sich die Scene Node - diese müssen gegebenenfalls
  bei Änderungen aktualisiert werden. Auch der Physik Teil der Scene Node wird so ein Listene damit der Physik Körper auf
  die aktuelle Postion gesetzt werden kann.
- PLTSceneNode um Liste mit optionalen Modifiern erweitert.



>> 17.07.2005
[CO]
PLEngine
- PerPixelLighting Renderer teilweise an neues Scene System angepasst
- Änderte bei allen VC Projekten die Compiler Einstellungen so das z.B.
    for (int i=0; i<0; i++) {
    }
    i = 0;
  NICHT mehr Akzeptiert wird. Denn unter Linux gibts da generell Probleme mit und so ists ja auch irendwie korrekt und 
  Stephan muss sich nicht mehr Ärgern wenn das doch noch irgendwo 'inkorrekt' war. :)
  (Compiler Einstellungen -> C/C++ -> Sprache -> Übereinstimmung in einem For-Schleifenberei erzwingen = Ja)
  Dort wo nun gemeckert wurde änderte ich die for-Schleifen - beim 3ds Max Exporter musste ich allerdings die Compiler 
  Einstellungen so lassen das dieses merkwürdige for-Konstrukt zugelassen wird... denn in den Max Headern kam es ansonnsten
  zu Compiler Fehlern - Lustig das ist! :)



>> 11.07.2005
[CO]
- PL::ScanFSArchives() hat nun diverse Abfragen um Crashs zu verhindern



>> 22.06.2005
[CO]
- PLTSceneQueryRender steht nun in seiner Grund-Funktionalität - auch der 'coherent hierarchical occlusion culling algorithm'
  funktioniert ganz prima. Damit haben wir nun endlich brauchbares und flottes Occlusion Culling drinen - und noch nen 
  'Dynamisches' dazu, sprich, man muss nichts außer der Scene Hierarchy selbst Vorberechnen. Damit müssten nun auch endlich
  etwas größere Szenen machbar sein wobei verdeckte Teile der Szene automatisch nicht gerendert werden. :)
  Die KD-Tree Hierarchy scheint für Occlusion Culling das Effektivste zu sein.



>> 19.06.2005
[CO]
- Entfernte das Language-System da dies mittlerweile total veraltet ist und sehr/zu umständlich zu Handhaben ist was gerade 
  in PixelLab ganz enorm stört.
  Fügte dafür in 'PLGeneral/PLTypes.h' das Makro (#define PLT(text) text) ein welches immer verwendet werden sollte
  wenn man mit Texten arbeitet. Bei Zeiten müssen wir mal nen sauberes kleines Sprach-System implementieren. Im Prinzip
  intern nur ne Hash-Table welche z.B. für PLT("Hallo") in seiner 'Datenbank' nachschaut obs in der aktuell aktiven Sprache
  dafür was passendes gibt - wenn nicht wird halt 'Hallo' verwendet. :)
  Diese Datenbank kann dann ja Unicode verwenden - das braucht man ja wirklich nur für die 'Lesbaren' Texte :)



>> 11.06.2005
[CO] 
- Die ersten Scene-System Query-Klassen funktionieren mittlerweile.
- Der Ordner PLCollision wurde entfernt. Dies ist so mittlerweile Überflüssig. Für Dinge wie 'Trace line' hat man 
  mittlerweile Scene-Queries.



>> 09.06.2005
[CO]
- Das Scene-System welches Stefan und ich uns in den letzten Wochen ausgedacht haben steht nun in seinen Grundzügen. Auch 
  ist bereits eine erste Hierarchy Implementiert. (Kd-Tree) Nun fehlen nur noch ein paar Query Klassen (u.a. zum Rendern) 
  und alle wichtigen Komponenten sind Implementiert. Danach 'nur noch' erweitern & Feilen - danach sollten auch größere 
  Szenen kein Problem mehr sein. :)



>> 01.06.2005
[CO]
- Ein paar kleine Bugs am PL Ingame Gui behoben so das es wieder korrekt läuft.
  In 'PLRuntime/Data' 'GuiPL.pak' hinzugefügt wo die fürs Ingame Gui benötigten Daten liegen.
- In 'PLRuntime/Data' 'PLPostProcessEffects.pak' hinzugefügt in dem diverse fertige Post Process Effekte
  liegen.



>> 29.05.2005
[CO]
- Da mittlerweile das mit dem Scene-System an sich soweit funktioniert stellte ich alle Projekte darauf um. Im 
  einfachsten Fall lässt sich alles immer noch genauso bedienen wie früher mit dem einen globalen Entity-Manager.
  Man hat also PLTSceneContainerEntity als Scene Root und fügt dort wie früher über CreateEntity() Entities ein
  oder verwendet Load() um wie früher eine Welt einzuladen. In PLSampleContainer kann man sehen wie einfach das
  im Einfachsten Fall ist. ;-)
- Fügte überall wo RTTI Klassen erzeugt werden Basis-Klassen Abfragen hinzu - nicht das nacher so nen Scherzkeks
  ne Container Hierarchy erzeugen will und als Klassen Name eine Scene Query Klasse übergibt. ;-)



>> 27.05.2005
[CO]
- Implementierte eine erste Version des Scene-Systems welches Stefan und ich ausgetüftelt haben.
  Es gibt einen neuen Unterordner Namens PLScene wo die für das Scene Management verantwortlichen Klassen liegen.
  Daneben gibts wie früher auch schon den PLEntity Ordner wo alles Entity relavante drin liegt. Nun also 
  PLSceneContainerEntity etc. PLTEntity ist nun eine Scene-Node. Verschob alle nicht DIREKT zum Grundsystem
  gehörenden Entity Klassen in einen Unterordner Namens Misc damit ersichtlich ist was Grundklassen sind und
  was nicht. (mir waren das momentan einfach zu viele verschieden Dateien in einem Ordner)
- Für Scene Node & Scene Container verwendete ich die Resource Templates aus PLGeneral da ich keine Lust hatte 
  das alles nochmal neu zu schreiben - und ich denke es sollte kein Problem sein das auch hier zu verwenden.
  Will man den Kontainer eines Knotens bekommen verwendet man einfach GetManager(). Hab zusätzlich in PLTSceneNode
  noch ne Funktion namens GetContainer() implementiert welche intern GetManager() verwendet und Castet - so kommt
  hoffentlich keiner mit den Namen durcheinander. Man könnte zwar ganz allgemein Resource Manager in Resource
  Container umbenennen - aber Resource Manager gefällt mir irgendwie besser. ;-)
- Der World-Ordner wurde entfernt da nun quasi jedes PLSceneContainerEntity eine Welt ist. 
- PLTSurfaceListener um neue Funktionen GetSceneRootNode() & SetSceneRootNode() mit denen man den Hauptknoten der
  verwendeten Szene managen kann.



>> 11.05.2005
[CO]
- PLTPostProcessManager kann nun 2D oder Rectangle Texture Targets verarbeiten - wobei das letztere natürlich 
  bevorzugt verwendet werden sollte da man dann Texturen verarbeiten kann die genauso groß sind wie das Ausgabe
  Fenster. (= bessere Performance & Qualität)


>> 10.05.2005
[CO]
- PLTConsole: Der Cursor blinkt wieder korrekt. Desweiteren kann man nun den Eingabe Text auch wie man es gewohnt ist
  Selektieren und in den Zwischenbuffer kopieren oder Text vom Zwischenbuffer in der Konsole einfügen - nette Spielerei. ;-)
- Der Sound funktioniert nun in der Engine wieder. In PLTGuiListener::OnGuiUpdate() musste man dem Sound-Manager noch ein
  paar Informationen über z.B. den Listener geben... auch wird der Sound nun je nach PLTTimer Einstellungen beschleunigt
  und verlangsamt - ein ziemlich cooler Effekt. Wenn dieser Effekt z.B. für die Musik nicht erwünscht ist kann man das ja 
  in PLSoundLib jederzeit Einstellen.
- PLTSurfaceListener: Hinterlegt nun die Profiling Informationen mit einem Material das den Hintergrund abdunkeln kann so 
  das man den Text auch lesen kann wenn die Szene gerade sehr hell ist.



>> 07.05.2005
[CO]
- Von PLTPostProcess kann man nun eigene Klassen ableiten die dann ganz spezielle Material Parameter aktualisieren.



>> 01.05.2005
[CO]
- Post-Process Manager hinzu gefügt. Dieser Verwaltet intern diverse Post-Processe (im Prinzip einfache Materialien)
  welche nacheinander auf das übergebene Texture Surface angewand werden. Am Ende kann man sich das Ergebniss 
  zurückgeben lassen und dieses als Finales Bild Rendern. Jeder Scene Manager sollte dann seinen eigenen optionalen
  Post-Process Manager haben. Damit lassen sich dann all die coolen Effekte die mittlerweile Standard sind erzeugen.
  (Blur, Bloom, Depth-Of-Field) Wobei manche Effekte neben den Farb Werten auch noch Tiefen Werte etc. benötigen.
  (z.B.Depth-Of-Field) - man muss also im Extremfall die Scene mehrmals in verschiedene Texturen Rendern um alle Daten
  zusammenzubekommen die man für Aufwändigere Post-Process Effekte benötigt. Allerdings ist das wirklich eine Optionale 
  Geschichte die Benutzer mit besseren Systemen dazuschalten können um eine bessere Optik zu erhalten.



>> 28.04.2005
[CO]
  Neue Funktion: PL::ScanFSArchives() -> Fügt alle gefundenen Archive dem FS als Basis Pfade hinzu. Die Engine
  fügt nun selbst beim Initialisieren alle pak-Dateien welche unter 'Data/' (PLRuntime und aktuelles Verzeichniss)
  liegen hinzu. Ist sicherlich noch nicht die schönste Lösung, aber so werden nun wenigstens die pak-Dateien
  automatisch hinzugefügt.
  LoadFSSettings() -> Fügt Basis & Such Pfade aus einer Datei dem FS hinzu.
  SaveFSSettings() -> Speichert die aktuellen Basis & Such Pfade.
- PLTShadowVolumes um Directionale Lichter erweitert. Diese produzieren sehr viel Performantere Schatten da man genau
  weiß das der Schatten 'in der Unendlichkeit' unendlich klein wird - darum kann man das Volumen mit Dreiecken anstatt
  mit Quads rendern. Feature mäßig müssten die Shadow Volumes nun alles können was 'Standard' ist. Jetzt muss ich in dieser
  Schatten Klasse nur hier und da noch etwas Feilen. (gib ja viele Sonderfälle zu beachten)



>> 26.04.2005
[CO]
- PLTLight wird nun von PLTEntityCamera abgeleitet. Denn z.B. beim Projective Texturing oder bei Shadow Mapping wird ein
  Licht ja als Kamera angesehen.



>> 20.04.2005
[CO]
- PLTSMPerPixelLighting etwas erweitert. Derzeit sind 3 verschiedene Licht Typen implementiert, darunter zwei welche
  Projective Texturing verwenden... in den PLTests wird mittlerweile Video auf die Geometrien Projeziert. :)



>> 19.04.2005
[CO]
- PLTGuiDebugTexture::OnUpdate() um Rectangle Texture Support erweitert



>> 07.04.2005
[CO]
- Meine Änderungen der letzten Tage auf den Server geladen. Hier noch nen paar Infos was ich die letzten Tage so getrieben 
  habe da mein Log dort so leer ist. ;-)
- Lud die Codes des neuen Terrains in den Engine Entitiy Ordner PLTerrain2... da das neue Terrain noch nicht komplett fertig
  ist liegt es in diesem Temp-Ordner. (so hab ich wenigstens nen kleines Backup auf dem Server :)
  Die Codes müssen noch etwas rausgeputzt werden, desweiteren muss noch Support für Multi-Pass Rendering implementiert werden.
  Auf meiner Radion 9600 kann ich locker mehrere Texturschichten in einem Pass haben, NVIDIA Karten scheinen da etwas 
  limitierter zu sein und in dem Fall muss dann das Terrain mit einer anderen Material Technik Dargestellt werden welches alles
  in mehreren Schritten Rendert. Dies wird auch nötig wenn man sehr viele verschiedene Textur Schichten auf dem Terrain
  mischen will. In dem Fall sind dann ja meistens bei einem Patch nie alle Schichten auf einmal aktiv, und da kann man dann
  gut Optimieren. :)
  Aber ansonnsten klappt alles schon super, sogar die LOD Interpolation über die GPU. Sobald alles drin ist was noch rein 
  muss kick ich das mittlerweile veraltete Terrain und ersetzte es durch das neue. Hatte ja schon vor ein paar Tagen einen
  Terrain Test hochgeladen, der aber bei Jens schwarzes Terrain zeigte da es für die NVIDIA Karte wohl zu viele Texturen 
  auf einmal sind. (die oben erwähnte Multi-Pass Geschichte)
- Brachte 'ToDo.txt' mal wieder auf Vordermann. Diverse kleinere noch anstehende Dinge fehlen sicherlich noch, aber es ist
  nicht schlecht ne grobe Übersicht über die aktuell noch anstehenden Dinge zu haben. ;-)
  Stefan, trage bitte noch die Dinge ein die du vermisst.



>> 06.04.2005
[CO]
- PLEngine auf neuen Kommentar-Style umgestellt. PLPhysics, PLInput, PLLanguage und PLPath lies ich erstmal unangetastet
  da diese Teile bei Zeiten noch überarbeitet/ersetzt werden. In Actual/Docs liegt die erzeugte API Dokumentation. 
  (PLEngine.chm)
- PLConsole: Ein paar mittlerweile überflüssige Befehle rausgenommen und neue hinzugefügt



>> 31.03.2005
[CO]
- Verbrachte die letzten paar Tage damit das Terrain-Entity komplett zu überarbeiten. Es kann nun die GeoMipmap LODs weich 
  interpolieren (über Soft- oder Hardware) so das kein hässliches 'Poppen' mehr Sichtbar ist. Desweiteren ist auch ein PVS
  drin und Texture Splatting. Das müsste nun wirklich erstmal ausreichend sein. :)
  Die Code müssen nun noch etwas geordnet werden. Wenn alles soweit sauber ist, werd ich das alte Terrain durch das neue 
  ersetzen.



>> 16.03.2005
[CO]
- PLTSMPerPixelLighting um u.a. Scissor Rectangle und mehr Einstell möglichkeiten erweitert



>> 12.03.2005
[CO]
- Die letzten Tage verbrachte ich damit neue PLTests herzustellen. Dabei fand und behob ich überall kleinere Bugs.
  (also in allen Projekten außer PLGui & PLBase)
- Shadow Volumes wurden erweitert. Das Volumen + die Teile aus denen es sich zusammensetzen kann werden nun auf die 
  Sichtbarkeit hin überprüft.
- Entfernte PLTSMSimplePerPixelLighting da mittlerweile überflüssig



>> 08.03.2005
[CO]
- PLTEntity::EntityInitFunction(): Ist das Entity bereits Initialisiert wird es nun zuerst De-Initialisiert 
  bevor es nochmal Initialisiert wird
- PLTParticleGroup: Textur Koordinaten werden nun korrekt berechnet



>> 05.03.2005
[CO]
- PLTLoadScreen aus den PLTests liegt nun direkt in der Engine. PLTLoadScreenBase ist dabei wie bei PLTConsoleBase
  die Basis Klasse dieses Entity-Typs. Von dieser Basis-Klasse sollte man Ableiten wenn man z.B. einen komplett
  eigenen Lade-Bildschirm implementieren will.



>> 01.03.2005
[CO]
- Jedes Entity kann nun ein Icon haben mit dem dieses Entity z.B. im World Editor Dargestellt wird. Trug bei Entities mit
  Variablen vom Typ PL_VAR_FLAGS in Enum die verfügbaren Flags ein damit man diese im ClassView beqeum setzen kann.
- standard.pak aktualisiert
- Kleinen Fehler in PLTWorld::Load() behoben - '\n' fehlte und dadurch wurden Welten welche vom WE gespeichert
  wurden nicht korrekt geladen.



>> 28.02.2005
[CO]
- RTTI Entity Namen gesetzt. 'Name' liest sich im WE einfach netter als 'm_szName'. Desweiteren Entities auf VarChanged 
  umgestellt und das alte 'ReInit' aus den Annotations genommen - der universelle Class Inspector kann dies nicht und diese
  Lösung war sowieso sehr unschön. (ging damals aber leider nicht anderst)
  Somit kann man z.B. im WE fast problemlos die Variablen ändern. (ein paar Dinge müssen noch ausgebaut/verfeinert werden)



>> 25.02.2005
[CO]
- Entity Debug Dialog: Entity Klassen können wieder ausgewählt und erzeugt werden. Da ich das für den WE gerade 
  wieder eingebaut hatte machte ich das hier gleich mit.



>> 23.02.2005
[CO]
- standard.pak aktualisiert



>> 22.02.2005
[SB]
- Alle Projekte an die neuen RTTI-Makros angepaßt



>> 19.02.2005
[CO]
- Überall wo vorher PLTMaterial direkt verwendet wurde wird nun PLTMaterialHandler verwendet
- Fügte Material-Debug Dialog hinzu



>> 17.02.2005
[CO]
- Alle Entities von PLEntities wurden nun in die Engine verschoben da diese Entities immer vorhanden sein sollten. Das 
  Projekt PLEntities wurde entfernt.



>> 14.02.2005
[CO]
- Die Textur Animationen in der Engine hab ich derzeit Deaktiviert da ich in PLTAnimationInfo kleine Änderungen
  machen musste.



>> 08.02.2005
[CO]
- Skeleton-Manager Debug Dialog hinzugefügt



>> 05.02.2005
[CO]
- Machte PLTLanguageManager und PLTCollision zu Singletons
- Nam Konsolen heraus da diese nun als Entity realisiert ist
- Die Entity Draw Funktionen geben nun einen Wert zurück der angibt ob etwas gezeichnet wurde oder nicht.



>> 04.02.2005
[CO]
- Resource Manager an die CreateResource() Änderung angepasst
- Debug Dialoge an Änderungen der letzen Zeit angepasst so das diese wieder wie früher funktionieren.
- PLTGuiEntityVariables gibt es nun nicht mehr da GuiClassView diese Aufgabe übernommen hat :)
- Löschte PLGuis/PLGuiConfig Ordner da mittlerweile überflüssig



>> 02.02.2005
[CO]
- PLTGadget::PlaySound() entfernt da mittlerweile veraltet
- Entfernte alte Module-Templates
- Entfernte PLPredefinitions.h, PLDefinitions.h
- Stellte Entity-Manager auf PLTResourceManager um und passte alles an



>> 01.02.2005
[CO]
- Passte an FS Namens Änderungen an
- Der Language Manager läuft wieder wie früher



>> 31.01.2005
[CO]
- PLTStandardConsole::Update() -> Liest nun wieder das Log aus und gibt es aus. Jedoch wird hier derzeit noch
  Win32 Code direkt verwendet um herauszufinden ob sich die Log-Datei seit dem letzten mal geändert hat.
  (das FS hat ja noch keine solche Funktionen :(
- PL::Init() kann nun optional wie besprochen der Name des zu verwendenen Renderers übergeben werden. Wird kein
  Renderer Name übergeben wird der von PLTEngineGraphicConfig::m_szRendererAPI verwendet.
  "PLTRendererOpenGL" ist dabei Default da es erstens derzeit am besten läuft und zweitens universeller ist. :)
- "PreLoad.ini" gehört nun der Vergangenheit an. PL::InitEngine() trägt nun auch "standard.pak" korrekt ein
  wobei dieses auch im PLRuntime/Data Ordner liegen kann. Aktualierte "standard.pak" in PLRuntime/Data.



>> 30.01.2005
[CO]
- Stellte Texture-, Shader-, World- und Path-Manager auf die neuen Resourcen-Klassen um



>> 26.01.2005
[CO]
- PLEntityPluginDef.h gelöscht da nun überflüssig
- Stellte alles auf das neue Config-System um und nahm das alte heraus. Auch die Config-Dialoge wurden entfernt. Da werd
  ich in PLGui nen universellen Config-Dialog implementieren. Müsste nun mal Laden & Speichern in die neue Config-Klasse
  einbauen. :)
- Alles auf das neue FS umgestellt und das alte komplett rausgenommen. Die Debug Dialoge sind derzeit deaktiviert, diese
  müssten auch nochmal überarbeitet werden. :)
- PL::PreloadData() nam ich raus da es mittlerweile irgendwie nicht mehr so recht ins Design passt
- PLTLanguageManager etc. müsste nochmal überarbeitet werden



>> 21.01.2005
[SB]
- Entity-System auf RTTI umgestellt
  - PLEngine: Entityklassen angepaßt, Initialisierung in PLEngine
  - PLEngine: Verwendung von Entityvariablen in der gesamten Engine umgestellt
  - Zur Zeit noch nicht wieder voll funktionstüchtig: Konsole, Guis
  - Im Moment gibt es einen Absturz beim Beenden, der mit dem Deinitialisieren der Kamera
    zu tun hat. Konnte das Problem leider noch nicht ganz lokalisieren, aber es scheint
    so, als würde ein Objekt zweimal gelöscht werden
- Überarbeitung der englischen Kommentare in PLEntity, sowie an einigen anderen Stellen
- Umbenennung von PLTPhysicHandler in PLTPhysicsHandler: Im Englischen gibt es das
  Wort "Physics" nur im Plural, "Physic" bedeutet etwas völlig anderes :-)
- PLEntities auf RTTI umgestellt
- PLParticleGroups auf RTTI umgestellt



>> 11.01.2005
[CO]
- Machte ein paar kleinere Bug-Fixes



>> 09.01.2005
[CO]
- Alles noch an ein paar Änderungen angepasst.



>> 26.12.2004
[CO]
- PLEngine läuft nun endlich auch wieder einigermaßen



>> 24.12.2004
[CO]
- PLEngine auf PLContainer umgestellt damit sich derzeit alles wieder übersetzen lässt - ansonnsten nichts gemacht
  da die Engine selbst derzeit Stefans hoheitsgebiet ist. Beim Anpassen merkte ich wieder wie Chaotisch der alte Engine
  Kern mittlerweile ist. :)
  Desweiteren passte ich alle über PL liegenden Projekte wie PLEntities, PLODEEntities etc. an - läuft wieder alles wie vor
  der Umstellung.
  -> Stefan, du musst nicht das nun auf dem Server liegende an deine Änderungen anpassen, du kannst auch alternativ deine aktuellen
     Arbeiten an PLContainer anpassen... ist ja im Prinip egal.
     Dadurch das ich das alte wieder lauffähig machte konnte ich nun auch PLRenderer & PLModelLib auf die korrekte lauffähigkeit
     nach der Umstellung testen so das du während du an PLEngine arbeitest dich nicht mit dummen kleinen Umstellbugs dieser
     Teilprojekte herumärgern muss. ;-)



>> 26.11.2004
[CO]
- PLTTexture: Das mit dem automatischen setzten des Color Keys funktioniert wieder.



>> 23.11.2004
[CO]
- PLTTexture wieder halbwechs fitt gemacht so das auch die Texturen wieder von der größe her Automatisch angepasst werden.
  Das war wichtig da das Verhalten der GPU unberechenbar wird sobald eine Textur kein vielfaches von 2 ist, dieses Verhalten
  reicht von falscher Darstellung bis hin zum Crash. :)
  Sobald die größeren Engine umbauarbeiten fertig sind und das mit dem XML-Config System ausgearbeitet ist müsste man diese
  Klasse und das plm wohl nochmal überarbeiten.



>> 19.11.2004
[CO]
- Alles auf Timer Singleton umgestellt (PL::Timer. wurde zu PLTTimer::GetInstance()->)
- Alles auf das Log Singleton umgestellt und das alte aus nun aus der Engine genommen, der PLTools unterordner der 
  Engine wurde gelöscht da nun überflüssig. Die Engine inititialisiert und deintitialisiert das Log.
- Das import/export überall auf den Style von PLGeneral umgestellt damit das endlich einheitlich ist. Dateien wie z.B.
  PLRendererDll wurden gelöscht. StdAfx.h in den Renderer Backends und Model Lib gelöscht.
  Die Entity Plugins selbst hab ich erstmal gelassen da es zuviel geworden wäre und diese durch die Umstellung auf das RTTI
  ja sowieso nochmal alle angepasst werden müssen. :)
- PLImport.h, PLExport.h und PLEngineDll.h gelöscht
  -> Ich hoffe das wir dadurch nicht probleme mit dem Code angleichen bekommen da Stefan derzeit ja jede menge grundliegende
     Dinge fitt macht - aber das mit dem Timer wurde höchste Zeit damit u.a. der Renderer endlich nicht mehr an der Engine hängt,
     endlich wieder alles korrekt Log ausgaben macht und die Abhängigkeiten damit ein stück sauberer sind.



>> 15.11.2004
[SB]
- Das Laden der Plugins auf PLTSystem umstellt



>> 11.11.04
[CO]
- PL::InitRenderer() verwendet nun zum Initialisieren des Renderers das RTTI, passte auch gleich das Initialisieren
  des Renderers in den Tests etc. an. Endlich ein paar dll's weniger pro Projekt, das Plugin System ist nur noch cool. :)



>> 06.11.04
[SB]
- Da ein schrittweises Umstellen auf das neue FS unmöglich ist, solange beide die gleichen Klassennamen enthalten,
  habe ich die alten Klassen in _PLTFileSystem und _PLTFile umbenannt. Davon sind natürlich nahezu alle Projekte
  betroffen, da überall die Namen verändert werden mußten. Es ist nun möglich, Schritt für Schritt das alte
  FS auszubauen und durch das neue zu ersetzen. Beim Initialisieren der Engine wird bereits das neue Plugin-System
  aufgerufen, dieses findet jedoch zur Zeit noch keine kompatiblen DLLs, daher sollte es sich auch nicht mit
  dem alten System stören - hoffentlich ;-)



>> 29.10.04
[CO]
- PLTSMBasic: Unterstüzt nun auch ShadowVolumes.
- PLTShadowVolume prüft nun zusätzlich Automatisch intern ob aktualisiert werden muss



>> 05.10.04
[CO]
- An PLTShadowVolume weitergearbeitet - Jedes Entity kann nun mehere PLTShadowVolume Objekte haben und somit Schatten werfen.



>> 03.10.04
[CO]
- PLTLight: Verschwindet nun durch Occlusion Query Test wieder wenn es durch etwas verdeckt wird



>> 30.09.04
[CO]
- PLTTexture an die neue Klasse PLTImage angepasst - fürs erste nur diese grobe Anpassung. Bei Zeiten werd ich PLTTexture nochmal überarbeiten
  so das alles sauber ist und auch Texturen bei bedarf wieder Skaliert etc. werden können.



>> 14.09.04
[CO]
- GuiPL: Fügte die neuen Clipboard Funktionen hinzu



>> 10.09.04
[CO]
- Shadow Volumes weiter ausgebaut, es wird nun u.a. intern geprüft ob das aufwenigere zfail benötigt wird oder das schnellere
  zpass verwendet werden kann. (kann u.a. verwendet werden wenn die Kamera nicht im Schatten ist)
- PLTObject & PLTODEObject: Die Mesh Sphere wird nun dafür verwendet um zu prüfen ob das Mesh gerade sichtbar ist oder nicht.



>> 09.09.04
[CO]
- Shadow Volumes weiter ausgebaut, diese Funktionieren mittlerweile recht gut, sind nur noch etwas langsam.
- PLTEntity: Neues Flag: PLeEntityFlagCastShadow, ansonnsten hat sich in der Entity Klasse nichts geändert.



>> 08.09.04
[CO]
- Shadow Volumes implementiert. Die Klasse PLTShadowVolume liegt bei den SceneManagern und wird von diesen bei Bedarf
  verwendet.



>> 06.09.04
[CO]
- PLTMaterialPass::Bind() etwas auf die neuen Render Flags optimiert, z.B. wird das setzen von Texturen und Shadern
  gegebenenfalls komplett übersprungen.



>> 05.09.04
[CO]
- Entfernte alles SceneManager relavante aus PLTSurfaceListener und erzeugte einen neuen Unterordner namens
  PLSceneManagers wo nun alle SceneManager Dinge abgelegt sind. Ein SceneManager ist dafür verantwortlich wie die
  Scene (sprich: ALLES!) verarbeitet wird, also wie es gezeichnet wird, Kollisions Abfragen etc. Da dies oft auf die
  jeweilige Andwendung angepasst sein muss ist das nun eine eigenständige Klasse. PLTSurfaceListener selbst verwaltet
  noch die Kamera, gibt Standard Informationen aus etc. ... etwas universelles halt. :)
- PLScenePVS.cpp und PLScenePVS.h in PLSceneManagers verschoben
- Erzeugte drei SceneManager: -> PLTSMBasic: Gaaanz primitiv und stellt einfach alle Entities ohne besondere Behandlung
  dar. -> PLTSMPortal: Verwendet Portale & Sectoren zur Darstellung. -> PLTSMPerPixelLighting: Zeichnet alles mit Hilfe
  von BumpMapping.
  -> weitere SceneManager werden später folgen wie Portale & BumpMapping oder richtig komplexe SceneGraphs.
- Im World Format kann man nun außerhalb des Entities Blocks den verwendeten SceneManager selbst setzen. Beispiel:
  SceneManager="PLTSMPerPixelLighting" setzt den PerPixelLighting SceneManager - jedoch nur beim Standard Surface Listener.
  ... es ist also keine universelle schöne Lösung, aber fürs erste gehts so. (denn irgendwie muss man das ja Einstellen
  können :)



>> 28.08.04
[CO]
- Passte ein paar Stellen an die Änderung bei der Farb Klasse an - aber wirklich nur so viel wie nötig damit wir nicht
  durcheinander kommen. ;-)



>> 26.08.04
[CO]
- Musste in PLEngine.cpp ein paar kleinigkeit verbessern, z.b. darf das Haupt GUI von einem FPS-Limit nicht beeinflusst werden.
- PLTArea::EntityInitFunction() berechnet nun den korrekten Collision Sphere Radius
- PLTPortal::UpdatePlaneSet() -> Plane Set Sphere wird nun korrekt berechnet



>> 16.08.04
[CO]
- PLAuthenticity.h mit gültigem Key liegt nun bei mir in PLIntern, einem seperaten Ordner auf meiner Festplatte wo
  ich alles internes gespeichert habe, in VC gebe ich dies als Include Verzeichniss an und setzte dieses vor alle anderen.
  Im Engine Ordner selbst liegt das File das dann dem SDK immer beiliegt, also ohne gültigen Key, doch durch die VC-Projekt
  einstellung geht trotzdem noch alles - nun kann man nicht mehr vergessen in PLAuthenticity.h den Key zu löschen bevor
  man das SDK rausgibt, und auch wenn dann mal das SDK automatisch auf dem Server erzeugt wird ist das sicherlich praktisch so.
  Stefan, am besten bei dir ähnlich einrichten. ;-)
- Aktuelles PL-SDK hochgeladen



>> 11.08.04
[CO]
- PLTFrame::PLTFrame: Muss 'natürlich' den Input Handler an das Content Window binden, ansonnsten war am ende immer die
  Maus Position verschoben.
- Ich entschloss mich dazu in der Engine ein Standard-Material anzubieten welches man quasi dazu verwenden kann einfach
  alle Render States wie BlendEnable auf vorgegebene Werte zu setzen - meistens ist das z.B. vor dem Darstellen eines Textes
  sicher das Standard Material vorher zu setzen. Hab dazu ne Funktion namens UseStandardMaterial() implementiert welche man 
  verwenden kann wenn man sicher sein will das alle Einstellungen korrekt sind. Die Material Datei liegt im standard Packet
  und heist standard.mat... im Prinzip eine leere Text-Datei. ;-)
  Hab UseStandardMaterial() an diversen Stellen eingesetzt wo man gerne die Standard-Einstellungen hätte - wie beim zeichnen von
  BoundingBoxes etc. 



>> 08.08.04
[CO]
PLTInput:
- Neue Funktion: SetMousePos() -> Setzt die Maus Position und informiert gegebenenfalls alle Input Handler
  darüber - durch sieht es dann für diese nicht mehr so aus als ob die Maus sich bewegt hätte was beim Mouse Wrapping
  in den Editoren ziemlich nervend war.



>> 07.08.04
[CO]
- PLEntity: GetAnchorPoint() funktioniert wieder



>> 03.08.04
[CO]
- Diverse Basis Kollisions Funktionen in PLMath verschoben
- PLTEntity: Neue Funktion: FindTriangle() verwendet die MeshHandler Funktion um einen einfachen Ray/Mesh
  Kollisions-Test zu machen.
- PLTCollision::TraceLine() funktioniert wieder



>> 29.07.04
[CO]
- PLTTextureHandler: Neue Funktionen GetNoBinding() & SetNoBinding() -> Ist 'no binding' gesetzt wird die Texture
  beim aufruf von Bind() nicht gesetzt. Dies ist recht praktisch wenn man z.B. im Material eine Schicht haben will
  bei der die Texture dynamisch im Code gesetzt wird und auch beim verwenden eines Materials gesetzt bleiben soll.
  Da jedoch ein Material von einer solchen Schicht wissen muss kann man nun bei Layer/Texture = -1 setzen was soviel
  wie 'unbekannt' heist, sprich, es ist zwar eine Texture Schicht bekannt, jedoch lässt das Material selbst diese
  unberührt. Gutes Beispiel wo man das brauchen kann ist z.B. bei Spiegeln: Man rendert die Szene in eine Textur
  und verwendet diese Dynamische Textur dann.



>> 23.07.04
[CO]
- PLTMaterial::Bind() -> Früher MUSSTE ein Material an ein Entity gebunden werden um z.B. den Shadern die
  World Matrix des Entities zu übergeben. Mittlerweile lässt sich die aktuelle World
  Matrix jedoch aus dem Renderer auslesen so das man nun Materialien nur noch an Entities
  bindet wenn z.B. Animationen Nachrichten an dieses Senden sollen.



>> 15.07.04
[CO]
- Implementierte GuiPLFont
- Feilte an PL ingame GUI - in PLSamples PLGui Daten aktualisiert so das man das ingame gui korrekt sehen kann



>> 08.07.04
[CO]
- Das Ingame GUI lässt sich nun wieder einigermaßen ordentlich darstellen, es gibt nur noch ein paar schönheits
  fehler zu beheben (in PLSampleLarge ist ja ein Ingame Beispiel implementiert... :)



>> 26.06.04
[CO]
- Arbeitete an der Physik Unterstützung weiter... mittlerweile kann das ODE Backend auch Triangle Mesh Kollisionen.



>> 22.06.04
[CO]
- PLTArea -> Überläd die Test funktionen von PLTPlaneSet so das man dieses Entities nun auch problemlos herum
  bewegen kann
- Sichtbarkeits System weiter ausgebaut, mittlerweile funktioniet dieses schon recht ordentlich :)
- Engine und PLEntities an Material Factory angepasst



>> 19.06.04
[CO]
- Neue Klasse PLTScenePVS -> Ist für die Sichtbarkeitsbestimmung bis Portalen und Sektoren verantwortlich
- PLTSurfaceListener wird nun von PLTScenePVS abgeleitet, intern werden nun (wenn vorhanden) Sektoren und Portale
  zur Sichtbarkeitsbestimmung verwendet



>> 18.06.04
[CO]
- PLTMaterial: Copy Operator überarbeitet - sollte nun einwandfrei funktionieren. Da nicht alle Materialien
  eingeladen werden ist es notwendig das alle Informationen umkopiert werden. Dies erforderte
  das hinzufügen von Copy Operatoren in diversen anderen vom Material verwendeten Klassen.
- PLTPortal: Weiter verbessert



>> 17.06.04
[CO]
- PLTZone in PLTSector umbenannt da dies eine häufiger verwendete Bezeichnung im zusammenhang mit Portalen ist
- PLTPortal kann wieder dargestellt werden und sind nun funktionsfähig, sogar der Scissor Test klappt so das 
  'fast' nur noch das gerendert werden muss was auch durch das Portal sichtbar ist. :)
- PLTMaterialPass::ResetRenderStates() -> ein paar Einstellungen werden nun vom Material standardmäßig NICHT
  gesetzt - ansonnsten gibts z.B. probleme mit dem Scissor Test



>> 15.06.04
[CO]
- PLConfig: Neue Funktion: GetUpdateFrustum() & SetUpdateFrustum() -> Ist recht praktisch zum austesten der
  Sichbarkeit (Konsole wie gehabt: 'updatefrustum' :)



>> 05.06.04
[SB]
- PLTFile: Kleinen Bug beim Schreiben von Dateien behoben



>> 04.06.04
[CO]
- PLTEntity: An Mesh Handler angepasst
- Kleine anpassung von PLTFile



>> 21.05.04
[CO]
- PLTSurfaceListener::DrawScene() ruft wieder den Entity Sichtbarkeits Test auf



>> 20.05.04
[CO]
- PLModel: PLGeometry.h in _PLGeometry.h und PLMesh.h in _PLMesh.h umbenannt um Namenskonflikte mit der neuen
  Modell Lib zu vermeiden -> Dieser veraltete Modell Ordner wird bei Zeiten ja sowieso mal entrümpelt
- PLMeshGeometry.cpp & PLMeshGeometry.h gelöscht da dies nun in Form von PLMeshCreator in der Modell Lib
  ist



>> 16.05.04
[CO]
- PLTTexture -> ColorKey und Gamma setzen funktioniert wieder:
- In PLSamples und PLTests sind nun alle verwendeten Test Materialien aktuell (also keine im alten Format mehr :)
  Das Material-Format wird sich wohl im absehrbarer Zeit nicht mehr ändern, oder nur minimal - man weis ja nie...



>> 15.05.04
[CO]
- Die Standard-Konsole sieht nun wieder genauso aus wie im alten Renderer
- PLTMaterial: Copy Operator = reimplementiert
- standard.pak aktualisiert



>> 14.05.04
[CO]
- PLTSoundManager::Update() -> Listener wird mit Renderer Kamera Settings wieder korrekt eingestellt
- Debug Dialoge bis auf Modell-Teil reimplementiert



>> 13.05.04
[CO]
- Stellen an denen eine Box, Sphere oder so gezeichnet werden sind nun wieder implementiert
- PLTSurfaceListener: Die grund Ebenen und die FPS können wieder dargestellt werden. Desweiteren werden die
  Lichter wieder aktiviert/deaktiviert.
- PLTEntity: BoundingBoxes und Kollisions Radius können wieder dargestellt werden
- PLTLight funktioniert nun größtenteils wieder
- PLTMaterial um TextureStageState pro Layer erweitert. PLTextureCombineParameters.cpp und
  PLTextureCombineParameters.h entfernt da nun überflüssig.



>> 12.05.04
[CO]
- PLTMaterialPass & PLTTextureHandler mit den neuen Renderer Funktionen etwas vereinfacht
- PLTPath lässt sich wieder mit PLTPath::Draw() darstellen -> Siehe PLTest für einen Path-Test ;-)
- Materialien standard.pak in PLRuntime/Data aktualisiert



>> 11.05.04
[CO]
- Die direkte Verwendung PL::GetRenderer() wurde so weit wie möglich durch Zeigen auf den zu verwendenden Renderer
  ersetzt - so ist alles Renderer unabhängiger falls man z.B. mal zwei Renderer gleichzeitig haben möchte. ;-)
- PLTLight zur hälfte reimplementiert



>> 09.05.04
[CO]
- PLTSurfaceListener weiter ausgebaut
- PL: Neue Funktion: GetDefaultSurfaceListener() -> Gibt den Standard Surface Listener der Engine zurück
- PLEntity.h includiert nun auch den Entity Plugin Manager da dieser sowieso IMMER benötigt wird ;-)
-> #include <PLEntity/PLEntityPluginManager.h> in den Entities cpp-Dateien entfernt



>> 04.05.04
[CO]
- PLGui lässt sich wieder übersetzten und funktioniert im groben auch wieder soweit.
- PLTStandardConsole: Ausgabe funktioniert wieder
- PLTEntity: Diverse Debug Informationen in DrawSolid() und DrawTransparent() wieder implementiert



>> 29.04.04
[CO]
- Alle über PL::CreateFrame() erzeugten Frames erhalten nun den Standard Surface Listener PLTSurfaceListener welcher
  im Prinzip das macht was früher PLTRendererHandler machte.
- Die Engine erzeugt nun beim Initialisieren des Renderers eine Standard Schrift welche mit PL::GetDefaultFont2D()
  ermittelt werden kann
- PLTProfiling funktioniert wieder wie vorher



>> 07.04.04
[CO]
- Neue Klasse: PLTFrame -> Ist eine Ableitung von PLTRendererFrame welches noch Engine abhängige Features
  implementiert



>> 21.03.04
[SB]
- Umstellung diverser Klassen in PLEngine und PLEntities auf die veränderten Klassen



>> 18.03.04
[CO]
- PLCollision: Neue Funktionen: IntersectRayPlane() und ClosestPointOnTriangle()



>> 16.03.04
[CO]
- PLTWorld::Load() -> Kleinen Fehler behoben



>> 25.02.04
[CO]
- Benannte PLEntityCollision.cpp in PLEntityCollisionMove.cpp um da in dieser Datei nur Kollisions Abfragen welche auf Bewegung
  prüfen sind. Verwendet man eine Physik Engine weis man aber nicht wirklich WIE sich das Entity im nächsten schritt tatsächlich
  bewegen wird.



>> 23.02.04
[CO]
- PL Text Datei Formate wie mat, plt etc. werden nun noch stabiler eingelesen
- Aktuelles PLSDK und PLDemos hochgeladen. (040223) Das ist die Version welche Jan Häusle für den finalen HDRI Viewer
  verwenden 'muss'. :)
  Die Tools wurden etwas weiterentwickelt und vorallem der WE ist mittlerweile 'etwas' brauchbarer geworden.



>> 22.02.04
[CO]
- PLTMaterial Interface ausgebaut und Material an sich 'verfeinert'. Die Silhouetten wurden aus dem Material entfernt
  da man diese z.B. durch einen Pass welcher im Wireframe Modus rendert realisieren kann. Über diesen Polygon Modus
  lässt sich auch einstellen ob und welche Seite gezeichnet wird -> cull face herausgenommen da nun überflüssig.



>> 20.02.04
[CO]
- PLTParticleGroup: Die Partikel haben nun optional anstatt vNormal eine Rotations Matrix vRot. Dies war auch der Hauptgrund
- Entity Variable Inspector erweitert so das man nun die Variablen auch komfortabel über Gui Elemente einstellen kann



>> 19.02.04
[CO]
- Entities haben nun bei ihren Variablen auch noch Custom Annotation Strings in welchen beliebige Dinge wie z.B. Informationen
  für Gui Elemente der Editoren stehen können.



>> 18.02.04
[CO]
- Entiy Variablen Export Codes etwas rausgeputzt



>> 17.02.04
[CO]
- Da man die Szene von verschiedenen Kameras aus mehrmals Rendern kann musste ich noch die Entity Sichtbarkeit anpassen.
  InFrustum speichert ob das Entity von dem aktuellen Frustum aus sichtbar ist und der Visibility Counter zählt wie oft
  ein Entity sichtbar ist, dabei wird noch die geringste Entfernung zur Kamera gespeichert -> Diese Informationen sind
  wichtig beim Entity aktualisieren, wenn ein Entity überhaupt nicht sichtbar ist oder generell zu weit entfernt ist
  kann es z.B. optional nicht aktualisiert werden um Performance zu sparen.



>> 26.01.04
[CO]
- PLTTexture: Save() in SaveData() umbenannt -> Intern verwendet diese Funktion nun wie beim Laden von Texturen
  DevIL auch zum speichern wodurch sehr viel mehr Formate gespeichert werden können!
  PLTextureSave.cpp wurde aus dem Projekt gelöscht da nun überflüssig.



>> 20.01.04
[CO]
- PLTGMMSurface: Verbesserte verwaltung von mehren Textur schichten
- PLTWorld::Load() -> Es gab noch ein problem beim Einladen einer Welt wenn von einem Entity NUR der Typ angegeben wurde (z.B. PLTClear)
- PLTFont verwendet nun als Default 'standardfont.mat'



>> 10.01.04
[CO]
- PLTInput: Neue Funktionen: GetMouseWrapping() und SetMouseWrapping() -> Zum einstellen ob die Maus auf der anderen
  Bildschirmseite wieder herauskommen soll oder nicht. In HRDI Viewer ist dies z.B. absolut unverwünscht - jedoch
  gibt es anscheinend keine vollkompatible und saubere Windows Funktion welche einem die Maus Bewegung mitteilt und daher
  muss mal selbst die aktuelle Position von der letzten abziehen und wenn die Maus am Bildschirmrand stehen bleibt ist
  es unmöglich die Mausbewegung festzustellen. Daher lässt sich dieses Wrapping nun optional abschalten.
  Daher sollte es später auf jedenfall noch ein DX Input Backend geben da es dort problemlos möglich ist die Maus Bewegung
  herauszulesen.



>> 03.01.04
[CO]
- PLTCamera: Neue Funktion: GetViewMatrix() -> Gibt die View Matrix zurück
- PLTEntity: Neue Funktion: GetWorldMatrix() -> Gibt die Welt Matrix des Entities zurück



>> 25.12.03
[CO]
- Stellte PLTGMMSurface auf VBO's um
- PLInput: Sobald ein Input Handler inaktiv wird, wird er zurückgesetzt



>> 23.12.03
[CO]
- PLTCloth hat nun eine BoundingBox
- PLTEntity: Neue Funktionen: GetUpdateBoundingBoxes() & SetUpdateBoundingBoxes() -> Damit kann man Einstellen ob jeden Frame
  die Bounding Boxes eines Entities aktualisiert werden sollen. (position etc. setzen)
  Manchmal kann dies unerwünscht sein wie z.B. in PLTCloth.
- PLTEntityCamera: Bei m_nCameraFlags & eFlagLookAtTarget muss normalerweise die Rotationsmatrix immer zurückgesetzt werden
  um eine sonst stattfindente 'verdrehung' zu verhindern. Ist jedoch noch zusätzlich das Flag eFlagOrbiter gesetzt so darf
  die Rotationsmatrix nicht zurückgesetzt werden da ansonnsten das Rotieren nicht mehr richtig funktioniert.
  (siehe ME orbiter-Kamera :)



>> 20.12.03
[CO]
- Wenn man in der Konsole 'About' eingibt sieht man nun auch auf welche Firma die Engine regestriert ist - kann man auch
  im engine about dialog sehen (ist eine globale variable damit man diese vom Interface aus nicht sehen kann)



>> 13.12.03
[CO]
- PLTMesh::Draw() -> Geometry Rendering Prozess beschleunigt da nun nach Material sortiert
- Konsole: Auch Strings mit Leerzeichen welche mit "" oder `` als zusammenhängener String gekennzeichnet wurden werden nun
  korrekt ausgelesen. So kann man nun z.B. auch debug "Magic flame" schreiben um das Entity 'Magic flame' in den Debug Modus
  zu schalten
- Behob fehler in PLTParticleGroup::AutoBoundingBox()
- Interne Engine Update Funktion ist nun ein PLGui listener. Dadurch laufen nun auch modale Ingame Dialoge korrekt
  (siehe GuiColorDialog im PLSample -> ebenfalls aktualisiert)
- In allen Entitiy Klassen stehen nun die Exportierten Entity Variablen jeweils in einem Block damit man auf einen Blick
  sehen kann welche Variablen Exportiert werden (auch ST Entities so umgeschrieben)



>> 29.11.03
[CO]
- In fast allen Projekten gab es durch empfindlichere Compiler Einstellungen diverse Warnungen welche nun behoben sind



>> 22.11.03
[CO]
- PLTEntity: Wird es z.B. per IncRot rotiert so wird nun auch die Default Rotation m_vRot mit verändert -> diese Default
  Rotation wird z.B. bei PLTCameraEntity für die Look up/down Beschränkung verwendet



/*********************************************************\
 *  Einträge aus altem Diary, damals noch ohne genaue Datum angaben. (oben -> unten = neuer -> älter)
\*********************************************************/



[SB] GuiPL eingebaut und alte Gui2D entfernt
[SB] Der Z-Buffer wird nun verwendet, um das Child-Clipping in der GuiPL zu realisieren
[SB] GuiPL unterstützt nun auch die erweiterten Funktionen der PLGui Library (MouseCapturing, Z-Order)
[SB] PLGui-Port für die PLEngine geschrieben (GuiPL), welcher für die Ingame-Gui verwendet werden kann. Die wichtigsten
     Gui-Funktionen sind bereits implementiert
[CO] PLTEntity: Ein paar inline Funktionen wieder zu normalen Funktionen gemacht da dort zu viele weitere Header
     eingebunden werden mussten
[CO] Engine Includes an das PLGui-Include Prizip angepasst - es wird also nur noch das jeweils wirklich verwendete
     includiert - dadurch muss bei einer kleinen Header-Änderung nicht mehr (bzw. nur noch sehr selten :) alles neu
     übersetzt werden
[CO] Diverse häufig verwendete Engine funktionen inline gemacht
[CO] PLTEntity: DrawSolid() und DrawTransparent() prüfen nun wenn ein Modell Handler vorhanden ist ob dessen Bounding
     Box von etwas verdeckt wird. Ist kein Modell Handler vorhanden so wird die erste Entity Bounding Box für diesen
     Test verwendet - falls das Entity keine Bounding Box hat so wird dieser Test übersprungen -> Entities welche von
     z.B: einer Wand oder einem Hügel verdeckt werden können nun möglicherweise beim Rendern ignoriert werden :)
[CO] Engine Dialoge an GuiGroupBox Änderung angepasst (Content Window)
[CO] Debug Dialoge: Umfangreichere listen werden zuerst unsichtbar gemacht bevor diese gefüllt werden und danach wieder
     sichtbar gemacht - ansonnsten kann es zu lange dauern da nach jedem Element hinzufügen die Liste neu gezeichnet wird
[CO] Neue Funktion: PLTEntity::IsClass() -> Prüft ob ein Entity eine Ableitung von einer Entity Klasse ist
[CO] PLTEntity: Neue Funktion: GetPluginVar() -> Gibt die Entity Plugin Variable mit dem entsprechenden Namen zurück
[CO] Entity Variablen System verbessert. Es gibt nun zwei verschiedene Arten von Entity Variablen, die einen werden
     direkt im Entity selbst gespeichert und die anderen im Entity Plugin wo weitere Variablen Informationen wie z.B. die
     Beschreibung sind. Sobald ein Entity erzeugt wurde wird das entsprechende Entity Plugin initialisiert. Z.B. wird der
     Name des Basis Entities gesetzt. -> Somit wird der Speicher etwas geschont da nur noch sehr wenige Variable Daten in
     den einzelnen Entities gespeichert werden. :)
[CO] PLTEntityPluginManager::RegisterExternalEntities() verbessert, es wird nun immer zuerst überprüft ob eine dll bereits
     geladen ist... wenn ja so darf diese nicht mehr neu geladen oder gar gelöscht werden da es ansonnsten zu problemen
     kommen kann... PLGui gab nach so einer dll neulade aktion den Geist auf bzw verursachte wieder einige dieser
     'merkwürdigen'-Bugs! :(
[CO] Engine auf neue PLGui umgestellt
[CO] PLTEntityGroup: Neue Funktion: GetIndex() -> Liefert den Index eines Entities in der Gruppe zurück
[CO] Fehler in PLTEntityGroup::Clear() behoben -> die Gruppe wurde bei diesem Vorgang normalerweise gelöscht was jedoch
     dort nicht erwünscht ist
[CO] PLTEntity: Neue Funktion: GetNoCollisionGroup() gibt eine Liste von Namen aller Entity Gruppen zurück bei denen die
     Kollisionen Ignoriert werden sollen (ist ein Entity in einer solchen Gruppe wird es bei der Kollision irgnoriert)
[CO] PLTEntity: Kollisions-System verbessert
[CO] PLTCollision::IsTriangleCollision Optimiert da teils sehr oft aufgerufen - billanz der letzten zwei Optimierungen ->
     der Test ist nun DOPPELT so schnell! :)
[CO] PLTCollision::IsPointInTriangle: Beim ersten schnell Test fehler Tolleranz hinzugefügt da ansonnsten der Test oft
     aufgrund mangelnder Genauigkeit fehlschlug -> Da die Funktion IsPointInTriangle welche noch die Normale der Ebene
     entgegennahm ist langsamer ist als die neue IsPointInTriangle funktion wurde diese entfernt (weniger benötigte daten
     bei mehr Performance - ideal :)
[CO] PLTInputHandler: Tasten Abfrage auf GetAsyncKeyState() umgestellt.
[CO] In PLTEntityPluginManager::RegisterEntityPlugin() war ein kleiner fehler wodurch interne Programm Entities nicht ins
     Plugin System eingetragen wurden
[CO] PreLoad Datei Format aktualisiert
[CO] PLTInputHandler: Schlägt das Initialisieren des Joysticks fehl, so wird der Joystick nicht mehr aktualisiert ->
     verursachte enorme Latenz probleme in den Editoren!
[CO] PLTInput::Update() -> Aktualisiert nun automatisch ALLE Input Handler
[CO] PLTInputHandler: Neue Funktionen: GetSimulateThirdMouseButton() & SetSimulateThirdMouseButton() -> damit läst sich
     das Simulieren einer dritten Maustaste ein/ausschalten -> Man muss nun gleichzeitig strg & alt & shift & Maus Taste
     1 drücken um den dritten Button zu simulieren (nur strg und Button eins gab probleme in den Editoren :)
[CO] PLTEntity: Neues Debug Flags: PLeEntityFlagDebugBoundingBoxes -> Zeigt die Bounding Boxes an
[CO] PLTEntityManager: CreateEntity() -> Wenn ein dummy Entity von anderen dummy Entity Klassen abgeleitet ist so werden
     nun die Variablen aller Klassen Korrekt eingetragen
[CO] PLTCollision: IsPointInTriangle() -> Schnellere Test-Funktion gefunden, noch nicht direkt im Einsatz getestet daher
     backup von alten und laaamen Code :)
[CO] Lade Bildschirm Entities werden nun nicht mehr über den Namen identifiziert sondern müssen sich in der Entity Gruppe
    'PLLoadScreens' befinden
[CO] 'Zertifikat' eingebaut. In PLAuthenticity.h muss man nun seinen Firmen Namen und den entsprechenden Key eintragen
     damit die Engine läuft.
[CO] PLTInputHandler: Die Maus wird nun von den Bildschirmbegrenzungen nicht mehr aufgehalten, ist die Maus z.B. links
     und wird weiter bewegt so taucht diese Rechts wieder auf -> Löst u.a. das Problem mit dem abfragen der Bewegung :)
[CO] Debug Dialoge: Replace-Buttons eingebaut -> Damit kann man Resource während das Programm läuft austauschen :)  ->
     PLTModelHandler hat nun funktionen welche die Daten initialisieren und de-initialisieren -> Modell aktualisiert
     beim Laden also auch gleich die Modell Handler
[CO] Benannte PLTGui in PLTGui2D um damit es keine verwechlungen mit der PLGui Bibliothek gibt, ebenfalls das gui-Format
     in gui2d umbenannt um den fall vorzubeugen das PLGui später auch mal ein Format haben könnte ;-)
[CO] PLTSceneManager: World einstellungen entfernt da dies mittlerweile veraltet ist
[CO] Engine Debug Dialog eingebaut welcher über PL::OpenDebugDialog() geöffnet werden kann. Alle überbleibsel der alten
     Debug Dialoge entfernt. -> Konsole: 'debugdialog' zum öffnen des Dialoges
[CO] Engine Konfiguration: Statt Partikel Dichte usw. gibt es nun eine allgemeine Detail einstellung
[CO] Engine Konfigurations-Dialog wieder eingebaut
[CO] PLTWorld -> Progress Window funktioniert wieder
[CO] PLTEntityManager: Neue Funktion: GetGroup(group index)
[CO] PLTEntityPluginManager: Neue Funktion: GetModuleNameList() gibt eine Liste alles Module aus
[CO] Joystick Support eingebaut
[CO] PLTInput und PLTInputHandler verwenden nun kein DirectX mehr, zudem kann nun auch das Maus Rad abgefragt werden
[CO] Entfernte PLTParticleManager und verschob PLTParticleGroup in PLEntities mit namen EntityPG -> Da Partikel Effekte
     mittlerweile nur noch ein weiteres Entity sind war die Implementation veraltet :)
[CO] Behob kleinen Fehler im Destruktor von PLTEntityPlugin der zum Crash führte
[SB] Da der WindowManager nun nicht mehr existiert, wurde die Funktion zum Erstellen eines Render-Fenster nach
     PL::CreateRenderWindow() verschoben
[SB] Die Engine-Dialoge wurden zeitweilig entfernt und werden nun mit der PLGui neu geschrieben
[SB] PixelLight verwendet nun die PLGui zum Verwalten der Fenster, dabei werden Initialisierung und Update der PLGui
     automatisch von der Engine ausgeführt, ein Programm welches die PLEngine verwendet muß dies also nicht mehr machen
[CO] Baute eigene Tasten-Definationen ein welche sich in PLInputKeys.h befinden
[CO] PLTEntity: Neue Funktion: UpdateRot() diese funktion sollte aufgerufen werden nachdem die Rotations-Matrix
     verändert wurde um sicherzustellen das z.B. die World Rotation des Entities aktualisiert wird!
[CO] PL::InitEngine(): Falls das Initialisieren des Sound Managers fehlschlägt läuft die Engine trotzdem, nur ist der
     Sound dann deaktiviert (falls ein System keine Sound Karte hat oder diese nicht richtig konfiguriert ist)
[CO] PLTEntityGroup: Neue Funktion: SendMessage() -> Sended eine Nachricht an alle Entities in einer Gruppe
[CO] PLTCamera: Neue Funktion: CalculateFrustumSphere() -> Berechnet eine Sphere welche den Kamera frustum einschliest
     (noch noch schnellere abfragen :)
[CO] PLTCollision. Funktionen in PLTSphere verschoben: IsPointInSphere(), IntersectRaySphere()
[CO] PLTEntity: Zone-Funktionen eingebaut
[CO] Neues Engine-Entity: PLTPortal -> Durch ein Portal kann man in eine andere Zonen 'sehen', bzw 'gehen'. Ein Portal
     besteht aus einem Polygon (PLTPolygon, normalerweise 4 Vertices, können aber auch mehr sein :) welche den FOV
     verändern.
[CO] Neues Engine-Entity: PLTZone -> Eine Zone ist eine art von Entity-Gruppe durch welche die Welt in handliche Stücke
     zerlegt werden kann. Ist eine Zone nicht sichtbar sind automatisch alle Entities in dieser Zone ebenfalls nicht
     sichtbar.
[CO] PLTEventArea ist nun eine ableitung von PLTArea
[CO] Neues Engine-Entity: PLTArea -> Ist ein normalerweise Konvexes Volumen
[CO] PLTCollision: IsLineInBox() entfernt da dies mittlerweile PLTBoundingBox macht, ClassifyPoint() &
     IntersectRayPlane() wird von PLTPlane übernommen (GetDistance() für ClassifyPoint()), Reflect() in PLTVector3D
     verschoben
[SB] Fehler in PLEngine.h behoben: Jede Datei, die diesen Header eingebunden hat, wurde mit einem struct-alignment von 1
     kompiliert. Dies war natürlich nicht beabsichtigt, daher wurde PACK_STRUCT neu definiert, so daß nun nur noch die
     damit gekennzeichneten Strukturen ein alignment von 1 erhalten (siehe auch PLModelFile.h)
[CO] PLTGuiWidget: Textur auf Material umgestellt. GetBlend() &  SetBlend() herausgenommen da dies im Material
     eingestellt wird
[CO] PLGui: Texturen auf Material umgestellt
[CO] PLTEntity: Die Rotation von Bone Anker Punkten wird nun korrekt ermittelt, desweiteren lässt sich einstellen ob die
     Skalierung des Parent Entities berücksichtigt werden soll oder nicht
[CO] PLTLight um Directional Lighting und abschwächung des Lichtes erweitert. Je weiter etwas von der Lichtquelle
     entfernt ist desto weniger wird es Beleuchtet -> nun kann man auch coole 'Scheinwerfer'-Effekte mit den 'normalen
     Lichtern' machen, natürlich kann man diesen Effekt auch über Projected Lights (Perspective Texturing) erreichen...
     sollte also fürs erste ne menge Beleuchtungs-möglichkeiten bieten ;-) -> Siehe neue Demo-Welt für PLSample (im File
     kann man verschiedene Lichter auswählen)
[CO] PLTEntity: Ist ein Entity an einen Bone Anker Punkt gebunden so erhält dieses nun auch seine Rotation von diesem Bone
[CO] Beim Initialisieren der Engine kann man nun angeben ob sich diese im Debug Modus befindet oder nicht
[CO] PLTEntityManager: Neue Funktion: UpdateVisibility() -> aktualisiert die Sichtbarkeit alles Entities
[CO] Projective Texturing eingebaut
[CO] PLTLight: Befindet sich das Entity im Debug Modus so wird nun auch noch der Frustum angezeigt
[CO] pls-Format umgeschrieben
[CO] Neuer Konsolen-Befehl: entities -> Zeigt eine Liste aller Entities
[CO] PLTEntity: Neue Funktion: IsGroup() -> Überprüft ob ein Entity zu einer Gruppe gehört
[CO] PLTEntity: Neue Funktion: EntityModelDeInitFunction() wird aufgerufen wenn ein Modell entladen wird (um z.B. die
     Bounding Boxes zu löschen)
[CO] PLTEntity: GetWorldDirVector() & GetDirVector() liefern nun nicht mehr den negativen Richtungs-Vektor zurück...
     dieser stimmt nun mit der Z-Achse überein (so ists einfacher zu Handhaben :)
[CO] Neue Konsolen Befehle: classes -> Gibt eine Liste aller regestrierten Entity Klassen aus     showvars -> Gibt eine
     Liste aller Entity Variablen aus pause -> ändert den Pause-Modus fpslimit -> Zum setzen eines FPS limits
[CO] PLTObject, PLTEntityCamera, PLTCloth, PLTSky und PLTTerrain in PLEntities-Projekt ausgelagert da diese Dinge nicht
     direkt zur Engine gehören sondern so ne art von 'Bonus' sind, also fertige Bausteinchen :)  (Entities leicht
     umbenannt!)
[CO] Kollisions-System ausgebaut, PerformCollisionDetection() führt NUR ein Kollisions-Test durch, Move() hingegen
     reagiert auch auf die Kollision, Sphere/Mesh Kollisionen sind manchmal noch fehlerhaft -> Box/Mesh Kollision
     muss noch implementiert werden (für ST sind Sphere/Mesh Kollisionen zu ungenau :)
[CO] PLTEntity: Befindet sich ein Entity im Debug Modus so wird nun auch dessen Kollisions-Radius visualisiert
[CO] PLTEntity::m_vLastPos herausgenommen, dies sollte bei Bedarf ein Abgeleiteten Klassen machen
[CO] Entity Binding verbessert, jedes Entity hat nun eine Liste seiner Child Entities... somit werden die Child-Entities
     ebenfalls gleich korrekt mit aktualisiert!
[CO] PLTEntity::SetParentEntity() aktualisiert nun auch auf Wunsch die Welt Transformation (standard)
[CO] WorldTransformation um funktionen zum aktualisieren von NUR Position/Rotation/Skalierung erweitert
[SB] Nach jeder Veränderung von Position/Rotation/Skalierung eines Entities wird nun auch die WorldTransformation
     aktualisiert. Es reicht leider nicht aus, dies nur einmal pro frame zu tun, da Funktionen, die mit GetWorldPos()
     die aktuelle Position erhalten wollen, damit veraltete Werte bekommen
[CO] PLTEntityCamera auf Welt Koordinaten umgestellt
[CO] Diverse Fehler im Pfad-Code behoben
[CO] PLTLight erweitert. Mit dem Licht-Flag PLeLightFlagQuality lässt sich nun Qualitativ gute Licht Effekte wie eine
     Korona, Lens Flares usw. machen... sprich, es werden viele Informationen aus dem tiefen puffer ausgelesen womit
     das Licht je nachdem wie stark es 'verdeckt' ist verschwindet was jedoch bei vielen Lichtern schnell auf kosten
     der Performance geht. Standardmäßig wird nur getestet ob ein Licht verdeckt oder sichtbar ist, die Licht-Helligkeit
     wird dann weich angepasst.
[CO] Lagerte Entity Kollision in extra Datei (PLEntityCollision.cpp) aus da der Entity Coder mittlerweile recht
     umfangreich ist und der Kollisions-Code ebenfalls noch umfangreicher wird
[SB] Kollisionsfunktionen: Es werden nun die Kollisionen während der Bewegung getestet, die Bewegung wird nur noch dann
     ausgeführt, wenn diese zu keiner Kollision führt. Als nächstes wird das Kollisionsverhalten der Entities genauer
     bestimmt werden
[CO] In PLTEntity wird im Destruktor nun auch der Speicher für die belegten Entity-Variablen wieder gelöscht
[CO] Entity-Plugin-System erweitert. Mit Hilfe einer entities-Datei werden nun die Entities exportiert welche in einer
     exe-liegen... oder besser gesagt werden nur deren Eigenschaften exportiert. Im PL-Doc unter World/Entities steht
     genaueres.
[CO] PLTEntity::PerformBouncing() verbessert
[CO] PLTEntity::PerformEntitySphereCollision() verbessert. Zuerst werden diverse Tests vorgenommen ob die Entities
     während ihrer Bewegung miteinander Kollidieren, ist dies der Fall, so werden beide nicht einfach mehr plump an ihre
     alte Position gesetzt sondern es wird die Position ermittelt an der die beiden Entities kollidieren und diese dann
     entsprechend Positioniert
[CO] Der Entity Manager kann nun auch Entity-Gruppen verwalten. Jedes Entity kann dabei zu mehreren Gruppen gehören.
[CO] Machte Destruktor von PLTGuiWidget virtuell da es ansonnsten Crashs gab
[CO] PLTEntityManager::Add() -> Wird kein Entity Name angegeben, so wird nun immer ein korrekter noch nicht verwendeter
     Namen vergeben
[SB] PLTEntity: UpdateWorldSpace() mußte verschoben werden, damit die nachfolgenden Berechnungen (Kollisionsabfragen)
     die aktuellen Werte verwenden können
[CO] PLTEntityPluginManager::UnRegisterEntityPlugin() löscht nun alle Entities welche diese Klasse verwenden
[CO] PLTObject::GetAnchorPoint() in PLTEntity verschoben. Entities können nun nicht mehr nur an andere Entities gebunden
     werden, es ist jetzt auch möglich ein Entity an einen Anker Punkt des Models eines anderen Entities zu hängen
[CO] PLTParticleGroup verbessert. Es ist nun möglich die Partikel Gruppen direkt im WE zu bearbeiten! :)
[CO] PLTEntity: Die aktuelle reale Welt-Position wird nun gespeichert und nur einmal in der Update() funktion
     aktualisiert, mit der Funktion PLTEntity::UpdateWorldSpace() kann man diese Welt-Daten auch per Hand aktualisieren
     lassen. Somit liefern GetWorldPos() usw. vorberechnete werte wodurch die Performance deutlich besser wird... will man
     die reale Position eines Entities wissen, so sollte man IMMER die Funktionen GetWorldPos(), GetWorldScale() und
     GetWorldRotMatrix() verwenden. Dadurch ist es nun ohne Probleme möglich mehere Entities zu verbinden. :)
[CO] PLTEntityPluginManager: Regestrierung von dll-Entities in Funktion RegisterExternalEntities() ausgelagert. Mit der
     Funktion UnRegisterExternalEntities() kann man die dll entities wieder entladen -> PLTFileSystem::SetApplicationPath()
     enläd die alten dlls und läd neue ein.
[CO] Da die Entity-Klasse mittlerweile doch recht umfangreich ist ordnete ich das Klassen-Interface neu an so das es nun
     etwas übersichtlicher ist :)
[CO] Entities können nun ein Parent-Entity haben an welchen sie gebunden sind und in dessen Objekt Space sie sich befinden.
[CO] Neue World-File-Option: UnloadUnusedData -> Löscht alle nicht benötigten Daten. (Modelle, Texturen usw.) Dies sollte
     nur am Ende des World-File Skriptes stehen da es ansonnsten sein könnte das man Daten löscht die dann gleich wieder
     von einem neuen Entity geladen werden müssen! :)
[CO] Neue Funktion: PL::UnloadUnusedData() -> Entläd alle nicht verwendeten Daten wie z.B. Texturen, Modelle usw.
[CO] Pfade können nun auch im World-File gespeichert werden
[CO] Neue Funktion: PLTEntity::GetVar() -> gibt eine Variable anhand ihres Namens zurück
[CO] Schrieb den Fog-Code um. Früher konnte man den Nebel im SceneManager einstellen. Nun werden die aktuellen Einstellungen
     Renderer selbst verwaltet... der Nebel selbst wird über Entities (wie z.B. TEntityFog in PLEntities.dll) angesteuert.
[CO] In PLTEntity m_fUpdateDistance eingebaut -> Damit kann man das aktualisieren eines Entities ab einer bestimmten
     Entfernung deaktivieren (Performance)
[CO] Neue Funktion: PLTEntity::GetVars() -> Gibt einen String mit allen Variable Inhalten zurück, Optional können Variablen
     mit Default-Werten ignoriert werden (standard)
[CO] PLTEntity: Mit der Funktion ForceUpdate() kann man eine aktualisierung des Entities 'erzwingen'. (im Pause Modus wird
     es normalerweise nicht aktualisiert)
[CO] Neue Konsolen-Befehle: getvar -> Zeigt den Wert einer Entity-Variable an   clearworlds -> Löscht alle Welten
[CO] PLTEntityCamera stellt nun diverse Kamera Einstellungen ein (FOV usw.)
[CO] PLTCamera: Neue Funktionen: GetAspect() & SetAspect() zum einstellen des Aspect-Factors
[CO] PLTEntity: Neue Variable m_bPerformPause eingebaut. Damit kann man bestimmen ob ein Entity eine Pause einlegt wenn der
     Timer im Pause-Modus ist oder nicht. Normalerweise sollten alle Entities Pausierbar sein, jedoch kann man z.B. Kameras
     so einstellen das diese von der Pause nicht betroffen werden... dann wird die Szene 'eingefroren' und die Kamera ist
     trotzdem noch bewegbar. -> gut für Editor & Effekte a la Matrix ;-)
[SB] Kleinen Fehler in PLTWindowOpenDialog behoben (Die Filterliste muß mit zwei Null-Zeichen enden, da es sich um eine
     Liste von Strings handelt)
[CO] Kleinen Fehler in PLTEntity:SetName() behoben (Hash Table wurde nicht richtig aktualisiert...)
[CO] Der World Manager kann nun optional auch einen Lade-Fortschritts Dialog anzeigen (für Editoren praktisch :)
[CO] PLTEntityManager: Kleinen (aber fatalen!! :( fehler beim Löschen von Entities gehoben. (index zurücksetzen da
     gelöschtes Entity durch nachrückendes ersetzt wird)
[CO] Wird PLTEntity::Remove() aufgerufen wird das Entity nun nicht gelöscht wenn es 'Geschützt' ist
[SB] PLTCamera speichert nun auch die Projektionsmatrix, von Außen kann man sich diese über GetProjectionMatrix() zurückgeben
     lassen. Die Projektion wird mittels der Matrixfunktionen errechnet und dann gespeichert, gluPerspective() wird nicht
     mehr verwendet. Die Speicherung der Projektionsmatrix in der Camera macht das spätere Auslesen aus dem
     OpenGl-Matrix-Stack unnötig
[CO] Neuer Konsolen-Befehl: listworlds -> Gibt eine Liste aller geladenen Welten aus
[CO] PLTWorldManager zum Welten-'Pool'ausgebaut. Jede 'Welt' merkt sich nun die Entities welche zu ihr gehören. Ist
     praktisch wenn man einzelne Welten wieder löschen will, zudem lassen sich Welt-Einstellungen so auch für jede Welt
     speichern. -> Lässt sich jedoch wie früher verwenden... nur kanns nun ein ein bisschen mehr sein. ;-)
[CO] In PLTEntity wird nun auch der Klassen Name vermerkt
[CO] Neue Funktion: PLTEntityVar::GetVar() Liefert dem Inhalt einer Variable als String zurück, fügte einen neuen
     Entity-Variablen Typ hinzu: PL_ENTITYVAR_UCHAR (unsigned char)
[SB] Neues Projekt PLEntities hinzugefügt. Hier können wir in Zukunft Entities einbauen, welche an kein Projekt gebunden
     sind, jedoch nicht so grundlegend sind, daß sie in die Engine gehören (z.B. RotationsEntity, AnimationsEntity, ...)
[SB] Das Entity-Plugin System lädt nun auch Entities aus externen DLLs
[CO] World-Format: Mit FreezeTimer=1 kann man nun den Timer einfrieren oder wieder auftauen. Beim Laden größerer Szenen
     sollte man den Timer einfrieren da ansonnsten das Spiel bereits während der Lade-Zeit beginnt... wenn man nur kleine
     Teile nachläd so fällt das im Spiel nicht wirklich auf. (et voila, wir können mittlerweile dynamisch Welt-Teile nachladen!! :)
[CO] PLTWorldManager: Wird ein Entity mit dem Namen 'Load screen' gefunden so wird dieses automatisch als Lade-Screen verwendet
    (bekommt also über SetVar() Information darüber wie viel bereits geladen wurde :)
[CO] Konsole: Befehl 'create' ist nun 'vollständig' zum erzeugen von Entities brauchbar
[CO] Konsolen Befehle haben nun ein Debug-Flag. Somit können Debug-Befehle nicht verwendet werden wenn das Programm nicht
     im DebugModus ist. :) (PLConfig.ini -> [General] DebugMode=1   -> über PL::Config.SetDebugMode() kann man den Debug Modus
     auch während des ausführens änden... gib Cheatern keine Chance!! ;-)
[CO] Standard Kamera Entity PLTEntityCamera eingebaut welche verschiedene Funktionen besitzt welche jede Kamera haben sollte
[CO] In den Entity Parametern können nun auch die Bounding Boxes definiert werden
[CO] Event Area Parameter zum Definieren des Volumens eingebaut... eine Funktion welche eine Event Box erstellt... oder die
     harte Tour durch definieren der einzelnen Ebenen ;-)
[CO] Neuer Konsolen-Befehl: setvars zum setzten von Entity Variablen... nun kann man sogar teilweise 'Realtime'-Edieren!! :)
[CO] Konsole nochmals verbessert, nun lassen sich auch Shift usw. verwenden, desweiteren werden nun nicht 'verarbeitete'
     Command-Parameter gespeichert...
[CO] PLTObject wird hat nun zwei Draw Funktionen... einen zweiten für die Transparenten Mesh-Teile, desweitern hab ich
     den Entity-Draw Code etwas aktualisiert so das nun Transparente Materialien keine so großen Probleme mehr machen
[CO] Neue Konsolen-Befehle: loadworld "world filename"  cloadworld "world filename"  clearworld
[CO] Neue Funktion: PLTWorld::Load() -> Läd eine world-Datei und erzeugt alle Entities
[CO] Parameter der Entities eingetragen & Doc aktualisiert (World\Entities.html)
[CO] Neue Entity-Makro-Parameter eingebaut sowie eine Beschreibung der Parameter und deren Default wert
[CO] Wind in Physik-Klasse eingebaut
[CO] Neues Entity: PLTCloth -> Simuliert ein Kleidungs-Stück -> Eigenschaften werden im Material eingestellt
[SB] PLTEntity: Neue Funktionen SetVar() und SetVars() eingebaut, über diese Funktionen können die Variablen des Entities per
     Strings gesetzt werden
[SB] EntityPluginManager zum Verwalten der Entity-Plugins eingebaut
[SB] Entity Plugin-Makros implementiert, diese Makros definieren die notwendigen Daten und Funktionen, damit eine
     Entity-Klasse vom Plugin System erkannt wird
[CO] Konsole komfortabler gemacht. Man kann nun den Cursor frei platzieren. Desweiteren gibts nun eine Auto-Complete
     funktion... im hintergrund sieht man in Grau den Vorschlag, drücke man TAB so wird dieser Befehl ausgewählt
     (PL-Doc aktualisiert)
[CO] Neue Konsolen Befehle: create & remove zum erzeugen und löschen von Entities, debugmode -> zum setzen des Debug
     Modus (Log)
[CO] Neuer Konsolen-Befehl: gamma -> Damit lässt sich der Gamma-Wert einstellen
[CO] In PLTCamera lässt sich nun einstellen ob der Frustum aktualisiert werden kann. Über den Konsolen Befehl
    'updatefrustum' lässt sich diese Einstellung der aktuellen Kamera ändern. (praktisch zum Testen ob die Szene richtig
     auf Sichtbarkeit hin überprüft wird :)
[CO] Entities an neues Entity System angepasst (Klassen Namen)
[CO] Terminierte alte & hässliche Entity Makros 
[CO] PLTSky & PLTTerrain sind nun Entity-Ableitungen
[SB] PLTEntity: Anpassungen zum Zeichnen der Bounding Boxes, da sich die Methoden hierfür verändert haben
[SB] PLTObject: Beim Initialisieren eines Models (ModelInitFunction) werden automatisch die Bounding Box und der
     Kollisionsradius initialisiert, dabei werden die vom ModelHandler zurückgegebenen Werte verwendet
[SB] Erster Entity-Plugin Test, die Entities können nun über ihren Namen als String erstellt werden, dafür meldet sich
     ein Entity beim PluginManager an. Laden aus DLLs ist noch nicht implementiert, aber nicht mehr weiter schwierig :-)
[CO] Nebel bei Partikeln vorerst deaktiviert da problematisch
[CO] Konnte endlich die Ursache für den merkwürdigen Fehler beseitigen welche bei aktiven Dialogen auf manchen Systemen
     auftrat. (Menüs usw. konnten nicht mehr richtig angewählt werden) -> PLTWindowManager::Update() -> Ist ein Dialog
     vorhanden so übernimmt dieser anscheinend die Bearbeitung der Nachrichten usw.
[CO] Im Szenen-Manager lässt sich nun Neben einstellen
[CO] Die Lichtquellen funktionieren nun richtig
[CO] Die 3 extra Normalen für unsere eigenen Lichtberechnungen entfernt und BumpMapping & CelShading fürs erste
     Deaktiviert da diese Effekte aus Performance gründen zukünftig mit Vertex Programmen realisiert werden
[CO] PLTObject neue Funktion: GetAnchorPoint() gibt die Welt-Position eines Anker Punktes zurück
[CO] PL::Update() -> Die Viewports werden nun als erstes aktualisiert... in SpaceTaxi z.B. wird die 2D Bildschirm
     Position des Spielers ermittelt damit man den Bildschirm nicht verlassen kann... wenn das Entity zuerst aktualisiert
     wird so stimmt Projektion-Matrix nicht da noch keine Kamera gesetzt wurd alles läuft dann etwas 'unerwünscht' ab...
     so herum machts also weniger probleme. (erst Zeichnen, dann aktualisieren)
[CO] Neues Makro zum erstellen von Entities: PLCreateEntity2 -> Setzt auch gleich Position... ist recht oft recht hilfreich ;-)
[CO] PLTEntity neue Funktion: GetEventAreas() -> Gibt einen array von Event Areas zurück in welchen sich das Entity befindet
[CO] PLTEntity neue Funktion: CheckEventAreas() -> Sendet eine Nachricht an sich selbst wenn es in einer Event Area ist
[CO] PLTEntity neue Custom funktion: EntityModelInitFunction() -> Wird aufgerufen nachdem ein Modell Handler an ein Entity
     gebunden wurde -> Dort sollte man dann u.a. Model abhängige Animations-Informationen einstellen
[CO] Partikel System aktualisiert... diverse Einstellungen werden nun direkt im Material vorgenommen (Transparenz usw.)
[CO] PLTObject um EntityFrustumFunction()-Funktion erweitert welches automatisch mit der Bounding Box des Model Handlers
     die Sichtbarkeitsbestimmung durchführt
[CO] PLTEntity um extra Debug Flags erweitert
[CO] Stellte Terrain Klasse auf GMM Surfaces um
[CO] PLTGMMSurface Klasse eingebaut welche ähnlich den ROAM surface eine Height map darstellt -> für moderne Hardware
     wesentlich besser als ROAM, ROAM surface wieder aus der Engine entfernt da somit überflüssig :)
[CO] Multitexturing-Option aus der Konfiguration entfernt da heutzutage jede Grafik-Karte mindestens 2 Textur Einheiten
     hat. Das Material verwaltet nun die Textur Layer. Man kann x-Textur Layer definieren, jedoch werden nur so viele
     Dargestellt wie von der Hardware unterstützt (üblich 4+ :)
[CO] Weitere Profiling informationen eingebaut (general, Textur Manager, Modell manager)
[CO] Terrain Klasse (PLTTerrain) eingebaut -> verwendet eine ROAM Oberfläche und einen Quadtree zur sichtbarkeits bestimmung
[CO] Neue Konsolen Befehle: names -> Zeigt die Entity Namen an debug "entity name" -> Ändert den Debug-Modus des
     entsprechenden Entities
[CO] ROAM Oberfläche eingebaut (PLTROAMSurface) welche eine Oberfläche mit einer Hightmap und dynamischen Detail darstellt
     -> Wird u.a. für Terrain eingesetzt
[CO] Neue Klasse: PLTEventArea -> Verwendet PLTPlaneSet um ein Gebiet zu definieren in welchen ein Ereigniss ausgelöst wird
[CO] PL::PreloadData() ist nun public da es gut möglich ist das es später sinnvoll wird weitere 'Vordefinierte Resourcen'
     in einem rutsch einzuladen
[CO] Himmel können nun in einer Text-Datei definiert werden (sky)
[CO] Sky Klasse eingebaut (PLTSky) -> Verschiedene Sky Layer verschiedener Typen können übereinander gelegt werden um
     eindrucksvolle Hintergründe zu erzeugen wobei Textur Animationen z.B. dazu verwendet werden können um die Wolken zu
     animieren. Verwendet die PLTPool & PLTMesh Klasse... somit ist wieder einmal alles eingeitlich und es sind eine
     menge variationen möglich! :)
[CO] Konsolen Befehls Liste um Profiling Befehle erweitert
[CO] PLTEntity: Neue Funktionen: SetName(), GetPriority(), SetPriority(), CustomFrustumFunction(), GetClipDistance() &
     SetClipDistance()
[CO] PL::CreateMainWindow() gibt es nicht mehr, dafür ist eine ähnliche Funktion namens WindowCreate() nun in
     PLTWindowManager. Grund: Das 'Hauptfenster' ist durch den Renderer umbau unnötig geworden. Will man sich trotzdem
     nicht um den Fenster-Kram kümmern so funktioniert alles eigentlich wie bisher... generell gibts nun weniger Fenster
     und Renderer betreffende Crashs. :)
[CO] Das Plugin für Max zum Exportieren der Engine Modelle funktioniert nun. -> Noch werden keine Bone Animationen exportiert.
[CO] PLTSceneManager -> Neue Einstellung -> m_bRenderWorld um einzustellen ob Bsp und Terrain gerendert werden soll
[CO] PLTWorldManager -> Verwaltet BSP-Levels, Terrain usw. -> Quake3-Bsp-Levels sind bereits eingebaut
[CO] PLTEntity::Update() ist nun Public. Manchmal ists recht sinnvoll wenn man nur ein bestimmtes Entity aktualisieren will...
[CO] PLTSceneManager: Zwei neue customer Funktionen: SceneDrawEngineInfo() und SceneFinished()
[CO] Nam das Automatische beenden der Engine wenn man ein Fenster schließt heraus (~PLTWindow())
[CO] Versuchte erste Teile der Engine so umzubauen das nicht immer alle Header miteinbezogen werden müssen
[CO] Neue Funktion: PL::WindowManager.ChooseColor() -> Zum bequemen auswählen einer Farbe
[CO] PLTCamera: Neue Funktionen: SetTargetEntity() und GetTargetEntity()
[CO] Passte Model Editor an neue Kamera Klasse an
[SB] PLTCamera: Neue Funktionen zum Ändern der Clipping Planes (SetNearPlane(), GetNearPlane(), SetFarPlane(), GetFarPlane())
[CO] PLTInput: Neue Funktion: IsMouseInWindow()
[CO] Die Konsole funktioniert wieder richtig
[SB] Habe bei einigen Klassen die Destruktoren als virtual deklariert. Das Fehlen des virtual keywords hatte zur Folge, daß
     beim Löschen von Objekten abgeleiteter Klassen nicht immer alle Daten freigegeben wurden. Angepaßte Klassen : PLTEntity,
     PLTEntityHandler, PLTPathHandler
[SB] Beim Deinitialisieren der Engine wird nun auch PathManager.DeInit() aufgerufen
[CO] Der Kamera Code liegt nun im Entity Ordner
[SB] Der Mousecursor wird innerhalb des Engine Windows nun ausgeblendet
[CO] Text Ausgabe Funktionen an neue 2D-Mode funktionen angepasst
[SB] PLTGui: Die Textbeschreibung von Menüs wurde um die Attribute Alpha, Blend und Invisible erweitert
[SB] PLTGui: Mouse Delta eingebaut, damit das Mausbild etwas verschoben von der aktuellen Mausposition angezeigt werden kann
[SB] PLTGui: Neues widget Label eingebaut, um Text in einem Menü anzuzeigen
[SB] PLTGui: Beschreibungen von Menüs können nun aus .gui Dateien ausgelesen werden.
[SB] PLTGui Klasse hinzugefügt, welche zum Anzeigen des Gui dient. Das Gui kann global an und aus geschaltet werden, zusätzlich
     kann jeder Scenemanager das Gui anzeigen oder ausblenden. Das Gui kann aus einzelnen widgets zusammengesetzt werden,
     bereits implementiert sind PLTWidget und PLTButton
[CO] PLTEntity: IncScale() Funktionen eingebaut
[CO] PLTEntity: Transform Funktion welche automatisch positioniert, rotiert und skaliert
[SB] Habe eine zweite Methode DrawBitmap() eingebaut, mit welcher nun auch Ausschnitte von Bildern gezeichnet werden können.
     Eine Methode welche gewissen anderen Engines fehlt ;-)
[SB] Die CollisionFunction hat nun den Rückgabetyp bool. Durch Rückgabe von false kann in bestimmten Situationen die Kollision
     komplett ignoriert werden.
[SB] Die Kollisionsabfrage der Entities wurde verbessert, das Kollisionsverhalten von Entities mit gesetztem Solid-Flag wurde
     bestimmt. Jede Kollisionsbox kann nun NamingFlags setzen, wodurch das Entity feststellen kann, welche seiner Bounding Box
     zur Kollision geführt hat.
[CO] PL::Collision.TraceLine eingebaut
[CO] Baute Funktionen zur Gamma Kontrolle ein
[SB] Entity: Änderungen bei den Kollisionsabfragen und Kollisionseinstellungen. Es wird nun immer erst die BoundingSphere
     getestet, dann die BoundingBoxes. Pro Entity können beliebig viele BoundingBoxes definiert werden. Ebenfalls wurden die
     Flags verändert, ist SolidCollision eingestellt, so stoppt das Entity, wenn eine Kollision erfolgt ist
[CO] Die Stencil Schatten funktionieren nun mehr oder weniger... sind noch etwas fehlerhaft usw. aber das Prinzip klappt :)
[CO] Dateien werden nun auch in Sprach unterordner gesucht wie z.B. 'Textures\D\options.jpg'. (vereinfacht verwaltung von
     verschiedenen Sprach-Versionen)
[CO] Files: Dateinamen werden nun so gespeichert wie diese übergeben wurden. Ein korrekter Name wird dann immer intern
     ermittelt. (vereinfacht neuladen von Dateien welche verschoben wurden)
[CO] Entity Send Message Funktionen erweitert
[CO] Die Partikel haben nun ebenfalls ein Material und werden daher wieder dargestellt (den anderen kleinen Fehler hat ich
     vor ein paar Minuten ebenfalls schon behoben :)
[SB] Funktionen zur Verbesserungen der Debug-Funktionalitäten im Log eingebaut. Es ist nun möglich, Ausgaben mit
     Prioritäten zu versehen, so daß diese nur in speziellen "kritischen Phasen" ausgegeben werden
[CO] 'GetPrivateProfileString' usw. durch eigene Funktionen ersetzt (damit u.a. auch aus Archiv ladbar)
[SB] Alle Dateien wurden nun auf den neuen Kommentarstyle umgestellt
[CO] Invertierte 'Done.log'... neue Einträge sind nun oben... komfortabler ;-)
[CO] Baute Bump Mapping ein
[CO] Bmp, PPM & Jpg Funktionen an die neue File Klasse angepasst
[SB] Änderungen an CreateMainWindow(), es kann nun ein Titel sowie die Fenstergröße angegeben werden
[SB] Änderungen an CreateMainWindow(), es kann nun ein Titel sowie die Fenstergröße angegeben werden
[SB] Neue Klasse PLTSceneManager hinzugefügt, welche das SceneRendering für einen RendererHandler definiert. Durch
     Überschreiben der virtuellen Funktionen können in jeder Render-Phase eigene Rendering-Funktionen ausgeführt werden.
     Außerdem kann durch Flags das Standardverhalten verändert werden (z.B. das Rendern von Entities oder das Rendern der Konsole).
[SB] Geringfügige Änderungen in der Fensterverwaltung, z.B. wird nicht mehr für jedes Fenster eine eigene Windowclass erstellt,
     außerdem einige andere kleine Änderungen und Verbesserungen der Fensterklassen
[SB] Einige Änderungen des Renderers und des Hauptfensters. Der Renderer erzeugt nun am Anfang ein temporäres Fenster, welches
     dann wieder entfernt wird. Die Applikation muß nun entweder selbst ein Fenster erzeugen oder dies über die neue Funktion
     PL::CreateMainWindow() erzeugen.
[CO] Die Konsole ist nun Einsatzfähig
[SB] Habe Fehler bei der Berechnung der Normalenvektoren behoben. Durch die Duplizierung der Vertices im .Model-file wurden die
     Vertexnormalen nicht mehr korrekt berechnet, dies ist nun behoben. Evtl. sollte das Dateiformat nochmal verändert werden,
     damit dieses Problem einfacher gelöst werden kann
[SB] Anpassung einiger Klassen an den neuen Kommentarstyle
[SB] Einige Mathematische Dinge verbessert (Achsen der Entities)
[SB] Entity: Zum speichern der Rotation wird nun eine einfache Matrix verwendet, dies vereinfacht an einigen Stellen die
     Berechnungen und verhindert auch Inkonsistenzen zwischen Programmteilen, die durch häufiges Hinund Zurückrechnen von
     Quaternionen oder Euler-Winkeln entstehen können
[CO] Baute eine Konsole ein (infos: Docs/Console)
[CO] Veränderte einige kleinigkeiten am Input Manager
[SB] Neue Klasse PLTObject als Basisklasse für alle Entities, welche ein 3D-Model besitzen
[SB] Neue virtuelle Funktionen in PLTEntity eingebaut, welche bei Ableitungen verwendet werden können
[CO] Alle 'Predefinationen' stehen nun im Header 'PLPredefinitions.h'... auch keine schöne lösung aber besser als diese hässlichen
    'Predefinationen' doppelt und dreifach zu machen... vielleicht findet man später noch eine bessere Lösung :)
[CO] diverse [TEST] transformationen herausgenommen, diese werden nun durch PLTCamera verwaltet. (welche noch verbessert werden muss :)
[CO] 'hässliches' typedef überall entfernt und diverse Code 'verschönerungen' durch Kommentare usw. :)
[CO] Partikel Shapes werden nun in PLTMesh verwaltet und darüber auch ausgegeben (neue Variable in PLTGeometry: m_nUsed)
[CO] der Mainloop wird nun der Application überlassen
