>> 27.09.2011
[CO]
PLRendererOpenGLES2:
- The OpenGL ES 2.0 emulator from ARM can now be used under Linux as well (although it's horrible slow compared to MS Windows, at least on my system)
- Using native OpenGL ES 2.0 on a desktop PC under Linux is now working as well, at least the initalization... right now, when running something there's just a black
  flickering something visible (all EGL and OpenGL ES 2.0 entry points were found, no errors within the log etc.)...



>> 25.09.2011
[CO]
- "PLRendererOpenGLES2": Added support for "GL_EXT_texture_compression_s3tc", "GL_EXT_texture_compression_latc" and "GL_AMD_compressed_3DC_texture"



>> 13.09.2011
[CO]
- "PLCore::FrontendConfig" and "PLRenderer::Config" have now the same default size (800x600 still feels quite fine during development)
- "PLRendererOpenGLES2": Implemented render to texture using "PLRendererOpenGL" as base. Please note that this is definitly not optimal and not final... but
  right now I don't want to do the required render to texture refactoring within PLRenderer... the current render to texture design is from the time were one had
  to use e.g. "pbuffer" and the "framebuffer"-extension of OpenGL was not yet existing. So, the current PLRenderer render to texture interface is somewhat out-of-date
  (but for now, it is still usable).



>> 06.09.2011
[CO]
- "PLRendererOpenGLES2": Added Android part to the EGL headers



>> 04.09.2011
[CO]
- Moved the null font manager implementation from "PLRendererNull" into "PLRenderer" backend tools
- "PLRendererOpenGL" & "PLRendererOpenGLES2": It's now possible to disable the font support and by doing so removing the freetype external dependency. Usually
  font support is a nice thing to have - except when you start porting to a new platform and want to see first "proof of concept" results as fast as possible
  before you start to hammer out the details.



>> 01.09.2011
[CO]
- "PLRendererOpenGLES2": The runtime linking approach used in "ContextDesktop" is working really well... time to realize a single source solution working for
  desktop, emulator and mobile device without reconfigurating the CMake file or the source code. This makes it really easier to use the OpenGL GL 2.0 renderer
  and it's now also possible to switch between desktop or emulator by just adding the emulator dlls into the same directory as the renderer dll or removing them
  from this directory. No need to recompile.
  -> Renamed "ContextDesktop" into "ContextRuntimeLinking" and removed "ContextEmulator" and "ContextNative"
- "Renderer": Added "IsInitialized()"-method returning whether or not the renderer instance was initialized successfully within it's constructor
- "RendererContext::CreateInstance()": In case the renderer instance was not initialized successfully within it's constructor, the created instance is destroyed
  and a null pointer will be returned (would be be to dangerous to use a not correctly initialized renderer instance)



>> 31.08.2011
[CO]
- Android port related: "PLRendererOpenGLES2": No X11 when using Android
- Android port related: "PLRendererOpenGLES2" is now compiling as well (when configuring "CMakeFile.txt", this will be changed soon, but one step after another :)



>> 27.08.2011
[CO]
- D'OH! After one hour of experiments it appears that the native OpenGL ES 2.0 support of my ATI desktop driver ("AMD Catalyst 11.8", Windows 7 64 bit,
  "ATI Mobility Radeon HD 4850" with Windows Aero deactivated) can't deal with multiple windows. Until now, the OpenGL renderer implementations
  always created an internal dummy window because OpenGL just needs an OS window to work in the first place... even if your application doesn't
  have a window at all because you're only rendering into background buffers.
  The renderer context is by design window independent, it doesn't even know anything about one or multiple windows (renderer targets). The renderer
  instance is connected with the renderer context. So, the renderer doesn't depend on an OS window as well, but the internal renderer implementation
  may need an OS window. If you have an OS main window which is valid as long as the renderer context instance exists, it's highly recommended to tell
  the renderer context of this main window during creation, else the internal renderer may create it's own invisible dummy window. Most times, there's
  no problem with an invisible dummy window holding a renderer implementation together. Sadly, there are e.g. some OpenGL ES 2.0 implementations which
  just fail when using multiple windows (the internal invisible dummy window and the real visible one => two windows).
  In a nutshell:
  - If you've already got an OS main window which is valid as long as the renderer context instance exists, just tell the renderer
    context about it
  - If you don't have such an OS main window, don't create one just for the renderer context and pass in "NULL_HANDLE", the renderer
    implementation must be able to deal with this situation on it's own
- Bugfix: PLRendererOpenGL & PLRendererOpenGLES2: Automatic texture uncompression was broken ("Passing "empty" images to the GPU no longer creates internal
  image data"-change in PixelLight 0.9.6-R1)
  Bug birth "22.03.2011", but death "27.08.2011": PLRendererOpenGL & PLRendererOpenGLES2: When there's an image without data, e.g. "glTexImage2D()" is
  called with nullptr instead of "ImageBuffer::GetData()" which creates internal image data although it's not required... but only if there's also no
  compressed data available as well! In here, the new "PLGraphics::ImageBuffer::HasAnyData()"-method is now used instead of the
  "PLGraphics::ImageBuffer::HasData()"-method just looking for uncompressed data.
- "PLRendererOpenGLES2" -> "FontManager_GLSL.h": The native OpenGL ES 2.0 support of my ATI desktop driver now eats this shader as well



>> 26.08.2011
[CO]
- PLRendererOpenGLES: Current AMD GPU drivers are (at least in theory) able to provide native OpenGL ES 2.0 support. So, this renderer implementation now
  has three supported use cases:
  - Emulator (for development)
  - Desktop using GPU drivers supporting this (primarily for development)
  - Native (for the mobile devices)
  First, I just saw nothing at all when using the desktop version. No errors, no crashes, but also no graphics. Tested it with "AMD Catalyst 11.8" and Windows
  7 64 bit on a "ATI Mobility Radeon HD 4850" with Windows Aero active. As soon as I disabled Windows Aero all went fine. Good that I tried that after over two
  hours of research and experiments... "(?!$$(!"=$/()=!"$
  Ok, looks like a driver bug or so, but it's really cool that I can now use OpenGL ES 2.0 on my desktop without an emulator! :D
- Renamed PLRendererOpenGLES into PLRendererOpenGLES2 to avoid any future name conflicts



>> 20.08.2011
[CO]
- "FontManager::GetFontTexture()": Font filename comparison should only be done on the absolute paths to be on the safe side



>> 19.08.2011
[CO]
- "RendererApplication" is using the display mode settings from the configuration again



>> 16.08.2011
[CO]
- "RendererContext" destructor was virtual, but it shouldn't be
- Renamed "PLRendererOpenGLCg::ShaderToolsCg" into "PLRendererOpenGLCg::CgContext"



>> 13.08.2011
[CO]
- Removed default font options within the renderer configuration. The font manager itself has now a build in default texture font. In order to remove the default
  texture font or to set another default texture font, just set it during the application initialization.
- Renamed "RendererBackend::GetStatisticsT()" into "RendererBackend::GetWritableStatistics()"



>> 07.08.2011
[CO]
- Renamed "Surface::Update()" into "Surface::Draw()" to make clear that this method is considered to only draw and not e.g. update the complete game logic
- "RendererApplication": Removed "IsFullscreen()" and "SetFullscreen()", this stuff is now part of the frontend-side



>> 06.08.2011
[CO]
- Removed "RendererApplication::Update()"
- "RendererApplication::OnUpdate()" is now an overridden method of "PLCore::AbstractFrontend"
- "RendererBackend::Update()" no longer updates (= redraws) the renderer surfaces
- "RendererApplication::OnDraw()" now only updates the primary frontend renderer surface, while "update" only means "draw"



>> 04.08.2011
[CO]
- Moved "RenderApplication" from "PLEngine" into "PLRenderer". It's now finally possible to use RenderApplication for applications just using PLRenderer... until now
  one had to also include a bunch of other high level components like PLMesh, PLScene, PLEngine... and of course also the big project PLGui...
  It should be possible to write bare minimum applications just using PLRenderer for basic rendering without the need to use any high level components like meshes or
  the scene graph. This should also make it easier to port PixelLight to new platforms - in order to use e.g. the sample application 50RendererTriangle to test
  PLRenderer, one doesn't need to port/compile everything up to PLEngine to do so.
- Renamed "RenderApplication" into "RendererApplication" so that one can guess the name of this class by just knowing the component name it's in



>> 24.05.2011
[CO]
PLRendererOpenGLEs:
- Bugfix: "ShaderLanguageGLSL": "pl_class" and "pl_implement_class(ShaderLanguageGLSL)" was missing
PLRendererOpenGLCg:
- Bugfix: "ShaderLanguageCg": "pl_implement_class(ShaderLanguageCg)" was missing



>> 09.05.2011
[CO]
- Bugfix: "TextureManager::CreateTexture()" set a new instance of "ResourceHandler" which was totally wrong because there were already an instance.
  Thank you "jacky" for pointing this out within the PixelLight forum at http://dev.pixellight.org/forum/viewtopic.php?f=6&t=47
  This whole "m_bShareTextureBuffer" looks somewhat messy, but right now I don't dare to refactor something in here because I'am currently working on totally different
  stuff.



>> 08.05.2011
[CO]
- Added "Capabilities::bTextureBufferNonPowerOfTwo", if it's "true" there are no power of two restrictions for all texture buffer types (yeah! :)
- "Renderer": Added "IsValidTextureBuffer1DSize()" & "IsValidTextureBuffer2DSize()" & "IsValidTextureBufferRectangleSize()" & "IsValidTextureBuffer3DSize()" &
  "IsValidTextureBufferCubeSize()" to make validating a texture buffer size more comfortable. Modern graphics APIs/extensions and GPUs have finally removed nearly all
  limitations from the texture buffers, except for maximum size of course. The renderer interface and PixelLight in general must stay compatible with legacy stuff so
  there are multiple test methods instead of just one for all texture buffer types.
PLRendererOpenGL:
- If "GL_ARB_texture_non_power_of_two" is available "Capabilities::bTextureBufferNonPowerOfTwo" is set to "true"



>> 22.04.2011
[CO]
- Added a version of "DrawHelpers::DrawImage()" with an 3D image position and an object space to clip space matrix as parameters
PLRendererOpenGL:
- "gl_PointSize" in GLSL and "PSIZE" in Cg had no effect because "GL_VERTEX_PROGRAM_POINT_SIZE_ARB" was not enabled
  (see from http://www.opengl.org/registry/specs/ARB/vertex_program.txt -> "(42) How does PointSize work with vertex programs?" for more information)



>> 16.04.2011
[CO]
PLRendererOpenGL:
- Added support for the OpenGL extension "GL_EXT_transform_feedback", currently only used for the binding point of "GL_ARB_uniform_buffer_object"
  (but transform feedback support is planned!)



>> 15.04.2011
[CO]
- "PLRendererOpenGLCg::ProgramCg" was emitting the "EventDirty"-event when the program destructor was called while "PLRendererOpenGL::ProgramGLSL" was not,
  "PLRendererOpenGL::ProgramGLSL" is now emitting this event within the destructor as well
- Added "uniform buffer" (UBO, aka "constant buffer") support



>> 10.04.2011
[CO]
- Added "TextureBuffer::IsDepthFormat()" which returns whether or not a texture buffer format is a depth buffer format
PLRendererOpenGL:
- Ouch! When using a depth buffer texture format (D16, D24, D32) "FrameBufferObject::Initialize()" was also adding a color buffer, fixed that. The interesting
  thing is that my ATI driver never told me "Incomplete attachment frame buffer object" while the NVIDIA sytem, I'am using for testing, told me at once that
  there's something wrong...



>> 08.04.2011
[CO]
- "Parameter::Parameter()" sets the value by default to zero
- Added "ParameterManager::OnParameterChange()" which is called when a parameter has been changed (created, destroyed, value changed)
- Added "ParameterManager::EventParameterChanged"-event which is called when a parameter has been changed (created, destroyed, value changed)
- Added "Material::EventParameterChanged"-event which is called when a parameter has been changed (created, destroyed, value changed)



>> 01.04.2011
[CO]
- Ok, I have enough of this GLSL precision qualifiers issues on NVIDIA systems... now I've receive a "error C1101: ambiguous overloaded function reference
  "clamp(lowp float, float, float)"" while everything works on my AMD/ATI system. I removed the precision qualifiers from all none OpenGL ES 2.0
  runnable shaders, and for those GLSL shaders targeting OpenGL as well as OpenGL ES 2.0, I will remove precision qualifiers from the shader source
  code before passing it to OpenGL. It's just not worth all this issues and it's really sad that there are that many issues with the different
  GPU driver implementations of precision qualifiers (which, as mentioned, on OpenGL have no real effect anyway... at least according to the
  specification... but who cares about specifications anyway, beside me?!).
- Finally removed "PLRenderer::ProgramGenerator::ApplyGLSLHacks()"... again... see diary entries from "07.07.2010", "26.11.2010" and "01.12.2010" for
  more detail (written in German at this time)
- Added "Shader::RemovePrecisionQualifiersFromGLSL()" which is in fact the "PLRenderer::ProgramGenerator::ApplyGLSLHacks()", but this is no longer a
  hack - it's a feature *g*
-> ... cool, it finally looks like that the GLSL shaders are now working properly on my AMD/ATI system as well as the NVIDIA system at my university.
   While the NVIDIA driver is totally fixed on the given GLSL version and blames each and every single wrong set point (this is a good thing!!!),
   the AMD/ATI driver isn't really that interested in the given GLSL version. Sadly, this means when I'am working with GLSL shaders, I can never be sure
   whether or not I missed a GLSL version issue because the AMD/ATI driver probablity won't tell me what I've done wrong according to the selected
   GLSL version. :/



>> 31.03.2011
[CO]
- I was wondering for some time now why on NVIDIA systems there were some issues when using GLSL. Finally I had the possibility and time to check this
  issue in detail using the NVIDIA system at my university. It took me just a few minutes to figure it out that the issue had to do with the "#version"
  directive of GLSL. I was aware that there's such a precompiler definition, and I already put it as comment into the GLSL shader codes as a reminder...
  the reason to don't add a version information was to create one GLSL shader that can be used on e.g. OpenGL and OpenGL ES 2.0 at the same time. On my
  ATI system this approach worked really well, but as mentioned this way was not working the same on NVIDIA systems... and after having a look into the
  OpenGL specification I just noticed that the ATI driver handles this thing "wrong", meaning not according to the specification:
    "The OpenGL® Shading Language - Language Version: 3.30 - Document Revision: 6 - 11-Mar-2010" Page 14: "Version 1.10 of the language does not require
     shaders to include this directive, and shaders that do not include a #version directive will be treated as targeting version 1.10."
  Ok, this means that one REALLY has to put the GLSL version into the shader source code... but I still try to keep some shaders OpenGL ES 2.0 usable by
  adding the version definition at runtime. I think for the deferred renderer shaders I can but the version directly into the shaders and use more modern
  GLSL language constructs because it will not really run on OpenGL ES 2.0 anyway.
  In GLSL, "#version" must occur before any other statement in the program as stated within:
    "The OpenGL® Shading Language - Language Version: 3.30 - Document Revision: 6 - 11-Mar-2010" Page 15: "The #version directive must occur in a shader
     before anything else, except for comments and white space."
  ... sadly, this time NVIDIA (driver: "266.58 WHQL") is not implementing the specification in detail and while on AMD/ATI drivers ("AMD Catalyst™ 11.3")
  you get the error message "error(#105) #version must occur before any other statement in the program" when breaking specification, NVIDIA (driver: "266.58 WHQL")
  just accepts it without any error.
  ... and another one... "Order of Qualification" ...
    "The OpenGL® Shading Language - Language Version: 3.30 - Document Revision: 6 - 11-Mar-2010" Page 52:
    "4.7 Order of Qualification
     When multiple qualifications are present, they must follow a strict order. This order is as follows.
     invariant-qualifier interpolation-qualifier storage-qualifier precision-qualifier
     storage-qualifier parameter-qualifier precision-qualifier"
  NVIDIA (driver: "266.58 WHQL") did not yell at me when I wrote "in highp vec4 VertexPosition" while the AMD/ATI driver ("AMD Catalyst™ 11.3") throw a
  "error(#132) Syntax error: 'in' parse error" at me which, according to the specification, was the right action... I changed it yesterday from
  "highp in vec4 VertexPosition" (correct) into "in highp vec4 VertexPosition" (wrong) because the NVIDIA driver gave me a "error C7538: OpenGL does not
  allow 'highp' after 'inout'" (I was not able to find this statement in the GLSL specification!). After looking into the GLSL specification again after all
  this confusion, it looks like that the NVIDIA driver does it "wrong". I know that the precision qualifiers are for OpenGL ES 2.0 compatibilty
  and (currently) have no effect when using OpenGL, but I wanted to use them anyway. Ok, in this situation (in/out/inout) I have no chance to make it working
  using precision qualifiers on both, NVIDIA and AMD/ATI... so I just removed the precision qualifiers for this use cases... :/
  ... such things REALLY make it hard to write shaders running on a broad range of GPU's! As for me, as mentioned, I "just" have an AMD/ATI graphics card and
  no NVIDIA graphics card. At the moment, when I want to test everything on a NVIDIA system, I have to use the NVIDIA system at my university - either directly
  within the university laboratory or via horrible slow remote control. So, I can't test each and every time when making a change within the PixelLight
  codes. If any of you have a NVIDIA system and notice any strange behaviour, please tell me at once so that I can test and fix it!
- Because "PLRenderer::ProgramGenerator" adds "#define" dynamically at runtime at the top of the shader, this is a break of the GLSL specification because
  "#version" needs to be on the very top (see comments above). Therefore, "PLRenderer::ProgramGenerator" is required to also add "#version"... but I don't
  think that's a real problem. For Cg, one already had to provide a "profile"... I extended this to GLSL so that "PLRenderer::ProgramGenerator" adds a GLSL
  version if the current shader language is GLSL and profile, which is this case now contains the GLSL version, if not empty.
- Added some important GLSL comments to "Shader::SetSourceCode()" so that I hopefully never again stumble over this GLSL version issue...



>> 28.03.2011
[CO]
- Added "Renderer::GetTexelToPixelOffset()" returning the pixel origin to texel origin offset, usually (0.0, 0.0) or (-0.5, -0.5).
  OpenGL/D3D10/D3D11 have no offset while D3D9 has an offset of -0.5 (see http://msdn.microsoft.com/en-us/library/bb219690%28VS.85%29.aspx)
  -> The "libRocket"-interface requires this type of renderer API information and this is possibly not the only use case for this offset
     information



>> 25.03.2011
[CO]
- "GeometryShader" input/output primitive type and the number of output vertices can now be set by the user



>> 22.03.2011
[CO]
- PLRendererOpenGL & PLRendererOpenGLES: When there's an image without data, e.g. "glTexImage2D()" is called with nullptr instead of
  "ImageBuffer::GetData()" which creates internal image data although it's not required
PLRendererOpenGLCg:
- "ProgramCg::GetCompiledProgram()": ... when not using "cgIsProgramCompiled()", "cgGetProgramString()" may just crash in case the
  program is not compiled... crashs are never a good thing, so I added a check...
PLRenderer:
- Added "Program::IsValid()"
- Added "Renderer::GetSwapInterval()" and "Renderer::SetSwapInterval()"



>> 18.03.2011
[CO]
PLRendererD3D11:
- Continued the work on the renderer backend, it's now possible to render into multiple windows - clear to color is up and running



>> 15.03.2011
[CO]
PLRendererD3D11:
- After some discussion within the PixelLight forum at http://dev.pixellight.org/forum/viewtopic.php?f=3&t=8 I noticed that there's really interesting
  in an up and running D3D11 renderer backend... and I wanted to have a look at the latest graphics API evolution of OpenGL/D3D11 anyway. I started the
  PLRendererD3D11 project by using PLRendererNull as usual as start point.
- Device and device context creation is now implemented, I really like those feature levels of DirectX 11



>> 08.03.2011
[CO]
PLRendererOpenGL:
- Linux: My OS OpenGL header automatically (!) included "glext.h", which was of course out-of-date... so, I was forced to define "GL_GLEXT_LEGACY" to
  deactivate this include behaviour
- Linux: "ContextLinux::SwapInterval()" was using "glXSwapIntervalSGI" without checking whether or not the extension is actually available
- Linux: Wow, "glXSwapIntervalSGI" was used without been defined or initialized, I wonder why it worked at all...
  ... at least for most people. This bug was found by a user which got an "libPLRendererOpenGL.so: undefined symbol: glXSwapIntervalSGI"
  (PixelLight forum post: http://dev.pixellight.org/forum/viewtopic.php?f=6&t=5)



>> 25.02.2011
[CO]
- Added "PLRenderer::Program::GetCompiledProgram()"
PLRendererOpenGL:
- Added support for "GL_ARB_get_program_binary" - but sadly, "glGetProgramivARB(nOpenGLProgram, GL_PROGRAM_BINARY_LENGTH, &nBinaryLength);" returns
  always 0? (Catalyst 11.2 - there are forum posts reporting similar problems, a driver issue?)
  As a result, I can't implement "load from binary object" because I'am not able to test it right now. :/
  At least the Cg implementation of this new method works, in my test, I received the GLSL codes compiled from the provided Cg shader codes.



>> 19.02.2011
[CO]
PLRendererOpenGL:
- Implemented "RenderState::PointScaleEnable"



>> 28.01.2011
[CO]
- Bugfix: "Texture::Load()": There can be the situation that the image loading was successfully, but there's still no image buffer -
  we really have to deal with this situation properly to avoid a crash



>> 27.12.2010
[CO]
- "PLRenderer::TextureBuffer::GetFormatFromImage": Added L32F support
- "PLRenderer::Texture": For floating point image data: GrayscaleA and RGB data is converted into RGBA internally so it can be used as texture



/*********************************************************\
 *  The entries below are in German only
\*********************************************************/



>> 01.12.2010
[CO]
- Ich hatte heute kurz die Gelegenheit den Dungeon Demo auf einem NVIDIA System an der Hochschule, wo ich derzeit für meinen
  Master studiere, zu testen... leider bekam ich tausende von Shader Compiler fehler, die ältere Version mit GLSL hack ging
  allerdings - verdammt. Hab den Hack erstmal wieder rein und schau zu morgen auf diesem NVIDIA System mal die neusten Treiber
  zu installieren und nochmals zu testen... unglaublich dieses unterschiedliche Treiber verhalten, vorallem wenns laut OpenGL
  Spezifikation gehen sollte (diesmal sich also die ATI Treiber korrekt verhalten)...



>> 26.11.2010
[CO]
- Die am "07.07.2010" (siehe entsprechenden Tagebucheintrag für mehr Informationen) erstellte Methode "PLRenderer::ProgramGenerator::ApplyGLSLHacks()"
  entfernt da es scheinbar mittlerweile auch ohne geht - hoffentlich wirklich ohne Probleme auf NVIDIA-Karten... denn solche Hacks (nur weil ein GPU-Treiber
  sich nicht an den Standard hält!) sind einfach nur dämlich und böse Seiteneffekte sind da natürlich nicht auszuschließen. Wäre nett wenn jemand mit einer
  NVIDIA-Karte und aktuellen Treibern das nochmals gegentesten könnte.



>> 08.10.2010
[CO]
- "PLRendererOpenGL::ProgramGLSL" & "PLRendererOpenGLCg::ProgramCg": "RelinkRequired()" wird nur noch in "RestoreDeviceData()" und nicht mehr auch in
  "BackupDeviceData()" aufgerufen, es ist einfach am Geschicktesten wenn das "Dirty"-Event dann kommt, wenn es möglich ist wieder ein neues internes
  Program zu erzeugen (von dem man sich dann z.B. direkte Zeiger auf Attribute/Uniforms speichern kann)



>> 05.10.2010
[CO]
- "DrawHelpersBackend::DrawText": Scale & Bias Parameter wurden nicht verwendet



>> 01.10.2010
[CO]
- "AbstractShader" in "Shader" umbenannt da der Name "Shader" durch das entfernen des alten Shader-Interfaces nun wieder frei ist und es so konsistenter
  zu den anderen PLRenderer Klassennamen ist



>> 28.09.2010
[CO]
- Dank der Umbauten in der letzten Zeit, konnte ich nun endlich Cg-Support von PLRendererOpenGL in ein seperates Plugin Namens PLRendererOpenGLCg
  verschieben. (ein Plugin für ein Plugin *g*) Cg hat seine Vorteile, hat aber leider genauso auch einige Nachteile - z.B. eher mangelhafter Support
  für ATI Grafikkarten, ist nicht OpenSource + die Header & Libs darf man nicht weiterverbreiten so das jeder der PL übersetzen will zuerst Cg installieren
  muss... und ganz nebenbei sind die Cg dlls mittlerweile 6,5 MB groß und scheinen mit jedem neuen Release auch weiter zu wachsen. Dies sind also mehr
  als genug Gründe die dafür sprechen Cg nun komplett Optional zu machen, mit GLSL ist man einfach etwas leichtgewichtiger unterwegs da die Shader-Compiler hier
  direkt in den Grafikkarten-Treibern integriert sind.



>> 27.09.2010
[CO]
- "ShaderLanguage"-Schnittstelle eingeführt. Da zukünftig in z.B. PLRendererOpenGL Shader Sprachen über Plugins hinzugefügt werden können sollen
  (z.B. Cg wird rein optional über Plugin), macht eine eigene Schnittstelle denke ich wirklich Sinn. In der "Renderer" Klasse wurden die Methoden
  CreateVertexShader(), CreateGeometryShader(), CreateFragmentShader(), CreateProgram() entfernt - diese Methoden liegen nun in "ShaderLanguage".
  (mittlerweile gibts noch einige weitere neue Shader Typen die wir noch nicht unterstützen... da würde es auf die Dauer in "Renderer" auch ziemlich
  voll werden :/)
  Über z.B. "Renderer::GetShaderLanguage(<Name>)" lässt sich eine Instanz einer Shadersprache anfragen.
PLRendererOpenGL:
- ProgramCg::BuildUniformInformation(): Einzelnde Array Elemente können nun z.B. über "MyArray[1]" angesprochen werden
- ProgramCg::BuildAttributeInformation(): Elemente einer Struktur können nun über z.B. "MyStructure.MyPosition" angesprochen werden
- ProgramCg & ProgramGLSL sind nun von der Basisklass Program, und ProgramUniformCg & ProgramUniformGLSL sind nun von der Basisklass ProgramUniform
  abgeleitet, damit fallen an zwei stellen Shadersprachen-Fallunterscheidungen weg



>> 26.09.2010
[CO]
- Effekt-Klassen auf das neue Shader-Interface umgestellt
- Das alte Shader-Interface endlich entfernt :D



>> 17.09.2010
[CO]
PLRendererOpenGL:
- "FixedFunctions::SetVertexBuffer()": Vertex Attribute werden nun nicht mehr in "VertexBuffer::MakeCurrent()" an z.B. "glNormalPointer" für Fixed Functions
  Rendering übergeben, sondern in "FixedFunctions::SetVertexBuffer()" so das die (grausamen) Fixed Functions Dinge beisammen sind
- "VertexBuffer::MakeCurrent()" durch "BindAndUpdate()" ersetzt - die neue Implementation ist *sehr* schlank, im Grunde nur "glBindBufferARB" und falls nötig
  ein "glBufferSubDataARB" um die VBO Daten auf der GPU zu aktualisieren



>> 07.09.2010
[CO]
PLRendererOpenGL:
- ProgramCg: MakeCurrent()/UnmakeCurrent() dürfen cgGLEnableClientState/cgGLDisableClientState NUR bei Vertex Program Attributen aufrufen
- Renderer::SetProgram(): Bis das alte Shader Interface raus ist, wird hier noch geprüft ob momentan ein Shader über das alte Shader Interface gesetzt wurde,
  wenn ja, wird das hier zurückgesetzt.
- "Renderer::SetProgram(" setzt kein "glUseProgramObjectARB(0)" mehr, das ist Job von "ProgramGLSL::UnmakeCurrent()"... das machte als ich das neue Shader Interface
  implementierte noch Probleme, nun scheint es aber mittlerweile endlich sauber zu laufen :D



>> 06.09.2010
[CO]
PLRendererOpenGL:
- "ATI2N" Support läuft (es folgen noch ein paar Arbeitsschritte). Gegenüber "DXT5 xGxR" hat man zwar keine Speicherersparnis, die Qualität ist allerdings besser.
  (siehe http://developer.nvidia.com/object/real-time-normal-map-dxt-compression.html und http://www.ozone3d.net/tutorials/bump_map_compression_p4.php)
  Von den Namen her ist das wieder herrlich, ATI führte das unter dem Marketingnamen 3DC ein, technisch bezeichnet man das als ATI2N, mittlerweile
  gibts ne universellere OpenGL Extension die auch auf NVIDIA Karten läuft und das LATC2 nennt, in DirectX 10 ist es unter BC5 bekannt... *g*
  Ich unterstütze ebenfalls "Alternate XY Swizzle ATI2N", dies ist vergleichbar zu "DXT5 xGxR", beides kann mit "The Compressonator" von ATI erzeugt werden...
  das hat den Vorteil das ich die Shader in den Compositing Schritten NICHT erweitern muss, da bei "ATI2N" der Rest wie bei "DXT5 xGxR" abläuft.
  (sprich, 3'te Komponente errechnen)
- "GL_ATI_texture_compression_3dc" scheint am Aussterben zu sein, "GL_EXT_texture_compression_latc" heißt der "quasi Nachfolger" der ebenfalls auf NVIDIA Karten läuft.
  "ATI2N" in "LATC2" umbenannt (das Format an sich ist das gleiche!) und Support für "GL_EXT_texture_compression_latc" hinzugefügt das Standardmäßig verwendet
  wird, erst wenn diese Erweiterung nicht vorhanden ist, wird nach "GL_ATI_texture_compression_3dc" gesucht. (hätte ich RGTC2 gewählt, wäre das nicht Rückwärtskompatibel
  zu 3DC und weitere Fallunterscheidungen müssten her, das wollte ich aber vermeiden)
  Ist weder "GL_EXT_texture_compression_latc" noch "GL_ATI_texture_compression_3dc" vorhanden, wird die Texture zu L8A8 auf der CPU dekomprimiert und dann so zur
  GPU gegeben, so das man trotzdem was sehen kann auch wenn dann natürlich der Speicherverbrauch höher ist.
  -> Da ich keine NVIDIA Karte habe, kann ich das natürlich nicht gegentesten ob das auch sauber auf NVIDIA Karten läuft. Zukünftig werde ich "LATC2" im Dungeon
     Demo nutzen da dieses Feature mittlerweile eigentlich von allen halbwechs aktuellen GPU's unterstützt werden sollte, im PL SDK bleibe ich zur Sicherheit auf
     "DXT5 xGxR" da ich hier höchstmögliche Kompatibilität haben will.
- "ATI1N" (zu dem es nicht wirklich Informationen im Netz gibt) in "LATC1" umbenannt und PLRenderer um Support für dieses Texture Format erweitert. Damit ist es
  endlich auch möglich reine Luminance Texturen (z.B. Height Map) vernümpftig zu komprimieren. Ist "GL_EXT_texture_compression_latc" nicht vorhanden, wird auf der
  CPU dekomprimiert bevor die Daten an die GPU weitergereicht werden. Wie schon bei "LATC2" hat auch "LATC1" *nur* Qualitätsvorteile, aber keinen geringeren
  Speicherbedarf gegenüber "DXT1".



>> 05.09.2010
[CO]
PLRendererOpenGL:
- ProgramCg::UnmakeCurrent(): Hier sollte cgGLDisableClientState für alle Attribute aufgerufen werden... macht man das nicht und nutzt
  natives GLSL und Cg gleichzeitig, kann man Probleme bekommen was ich gerade hatte, die Vertex Daten waren dann im Cg Shader kaputt. :/
  (und dann sucht man ertmal Ewig was denn im Shader falsch sein könnte, obwohl dort alles richtig ist...)



>> 01.09.2010
[CO]
PLRendererOpenGL:
- SurfaceWindow: Gamma wird am Ende nur noch zurückgesetzt, wenn Gamma durch "SetGamma()" verändert wurde. Sollte das setzen von Gamma
  unerwartet mal Probleme machen, so hat man nun wenigstens keine Probleme, wenn man von der Anwendung aus nie Gamma verändert :D



>> 20.08.2010
[CO]
PLRendererOpenGL:
- ContextWindows::QueryDisplayModes/ContextLinux::QueryDisplayModes stellen sicher das sich unter keinen Umständen doppelte Einträge
  in der Liste befinden



>> 17.08.2010
[CO]
PLRendererOpenGL:
- "GL_ARB_texture_float"-Extension wird nun unterstützt und Vendor-Abhängigen Extensions vorgezogen, so funktionieren nun auch Float-Texturen
  unter Linux und damit auch der Deferred Renderer :D
- Capabilities::bR16G16B16A16 entfernt da mittlerweile irgendwie Witzlos



>> 11.08.2010
[CO]
- PLRendererOpenGL & PLRendererOpenGLES: "FontTexture" speicherte nur den Dateinamen der Font, aber ohne Pfad so das der Font-Manager
  dann nicht mehr wirklich prüfen konnte ob eine Font bereits im Cache ist



>> 10.08.2010
[CO]
- "FontManager::CreateFontTexture(": Hier war noch "Data/Fonts/" fest eingebaut was natürlich nicht ok war
  (ACHTUNG: am besten alls Configs löschen da dort auch ein Font Dateiname steht...)



>> 07.08.2010
[CO]
- SPDefault überarbeitet. Hier fliegt nun das PixelLight Logo gemütlich durch die Gegend + ein Text erklärt was los ist. Dadurch das nur DrawHelpers
  Dinge verwendet werden, ist das nun auch Shader & Fixed Functions unabhängig.



>> 04.08.2010
[CO]
- "DisplayMode": "nZBufferBits" & "nStencilBits" müssen wie schon die Multisample Einstellung nun einmal beim erzeugen einer Renderer Instanz
  übergeben werden. Hintergrund ist, das diese Einstellungen scheinbar auch "global" für den gesamten OpenGL Context zu gelten scheinen. Versucht
  man mehrere Fenster in einem OpenGL Context zu erzeugen die z.B. unterschiedliche Stencil-Bits haben, so scheint dies auf ATI Grafikkarten zu
  funktionieren, bei NVIDIA Grafikkarten hingegen sieht man dann absolut nix mehr. Im Internet konnte ich leider keine Informationen dazu finden,
  scheinbar verwendet alle Welt nur ein einziges Fenster zum Rendern, brrr. Da wir nun mehrmals über dieses dämliche Problem gestolpert sind,
  und es wohl bei diesen Einstellungen ok ist das diese für alle Fenster eines Renderers verwendet werden, nun diese kleine Änderung. Da man
  heutzutage meist erstmal in Texturen Rendert und dort wiederum andere Tiefen/Stencil Einstellungen haben kann, fällt diese globale Einstellung
  für das OS Fenster wohl nochmals weniger ins Gewicht.
PLRendererOpenGL:
- Argh, neue Treiber Probleme: Seit der neusten ATI Catalyst Version ging bei mir irgendwie kein Antialiasing mehr... ein Blick in die unterstützten
  Pixel-Formate zeigte was los ist: 32 Bit Farbtiefe und Antialiasing scheint nicht mehr unterstützt zu werden. Daher musste ich das suchen eines
  geeigneten Pixel-Formates noch etwas erweitern: Wenn das gewünschte Pixel-Format nicht vorhanden ist, wird die Farbtiefe von 32 Bit auf 24, und dann
  von 24 auf 16 Bit veringert... dadurch steigt die Chance einen Treffer zu haben. brr (ja, da habe ich doppelten Code in zwei unterschiedlichen Klassen,
  das ist mir nun aber zu Riskant hier größere Umbauten zu machen da das praktisch jedesmal zurückschlägt und dann auf einem anderen System einen
  totalausfall der Grafik produziert :/)



>> 03.08.2010
[CO]
- "TextureBufferRectangle::GetNumOfBytes": Warum auch immer wurde hier die Anzahl der benötigten Bytes anderst, und zwar scheinbar falsch, berechnet
  so das es bei mir dann abschmierte sobald ich einen Bildschirm-Modus wechsel vornehmen wollte bei dem die Texturen von der GPU zurückgeladen werden



>> 27.07.2010
[CO]
- DrawHelpers::DrawImage() um Texture Matrize erweitert
- Parameter::GetValueTexture() nutzt nun TextureHandler::GetTexture() statt TextureHandler::GetResource() damit gehen auch Texture Animationen
- Animation um EventStart & EventStop Events erweitert



>> 25.07.2010
[CO]
PLRendererOpenGL:
- Log-Information wie z.B. "[Info]: Extension 'GL_ATI_separate_stencil' not found!" in
  "[Info]: Extension 'GL_ATI_separate_stencil' not found (nothing critical)" geändert da diese Log-Ausgaben bei PL-Problemen eigentlich immer
  erwähnt wurden ob dies das Problem sein könnte - ist es aber eigentlich nie da die Extensions Optional sind, z.B. fast alle. Dies ist eigentlich
  nur eine Information. (daher auch [Info])



>> 11.07.2010
[CO]
- "Font::Mipmapping" hinzugefügt damit man einstellen kann ob beim Schrift zeichnen Mipmapping verwendet werden soll oder nicht -
  da die Schrift dadurch etwas vermatscht und oder transparenter als sonst rüber kommen kann, muss man soetwas von Außen einstellen können



>> 07.07.2010
[CO]
- "ProgramGenerator" um einen unschönen Hack erweitert der auf Wunsch die GLSL Precision Qualifiers im übergebenen
  Shader Quellcode entfernen kann - Hintergrund ist, das auf Stefans Notebook mit NVIDIA GPU der Compiler fehler raushaut
  sobald Precision Qualifiers verwendet werden. Dies ist laut OpenGL Spezifikation allerdings ein Fehlerhaftes
  Verhalten + bei OpenGL ES 2.0 sollte man immer Precision Qualifiers nutzen - ich will aber möglichst nur jeweils
  einen Shader für alles schreiben. Da so eine Quellcode Modifikation schnell nach hinten gehen kann, habe ich das daher
  nur in "ProgramGenerator" eingebaut. Ebenfalls wird in Vertex Shadern soetwas wie "out vec4 VertexColorVS;"
  durch "varying out vec4 VertexColorVS;" ersetzt.
- ProgramGenerator Konstruktor um Profile Parameter erweitert, die ich bei mir unter Cg immer angeben sollte da
  es sonst vorkommen kann das z.B. "discard" bei mir nicht mit GLSL Profile läuft



>> 04.07.2010
[CO]
- Dem Renderer kann man beim Erzeugen im Konstruktor nun noch optional die gewünschte Default Shader Sprache übergeben



>> 03.07.2010
[CO]
PLRendererOpenGL:
- Cg Shader für Font Rendering hinzugefügt



>> 30.06.2010
[CO]
- "DrawHelpersBackend::DrawText()" stellt die Schrift wieder in der gleichen größe da wie früher so das erstmal alles wieder ok aussieht. (hoffentlich)
  Die Methode sollte man bei Zeiten nochmal kräftig durchdenken - allerdings sind die Schrift größe relevanten Teile nun zum Glück nur noch
  in DrawHelpersBackend - die konkreten Renderer Implementationen arbeiten außschließlich mit FreeType Schriftgrößen & Clip Space.
- Fonts: Auch Deutsche Umlaute gehen nun



>> 29.06.2010
[CO]
- MultisampleEnable Render State hinzugefügt. Bei OpenGL (bei OpenGL ES 2.0 nicht) gibt es die Möglichkeit Multisample Antialiasing
  beliebig an/aus zu schalten. Bei Image Based Verfahren funktioniert Multisample Antialiasing nicht "automatisch" sondern man muss
  spezielle GLSL Befehle verwenden, die nur die aktuelleren Grafikkarten können. (und Cg/ATI Kombination geht natürlich schonmal hier
  auch nicht) Resultat ist, dass die Performance total mies ist wenn Multisample Antialiasing aktiv ist wenn der Deferred Scene Renderer
  verwendet wird - ohne das man einen Antialiasing Effekt hat. Daher hier nun diese Möglichkeit das gezielt zu deaktivieren - dies
  passiert in der Regel automatisch durch die Surface Klasse so das man sich nicht weiter drum kümmern muss... sondern nur beim
  erzeugen eines Render Targets sagen muss ob man Multisample Antialiasing haben will, oder nicht.



>> 27.06.2010
[CO]
- DrawHelpersBackendShaders nutzt nun ebenfalls ProgramGenerator da der für "DrawImage()" benötigte Shader durch zahlreiche
  Features, die benötigt werden können, oder nicht, schon wieder zu kompliziert wurde
- Standardmäßig wird nun DrawHelpersBackendShaders als DrawHelpers Implementation verwendet, Shader sind einfach deutlich Handlicher
  und direkter als Fixed Functions
- CreateTextureBufferRectangle() gibt nun "TextureBuffer" zurück, ob dies dann TextureBufferRectangle oder TextureBuffer2D
  ist hängt von der Implementation ab. Hintergrund ist, das OpenGL ES 2.0 hier keinen Unterschied macht - und nun an zig Stellen in
  allen Codes Fallunterscheidungen zu machen wäre doof. Das einfachste ist daher Rectangle Texturen in PixelLight weiterhin über
  CreateTextureBufferRectangle() zu erzeugen, also weiterhin als eigenständige Texture damit es mit anderen API's läuft - die Implementation
  kann dann aber auch TextureBuffer2D zurückgeben... und für den Rest ist es im Grunde eigenltlich immer egal da man den TextureBuffer
  Typ testet. Sollte der Typ dann TextureBuffer2D sein, wird es wie eine normale 2D Texture behandelt, das es intern dann auch mal eine
  none-power-of-two Texture sein kann, ist total wurscht weil weiterhin hier mit normalisierten Texture Koordinaten gearbeitet wird und
  in GLSL weiterhin sampler2D/texture2D verwendet wird. (OpenGL ES 2.0 kenn z.B. auch kein sampler2DRect/texture2DRect)
PLRendererOpenGLES:
- In Texturen Rendern ist noch nicht implementiert, daher sollte hier dann auch immer NULL zurückgeben werden da man sonst z.B.
  durch aktives Shadow Mapping keinerlei Lichter mehr sieht da die Shadow Map nicht wirklich gefüllt wurde
- TextureBufferRectangle entfernt, TextureBufferRectangle läuft *g*



>> 26.06.2010
[CO]
- DrawHelpers: "DrawPlane()" aktualisiert
- DrawHelpersBackendShaders: Primitive (Punkt, Linie, Dreieck, Quad) lassen sich Darstellen. Somit ist es nun also auch unter
  OpenGL ES 2.0 möglich zahlreiche Debug Visualisierungen zu sehen. :D
- DrawHelpers: "DrawImage()" als Ersatz für "DrawBitmap()" hinzugefügt, leider mit zahlreichen Parametern - aber ich wüsste nicht
  was ich davon weglassen könnte ohne dann direkt den Nutzen einzuschränken :(



>> 25.06.2010
[CO]
- Resource: Type-Enums umbenannt damit es keine Namenskonflikte mehr mit den dazugehörenden Klassen gibt
- "Shader2" in "AbstractShader" umbenannt damit es keine Namenskonflikte mit der anderen "Shader" Klasse gibt
  die so glaub ich erstmal am besten drinnen bleibt.
- Beim erzeugen einer Renderer Instanz kann nun noch ein "Renderer Modus" eingestellt werden, so das es möglich ist
  die verwendung von Fixed Functions, oder Shadern zu unterbinden - soweit vom Renderer unterstützt. Damit kann man z.B.
  Fixed Functions Support im OpenGL Renderer abschalten, das hilft beim Testen wie es ohne Fixed Function läuft - und
  gibt auch minimal bessere Performance da mit weniger Zuständen herumjongliert werden muss.
- DrawHelpersBackend in DrawHelpersBackendFixedFunctions und DrawHelpersBackendShaders unterteilt. Ein paar Dinge können
  direkt in DrawHelpersBackend für beides Implementiert werden, wäre umständlich wenn man komplett alles immer neu Implementieren müsste.
- "FixedFunctions::RenderState::Lighting" ist nun Standardmäßig aus... so wie es am häufigsten verwendet wird und übrigens auch
  die Default Einstellung von OpenGL ist
- DrawHelpers: "DrawPoint()", "DrawLine()", "DrawBox()", "DrawTriangle()" und "DrawQuad()" überarbeitet. Wie schon bei Font muss
  auch hier nun die World Space Projection Matrize als Parameter übergeben werden. Dadurch konnte nun an einigen Stellen die Verwendung
  von Fixed Functions entfernt werden und alles wird etwas Überschaubarer vom Ablauf her.



>> 24.06.2010
[CO]
- Das bisherige PLRenderer Font Interface entfernt, auch "FontManager" im Grundordner + FTGL das wir nun nicht mehr nutzen
- FontManager ist nun ebenfalls Backend-Basierend, daher kann man eine Instanz davon nun über Renderer::GetFontManager() erhalten...
  dabei wird eine Referenz zurückgeben so das man weis das hier immer was gültiges zurückgegben werden muss - ansonnsten würde
  es in zuvielen unschönen NULL-Zeiger Abfragen im Code enden.
- Das neue Font Interface habe ich auf Basis dessen entwickelt was ich bereits für den OpenGL ES 2.0 Renderer in den letzten
  Tagen implementiert habe
- "2D Texte" werden zukünftig über "DrawHelpers" (derzeitiges 2D Interface) gezeichnet. Font kennt nur frei im Raum platzierbare
  Texte, also das universelle. Ich denke so sind die Aufgaben besser verteilt.
- Die Font Implementation von PLRendererOpenGLES und PLRendererOpenGL ist fast identisch, nur das PLRendererOpenGL auch noch
  zusäzlich Fixed Functions unterstützen muss



>> 21.06.2010
[CO]
PLRendererOpenGLES:
- Frei im Raum positionierbare Schriften funktionieren mittlerweile recht gut (was die Grundlage für alles weitere Darstellt da
  selbst "2D"-Schrift Polygone sind...)
- Auch das Darstellen von 2D Schriften funktioniert nun... als nächstes sollte dann das PLRenderer Font Interface neu aufgebaut
  werden da es etwas zugemüllt ist. Dies ist allerdings nix Technisches mehr, sondern nur noch eine reine Design-Frage. :D



>> 20.06.2010
[CO]
PLRenderer:
- Program: "EventDirty"-Event hinzugefügt das ausgelöst wird wenn Attribute und Uniforms höchstwahrscheinlich ungültig werden.
  "ProgramGenerator" hört auf dieses Event und zerstört die Benutzer Daten zu einem erzeugten Program. Somit müssen dann beim
  nächsten mal z.B. Uniforms und Attributes von neuem ermittelt werden. (aber immer noch besser als das in jedem Frame x mal
  zu machen! :)
PLRendererOpenGLES:
- Renderer::SetRenderState Implementation komplettiert
PLRendererOpenGL:
- Backup/Restore bei den neuen Shader Implementationen hinzugefügt - damit ist nun auch nach einem Vollbildmodus wechsel noch
  alles da. Bei PLRendererOpenGLES habe ich kein Backup/Restore da ich z.B. keine Texture Daten zurücklesen kann - wenn ganz, oder
  gar nicht, also bei OpenGL ES 2.0 gar nicht.
  Bei der Gelegenheit direkt das Shader Interface noch minimal erweitert.



>> 19.06.2010
[CO]
- ProgramGenerator: Das erzeugte Program wird nun in "GeneratedProgram" zusammen mit Zusatzinformationen gespeichert anstatt direkt
  ein Zeiger auf das erzeugte Program. "GeneratedProgram" hat ebenfalls "pUserData", dadurch kann man einem erzeugten Program noch
  Benutzereigene Informationen hinzufügen - z.B. etwas das direkte Zeiger auf alle Uniform & Attribute Parameter des Programs hält
  so das man einen performanteren Zugriff darauf hat.
PLRendererOpenGLES:
- Cube Maps Implementiert - ok, das war fast nur ein rüberkopieren aus PLRendererOpenGL *g*
PLRendererOpenGL:
- "FrameBufferObject::Initialize()" Multisample Antiasing Support wieder aktiviert da es scheinbar mittlerweile soweit sauber läuft
  (hatte am 12.06.2010 ja etwas daran gearbeitet)



>> 17.06.2010
[CO]
- "PLGui::ProgressWindow" Nutzung entfernt. Das sollte, wenn überhaupt, zukünftig über Events laufen. (die gabs damals noch nicht :)
- "PreviewWindow" von PLRenderer nach PLEngine verschoben
- "WindowConnection", "RenderWindow" und "RenderFrame" von PLRenderer nach PLEngine verschoben
- "Renderer::GetDisplayModes()" entfernt da der "Mehrwert" praktisch nicht vorhanden war
-> PLRenderer und dessen Backends sind nun komplett unabhängig von PLGui, das müsste die Flexibilität und Einsatzmöglichkeiten weiter erhöhen
PLRendererOpenGL & PLRendererOpenGLES:
- Jedesmal wenn ein Program aktiviert wird, wird nun glEnableVertexAttribArray für alle Attribute ausgeführt, wenn ein Program deaktiviert wird,
  wird hingegen glEnableVertexAttribArray ausgeführt. Wird dies nicht getan, so kann es schnell zu Konflikten mit Fixed Functions kommen.
  (*Kaputte Grafik*)



>> 16.06.2010
[CO]
- Die Renderer Backends nutzen kein PLGui mehr
PLRendererOpenGL:
- Da "OpenGLRenderContext" ein Krampf war, habe ich eine neue "Context" Klassen eingebaut - hatte genau soetwas schon vor Monaten nochmal für meine
  Bachelor sauber von 0 angefangen. "ContextWindows" für Windows läuft, "ContextLinux" hab ich soviel zusammengeraten wie ich konnte - wird aber
  sicherlich noch nicht laufen... ich hoffe aber das es weniger Arbeit macht das lauffähig zu machen als das alte "OpenGLRenderContext". :D



>> 15.06.2010
[CO]
- "ProgramGenerator" aus "PLCompositingShaders" nach "PLRenderer" verschoben, das ist etwas recht allgemeines das mitterweile auch recht ordentlich läuft



>> 14.06.2010
[CO]
- Renderer: Altes Shader Interface in einen "Depreciated shader interface" Block geschoben damit das alles übersichtlich beisammen ist was bei
  Zeiten wegkommt
- "GetVertices()" und "SetVertices()" vom Renderer in das FixedFunctions Interface verschoben und in "GetVertexBuffer()" und "SetVertexBuffer()"
  umbenannt. Das zuweisen von Vertex Daten an Shader Attribute läuft mittlerweile bei Shadern über ProgramAttribute ab. (was auch viel schöner
  und universeller ist :D)
- "GetIndices()" und "SetIndices()" in "GetIndexBuffer()" und "SetIndexBuffer()" umbenannt



>> 12.06.2010
[CO]
- Wow, OpenGL ES 2.0 kann sogar Multisample Antialiasing, dass muss natürlich genutzt werden da es die Bildqualität deutlich steigert.
  (weiche Kanten und generell weniger bis kein Pixelrauschen mehr, insgesamt ein ruhigeres und Angenehmeres Bild :)
  Damit hier eine Initialisierung nicht fehlschlägt nur weil man z.B. einen zu großen Samples Wert wünscht, hab ich hier einige Fallbacks
  eingebaut. Im Gegensatz zu OpenGL kann man Multisample allerdings nicht ein/ausschalten wenns erstmal ausgewählt wurde, aber das ist
  nicht wirklich schlimm. Ich hatte auch geprüft ob man das pro Surface einstellen könnte, sprich, Surfaces mit anderen EGL Config Einstellungen...
  beim internen Dummy Fenster bekam ich einen Crash, und bei normalen Fenstern - sah ich nur Müll. Sprich, es darf scheinbar nur eine einzige
  EGL config für *alles* verwendet werden. (zumindestens beim Emulator) Hm, das macht die Entscheidung etwas einfacher wie man von außen
  Multisample Antialiasing Einstellt - und zwar beim PLRenderer initialisieren!
- Aufgrund der gemachten Multisample Antialiasing Erfahrungen in OpenGL ES 2.0 habe ich mich dazu entschlossen das Multisample Antialiasing
  Samples am besten als Parameter bei "RendererContext::CreateInstance()" übergeben wird
- Auch bei OpenGL ist das so das wenn man einmal ein Fenster mit Multisample nutzt, alle anderen Fenster ebenfalls Multisample nutzen müssen -
  hm, hätte schwören können das wäre auch mal anderst gegangen. Ok, "DisplayMode::AntiAliasing" entfernt da witzos - Multisample Antialiasing
  wird nun also einmal beim Renderer Instanz erzeugen definiert, und dann wird das überall so verwendet.
- Renderer: "Init()" und "DeInit()" -> unnötig und gefähliche Methoden entfernt



>> 09.06.2010
[CO]
PLRendererOpenGLES:
- Sampler States eingebaut
- OpenGL ES 2.0 hat keinen Support für Occlusion Queries
- "Renderer::MakeScreenshot()" implementiert. Zuerst freute ich mich das dies ein 1:1 kopieren aus dem OpenGL Backend war... bis ich
  merkte, das glReadPixels nur einen Fehler zurückgab. Unter OpenGL ES 2.0 unterstützt glReadPixels kein GL_RGB was ich bisher verwendete,
  daher änderte ich das in GL_RGBA, und auch im OpenGL Backend - speichert man das als png hat man nun also auch noch eine Alpha Maske was
  ja auch mal von Vorteil sein kann. Mache ich einen Screenshot von "Mipmaps.scene", welches einen "leeren" Hintergrund hat, so hab ich im
  png hier nun eine Transparenz - nett. Sollte das jemand mal nicht wollen, kann man den Alpha Kanal nachträglich entfernen lassen.



>> 08.06.2010
[CO]
- Bis auf "Shader2": Die "2" aus den Namen des neuen Shader-Interfaces rausgenommen da es keine Konflikte gibt und es nun langsam an die
  Abschlussarbeiten geht... und es mehr Arbeit wäre nun alles umzustellen, und dann später nochmal die Namen anzupassen. :D
- Sampler Uniforms bekommen nun wie in Cg eine Texture Unit fest zugeteilt, so das man eine Texture nur einem Uniform zuweisen muss und
  der Rest intern automatisch gehandhabt wird. Das hat sich in der Vergangenheit als sehr Praktisch herausgestellt, die konkrete Texture
  Unit wird wie gehabt von der entsprechenden Methode als Parameter zurückgegeben oder kann durch "GetTextureUnit()" ermittelt werden.
- ProgramUniform um etliche Methoden erweitert
- Etwas mit den OpenGL Shader Language Versionen auseinandergesetzt, dazu werden im Log nun vom Renderer die jeweiligen Versionen rausgeschrieben.
  OpenGL ES 2.0 unterstützt nur "#version 100", das aktuelle OpenGL unterstützt NICHT "#version 100". Laut OpenGL GLSL Spezifikation sollte
  man die Version immer dazuschreiben, im Internet findet man eigentlich dann auch fast nur GLSL Codes wo die Version immer dabei steht -
  das dumme ist hier allerdings das ich nicht zwanghaft zwei GLSL Shader Code Versionen machen will "nur" weil halt die Version ne andere ist.
  Solange es auch ohne Versionsangabe dann auf OpenGL ES 2.0 und mit OpenGL läuft, machen wir es so. Dazu schreibe ich aber immer ein entsprechendes
  Kommentar in die GLSL Codes so das man nicht später mal denkt "huch, da sollte aber ne Versionsinfo" rein, sich dann freut das man sich nun
  an die Spefizikation hält, und dann irgendwann später erst merkt das nun bei der anderen OpenGL Version nun gar nix mehr geht. Mal schaun
  wann dann bei den Scene Renderer Schritten der Punkt kommt wo ich unterschiedliche GLSL Codes schreiben muss da ich Features nutzen will/müsste
  die erst die neueren Sprachen haben. Da muss ich mir dann wohl jeden Punkt anschaun - z.B. glaub ich nicht das es dann lohnen würde z.B. für
  SSAO Shader OpenGL ES 2.0 Versionen zu schreiben... denn damit wären die kleinen Maschienchen eh total überfordert + können auch kein MRT was
  ich für Deferred Rendering aber nutze, und z.B. SSAO nutze ich auch nur beim Deferred Renderer. Da muss man dann wohl immer Ordentliche
  Kommentare verfassen damit klar ist wie was. :D
  Ich hoffe das läuft so dann ohne Versionsangaben auch direkt z.B. auf dem Nokia N900, nicht das der Emulator hier zu nett zu mir ist. *g*
- Die abgeleiteten Renderer-Klassen heißen nun ebenfalls "Renderer", das macht deren Verwendung etwas angenehmer da man nicht immer
  "PLRendererOpenGLES::RendererOpenGLES" und "PLRendererOpenGL::RendererOpenGL" schreiben muss sondern nur noch z.B.
  "PLRendererOpenGLES::Renderer" - damit kann man etwas komforabler über z.B. die Konfigurations-Datei den Renderer wechseln ohne immer darauf
  achten zu müssen das man alles anpasst. Damit ist das nun konsistent zu den anderen Backend-Klassen - früher ging das leider nicht anderst
  da das alte RTTI keine Namespaces unterstützte. :D
  -> ACHTUNG: Sicherheitshalber die "cfg" Dateien löschen damit nun kein ungültiger Renderer angegeben wird.
  -> Die anderen Backend-Systeme sollten am besten genauso angepasst werden, das mit der Namespace nutzung ist einfach viel schöner und
     Handlicher :D



>> 07.06.2010
[CO]
- Die Geometry-Shader Implementation ist korrekt, die Nutzung im Beispiel war falsch... natürlich muss man auch hier schaun das die Daten
  sauber von der Vorstufe aufgenommen, und an die Nachstufe weitergegeben werden.
- "ShaderToolsGLSL::WriteProgramInformationIntoLog" war nicht ok... hm, das kommt eher selten vor das sich Dinge die früher Extensions waren
  und dann in den Kern übernommen wurden sich anderst verhalten und andere Funktionen da sind :/
- Wird der Shader Quellcode mit "SetSourceCode" gesetzt, so kann man nun ebenfalls das Profile als String übergeben - eigentlich nur für Cg
  relevant! Als Standard Profile nutzte ich bei Cg die GLSL Profile da ich so auch auf meiner ATI Karte ordentliche Shader schreiben kann -
  denn ansonnsten kann ich nur die ersten primitiven Shader Generationen auf meiner ATI Karte nutzen - der Rest geht *natürlich* nur auf
  NVIDIA Karten. Das war noch ein weiterer Grund wieso ich Cg nicht mehr als Hauptshadersprache haben will - als ATI Nutzer fühle ich mich
  da etwas veräppelt. *g*
  Mittlerweile läuft auch "glslv" korrekt... der Trick bestand darin "cgCombinePrograms2" zu nutzen was in Cg 1.5 eingeführt wurde... sprich,
  die einzelnden Cg Programme werden zu einem Cg Program zusammengematscht - Cg intern wohl u.a. wegen GLSL das nur ein gemeinsames Programm
  kennt. Nett. Das fand ich nun eher per Zufall. Sprich, das aktuelle PL Shader-Interface ist sehr gut so - da man einfach ein gesamt Programm
  braucht wenn es auf sovielen APIs wie möglich laufen soll.
  Cg ist irgendwie Horror, ich habe nun etliche Stunden damit verbracht zu Analysieren wie sich was verhält, denn die Cg-Dokus sind eher schwach
  und im Internet gibts meist auch keine Antworten auf meine speziellen Fragen. Sobald GLSL Profile verwendet werden, bricht in Cg die Hölle aus
  und einiges verhält sich schlichtweg anderst! Ich habe mir nun selbst zusammengereihmt das die Faußregel ist "Ein Shader mit GLSL, alles GLSL!".
  Ich habe entsprechende Log Fehlernachrichten eingebaut wenn man versucht Shader Profile zu mischen so das man nicht wie ich nun Stundenlang braucht
  um Fehlerquellen zu finden! Wenn man also nun ein GLSL Program hat, ein "Cg Combined Program", kann man z.B. mit "cgGLIsProgramLoaded" direkt
  testen ob alles geklappt hat. Verwendet man aber nicht GLSL, so geht "cgGLIsProgramLoaded" intersanterweise nicht, und man muss dann die Unterprogramme
  aus dennen sich das "Cg Combined Program" zusammensetzt einzelnd abtesten.
  Weitere Stunden gingen für den Cg Shader von SPTriangleShaders drauf - denn sobalg GLSL Profile genutzt werden, lassen sich auf einmal die Shader
  nicht mehr übersetzen wenn man nicht unverschämt strickte Regeln einhält. Z.B. dürfen Attribute wie Vertex Positionen dann nicht mehr frei mit
  z.B. "ATTR0" gekennzeichnet werden, nein, dann MUSS die Semantic auf einmal "POSITION", "COLOR" etc. sein. Das Spielchen mit den Semantics geht
  an anderen Stellen so weiter - so das hier wieder alles etwas Altbacken wirkt da man scheinbar mit Festverlöteten Daten-Bedeutungen arbeitet.
  Hat ja alles vor und Nachteile mit den Semantics, z.B. muss Cg ja wissen wie die einzelnden Daten Pipelines zusammengestöppelt werden, ist aber einfach
  ein zu GLSL anderer Ansatz wo man sich Gedanklich dann immer Umstellen muss.
  Das ist im naiven GLSL, also nicht Cg, alles viel schöner, da GLSL Attributen keine feste Bedeutung unterstellt - das einzige was "fest" ist, ist
  die Vertex-Position... denn die Vertex Position wird dazu verwendet um ein Dreieck zu Rasterisieren... hier muss die Hardware also wissen wo die
  Vertex Positionen zu finden sind. Alle anderen Datenströme braucht die GPU nicht zu interessieren!
  Gefreut habe ich mich darüber das es Funktionen wie "cgGetProfileProperty(m_pCgProfile, CG_IS_VERTEX_PROFILE)" gibt mit denen man Prüfen kann ob
  der Benutzer für einen Vertex Shader ein Profil angibt das nicht für Vertex Shader ist... geflucht hab ich als ich merkte das sobald "CG_IS_OPENGL_PROFILE"
  ja sagt, "CG_IS_VERTEX_PROFILE" etc. nicht gesetz sind so ich per Hand auf z.B. "CG_PROFILE_GLSLV" hin prüfen muss. Na also wirklich brauchbar
  sind diese Eigenschaften ja dann doch irgendwie nicht wann man am Ende dann wieder individuelle Profile in die Hand nehmen muss. (von dennen es in Cg
  so einige gibt und regelmäßig neue hinzukommen...)
  Geometry-Shader in Cg zum laufen zu bringen war natürlich genauso wenig lustig... umso mehr froh bin ich das nun scheinbar alles soweit läuft und
  das PL Shader-Interface einiges vom Cg Horror intern verbergen kann. Z.B. hab ich nirgends eine wirkliche Dokumentation für die Geometry-Shader
  gefunden. "emitVertex" sieht man oft, aber dann kam die Frage auf wie man denn nun ein neues Primitive anfängt, über Umwege fand ich dann
  "restartStrip". Dann wollte ich es wissen und durchsuchte nochmal das Cg-SDK... da liegt ein Dokument "Cg-2.0.pdf" bei, das sind Folien einer
  Präsentation, "restartStrip" taucht dort als Randnotiz auf einer Folie auf. Also offen gesagt, das ist schlichtweg Unprofessionel, das kann man
  doch nicht bringen für soetwas wie Cg eine derart schlampige Dokumentation zu haben. *gruml*
- Wird der Shader Quellcode mit "SetSourceCode" gesetzt, so kann man nun auch den Einstiegspunkt als String übergeben. GLSL kennt soetwas
  nicht, Cg aber schon. Standard ist "main".



>> 06.06.2010
[CO]
- Geometry Shader hinzugefügt, das ist etwas was heute umbedingt da sein sollte - damit hatte ich schon während meiner Bachelorarbeit etwas
  herumgespielt. Irgendwie schlägt aber momentan das Program linken ganz ohne Fehlermeldung fehl sobald ich einen Geometry Shader nutzen will,
  hm, das muss ich mir genauer anschaun. Aber für's erste sind schonmal die Geometry Shader Klassen drinnen.
PLRendererOpenGL:
- GLSL Implementation für das neue Shader-Interface hinzugefügt. Im Grunde musste ich nur das was ich für OpenGL ES 2.0 machte rüberkopieren,
  und dann die OpenGL Funktionen anpassen da hier GL_ARB_shader_objects & GL_ARB_vertex_shader verwendet wird. Uff, GL_ARB_shader_objects war
  einiges an Fleißarbeit bis alle Funktionen eingebunden waren. Schade das man hier in verschiedenen Projekten fast identsichen Code hat, aber
  mit Kopieren arbeiten muss damit das kein Chaos gibt. :/
  Die SDK Demos PLDemoRendererTriangle und PLDemoMeshTeapot laufen nun auch mit PLRendererOpenGL unter GLSL. Hier also absolut keinen Unterschied
  ob gerade OpenGL ES 2.0 oder OpenGL verwendet wird, GLSL ist GLSL. Das ist wohl ein weiteres Argument dafür das GLSL zukünftig unsere
  Hauptshaderprache wird.
- Cg Implementation für das neue Shader-Interface hinzugefügt



>> 05.06.2010
[CO]
PLRendererOpenGLES:
- TextureBuffer2D implementiert, ist fast genauso wie beim OpenGL Backend, nur das man Texturen nicht mehr von der GPU herunterladen kann
  und es keine DXT Kompressions Formate gibt (... dafür ein anderes Kompressions Format...)



>> 04.06.2010
[CO]
PLRendererOpenGLES:
- Leider braucht auch OpenGL ES immer ein gesetztes Fenster, sonst gehen Anfragen ins Leere (auch wenn diese eigentlich im Context
  gespeichert werden...)



>> 03.06.2010
[CO]
- Schnittstellen ProgramAttribute & ProgramUniform hinzugefügt, das erstere um Vertex Eingabestreams setzen zu können, das zweite
  für die Program Parameter. Auch hier orientierte ich mich wieder an OpenGL & GLSL, das müsste sich dann recht einfach auf Cg
  und sicherlich auch HLSL übertragen lassen und z.B. auch bei Cg werden Program Parameter im Shader Code mit "uniform" gekennzeichnet -
  von der Terminology her ist das also stimmig. :D



>> 02.06.2010
[CO]
- Neue Funktion "VertexBuffer::GetVertexAttribute" die ein Vertex Attribute anhand Semantic zurückgibt
- Mit dem neuen Shader-Interface begonnen, ich nenne alles erstmal "VertexShader2" und so weiter. Beim Design und den Namen versuche
  ich mich soweit wie möglich an GLSL zu halten da dies wohl unsere Hauptshadersprache wird - und z.B. Cg kennt kein "Program" Objekt
  in dem Sinne wie GLSL, von daher wird am Ende z.B. Cg wohl einfacher zu implementieren sein da das "Program" Objekt dort dann im
  grunde nur eine Vertex & Fragment Shader Sammlung ist, aber ohne das das "Program" noch "gelinkt" werden müsste. Die Methode
  "Renderer::SetVertices" wird es Zukünftig wohl nicht mehr geben, bzw. nicht mehr im Hauptinterface. (für Fixed Function wohl schon
  noch) Mittlerweile ist das alles viel offener und Dynamischer und z.B. "Vertex Shader Attribut" und "Vertex Buffer Attribut" werden
  nur "verlinkt". Ich mache diesmal auch direkt "VertexShader" etc. Klassen damit das sauberer ist als vorher wo alles über eine
  gemeinsame "Shader" Klasse lief. Insgesamt versuche ich die Shader Interfaces & Implementationen so direkt und leichtgewichtig wie
  möglich zu machen - das ist sehr Grundliegend, und ich denke gerade bei Mobilen Geräten sollte man darauf achten nicht unnötig viel
  Overhead einzubauen wenn sich das auch umgehen lässt.



>> 31.05.2010
[CO]
- "RendererBackend" und "DrawHelpersBackend" liegen nun direkt in PLRenderer



>> 30.05.2010
[CO]
- Nutzung von "glGetError" entfernt, das sollte im Allgemeinen nur für konkretes Debugging verwendet werden und in den meisten Fällen
  war die Verwendung von "glGetError" ohnehin nicht korrekt da wenn ein Fehler gefunden wurde, keine weiteren Fehler registiert werden
  bis der Fehler abgefragt wurde.



>> 29.05.2010
[CO]
- IndexBuffer: UByte wird als Index Datentyp nun ebenfalls unterstützt. UInt wird von OpenGL ES 2.0 nicht unterstützt,
  dafür wird UByte von DirectX 9 nicht unterstützt - UShort scheint das Format zu sein, das auf allen bisher unterstützten
  Grafik-API's läuft. Daher ist UInt nun nicht mehr der Default-Wert, sondern UShort damit es möglichst immer sofort läuft
  wenn man das mal von Hand füllt. (was in der Praxis eigentlich eher seltener vorkommt)
PLRendererOpenGLES:
- Mit der konkreten OpenGL ES 2.0 Implementation begonnen
- (Fensterloser) Context wird erzeugt und zerstört. Das geht mit der OpenGL ES API viel angenehmer als mit der alten OpenGL API. :D
- Renderer: SetViewport, SetScissorRect, SetColorMask, Clear, SetIndices und SetVertices implementiert, diese sind fast komplett
  identisch zu den OpenGL Implementationen
- Renderer: DrawPrimitives und DrawIndexedPrimitives implementiert. Prinzipiell identisch mit den OpenGL Implementationen, nur das es
  bei OpenGL ES 2.0 viel weniger 'Draw'-Varianten gibt, so das der Code zwanghaft kompakt bleiben muss.
- IndexBuffer implementiert. Praktisch identisch zu OpenGL, nur das Index Buffer in OpenGL ES 2.0 so direkt implementiert sind und
  man daher nicht über Extensions gehen muss. "MapBuffer" läuft weiterhin über Extensions, wird aber eher selten bis gar nicht genutzt
  da wir normalerweise dann direkt den Buffer Inhalt Host Seitig Buffern.
- VertexBuffer implementiert. Der Kern ist praktisch identisch zu OpenGL, nur das Vertex Buffer in OpenGL ES 2.0 so direkt implementiert
  sind und man daher nicht über Extensions gehen muss. "MapBuffer" läuft weiterhin über Extensions, wird aber eher selten bis gar nicht
  genutzt da wir normalerweise dann direkt den Buffer Inhalt Host Seitig Buffern. Ein zuweisen der Vertex Daten an Shader Attribute läuft
  natürlich etwas anderst ab als früher bei Fixed Functions - aber dieser Code stand ohnehin schon länger auf meiner Refactoring Liste und
  jetzt hab ich nen Grund das endlich mal zu überarbeiten damit es besser zu den modernen Grafik-API's passt. (und trotzdem auch noch mit
  Fixed Function läuft)



>> 03.05.2010
[SB]
- TextureBuffer::FixNANValues(): Da die Umwandlung von float in half noch nicht funktioniert, kan der übergebene
  Farbwert natürlich nicht konvertiert werden, hier kommt also immer 0 heraus. Das macht diese Funktion noch ziemlich
  nutzlos, denn "schwarz" anstelle von "schwarz" ist, naja, ... Habe darum erstmal hier feste Werte eingebaut, die
  Rot ergeben sollten. Neim Setzen der Farbe gab es auch noch einige kleine Fehler. Allerdings scheint die Methode dennoch
  nicht zu funktionieren, es ist jedenfalls nichts zu sehen, wenn ich das aufrufe (vermute, dass das eher daran liegt,
  dass die Textur nicht geupdatet wird, als am Farbwert).



>> 01.05.2010
[CO]
- TextureBuffer: Statische Funktionen GetComponentsPerPixel(), GetBytesPerPixelComponent() und GetBytesPerPixel() hinzugefügt. Damit sich
  das genauso verwenden lässt wie PLGraphics::ImageBuffer bleibt "Pixel" hier im Namen - eine Unterscheidung in Texel/Voxel wäre eine
  unnötige verkomplizierung.
- TextureBuffer::GetNumOfComponents() in TextureBuffer::GetComponentsPerPixel() umbenannt und weitere Funktionen GetBytesPerPixelComponent()
  und GetBytesPerPixel() hinzugefügt damit sich das genauso verwenden lässt wie PLGraphics::ImageBuffer
- TextureBuffer::IsCompressedFormat(), TextureBuffer::GetUncompressedFormat() und TextureBuffer::IsFloatingPointFormat() hinzugefügt
- Renderer::IsTextureBufferPixelFormatCompressed() entfernt, dafür gibts nun TextureBuffer::IsCompressedFormat()
- Renderer::GetTextureBufferPixelFormat() nach TextureBuffer verschoben und in GetFormatFromImage() umbenannt
- Neue Funktion TextureBuffer::GetNumOfFaces()
- Neue Funktion TextureBuffer::GetNumOfNANValues(): Für Fließkommezahlen Formate kann man hiermit die Anzahl der NANs in der Texture zusammenzählen
  lassen. Funktioniert im Augenblick noch nicht für 16 Bit Fließkommazahlen (half)... daher für den DOF Bug Test im "Begin" Render Schritt ein 32 Bit
  Fließkommazahlen Ziel einstellen. (ist unabhängig von "Float32" in "SRPDeferredGBuffer")
- TextureBuffer::GetNumOfNANValues() nutzt die neue PLMath::Half-Hilfsklasse, nun funktioniert auch der Test bei 16 Bit Fließkommazahlen Texturen
- TextureBuffer::FixNANValues() hinzugefügt, ist ähnlich zu TextureBuffer::GetNumOfNANValues(), ersetzt gefundene Pixel die irgendwo ein NAN haben
  jedoch direkt durch eine übergebene Farbe und läd am Ende den "geflickten" Buffer wieder hoch. Damit wüsste man zumindestens das nach einem Aufruf
  dieser Funktion der Buffer nur gültige Werte hat - könnte helfen NAN Fehler weiter einzugrenzen da weniger Ungewissheiten.



>> 18.04.2010
[CO]
- WindowConnection, RenderFrame, RenderWindow, PreviewWindow, SPDefault und SPDefault vom "Renderer"-Verzeichnis in den Grundordner von PLRenderer
  verschoben. Im "Renderer"-Verzeichnis sollten eigentlich nur Backend-Relevante Dinge liegen, also der Technische Kern. Die verschobenen Klassen
  sind hingegen bereits Klassen die auf dem System aufsetzen um es noch einen Tick einfacher nutzbar zu machen. Alles was man also braucht um sich
  einen "Renderer" zu erzeugen liegt nun im Grundverzeichnis.
- WindowConnection::SetToggleFullscreenMode() kümmert sich nun um die Registrierung der Hot-Keys
- WindowConnection-Konstruktor: Da ein PLGui Content-Window die Nachrichten nur an sein Parent weiterleitet, muss man leider im Falle von PLGui::Frame
  die Ereignisse von PLGui::Frame und nicht vom Content-Window abgreifen :/
- WindowConnection: Da ich gerade schon wieder darüber gestolpert bin, speichert WindowConnection nun selbst den aktuellen Vollbild-Modus so das man
  das interne Surface löschen kann, aber immer noch korrekte verwendete Einstellungen ermitteln kann.



>> 17.04.2010
[CO]
- Das meiste aus RenderFrame liegt nun in der neuen Klasse WindowConnection. RenderFrame und RenderWindow sind beide davon abgeleitet, dadurch sind
  beide Klassen nun fast leer was aber auch gut so ist. Diese zwei Klassen sollten nur "erweiterte" GUI Elements sein die man nutzen *kann* um
  direkt ein GUI Element Instanzieren zu können in das was gerendert wird. Auch ist endlich der Code nicht mehr doppelt was mich nun schon einige
  male etwas Störte - das bedeutet aber, das man Prinzipiell auch ein RenderWindow in einen Vollbild-Modus versetzen kann. Dies finde ich aber ok
  denn das könnte durchaus mal benötigt werden. (z.B. um ein Render-Fenster in einem Editor in den Vollbild-Modus zu schalten wie wir es vor langer
  laaaaaannger Zeit mal in PixelLab hatten :)
  WindowConnection müsste es nun auch etwas Einfacher machen ein PixelLight Render Fenster in eine andere Anwendung einzubetten... den Nativen OS
  Fenster Handle verpackt man dann wie gehabt in NativeWindow, und übergibt dieses dann WindowConnection. Ein weiteres GUI-Fenster wird also intern
  nicht mehr zwangsläufig erzeugt. Daher war ein Design-Ziel von WindowConnection auch, das es möglichst GUI unabhängig ist und wenn irgend möglich
  nichts am übergebenen GUI Fenster manipuliert. Wenn beispielsweise in den Vollbild-Modus geschaltet wird, ist es der Job von beispielsweise
  RenderFrame sich darum zu kümmern das das GUI Fenster links oben plaziert und auf die richtige größe gesetzt wird. Auch ob der Fensterrahmen
  sichtbar sein soll oder nicht ist nicht Job von WindowConnection.
- RenderFrame: "sTitle"-Parameter aus dem Konstuktor entfernt, das bringt hier nicht wirklich viel an Mehrnutzen und bläht das Interface nur
  unnötig auf
- PLRendererOpenGL: Bugfix: Wenn Mipmaps nicht bis 1x1 Definiert sind, werden die restlichen Mipmaps automatisch erzeugt da dies nötig ist... allerdings
  wurde m_nTotalNumOfBytes nicht aktualisiert
- TextureBuffer3D & TextureBuffer2D: GetSize(): Autsch, die kleinste Mipmap wurde nicht richtig zurückgegeben und konnte auch mal 0x1 oder so sein
  was ja nicht sein kann -> Der Fehler ist am 05.04.2010 reingekommen wo ich auf PLMath::Vector2i umgestellt habe.



>> 14.04.2010
[CO]
PLRendererOpenGL:
- FrameBufferObject: Depth&Stencil Support läuft, zumindestens über die GL_EXT_packed_depth_stencil-Erweiterung die man nutzen kann wenn man
  mit 24 Bit Tiefenbuffer und 8 Bit Stencilbuffer auskommt. Interessanterweise ging ein *seperater* Stencilbuffer immer noch nicht und ich konnte
  im Netz auch kein einziges laufendes Beispiel sehen das GL_EXT_packed_depth_stencil nicht nutzt.



>> 13.04.2010
[CO]
- Transform State Änderungen von gestern komplettiert... hui, das zog wirklich einige (kleine und immer gleiche :) Anpassungen in anderen Projekten
  nach sich da an vielen Stellen wo etwas gezeichnet wird derzeit direkt Fixed Function Zeug genutzt wird. Durch die Entfernung der Semantics aus
  Effect gehen derzeit ein paar Effekte wie z.B. "Volumetric Line" nicht. Daher werd ich heute mal schaun wo/wie ich Fixed Functions Nutzung
  einschränken kann bzw. es so zu ändern das es mit und ohne Fixed Functions läuft. (vorher macht es auch weniger Sinn z.B. sofort mit OpenGL ES
  anzufangen)
  Wie man am besten *bekannte* Effekt Shader Parameter setzt werd ich mir auch anschaun. Wird wohl darauf hinauslaufen das Scene Renderer das machen
  und Stellen die direkt zeichnen ohne über Scene Renderer zu gehen - aber in PLRenderer selbst sollte soetwas nicht mehr fest eingebaut sein, das
  ist einfach zu Chaotisch. :D



>> 12.04.2010
[CO]
- RenderState::ShadeMode nach FixedFunctions verschoben
- In OpenGL 3 und DirectX 10 wurden Clip Planes durch einfachere Clip Distances ersetzt die zumal anderst Verwendet werden. IsClipPlaneEnabled(),
  SetClipPlaneEnabled(), GetClipPlane() und SetClipPlane() daher nach FixedFunctions verschoben. Clip Distances bau ich aber erstmal nicht ein
  da wir das derzeit nicht benötigen.
- Ok, "Alpha-Test" scheint es bei den modernen Grafik-APIs ebenfalls nicht mehr zu geben. Hm, ok, dann geht das wohl zukünftig *nur* noch darüber das
  man in seinem Fragment-Shader selbst einen Alpha-Test realisiert und dann über "discard" (texkill) Fragmente verwirft. Gut, dann ist die Frage ob man
  lieber Alpha-Test oder "discard" verwendet geklärt. *g*
  Alpha-Test durch "discard" sollte weiterhin sparsam Eingesetzt werden da es laut diverser Quellen Tiefenbuffer Optimierungen deaktiviert.
  (z.B. laut http://developer.amd.com/media/gpu_assets/Depth_in-depth.pdf Early-Z... aber nur wenn man gerade auch in den Tiefen-Buffer schreibt)
  RenderStates AlphaTestEnable, AlphaFunc und AlphaRef nach FixedFunctions verschoben und die letzten zwei States in AlphaTestFunction und
  AlphaTestReference umbenannt damit das vom Namen her klar ist wozu das gehört.
- VertexBuffer: GetColor() und SetColor() arbeiten nun mit PLGraphics::Color4
- TextureBuffer: GetPriority(), SetPriority() entfernt da scheinbar bei allen aktuellen Grafik-APIs (OpenGL 3, OpenGL ES, DirextX 10>) Depricated
  oder bereits weg - selbst genutzt hatten wir das eigentlich nie
- GetColor() und SetColor() nach FixedFunctions verschoben und auf PLGraphics::Color4 umgestellt
- Renderer: ModifyProjectionMatrix() entfernt, nutzten wir schon seit einer Weile nicht mehr und soetwas sollte zukünftig nicht mehr direkt
  in PLRenderer sein
- Renderer: ResetTransformStates(), GetTransformState() und SetTransformState() nach FixedFunctions verschoben
- ShaderProgramCgBackend: BindSemanticParameters() und RefreshSemanticParameter() entfernt, das zog nochmal eine ganze Reihe von Änderungen nach sich.
  Auch wenn das früher mal ganz nett war, passt dies nun einfach soetwas von überhaupt nicht mehr ins Konzept. Es machte in PLRenderer vieles zu
  kompliziert und inperformant... PLRenderer muss zukünftig "Leichtgewichtiger" sein wenn wir auch soetwas wie OpenGL ES unterstützen wollen.
  Das mit den "Benutzer Shader über Effekte" klappt mit dem Scene Renderer Konzept ohnehin nicht mehr so richtig dolle, da muss ich mir bei Zeiten
  wohl was neues ausdenken, falls dies wirklich nötig werden sollte. (was ich zumindestens derzeit nicht sehen kann)



>> 10.04.2010
[CO]
- Renderer: Begin2DMode(), Is2DMode(), Get2DMode(), End2DMode(), Get2DZValue(), Set2DZValue() und DrawBitmap() nach DrawHelpers verschoben. Bisher war
  das ja irgendwie nett mit einem "2D-Modus", aber jetzt mit Shadern wirkt das irgendwie nur noch Umständlich. Das hab ich gerade in den letzten
  Wochen gemerkt als ich viel im "Image-Space" gearbeitet habe - da ist es einfacher wenn man auf all die World, View, Projektion und so weiter
  Matrizen verzichtet und *direkt* Clip-Space Koordinaten übergibt ohne wenn und aber. Zukünftig sollte man das also höchstens noch für
  "mal schnell was ausprobieren" nutzen, ansonnsten sollte man das entweder selbst richtig machen, oder über Hilfs-Klassen wie "PLScene::FullscreenQuad"
  die im Grunde fast schon die "DrawBitmap()"-Funktionalität ist... aber auf einer höheren Ebene und mit deutlich mehr Einflussmöglichkeiten.
  Wie auch bei den anderen DrawHelpers-Funktionen wird das allerdings derzeit noch hier und da ersthaft genutzt und ich habe alles nur soweit
  angepasst das es noch übersetzbar ist und läuft. Die Stellen muss ich mir dann im einzelnden anschaun und aktualsieren - so das am Ende dann
  auch *alles* läuft wenn das "FixedFunctions"-Interface nicht vorhanden ist. (sprich, auch alles sauber unter OpenGL ES läuft!)
- Renderer: GetLineWidth() und SetLineWidth() zu RenderState gemacht (hey, und das ist sogar noch Bestandteil von OpenGL 3>=!... auch wenn es bereits
  auf der Abschussliste steht *g*)
- DrawHelper-Funktionen haben nun Farbe als Parameter da hier SetColor() ohnehin schon ohne Wirkung war und man SetColor() nur noch wirklich für reine
  Fixed-Function Draw-Calls nutzen sollte
- Font::Draw() muss man nun die Farbe übergeben



>> 09.04.2010
[CO]
- DrawPoints2D(), DrawPoints3D(), DrawLines2D() und DrawLines3D() entfernt, diese Funktionen sind einfach nur daneben da totaler Overkill und
  umständlich. Will man viele Punkte und Linien zeichen, sollte man wirklich wirklich einen Vertex Buffer anlegen, das ist nicht sooo viel
  Arbeit und deutlich sauberer und Effizienter. DrawPoint() und DrawLine() hingegen sind noch ok, wenn man für Debugging mal schnell was kleines
  anzeigen will. (aber wirklich nur für Debugging bzw. Debugging Visualisierung, ein Draw-Call pro Element, das geht einfach nicht :)
- Neues Interface "DrawHelpers". DrawPoint(), DrawLine(), DrawTriangle(), DrawQuad(), DrawBox() und DrawPlane() hierhin verschoben. Das sind alles
  Dinge die man eigentlich nur "mal schnell was ausprobieren" oder "kleine schnell realisierte Debug-Visualisierung" nutzen solle, aber NIEMALS
  ernsthaft für richtige Grafik. (auch wenn das derzeit noch an wenigen Stellen so ist) Dafür ist es schlichtweg zu Ineffektiv einzelnde Elemente
  zu zeichen + auch viel zu Einschränkend da man keine Texture Koordinate, Vertex Farben und und und und angeben kann. (wäre auch der totale Overkill
  wenn man das alles in den Funktionen bieten wollte :)
  Auch hier heist die Diverse: Lieber einen kleinen eigenen Vertex Buffer anlegen, mit Daten füllen und dann auf einen Schlag zeichnen lassen.
  Im Renderer-Interface kommt man über die Funktion "GetDrawHelper()" an dieses Helper-Interface... hier wird eine Referenz zurückgegen da das
  Objekt *immer* gültig sein sollte, es wäre etwas am "schnell und einfach was ausprobieren"-Sinn vorbei wenn man erst Prüfen müsste ob der
  Zeiger überhaupt gültig ist.



>> 08.04.2010
[CO]
- "FixedFunctions"-Schnittstelle begonnen - hierhin werde ich nun Schrittweise alle Funktionalitäten verschieben die früher in Grafik-APIs und GPUs
  fest Verdrahtet waren, heute aber universell und frei über Shader realisiert werden. Dinge die es in DirectX 10 nicht mehr gibt, und in OpenGL 3.0
  Depreciated sind. Renderer Backends sind nicht gezwungen das Interface zu Implementieren - z.B. PLRendererOpenGLES wird es nicht implementieren.
- GetDefaultMaterialState(), ResetMaterialStates(), GetMaterialState(), SetMaterialState() nach FixedFunctions verschoben
- ShaderProgramCgBackend: Die "Verdrahtung" von Fixed-Function Render States und Shadern werd ich nun ebenfalls Schrittweise rausnehmen, das ist aus
  heutiger Sicht einfach nur noch dämlich und umständlich und viel zu Einschränkend. (haben wir eh nie ernsthaft genutzt) Entweder nutzt man Fixed-Function,
  oder gleich saubere Shader basierende Konzepte.
- GetDefaultLightSettings(), ResetLights(), IsLightEnabled(), SetLightEnabled(), GetLight(), SetLight() nach FixedFunctions verschoben
- Lighting, Ambient, NormalizeNormals von "RenderState" nach "FixedFunctions::RenderState" verschoben
- FogEnable, FogColor, FogDensity, FogStart, FogEnd, FogMode von "RenderState" nach "FixedFunctions::RenderState" verschoben
-> Achtung: In plfx-Dateien muss nun z.B. "Lighting" in "FixedFunctionsRenderStates" und nicht mehr "RenderStates" stehen
   (das ist schon OK das diese Namen nun länger sind - denn man sollte es NICHT mehr nutzen weils immer mehr Hardware gibt wo das einfach nicht mehr läuft *g*)
- Renderer-Flags BindNoTextures, BindNoShaders, LockModeStates, LockZBufferStates, LockAlphaStates, LockBlendStates, LockStencilStates, LockPointStates,
  LockTessellationStates, LockScissorTestStates entfernt... soetwas war noch nie schön und das ist mit dem Scene Renderer Konzept eh nun überflüssig.
  (und wer das nicht nutzt, muss sich eh um alles selbst kümmern)
- Renderer: GetFlags() und SetFlags() entfernt, das einzige Argument dafür war das von eine Zeile weiter oben
- Accumulation Buffer Support entfernt, das stand schon lange auf meiner Abschussliste. Zum einen gibs das nur für OpenGL, in OpenGL 3.0 scheint das auch
  Depriciated zu sein und ich wüsste auch nicht wofür man das noch bräuchte - denn mittlerweile kann man dafür genauso gut FBO nutzen das weit mehr bietet.
  (Fließkommazahlen, Blend Funktionen und und und) Tiefenunschärfe, Motion Blur - alles was man immer liest das dies so toll mit Accumulation Buffer geht,
  geht heute mit FBO und Shadern noch viel besser und Universeller. :D
- Renderer: ReadDepthComponent() entfernt... obwohl ich das ja eigentlich erst vor 6 Jahren eingebaut habe! *g*
  Für die Performance ist das *zurücklesen* von Werten über die traditionellen OpenGL Funktionen tötlich, unter DirectX gibts soetwas nüsch. Entweder kann
  man Occlusion Queries nutzen um zu ermitteln ob was verdeckt ist, oder man nutzt Render To Texture und holt sich dann die Texture Daten zurück.
  (das meiste wird eh mittlerweile direkt in Texturen gerendert so das man genauso gut "TextureBuffer::Download()" nutzen kann, es aber natürlich wegen
  mieser Performance nicht sollte) Wurde auch nirgends mehr verwendet.
- GetDefaultTextureStageState(), ResetTextureStageStates(), GetTextureStageState(), SetTextureStageState() nach "FixedFunctions::RenderState" verschoben
- "TextureStageStates"-Klasse in "FixedFunctionsTextureStageStates" umbenannt
-> Achtung: In plfx-Dateien muss nun z.B. "TexGen" in "FixedFunctionsTextureStageStates" und nicht mehr "TextureStageStates" stehen



>> 07.04.2010
[CO]
- GL_ATI_pn_triangles ("PNTriangles" = "TruForm") durch GL_AMD_vertex_shader_tessellator ersetzt. ATI hat GL_ATI_pn_triangles mittlerweile aus den Treibern
  entfernt und NVIDIA hat das leider nie unterstützt. Für Tessellation wird auf ATI Karten seit der HD2000 GL_AMD_vertex_shader_tessellator verwendet, unter
  OpenGL 4 und DirectX 11 ist das dann sogar "Standardisiert" und NVIDIA hat dort ebenfalls Tessellation. Da ich leider keine entsprechende GPU habe, ist das
  für mich derzeit uninteressant - da aber GL_AMD_vertex_shader_tessellator geht kann ich damit erste Tessellation und Displacement Mapping gehversuche machen.
  Displacement Mapping läuft bei den *modernen Tessellation Verfahren* ja genauso ab so das man dann die Daten weiternutzen kann.
  GL_AMD_vertex_shader_tessellator wird über GLSL "angesteuert", da wir derzeit nur Cg als Shader Sprache unterstützen konnte ich das noch nicht ausprobieren.
  (ein Grund für mich mehr auch GLSL direkt zu unterstützen *g*)
  Im grunde wollte ich Hauptsächlich erstmal GL_ATI_pn_triangles draußen haben, war aber einfacher das direkt durch GL_AMD_vertex_shader_tessellator zu ersetzen
  als das erstmal ganz rauszunehmen, und später wieder einzubauen.



>> 05.04.2010
[CO]
- Dort wo angebracht wird nun PLMath::Vector2i & PLMath::Vector3i anstatt GetWidth(), GetHeight() und GetDepth() verwendet



>> 04.04.2010
[CO]
- "Renderer::Clear()": Die Farbe übergibt man nun als PLGraphics::Color4 und nicht mehr als PLGeneral::uint32. Zum einen war das Umständlich, aber noch
  viel wichtiger - nun ist es auch möglich z.B. einen Buffer mit der Farbe "2 2 2 2" zu löschen, etwas was man u.B. bei Fließkommazahlen Render Targets
  brauchen kann!
RendererOpenGL:
- Die Extension "GL_ARB_color_buffer_float" wird nun unterstützt, damit kann man beeinflussen ob wo Automatisch Zahlen auf den Bereich [0, 1] beschränkt werden



>> 02.04.2010
[CO]
RendererOpenGL:
- "RendererOpenGL::SetColor()" setzt nun sofort die Farbe mit "glColor4f()", damit passiert das nur noch an einer Stelle - aber viel wichtiger ist,
  das "glColor4f()" im Zusammenspiel mit Shadern nix bringt und bisher in "RendererOpenGL::DrawPrimitives()" dann Overhead drinnen war.
- "RendererOpenGL::m_bWorldMatrixChanged" entfernt. Die Lazy-Evaluation ist zwar für Fixed-Function Rendering ganz nett, aber bei Shadern ist
  "glLoadMatrixf()" witzlos sofern man die States nicht über GLSL ausliest, was ich aber nicht mache und nicht machen werde. Noch ein Overhead
  bei verwendung von Shadern weniger.
- "RendererOpenGL::SetRenderTarget()": Vertex & Fragment Shader werden nicht mehr zurückgesetzt, das ist wirklich ziemlich störend - hab alles
  durchgetestet, geht alles noch.



>> 01.04.2010
[CO]
- Neue Funktion "SurfaceTextureBuffer::TakeDepthBufferFromSurfaceTextureBuffer()", damit kann eine Render Texture einer anderen den Tiefen Buffer
  Stehlen... oder freundlicher ausgedrückt: Der Tiefenbuffer wird Freundschaftlich herumgereicht, wie die Fackel bei der Eröffnung der Olympischen
  Spiele. *g*
  Ich weis noch nicht ob das final so bleibt, aber momentan will ich hier noch keine zu großen Umbauten machen. "PLScene::SRPDeferred" Implementationen
  nutzen das bereits und es klappt zumindestens recht gut.



>> 29.03.2010
[CO]
- Material: DetailNormalMap, HorizonMap, DiffuseRampMap, SpecularRampMap und EdgeRampMap Strings entfernt da schon viel zu sepeziell



>> 27.03.2010
[CO]
- Parameters: Integer, Integer2, Integer3, Integer4 und float3x3 Typen hinzugefügt... alles Typen die ich nun schon mehrmals nutzen
  wollte und mich jedesmal etwas Ärgerte als die nicht Existierten und es dadurch Umständlicher wurde



>> 25.03.2010
[CO]
- Material: "AmbientOcclusionMap"-String hinzugefügt - da wir diesen Map-Typ mittlerweile unter dem Namen "LightMap" bereits für
  viele Projekte verwendet haben, und laut Jens auch superduper wichtig ist und bleibt, ist das wohl gerechtfertigt das zu einem
  "bekannten Standard Parameter" zu machen.



>> 20.03.2010
[CO]
- Neue Funktion "SurfaceTextureBuffer::SetMaxColorTargets()"
-> Das "Render To Texture"-System muss ich umbedingt mal komplett überarbeiten... seit ich das System Implementiere hatte, hat sich enorm
   viel getan und es ist viel neues hinzugekommen. Das Rendern in Texturen ist heute über FBO in OpenGL aber sehr schön und einfach zu realisieren
   und verdammt mächtig. Das aktuelle PLRenderer-Interface beschränkt die Möglichkeiten derzeit noch und es ist ein viel zu großer interner Overhead
   vorhanden. Zukünftig muss FBO und Render Texturen getrennt werden, denn ein FBO kann man für sehr viele Dinge direkt so wiederverwenden und
   braucht nicht jedesmal wenn man in eine Texture Rendern will dazu ein neues FBO. Anhand des Deferred Scene Renderers kann man schön sehen
   wie das Render To Texture heute normalerweise eingesetzt wird.
- "RendererOpenGL::GetOpenGLFormat()": Ich bin hier gerade wieder über etwas gestolpert das mir bei meiner Bachelorarbeit, wo ich u.a. kräftig mit
  OpenGL 3.2 herumspielte, aufgefallen ist. Will ich in Texturen Rendern die nur eine Komponente haben, muss man bei z.B. glTexImage2D
  GL_RED als Format angeben und nicht GL_LUMINANCE oder GL_INTENSITY. Alles andere geht nicht. Ich hab noch irgends wirklich Literatur gefunden die dieses
  Verhalten erklärt... na hoffentlich gehts so auch auf NVIDIA Karten. (zumindestens auf dem FH System mit NVIDIA Karte ging das damals in meiner Bachelorarbeit)



>> 17.03.2010
[CO]
- RendererOpenGL: Multi-Render-Targets Support läuft, in "FrameBufferObject::Finish()" fehlte nur ein "glDrawBuffer(GL_NONE);". Man bin
  ich froh das dies endlich läuft... vor einigen Jahren ging das ja gar nicht so richtig, Crashte etc. - das lag glaub ich aber an meiner
  damaligen Hardware. Im PLSample "PLSampleRTT" kann man testen ob alles läuft, da müssten nun einige Teapots mit Grundfarben sein.
  GL_COLOR_ATTACHMENT0_EXT - GL_COLOR_ATTACHMENT15_EXT sind definiert, daher werden nun in diesem Renderer Backend 16 Render Targets
  Unterstützt... meine GPU hat beispielsweise 8 davon.



>> 15.03.2010
[CO]
- "nBitsPerPel" in "nColorBits" umbenannt da es so an anderen Stellen geschrieben wird und besser lesbar ist
- "RenderWindow": Neue Funktionen: "GetDisplayMode()" und "SetDisplayMode()", damit ist das Interface ähnlich zu "RenderFrame"



>> 14.03.2010
[CO]
- An die Änderungen des Konfigurations-Systems angepasst
- Texture-Manager: Neue Funktionen: "GetTextureQuality()" und "SetTextureQuality()"
- Texture-Manager: Neue Funktionen: "AreTextureMipmapsAllowed()" und "SetTextureMipmapsAllowed()"
- Texture-Manager: Neue Funktionen: "IsTextureCompressionAllowed()" und "SetTextureCompressionAllowed()"
- "RenderFrame"-Konstruktor überarbeitet. Wenn ein Fenster sofort im Vollbild-Modus erzeugt werden soll, so muss man nun
  noch weitere Einstellungen über "DisplayMode" übergeben. (wurde bisher fest verdrahtet über eine globale Konfiguration ausgelesen)
  Das müsste alles etwas Flexibler machen.
- "RenderFrame": Neue Funktionen: "GetDisplayMode()" und "SetDisplayMode()"
- "RenderFrame": Neues Event: "EventDisplayMode"
- "Renderer::CreateFrame()" entfernt da nicht wirklich nötig
- "Config" nach "PLEngine" verschoben und in "RendererConfigGroup" umbenannt
- "DisplayMode" um "nZBufferBits", "nStencilBits", "nAccumBits" und "nAntiAliasing" erweitert, diese Informationen werden ebenfalls
  benötigt wenn ein Fenster zum Rendern eingerichtet werden soll (wurde bisher fest verdrahtet über eine globale Konfiguration ausgelesen)
- "RenderWindow"-Konstruktor überarbeitet
- "Renderer::GetConfigs()" entfernt da nicht mehr benötigt. Dort war bisher eh nur eine "DisplayMode"-Instanz enthalten, was noch aus den
  Anfangszeiten stammt... mittlerweile kanns ja mehrere Fenster geben, und im Grunde eigentlich Prinzipiell auch mehrere Vollbild-Fenster -
  darum macht eine DisplayMode Information pro Renderer keinen Sinn. Diese Information ist pro Render-Fenster. Andere Renderer Einstellmöglichkeiten
  gehen direkt über das Renderer-Interface.
- "RendererBackend::UpdateCurrentDisplayModeInformation()" entfernt da unnötig



>> 10.09.2009
[CO]
- "Texture::Load()" nutzt das neue "PLGraphics::ImageEffects::RemovePalette()" um Paletten aufzulösen da Texturen mit
  Paletten nicht unterstützt werden



>> 02.08.2009
[CO]
- "EventListener" entfernt -> ein Überbleibsel aus unserer "Listener Zeit". :D
  Stattdessen gibts nun in "Animation" ein neues "EventSpecialFrame"-Event.
  Die Funktionen "GetNumOfEventListeners()", "IsEventListener()", "AddEventListener()", "RemoveEventListener()" und
  "ClearEventListeners()" in den Ruhestand geschickt.



>> 07.07.2009
[CO]
PLRendererOpenGL:
- "RendererOpenGL::MakeScreenshot()": Da bei OpenGL der Bildmittelpunkt links unten ist, müssen wir das erhaltene
  Bild um die Y Achse Spiegeln (die alte Image Klasse machte das Automatisch)
- "RendererOpenGL::MakeScreenshot()": Falls gerade ein FBO verwendet wird, wird "SurfaceTextureBuffer:::Finish()"
  aufgerufen damit im Falle von Multisample der Inhalt aktualisiert wird... macht man das nicht, bekommt man nur
  einen schwarzen Inhalt zu sehen



>> 11.06.2009
[SB]
PLRendererOpenGL:
- Linux-Implementation an neue OpenGL-Extensions angepasst und einige Übertragungsfehler behoben.
- Das Projekt lässt sich nun auch wieder fehlerfrei unter Linux/gcc übersetzen. 



>> 04.06.2009
[CO]
PLRendererOpenGL:
- "TextureBuffer2D::RestoreDeviceData()": Wenn es eine Tiefentexture ist müssen auch entsprechende Einstellungen
  wie in "TextureBuffer2D::TextureBuffer2D()" gemacht werden da ansonnsten z.B. Shadow Maps nach einem Bildschirm
  Modus wechsel nicht mehr sichtbar sind.



>> 31.05.2009
[CO]
PLRendererOpenGL:
- "GL_ARB_multisample" OpenGL Extension wird nun unterstützt für Anti-Aliasing
- "GL_EXT_framebuffer_multisample" & "GL_EXT_framebuffer_blit" OpenGL Extensions werden nun unterstützt für
  Anti-Aliasing während in Texturen gerendert wird
- "FrameBufferObject" & "SurfaceWindow" um Multisample Support erweitert
- In der Renderer-Config (z.B. "PLRendererOpenGL.cfg") gibts die neue Option "AntiAliasing" für Anti-Aliasing.
  Standardmäßig ist das 0, also aus, da das natürlich etwas an Leistung kostet. (sieht aber schick aus :)
  Typische Werte sind: 2, 4, 8...
- "SurfaceTextureBuffer": Neues Flag "NoAntiAliasing": Damit lässt sich Anti-Aliasing unterdrücken - das ist z.B.
  beim Shadow Map rendern nützlich da der Qualitätsunterschied hier praktisch nicht sichtbar ist... aber der Leistungs
  unterschied schon!



>> 29.05.2009
[CO]
- "Texture::Load()": Ich entschloss mich dazu CubeMaps über 'plt'-Dateien und dann entsprechende Dateinamen für die
  anderen CubeMap Seiten komplett herauszunehmen. Das ist einfach zu kompliziert und auch fehleranfällig da sehr
  schnell dann mal CubeMap Seiten nicht den Anforderungen entsprechen. Das zusammenfummeln der CubeMap über die
  'plt'-Datei und Dateinamen war auch nicht sonderlich Benutzerfreundlich. CubeMaps kann man wirklich sehr schön über
  das 'dds'-Dateiformat einladen und es gibt auch sehr einfach zu bedienende Tools wie z.B.
  http://ati.amd.com/developer/cubemapgen/index.html um "mal schnell" eine dds CubeMap zu erzeugen. Mir viel kein
  einziger Grund ein der dafür sprach das noch drinnen zu lassen.
- "Renderer::CreateTextureBufferCube()" bekommt nun nur noch ein Image-Objekt und kein Feld aus Image-Objekten
  mehr. Damit kann man CubeMaps dem Renderer also NUR noch über ein Image-Objekt das aus verschiedenen Teilen
  besteht übergeben - aber das ist dank der neuen Image-Klasse ja absolut kein Problem mehr. :D



>> 28.05.2009
[CO]
- "PLRendererOpenGL": "TextureBufferRectangle::TextureBufferRectangle()": Komprimierte Rectangle Texturen scheinen
  mittlerweile auch ganz wunderbar zu funktionieren



>> 26.05.2009
[CO]
- "Texture::Load()": "gamma correction" rausgenommen da hier nicht wirklich umbedingt nötig



>> 21.05.2009
[CO]
- "Renderer::DrawBitmap()" schaltet nicht mehr automatisch in einen "2D Modus" da dies einfach nur unpraktisch ist
  und es nicht mehr möglich ist z.B. eine Bitmap "frei" im 3D Raum zu zeichnen. "Renderer::DrawPoint()" schalteten
  ebenfalls nicht automatisch in einen "2D Modus" und von der Seite aus war das zusäzlich sogar noch inkonsequent.
  Durch diese kleine Änderung/Vereinfachung ist "Renderer::DrawBitmap()" nun vielseitiger einsetzbar.



>> 20.05.2009
[CO]
- "Font": "Draw()"-Funktion ohne Positionsangabe überarbeitet und die hinteren Parameter entfernt. Diese Funktion
  zeichnet nun "nur" noch Text ohne noch zig Render States zu verändern. Dadurch wird der Text z.B. nicht automatisch
  auf "2D" ausgerichtet - was immer mal wieder gewünscht ist um den "flachen" Text frei in einer 3D Szene plazieren
  zu können.



>> 19.05.2009
[CO]
- "PLRendererOpenGL": "Font2D" & "Font3D": "Draw()": Die aktuelle OpenGL-Farbe braucht nicht weggespeichert und
  wiederhergestellt werden



>> 10.05.2009
[CO]
- "OpenGLRenderContext" etwas aufgeräumt



>> 06.05.2009
[CO]
- "Animation": "EventFrameChange"-Event hinzugefügt damit man von außen mitbekommen kann wenn sich etwas änderte
  und dann z.B. ein Mesh aktualisieren kann... oder auch nur ein Flag das notiert das ein Mesh Update nötig ist :)
- "AnimationManager"-Klasse hinzugefügt
- "AnimationManager" besitzt nun ein "EventAnimationFrameChange"-Event das eine "Sammelstelle" für "EventFrameChange"-
  Events darstellt, das vereinfacht die Arbeit wenn man auf alle "EventFrameChange" hören will
- "Surface": Um "EventPaintBegin", "EventPaint" und "EventPaintEnd" Events erweitert damit man z.B. Texturen
  aktualisieren kann bevor das Zeichen beginnt



>> 29.04.2009
[CO]
- "RendererContext" hat nun ein "EventUpdate"-Event das in der neuen "Update()"-Funktion ausgelöst wird
- "TextureHandler" hat keine "Update()"-Funktion mehr. "TextureHandler::AnimationState()" hängt sich
  in das neue "EventUpdate"-Event von "RendererContext" ein. Dadurch folgen nun einige vereinfachungen
  die dazu führen das viele "Update"-Funktionen wegfallen und dadurch pro Frame weniger Arbeit direkt für
  die Tonne anfällt. :D
- "ShaderManager" hat keine "Update()"-Funktion mehr, die war eh praktisch leer
- "TextureManager" hat keine "Update()"-Funktion mehr, die war eh praktisch leer
- "Material" und "MaterialHandler" haben keine "Update()"-Funktionen mehr, dienten nur zum "TextureHandler"-Update
- "Mesh::UpdateMaterials()" entfernt
- "Effect::Update()" macht kein "TextureHandler"-Update mehr, "derzeit" noch drinnen wegen "m_fTimer"
- ... in auf PLRenderer aufbauenden Projekten konnten nun ebenfalls einige "Update"-Funktionen über den Jordan
  gehen. Wie man sehen kann zog das "Texture Animation"-Feature bis jetzt einen heftigen Rattenschwanz quer
  durch alle Projekte "nur" damit "falls eventuell vorhanden" Texture Animationen aktualsiert wurden. Dort gabs
  dann auch noch "Update"-Konflikte so das z.B. eine Animation pro Frame mehrmals an verschiedenen Stellen
  aktualisiert wurde und dadurch die Animation einmal schneller, einmal langsamer abspielte. Das war mir schon
  sehr lange ein Dort im Auge - und über die Events lies sich das nun denke ich recht einfach und ordentlich lösen.
- Bugfix: "RendererOpenGL::SetLight()": Directionale Lichter setzen war nicht ok, den Richtungsvektor setzt man
  lustigerweise über die "Position"



>> 26.04.2009
[CO]
- Hoffnunglos veralteten "Selection Buffer" vom Renderer entfernt. Folgende Funktionen gibt es also im
  "Renderer"-Interface nicht mehr: "GetSelectionBuffer()", "SetSelectionBuffer()", "GetRenderMode()",
  "SetRenderMode()", "InitNames()", "PushName()", "PopName()" und "LoadName()"
  In den anderen Projekten musste ledeglich  "PLSampleSceneNodes::SNSampleSelection" angepasst werden,
  ansonnsten wurde das nirgends genutzt da eher umständlich und eingeschränkt in der Nutzung.
  "Selection Buffer" gab es nur "früher" in OpenGL, in DirectX gab es soetwas nie - und ab OpenGL
  3.1 wurde dieses Feature entfernt. So wie es aussieht war das schon in den alten OpenGL Versionen immer
  nur eine "halbe" Sache und wurde in der CPU ausgeführt. Sobald VBO dazu kam ging es schon nicht mehr
  richtig und die Performance lag im einstelligen FPS Bereich... auf meinem aktuellen Notebook scheint es
  sogar überhaupt nicht mehr zu funktionieren. Höchste Zeit also uns komplett davon zu trennen - vorallem
  da man es eh nie wirklich nutzen konnte da es soetwas von überhaupt nicht in das PixelLight Scene Renderer
  Konzept passt. :D
- "RenderApplication" von PLRenderer nach PLEngine verschoben
- PLRendererOpenGL: Upsala, "GL_INDEX_ARRAY"/"glIndexPointer()" hat nix mit "Vertex Indices" zu tun sondern
  dies ist für "Color Index Arrays"
- "GetOcclusionQuery()" aus dem "Renderer"-Interface entfernt da dies nicht wirklich nötig ist und wohl schnell
  Probleme macht wenn von mehreren Stellen dieser Occlusion Query gleichzeitig genutzt werden würde. Es musste
  nichts weiter angepasst werden da diese Funktion nirgends verwendet wurde. *überbleibsel aus vergangenen Zeiten*



>> 22.04.2009
[CO]
- "ShaderLoaderCg::Load()": Implementation Optimiert: Falls die übergebene Datei bereits im Speicher liegt
  und am Ende eine "\0" ist, so wird die Datei nicht nochmals "Zwischengespeichert" sondern das bereits
  im Speicher liegende kann direkt so genutzt werden.



>> 15.04.2009
[CO]
- "ShaderManager": "Load()"-Funktion hinzugefügt der man direkt ein "File"-Objekt übergeben kann
- "ShaderManager" hat keinen "Default Shader" mehr da dieser nicht wirklich einen Sinn hat (Shader
  sind einfach speziell und lassen sich nicht einfach produktiv überall drauf klatschen wie z.B.
  das bei Texturen möglich ist) und nur dazu führt das ein total nutzloser Shader immer am Anfang
  eingeladen wird was dann dazu führt das "Cg" Initialisiert wird auch wenn man in einem Projekt
  überhaupt keine Shader nutzt.
- "EffectManager": "Default.plfx" wird nicht mehr geladen sondern dynamisch erzeugt damit man nicht
  immer gezwungen ist "Standard.zip" auszuliefern



>> 11.04.2009
[SB]
- PLRendererOpenGL: Habe versucht, die Änderungen mit dem OpenGLRendererContext auf Linux anzupassen. Leider
  sind mir so so beim drüberschauen, ohne die Änderungen selbst gemacht zu haben, nicht wirklich alle
  Zusammenhänge klar, weshalb dieses Unterfangen nicht gerade leicht ist. Deshalb wäre es wirklich gut,
  wenn gerade bei solchen Strukturänderungen auch *immer* die Linux-Variante mit angepasst wird, damit
  das nicht später immer schwieriger wird, das ganze noch anzupassen. Ich weiss, dass das etwas blöd ist,
  wenn man selbst nicht unter Linux arbeitet und dazu der Linux-Port noch gar nicht funktionsfähig ist. Aber
  für mich wird es auch immer schwieriger, das System unter Linux zu warten, wenn ich ständig 
  hinterherarbeiten muss, weil nach ein paar Wochen grundsätzlich irgend eine Änderung dazu geführt hat,
  dass das Projekt sich unter Linux nicht einmal mehr übersetzen lässt. Also bitte in Zukunft mal mehr
  darauf achten, insbesondere bei solchen Änderungen, wo dann sogar eine wgl-Funktion aus dem #ifdef
  herausgezogen wurde. Dann kann ich zumindest weiter unter Linux arbeiten und das System bleibt einiger
  Massen aktuell auch unter Linux. Und dann kann ich in der nächsten Zeit endlich den Linux-Port komplett
  neu aufsetzen, dann wird das ganze auch sinnvoller zu warten, wenn es auch endlich mal funktioniert :-)
  Aber bis dahin wäre es nett, wenn ich zumindest nicht ständig damit kämpfen müsste, dass es sich mal
  wieder nicht einmal mehr übersetzen lässt.



>> 08.04.2009
[CO]
- "RendererBackend::GetOcclusionQuery()" erzeugt die interne Instanz erst wenn diese zum ersten mal benötigt wird



>> 05.04.2009
[CO]
- "RendererOpenGL::Font2D" & "RendererOpenGL::Font3D": Die Fonts werden intern erst dann erzeugt wenn diese zum
  ersten mal benötigt werden (falls dies überhaupt mal der Fall ist... :)



>> 01.04.2009
[CO]
- "OpenGLRenderContext" hinzugefügt damit diese Dinge zukünfig überschaubar beisammen sind
- "RendererOpenGL::GetRenderingContext()" in "RendererOpenGL::GetOpenGLRenderContext()" umbenannt, gibt nun
  "OpenGLRenderContext" zurück
- "RendererOpenGL::BackupDeviceObjects()" & "RendererOpenGL::RestoreDeviceObjects()": Der OpenGL Rendering Context
  muss hier NICHT zerstört und wieder erzeugt werden
- "RendererOpenGL::CreateContext()" & "RendererOpenGL::DeleteContext()" entfernt, der OpenGL Render Context
  wird nun direkt in "RendererOpenGL::Init()" & "RendererOpenGL::DeInit()" erzeugt und zerstört
- Die OpenGL-Extensions werden nun im "OpenGLRenderContext"-Konstruktor initialisiert und nicht mehr in
  "SurfaceWindow::Init()" bzw. "SurfaceLinux::Init()"



>> 08.03.2009
[CO]
- "Material::Load()"-Implementation überarbeitet. Wenn man im Material eine "einfache Texture" einladen wollte MUSSTE diese immer eine
  bekannte Dateiendung haben oder das Laden schlug fehlt. Da man aber durchaus auch z.B. Dynamische Texturen haben kann die irgendeinen beliebigen
  Namen mit oder ohne "bekannte Dateiendung" haben sollte man hier keinen Namenscheck machen sondern einfach den Namen der zu verwendenden
  Texture "durchreichen".
- "Texture::Load()": Beim skalieren aufgrund von veringerter Qualität wurden Warnungen rausgeschrieben das die Texture größe nicht passt...
  das sollte natürlich nicht sein und die "NUR die Original" größe sollte auf passende Dimensionen hin geprüft werden und nicht die errechnete
  verkleinerte Dimension!
- "Texture::Load()": Beim skalieren wird nun auch noch ins Log geschrieben wie groß die Texture ursprünglich war



>> 07.02.2009
[CO]
- 'RendererBackend::UpdateCurrentDisplayModeInformation()': Wird die 'gegebene' Auflösung nicht gefunden, so wird nun zuerst versucht eine
  Auflösung zu finden 'die nah dran ist' - erst wenn auch das fehlschlägt wird die erstbeste Auflösung genommen
- 'Parameters': 'GetParameterTexture()' & 'SetParameterTexture()' hinzugefügt so das man nicht zwanghaft direkt über 'TextureBuffer' gehen muss.
  ('Texture' kann als eine art 'TextureBuffer Handler' angesehen werden)
- 'Parameters': 'GetParameterString()' in 'GetParameterString()' und 'SetParameterString()' in 'SetParameterString()' umbenannt damit konsistent
  zu den anderen Funktionen



>> 06.02.2009
[CO]
- 'RendererOpenGL::Init()': 'PLRendererOpenGL.cfg' wurde zwar geladen aber intern gibts derzeit noch ein
  'm_sConfigs.sDisplayMode' das nicht auf die gelesenen Werte gesetzt wurde



>> 05.02.2009
[SB]
- Animation: Wenn man eine Animation z.B. von Frame 0 - 50 abspielen läßt, sprang diese am Ende wieder auf
  Frame 0 zurück, da bei Stop() automatisch Reset() aufgerufen wurde. Habe dies nun geändert und in Stop()
  nur noch das aktuelle Abspielen beendet, nicht aber die gesamte Animation zurückgesetzt. Bitte mal in den
  aktuellen Projekten prüfen, ob irgendwo das alte Verhalten vorausgesetzt wurde.



>> 04.02.2009
[SB]
- Projekt auf Basis von RendererNull begonnen. Dies soll ein OpenGL ES 2.0 kompatibler Renderer für PixelLight werden.
  Zunächst implementieren wir dies anhand des OpenGL ES Emulator SDKs und dessen Samples.
- SurfaceWindow implementiert. Es kann erfolgreich ein Fenster mit diesem Renderer geöffnet und ein Kontext erzeugt werden.
  Testweise rendere ich in Present() ein simples Dreieck (übernommen aus dem Sample), damit man schonmal was sieht :-)  



>> 04.02.2009
[CO]
- 'RendererOpenGL' & 'RendererD3D9': 'QueryDisplayModes()' filtert nicht mehr künstlich ohne das man dies von außen
  beeinflussen könnte
- 'Renderer': Neue Funktion: 'GetDisplayModes()': Kann eine Liste 'sicherer' Bildschirm-Modi zurückgeben, man sollte
  wenn möglich immer diese Funktion nutzen um auf der halbwechs sicheren Seite zu sein
- 'RendererBackend::UpdateCurrentDisplayModeInformation()' nutzt nun als Fallback die erste gefundene 'sichere'
  Bildschirmauflösung
- 'RendererBackend::UpdateCurrentDisplayModeInformation()': Hier MUSS man derzeit auch noch die Einstellungen in der
  Konfiguration aktualisieren



>> 01.02.2009
[CO]
- 'Font': Derzeit gibts hier ein kleines Problem mit der 'virtuellen Bildschirmgröße'... 'Renderer::Begin2DMode()' hat als Default eine
  'normalisierte Bildschirmgröße', sprich, Breite und Höhe sind immer 1... das beißt sich allerdings wenn man Font größe in Pixel angeben will.
  Wir müssen uns das hier nochmal ganz genau anschaun und uns überlegen was wir hier machen wollen. Das einfachste wäre wenn man keine
  'normalisierte Bildschirmgröße' unterstützen würde, allerdings hätte das den Nachteil das man dann immer wissen muss was gerade die
  Bildschirmgröße (virtuell oder nicht) ist. Damit das nach außen hin erstmal wie gehabt funktioniert baute ich einen Hack ein.



>> 31.01.2009
[CO]
- 'ParameterManager::SetParameterTextureBuffer()': Wenn die interne Texture nur durch einen Texture Handler genutzt wird ist es relativ sicher
  einfach der Texture einen neuen Texture Buffer zu geben - dadurch werden nicht mehr so oft dynamisch Texturen erzeugt und wieder zerstört.
  (viel mir bei 'SCMirror' auf)



>> 30.01.2009
[CO]
- 'Font': Die 'Draw()'-Funktionen nutzen nun standardmäßig die 'virtuelle Bildschirmgröße' anstatt die gerade im Viewport eingestellte größe...
  dadurch passt sich die Schrift der Fensterskalierung "automatisch" an. Will man das 'alte' Verhalten, also Schriftgröße unabhängig von Viewport
  größe, so kann man dies über einen optionalen Parameter einstellen.
  Gleiche änderung bei 'GetWidthRelative()' und 'GetHeightRelative()'.



>> 29.01.2009
[CO]
- 'RenderApplication::Update()': Auch bei gesetzten 'bForceUpdate' MUSS natürlich 'Timing::GetInstance()->Update()'
  aufgerufen werden



>> 25.01.2009
[CO]
- 'Renderer': 'GetVendor()' hinzugefügt damit man z.B. rausfinden kann ob man gerade eine ATI oder NVIDIA GPU vor sich hat



>> 21.01.2009
[CO]
- 'RenderStates': 'DstBlendFunc' hat nun als Default-Einstellung 'InvSrcAlpha' statt 'One' da dies gängiger und viel nützlicher ist und
  wir selbst auch 'meistens' nutzen
- 'Animation': 'GetStartFrame()' & 'GetEndFrame()' & 'GetNumOfFrames()' hinzugefügt



>> 20.01.2009
[CO]
- 'ShaderManager::Load()': Diese Funktion unterscheidet nun zwischen 'Dateiname' und 'Name'... denn aus einer
  Shader Datei können über Defines eine vielzahl spezieller Shader erzeugt werden.



>> 10.01.2009
[CO]
- 'RenderFrame': Neben 'Alt-Return' kann man nun auch 'AltGr-Return' zum Vollbildmodus wechseln nutzen, das scheint so gängig zu sein
  (und ist auch viel 'bequemer' da man das auf normalen Tastaturen mit nur einer Hand machen kann *g*)



>> 09.01.2009
[CO]
- 'RenderApplication': 'IsFullscreen()' & 'SetFullscreen()' & 'OnFullscreenMode()' hinzugefügt
- 'RenderFrame': 'SetFullscreenMode()' in 'SetFullscreen()' umbenannt damit konsistent zu den anderen ähnlichen
  Funktions Namen
- 'SurfaceWindow::Init()': Der OS Mauszeiger wird nicht mehr sichtbar/unsichtbar gemacht - auch im Vollbild
  Modus kann der OS Mauszeiger scheinbar korrekt angezeigt werden... auf jedenfall auf den bis jetzt getesteten
  Systemen - meine mich erinnern zu können das dies vor Jahren mal Probleme machte - so wie es jetzt ist ist's
  jedenfalls viel besser.



>> 03.01.2009
[CO]
- 'Parameters' um 'String'-Typ erweitert den man für alles nutzen kann das nicht so recht in die anderen Typen passen mag. Nun hat
  man auch in 'ParameterManager::SetParameterString()' keine Probleme mehr 'automatisch' einen entsprechenden Parameter hinzuzufügen.
 (kein Sonderfall mehr :) Dummerweise muss man nun 'PLGeneral::String' in dieser + davon abgeleiteten Klassen schreiben da sonst der
 Compiler nicht weis was man nun meint... aber ich hätte es noch weniger schön gefunden den 'String'-Typ irgendwie anderst zu nennen.



>> 01.01.2009
[CO]
- 'SurfacePainter' etwas umgebaut. Diese Objekte werden nun statt über 'Surface::CreatePainter()' mit 'Renderer::CreateSurfacePainter()'
  erzeugt und wie gehabt über 'Surface::SetPainter()' gesetzt. 'SurfacePainter' sind nur noch von 'Renderer' zu 100% abhängig, das aktuelle
  'Surface' wird bei den 'Paint'-Funktionen als Parameter übergeben. So kann man nun sehr einfach einen SurfacePainter gleichzeitig für
  verschiedene Surfaces nutzen.



>> 31.12.2008
[CO]
- 'RenderApplication::Update()': Übernimmt nun den 'Timing' Test so das dies nicht in verschiedenen 'OnUpdate()' Implementationen immer
  wieder aufs neue implementiert werden muss. Über 'Update(true)' kann man ein Update erzwingen auch wenn es ein FPS Limit gibt und es
  eigentlich noch gar nicht Zeit für ein Update ist.



>> 03.12.2008
[SB]
- RenderApplication: Neue Methode Update(), die intern OnUpdate() aufruft. In der Mainloop wird nun Update() statt OnUpdate() aufgerufen,
  ausserdem wurde das Abfragen der Gui-Nachrichten aus OnUpdate() entfernt und in die Gui-Mainloop verschoben, damit dies auch wirklich nur
  bei Run() passiert, nicht aber bei eingebetteten Aufrufen. Die Methode Update() muss von aussen aufgerufen werden, wenn nicht per Run()
  eine einige Mainloop ausgeführt wird, sondern die Applikation beispielsweise irgendwo eingebettet wurde.
- RenderApplication: Es wurde bisher nur RenderFrame als Fenster akzeptiert, nicht aber RenderWindow. Es muss aber immer beides beachtet werden,
  damit nicht nur eigenständige Fenster sondern auch eingebettete Fenster mit 3D-Kontext benutzt werden können. Also bitte das RenderWindow
  in Zukunft nicht weiter so vernachlässigen, wie bisher ;-)
- RenderApplication: In OnCreateMainWindow() wird jetzt überprüft, ob die Applikation eingebettet werden soll, oder nicht, und je
  nachdem wird entweder ein RenderWindow oder ein RenderFrame instanziiert. Das bekommt man vielleicht noch allgemeiner hin, aber
  erstmal sollte es so in Ordnung sein.



>> 12.10.2008
[CO]
- RenderApplication: Wie besprochen geben 'OnCreateRendererContext()' & 'OnCreatePainter()' nix mehr zurück sondern
  setzen 'direkt' in diesen Funktionen



>> 06.10.2008
[CO]
- RendererApplication von PLEngine nach PLRenderer verschoben
- SPDefault: von PLEngine in PLRenderer verschoben



>> 27.09.2008
[CO]
PLRendererOpenGL:
- Nachdem ich gerade ein Grafikkarten-Treiber Update gemacht habe (Catalyst 8.9) Crashten auf einmal viele PL-Szenen....
  Konnte das Problem auf Tiefen Texturen zurückführen:
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
  Nach dem erzeugen der Texture ausführen und schon war der Treiber-Crash weg...



>> 12.09.2008
[CO]
PLRendererOpenGL:
- RendererOpenGL::SetupCapabilities(): Merkte gerade das auf meinem benntec-Computer 'nMaxTextureUnits' auf 4 stand, das aber hätte
  32 sein müssen. Schaute mir das hier also mal an... so wie es aussieht gabs bei GL_ARB_multitexture eine Änderung bzw. wie man
  mit 'Texture Units' umgeht. "http://developer.nvidia.com/object/General_FAQ.html" hier steht auch etwas darüber. Machte erstmal
  ein Kommentar in den Code - das muss ich mir nun genauer anschaun und überlegen wie ich das korrekt Umbauen kann.
  Wird wohl Zeit das PLRenderer Refactoring langsam mal in Angriff zu nehmen...



>> 04.09.2008
[CO]
- Renderer::GetDescription() in Renderer::GetAPI() umbenannt das z.B. 'OpenGL' oder 'Direct3D' zurück gibt... das bringt mehr
  als eine 'Beschreibung' da man dann einfach testen kann welche API gerade genutzt wird. Desweiteren kann man über diese Funktion
  auf Wunsch auch die 'Version' bekommen - wobei diese API abhängig ist.
PLRendererOpenGL:
- VertexBuffer::Allocate: Wenn kein VBO verfügbar ist wird die Software-Implementation genutzt
- IndexBuffer::Allocate: Wenn kein VBO verfügbar ist wird die Software-Implementation genutzt
- VertexBuffer::MakeCurrent(): Das 'return' beim setzen der Vertex Daten war definitiv KEINE gute Idee von mir... denn sobald
  'GL_ARB_vertex_program' nicht vorhanden war sah man dann gar nix mehr. Jetzt sieht man selbst dann bei 'Basic.sr'
  noch etwas wenn man seinen Grafikkarten-Treiber Deinstalliert - hatte nämlich heute hier den Fall das jemand keinen
  OpenGL Treiber Installiert hatte und der sich dann wunderte das nix ging...



>> 27.08.2008
[CO]
- 'Window' zu 'RenderWindow' und 'Frame' zu 'RenderFrame' gemacht damit man ohne Namespace keine Namenskonflikte mit den
  gleichnamigen PLGui Klassen bekommt was schon ziemlich störend war
- 'RenderWindow' und 'RenderFrame' ans RTTI angestöppelt damit man für 'sicheres Casting' 'IsInstanceOf()' nutzen kann



>> 24.08.2008
[CO]
- Wo sinnvoll 'Win32' zu 'Windows' gemacht da für 32 Bit als auch für 64 Bit



>> 20.08.2008
[SB]
- Font2D: Texte können nun auch transparent gerendert werden, zuvor wurde der Alpha-Wert der Farbe ignoriert.



>> 17.08.2008
[CO]
- Frame: Registriert 'Hot Key' für 'Alt-Return' zum Vollbild-Modus wechseln was eine recht gängige Kombination ist.
  Durch die kleine PLGui Erweiterung von heute muss man endlich nicht mehr 'Strg-Alt-Return' drücken (sonst konnte man das nicht
  abfragen) was umständlich war und auf das man auch nicht wirklich von selbst kam.
- Frame: 'EventFullscreenMode'-Event hinzugefügt das ausgelöst wird nachdem sich der Vollbild-Modus verändert hat



>> 08.08.2008
[CO]
- Wie von Stefan gewünscht erzeugt ParameterManager nun automatisch 'fehlende' Parameter wenn man z.B. "SetParameter3f()" nutzt.
  "SetParameterString()" ist jedoch nicht in der lage automatisch Parameter zu generieren, denn diese Funktion bekommt nur einen
  String, zum Parameter erzeugen muss aber bekannt sein von welchem Typ dieser Parameter ist. Einen 'String' Typ gibts nicht, der
  würde nicht wirklich sinn hier machen + wenn man floats als String übergibt bekommt man sicherlich nicht das als Ergebniss was
  man wollte, z.B. einen Float3-Parameter. Man könnte aufwändig Parsen und 'raten' was der User wollte, aber das wäre denke ich
  nicht gut da fehleranfällig. Man könnte irgendwie versuchen das gesammte 'Parameter System' noch universeller und flexibler zu
  machen, sehe aber momentan keinen Anlass dafür wichitgere Arbeiten fallen zu lassen um mich wieder was neuem zuzuwenden. :D



>> 06.08.2008
[CO]
PLRendererOpenGL:
- Mipmaps müssen bis 1x1 runter definitert werden. Übergibt man die Mipmaps direkt über ein 'Image', so wurde bis jetzt 'nur' im
  Log gewarnt wenn die kleinste Mipmap nicht 1x1 ist. Es ergab sich nun allerdings 'wieder einmal' (!) die Situation das wir
  'dds'-Bilder bekamen die zwar Mipmaps hatten, aber z.B. nur bis 2x2. Das Resultat verdutzte mich diese mal etwas, denn 'per'
  Zufall 'verschwanden' immer mal wieder, je nach Blickwinkel etc. (= 'scheinbar Zufällig' *g*) Lightmaps die genutzt wurden.
  Zuerst konnte ich nicht sofort das 'Problem' auf die fehlenden Mipmaps zurückführen, tests zeigten das "scheinbar" die Texture
  Koordinaten nach 'links unten sprangen'. (färbte hierzu eine Test-Texture entsprechend)
  Nachdem ich dann auf die Idee kam erstmal alle "Mipmaps müssen bis 1x1 definiert werden"-Warnungen im Log zu beseitigen stellte
  ich fest das das 'Problem' verschwunden war. Wie man anhand dieser Situation sehen kann, können die Auswirkungen ziemlich
  happig werden und man erkennt eventuell nicht 'sofort' was das Problem ist. Ich entschloss mich daher die fehlenden Mipmaps
  nun automatisch zu erzeugen - einfach über einen 'weißen'-Buffer. Die Textur aufwändig runterzuskalieren war mir offen gesagt
  zu dämlich, denn die Log Warnung sagt hier 'Du hast hier noch was zu tun!' und ich will offen gesagt 'schlamperei' nicht
  unterstützen... vorallem da dies sich auch etwas auf die Ladezeit auswirkt wenn man Daten 'selbst erzeugen muss' die 'eigentlich'
  hätten mitgeliefert 'werden müssen'. Wenn nur die 1x1 Mipmap fehlt, fällt das mit 'weis' nicht wirklich auf - sieht dann höchstens
  wie ein kleiner Pixel-Fehler aus, aber dabei bleibts dann wenigstens und löst keine Lawine der merkwürdigsten Grafig-Bugs aus.



>> 22.07.2008
[SB]
- Font, Font2D, Font3D: Die Methoden, um die Größe eines Strings auf dem Bildschirm zu messen, geben anscheinend die tatsächliche
Größe auf dem Bildschirm, also abhängig von der gewählten Auflösung, zurück. Das mag in vielen Fällen die gewünschte Information
sein, ist jedoch unbrauchbar, wenn es z.B. um Größen von Strings innerhalb der Ingame-GUI geht. Hier hat man eine virtuelle
Auflösung (z.B. 1024x768), daher muß das Ergebnis hier auch auf diese virtuelle Größe bezogen werden. Das kann jedoch hier nicht
mehr vernünftig gemacht werden, weil man dazu z.B. die Größe des Fensters wissen müßte, in dem die Scene gerendert wird in der
die Ingame-GUI angezeigt wird, da die Schrift entsprechend der Fenstergröße ja auch noch skaliert wird ... :-) An diese
Informationen kommt man aber nicht mehr heran und das wäre auch nicht gut und nicht wünschenswert, da ein Element in z.B. der
Ingame-Gui nicht mehr wissen muss, auf was für einem Surface mit was für einer Größe etc. es gerendert wird. Daher habe ich
zusätzliche Methoden hinzugefügt, um die Schriftgröße auf einer virtuellen Skala von 0.0 - 1.0 zu messen. Die Font-Klasse
von GuiPL nutzt dann diese Methode, und rechnet das Ergebnis wiederum auf die virtuelle Gui-Größe um. Damit dürften nun die
Größen-Messungen von Texten auch innerhalb der Ingame-Gui korrekt funktionieren, was bisher immer fehlerhaft war.



>> 17.07.2008
[CO]
- TextureAniLoaderPL & MaterialLoaderPL & EffectLoaderPL & Texture (plt): Um Format Versions Informationen erweitert



>> 11.07.2008
[CO]
- Texture::Load(): Tests auf 'm_nCompressionHint' etc. sollten erst 'nach' dem eventuellen Skalieren der Texture
  gemacht werden... denn dadurch kann es sein das die vorhandene Kompression verworfen werden muss.



>> 24.05.2008
[CO]
PLRendererOpenGL:
- Texturen: 'm_nSamplerState' wurde nicht initialisiert + in RendererOpenGL::RestoreDeviceStates() sollten diese Werte zurückgesetzt werden.
  Da OpenGL diese Einstellungen 'pro Texture' und nicht wie D3D (und bei uns im Renderer Interface) 'pro Stage' eingestellt ist dies
  eine Performance Optimierung da wir vergleichen können ob es nötig ist einen OpenGL API Call (die man so gering wie möglich halten sollte) zu
  machen oder ob die aktuellen Einstellungen noch immer passen.
- TextureBuffer1D::TextureBuffer1D(): Und nochmal ein Hack der üblen Sorte: Das hochladen komprimierter 1D Texturen scheint zu klappen, aber wenn
  ich dann die Daten wieder von der GPU hole und wieder hochlade (nach Bildschirm wechsel) habe ich irgendwie Schrott in den Händen. Wollte zuerst
  das wie in TextureBufferRectangle::BackupDeviceData() machen, also erst hier dann auch nicht Komprimiert schalten, aber sogar das funktionierte
  nicht richtig. Darum habe ich hier nun erstmal intern Texture Kompression für 1D Texturen komplett deaktiviert bis bekannt ist warum da was nicht
  geht und wie man es beheben kann. (Treiber Bug oder wieder etwas das mir einfach nur unbekannt ist?)
  Nicht schön, aber noch weniger schön ist es in z.B. der 'Cartoon'-Demo Szene nach einem Bildschirm Modus wechsel kaputte Grafik zu haben...



>> 23.05.2008
[CO]
PLRendererOpenGL:
- TextureBufferRectangle::BackupDeviceData(): Baute hier einen doofen Hack ein weil ich momentan keine Ahnung habe was hier los ist und es so herum
  immer noch besser ist als... Hat man eine 'RGB Rectangle Texture' klappt irgendwie das herunterladen der Daten von der GPU nicht so richtig, man
  bekommt die Daten leicht verschoben und wenn man das paar mal macht hat man nur noch Schrott in der Texture. (im schlimmsten Fall kann es sogar
  zu einem Crash im Treiber kommen...) Ist bei meinen ATI und NVIDIA Systemen der Fall wie meine Tests zeigten... mit RGBA gehts, darum stelle ich
  dann hier auf RGBA um. Entweder haben beide Hersteller hier einen Treiber-Bug oder es gibt iiirrgendetwas das man noch beachten muss - aber nicht
  wirklich offensichtlich Dokumentiert wurde. (generell scheint mir RGB eher schlecht denn recht Supported zu sein und irgendwie eher RGBA bevorzugt
  wird, hat wohl was mit der 32 Bit Speicherausrichtung zu tun)



>> 17.05.2008
[CO]
PLRenderer:
- 'Get2DCoordinate() 'und 'Get3DCoordinate()' herausgenommen da dies API unabhängige Mathematische Funktionen sind bzw. 'zu sein haben'. In
  'PLMath::Vector3' finden sich dafür nun zwei neue Funktionen Namens 'To2DCoordinate()' und 'To3DCoordinate()' die genau diese Aufgabe übernehmen.
- 'Renderer::PickMatrix()' entfernt da 'PLMath::Matrix4x4::RestrictedProjection()' ausreichend ist
- 'Renderer::CreateSelectionPlanes()' entfernt da 'PLMath::PlaneSet::CreateSelectionPlanes()' ausreichend ist



>> 16.05.2008
[CO]
- Neue Klasse: PreviewWindow: Implementiert eine einfache Kamera-Steuerung, das ist recht nützlich und wird bereits an verschiedenen Stellen genutzt
- "EffectLoaderFX" Effect Loader in neues "PLDefaultFileFormats"-Projekt verschoben
PLRendererOpenGL:
- RendererOpenGL::InitWrappers(): 'PLRenderer::TextureBuffer::D16' etc. mappen nun auf 'GL_DEPTH_COMPONENT16' etc. statt alle auf 'GL_DEPTH_COMPONENT'
  da dies nun korrekt zu funktionierten scheint - früher ging das mal nicht richtig mit diesen Einstellungen, so herum ist es aber korrekt.



>> 14.05.2008
[CO]
- RendererBackend::Get2DCoordinate() Implementation vereinfacht



>> 12.05.2008
[CO]
PLRendererOpenGL:
- RendererOpenGL::Accum(): Da es warum auch immer bei mir zum Crash kommen 'konnte' (war z.B. in 'PLSampleInGameGui' der Fall) wenn ein 'glAccum'
  Befehl aufgerufen wird während man gerade in eine Texture Rendert habe ich das erstmal so gelöst das Accumulation Buffer NUR für nicht Texture
  Render Targets genutzt wird... auf dauer wird diese Funktionalität dann sowieso in ein 'Legacy'-Interface verschoben darum machte ich mir nun
  nicht die Mühe mich Stundenlang hinzusetzen und rauszubekommen warum das probleme machen kann.



>> 10.05.2008
[CO]
- Material::Load(): Wird nur eine einfache Texture als Material übergeben so wird nun kein 'Standard Effekt' mehr gesetzt da sich das in der
  Praxis als "sehr" ungeschickt und umständlich herausstellte. Am besten fährt man wirklich wenn man wo immer möglich nur 'DiffuseMap' etc.
  Material Parameter setzt und den Rest komplett einem Scene Renderer überlässt. "Effekte" sollte man nach möglichkeit nur gaaanz selten
  nutzen da diese natürlich nicht mit 'Uniform Lighting and Shadowing' Harmonieren können + nicht sonderlich Performant sind weil sich einfach
  jeder Render State potentiell unkontrolliert verändern kann. Und wenn man später mal einen 'Raytrace Scene Renderer' haben sollte geht das
  schonmal überhaupt nicht mehr mit 'Custom Effects' in dieser Art.



>> 01.05.2008
[CO]
PLRendererOpenGL:
- Ich fand gerade heraus wieso z.B. der 'Bloom' Post Processing Effekt so grausam 'blockig' aussah... RendererOpenGL::GetCombinedMinMipFilter()...
  die Kommentare waren richtig, aber dann wurde statt 'GL_LINEAR' einfach 'GL_NEAREST' genommen. *gruml* Auf jedenfall passt das nun wieder
  und 'Bloom' etc. sieht endlich wieder wie 'Bloom' aus.



>> 27.04.2008
[CO]
PLRendererOpenGL:
- RendererOpenGL::RestoreDeviceStates(): Hier sollten natürlich auch die Texture Matrizen zurückgesetzt werden... und schon sieht man z.B. in der
  Cartoon-Szene wieder den Himmel...



>> 25.04.2008
[CO]
- Copy-Operators und Copy-Constructors hinzugefügt
- Renderer: Font-Funktionen DrawText(), DrawText3D(), GetFontSize(), SetFontSize(), GetFont2D(), SetFont2D(), GetFont3D() und SetFont3D()
  heraus genommen. Die 'Font'-Klasse hat dafür nun Draw()-Funktionen... so herum ist es das einfacher zu nutzen und die übergewichtige
  'Renderer'-Klasse ist minimal schlanker geworden.
  -> Passte alle Projekte daran an
- Renderer Context um einen einfachen Font Manager erweitert



>> 19.04.2008
[CO]
- Renderer::Clear(): 'nColor' als Default auf '0' gestellt da 'Color4::Black' bei Alpha 1 hat, (da es eine 'Farbe' ist) es aber gängig ist Alpha
  als Default ebenfalls auf 0 zu haben
- Renderer::CreateFont2D() muss man nun noch die Schrift größe als Parameter mitgeben
- Font Interface etwas erweitert
- 'Renderer::CreateFont2D()' mit Texture Handler entfernt da ich nicht wirklich einen Grund finden konnte wieso man das mal noch brauchen könnte +
  die Implementation wird dadurch gleich viel Übersichtlicher
PLRendererOpenGL:
- Font2D Implementation komplett überarbeitet. Wie von Stefan vorgeschlagen wird intern nun FreeType genutzt. Da die Implementation allerdings wieder
  immer unübersichtlicher und aufwändiger wurde entschloss ich mich dazu FTGL zu nutzen welches eine 'FreeType->OpenGL'-Schnittstelle darstellt. Damit
  war es bis auf zwei Stellen vergleichsweise einfach bessers Schriften zu realisieren. Das Einladen der Schrift 'direkt aus Speicher' war erstmal
  ungewohnt da das was aus der Datei gelesen wurde erhalten bleiben muss während die Schrift verwendet wird. Momentan wird intern wie früher auch
  eine 'Texture Font' genutzt da dies einfach die beste Performance hat - allerdings war die Schrift anfangst dann immer 'schwarz' da FTGL die Schrift
  in einer 'GL_ALPHA'-Texture hält. Gestern machte ich recht lange herum, kam aber auf keine Lösung wie man auch Schriften damit eine Farbe verpassen kann...
  Nachde ich eine Nacht über das Problem geschlafen hatte gelang mir das heute morgen sehr schnell eine saubere Lösung zu finden: Über 'glTexEnvi'
  wird der Alpha-Wert in der Schrift Texture zusammen mit der aktuell über 'glColor' eingestellten Farbe kombiniet - et voila, es sind wieder Farbige
  Texture Schriften möglich! :D
  Die aktuelle Implementation ist noch nicht vollständig, aber soviel wie früher geht allemal und es sieht dazu noch besser aus + man kann komfortabel
  Schriften wie 'ttf' oder 'otf' nutzen. Für PL sollten wir selbst immer 'otf', also 'OpenType' nutzen da es 'aktueller' ist und die Schrift Dateien
  normalerweise deutlich kompakter sind. (außer jemand hat einen guten Grund wieso wie das Format nicht nutzten sollten :)
  -> Passte alle Projekte an diese Änderungen an. Als Default-Schrift wird derzeit "Standard.pak/Data/Fonts/LinLibertine_Re-2.7.9.9.otf" genommen. Diese
     Schrift ist ganz ok und kann frei genutzt werden. 'Gefunden' habe ich diese Schrift hier: http://linuxlibertine.sourceforge.net/



>> 13.04.2008
[CO]
- 'RendererContext'-Klasse eingeführt. Diese verwaltet bereits 'Renderer', 'TextureManager', 'ShaderManager', 'EffectManager', 'MaterialManager'
  -> Passte alle Projekte entsprechend an
- Renderer API Wrapper Klassen in 'Renderer'-Unterordner verschoben
  -> Passte alle Projekte entsprechend an



>> 12.04.2008
[CO]
PLRendererOpenGL:
- Versuchte nochmals ein paar Minuten lang GLSL über Cg zu nutzen um Shader 3.0 auf meiner ATI Karte ('natürlich' unterstützt Cg NUR NVIDIA Extensions
  für mehr als Shader 2.0!"$=!"$=!") nutzen zu können - auf Dauer kommen wir da nicht drum herum. Allerdings waren die Ergebnisse nicht sonderlich
  prall und bis auf supereinfache Shader ging im Grunde nix richtig + man benötigt einen Hack der Shader wieder korrekt Deaktiviert, Cg scheint das
  nämlich bei GLSL Profilen nicht selbst automatisch zu machen. Schade. Habe das mit Shader unter GLSL korrekt deaktivieren eingebaut, kann das aber
  Zeitlich erstmal nicht weiterverfolgen da noch anderes zu machen ist.



>> 06.04.2008
[CO]
- 'PLRenderer::Texture' in 'PLRenderer::TextureBuffer' umbenannt, das gleiche für die konkreten Typen, so gibt es keinen Namenskonflikt mehr mit
  'PLMesh::Texture'. Passte alle Projekte entsprechend an so das alles wieder lauffähig ist. Allerdings muss man die Verwendung in den anderen
   Projekten nochmal genauer durchschaun und prüfen ob das nun 'Texture' oder 'TextureBuffer' ist damit das sauber getrennt ist.
- Alle Renderer-Backends haben nun ihren eigenen Namespace so wie es mittlerweile auch bei den anderen ähnlichen Projekten der Fall ist. Das ist
  so herum einfach viel überschaubarer was wo liegt + man muss nicht mehr künstlich neue Namen wie z.B. 'TextureBuffer1DOpenGL' generieren.
- 'PLRenderer::Shader' in 'PLRenderer::ShaderProgram' umbenannt, so gibt es keinen Namenskonflikt mehr mit 'PLMesh::Shader'. Passte alle Projekte
  entsprechend an so das alles wieder lauffähig ist.
- 'Texture', 'Shader', 'Effect', 'Material' + ein paar Animations-Klassen (da von 'Texture' benötigt) von PLMesh nach PLRenderer verschoben. Passte
  alle Projekte entsprechend an so das alles wieder lauffähig ist.



>> 05.04.2008
[SB]
- Surface: So geändert, dass der SurfacePainter von aussen gesetzt werden kann. Für das neue Application-Framework sollte
  das möglich sein, da nun alles im Rahmen einer Application-Instanz erzeugt und verwaltet werden sollt. Ich denke, die alte
  Methode über den Namen kann dann ganz gelöscht werden. Aber erst, wenn das Framework steht :-)



>> 31.12.2007
[CO]
PLRendererD3D9:
- Konstruktoren der Texture Implementationen noch etwas aufgeräumt so das man hier im Fehlerfall kein 'return' mehr hat +
  die Daten korrekt zurück gesetzt werden.
- ShaderD3D9::SetParameterTexture(): Die Funktion liefert nun die korrekte Texture Stage zurück an die die Textur gebunden wurde.
  Leider gab es keine 'direkte' Möglichkeit an diese Information zu kommen, darum musste ich hier etwas Tricksen. :D
- Texturen: Upsala, Image::Mode_DXTCDataFormat != Image::Mode_DXTCFormat ich sollte anfangen meine eigenen Kommentare zu lesen *g*



>> 28.12.2007
[CO]
PLRendererD3D9:
- Auf das "November 2007"-DirectX SDK umgestellt + alle unnötigen Libs und Header entfernt (wir nutzen ja wirklich NUR das grundliegenste :)
- Shader gehen wieder soweit, musste dafür 'nur' etwas mit ein paar Cg Features herumspielen. Merkwürdig ist u.a. das Vertex und Fragment Shader 3.0
  irgendwie fast immer "Unkown error" produzieren. Aber im großen und ganzen gehts so nun erstmal. (was nicht heißt das überall alles ok aussieht, da
  spielen noch andere Dinge mit rein :)



>> 27.12.2007
[CO]
PLRendererD3D9:
- Texture::R8G8B8 Kommentar erweitert da man NICHT davon ausgehen kann das es bei jeder Implementation intern wirklich 24-Bit sind. Unter D3D9
  muss ich z.B. D3DFMT_X8R8G8B8 anstatt D3DFMT_R8G8B8 nutzen da das letztere nicht sonderlich weit vom Hardware-Support her verbreitet zu sein
  scheint. (... egal welche API, immer das gleiche da die Hardware soetwas von unterschiedlich ist...)
- Das 'hochladen' von Textur Daten mit berücksichtigung von Kompression und Mipmaps müsste nun klappen (konnte jedenfalls keine Probleme
  feststellen)



>> 25.12.2007
[CO]
PLRendererOpenGL:
- Es fehlten Sicherheits-Abfragen für 'glActiveTextureARB' und 'glClientActiveTextureARB'... hab hier zum Testen gerade 'GDI Generic' als Renderer
  laufen, also das was bei Windows beiliegt - und das kann natürlich praktisch nix und ich bekam immer sofort einen Crash wenn ich etwas laufen
  lassen wollte.



>> 24.12.2007
[CO]
PLRendererD3D9:
- Man 'sieht' wieder etwas, bei einer der xxx Anpassungen hatte ich die Matrizen falsch übergeben



>> 22.12.2007
[CO]
PLRenderer:
- Auf "Cg 2.0 December 2007" umgestellt (keine PL Code Änderungen)



>> 21.12.2007
[CO]
PLRendererOpenGL:
- Fand gerade heraus wieso auf meinem neuem Notebook "scheinbar" 'Rectangle Texturen' nicht gehen - stellte sich heraus das auch
  im z.B. Texture Debug Dialog 'normale' Texturen nicht korrekt (bzw. gar nicht) angezeigt wurden... als ich etwas herum probierte
  landete ich am Ende in "RendererOpenGL::DrawBitmap()", genauer gesagt bei der Verwendung von "glMultiTexCoord2f()". Als ich zum
  Testen dort "glTexCoord2f()" einsetzte ging auf einmal alles wie auf dem alten Notebook!
  Googelte etc. etwas, fand aber nix was das erklären könnte... DAS kann eigentlich nur ein Treiber Bug von ATI sein, denn nicht
  nur in PL tritt das bei mir auf. Z.B. sehe ich beim "Starship Troopers"-Spiel (und noch bei anderen Dingen) das gleiche einfarbige
  flackern wie wenn ich in PL Post Processing an habe. ÄRGERLICH!
  Da mir das nun zu blöde wurde nahm ich die spezielle OpenGL "DrawBitmap()" von uns heraus so das immer mit Vertex Buffern gearbeitet
  wird. "glBegin()" etc. wird in OpenGL 3.0 nicht mehr dabei sein da es total veraltet ist und nicht mehr wirklich ins Konzept passt
  und alles nur umständlich und langsam macht. (die OpenGL Treiber Entwicklung ist angeblich mittlerweile Horror da alles in zig
  möglichkeiten ausartet wovon viele noch aus Zeigen stammen als es keine GPU's gab)
  Überlegte mir schon mehrmals ob ich "glBegin()" etc. komplett aus unserem OpenGL Renderer rausnehmen sollte... nun hab ich zumindestens
  einen Grund das an der Stelle rauszuhauen. :D



>> 23.10.2007
[CO]
PLRenderer:
- 'Types.h': Die verschiedenen Konstanten sind nun in Klassen anstatt Namespaces 'verpackt'. So herum sieht das in der
  von Doxygen erzeugten Dokumentation um einiges besser aus da die einzelnen Render-Definitionen nicht mehr als Namespaces
  auftauchen.



>> 20.09.2007
[CO]
PLRenderer:
- IndexBuffer: Neue Funktion namens 'SetElementTypeByMaximumIndex()' hinzugefügt die 'automatisch' anhand eines übergebenen
  maximalen Vertex Index einen passenden Element Typ setzt. Mir viel vor kurzem auf das wir häufige dieses Zeilen in den
  Codes stehen hatten:
    if (nVertices <= IndexBuffer::MaxVertexIndexUShort)
        pIndexBuffer->SetElementType(IndexBuffer::UShort);
    else pIndexBuffer->SetElementType(IndexBuffer::UInt);
  ... daher denke ich das diese neue Funktion recht Praktisch ist da man nun nur noch
      pIndexBuffer->SetElementTypeByMaximumIndex(nVertices-1);
  schreiben muss was viel überschaubarer ist + ganz nebenbei muss man sich keine Gedanken mehr machen ob das nun nur '<'
  oder '<=' ist. *g*



>> 17.09.2007
[CO]
- Alle Projekte von PLBool auf bool zurückgestellt (siehe PLBase Diary-Entrag von heute)



>> 08.09.2007
[CO]
PLRendererOpenGL:
- SurfaceWindowOpenGL::GetGamma(): Der verwendete Buffer liegt nun direkt auf dem Runtime-Stack, in der Funktion konnte
  es sogar ein Speicherleck geben wenn GetDeviceGammaRamp() fehlschlug!
- SurfaceWindowOpenGL::SetGamma(): Der verwendete Buffer liegt nun direkt auf dem Runtime-Stack
PLRendererD3D9:
- TextureCubeD3D9-Konstruktor: Zeiger auf die 6 CubeMap-Seiten liegen nun direkt auf dem Runtime-Stack



>> 06.09.2007
[CO]
PLRenderer:
- Auf "Cg 1.5 August 2007" umgestellt (war nur header, libs und dlls austauschen)
- cgSetAutoCompile() auf CG_COMPILE_LAZY gestellt damit die Shader erst dann übersetzt werden wenn diese wirklich benötigt
  werden



>> 22.08.2007
[CO]
PLRenderer:
- RendererOpenGL::GeneralSettings(): Nahm [TODO] heraus... wir lassen einfach die Default Einstellungen, diese Dinge machen
  heute sowieso nicht mehr sonderlich viel aus :)
- Nahm die Funktion "DrawSphere()" aus der Renderer-Klasse heraus da dies etwas zuviel des guten ist und das unter D3D
  nicht sonderlich schnell implementiert wäre + man unter OpenGL nicht ohne weiteres rausbekommt wieviele Vertices denn nun
  rausgehauen wurden. Macht also mehr Ärger als es Wert ist. Will man ne Sphere haben, kann man sich schnell so nen Mesh
  über einen Mesh-Creator erzeugen lassen, das ist kein Beinbruch. (wurde zudem auch nur in PLEngine::SceneNode::DrawDebug()
  verwendet)
  DrawTriangle() etc. lass ich mal drinnen da dies recht einfache Dinge sind und gerade DrawBox() etwas nettes ist.
RendererBackend:
- DrawPoints2D() & DrawPoints3D() & DrawLines2D() & DrawLines3D(): Nahm das [TODO] 'Implement more performant technique...
  (using m_pTempVertexBuffer)' heraus da soetwas nicht ganz unproblematisch wäre da man nicht wüsste wie groß dieser
  Zwischenbuffer sein müsste. Das gäbe eine ziemlich Chaotische Implementation zu versuchen da soetwas einzubauen... entweder
  wenn nötig vergrößern, dann hätte man eventuell plötzlich einen 20 MB Vertex Buffer oder so und müsste wieder schaun wann
  man den wie wieder dynamisch verkleinern kann. Das lohnt alles irgendwie nicht, zudem ist diese Angebotene Implementation
  so oder so immer Eingeschränkt da man nie ALLES bieten können wird was man in jeder möglichen Situation mal brauchen
  könnte. (z.B. Vertex Farben, Textur Koordinaten etc) Wenn man VIELE solcher Elemente zeichnen will, muss man sich nen
  Vertex Buffer schnell selbst anlegen und füllen - oft hat man ja diesen Buffer bereits. Das wäre also viel mehr Aufwand
  soetwas zu implementieren als es nutzen bringen würde. :)



>> 07.08.2007
[CO]
PLRenderer:
- SurfacePainter::OnPaintBegin() liefert nun einen Fehlerwert zurück



>> 03.08.2007
[CO]
PLRenderer:
- TextureRectangle::GetNumOfBytes(): Für komprimierte Texturen eine andere Formel eingebaut, das müsste so passen da dies
  so in der DirectX Dokumentation steht.



>> 06.07.2007
[CO]
PLRenderer + Backends:
- Wo möglich/sinnig von Zeiger auf Referenzen umgestellt



>> 02.06.2007
[CO]
PLRenderer:
- Texture: Neue Funktionen: GetPriority() & SetPriority(): Damit lässt sich die GPU Textur Speicherverwaltung etwas beeinflussen.
  OpenGL kennt auch noch 'glAreTexturesResident' worüber man rausfinden kann ob eine Textur gerade im Textur-Speicher ist oder
  nicht - bei D3D konnte ich so eine Funktion bis jetzt noch nicht finden und fügte daher erstmal keine solche Funktion
  ins Textur Interface ein.
PLRendererOpenGL:
- Ein paar unnötige 'glClientActiveTextureARB' herausgenommen
- Sampler State Changes minimiert indem jede Textur noch ihre aktuellen States speichert und nur wenn nötig etwas angeglichen
  wird... In OpenGL werden diese zustände pro Textur, in D3D pro Stage gespeichert - für PL entschied ich mich damals für
  die D3D Methode. :)
  Performance mäßig konnte ich keine Änderung feststellen, allerdings sind die API Aufrufe hier nun meistens um den Faktor
  10 weniger - das sah im Profiling schon etwas merkwürdig aus wenn da immer z.B. '1000' Sampler State Changes stand obwohl
  nicht viel auf dem Bildschirm zu sehen war.



>> 21.05.2007
[CO]
PLMesh: Effekt-Komponente:
- Ein paar 'const' eingefügt
- Ein paar Konstruktoren & Destruktoren hinzugefügt, ein paar Dinge 'private' gemacht + sichergestellt das in den Konstruktoren
  auch ohne RTTI alle Variablen korrekt Initialisiert werden
- Ein paar Zeiger zu Referenzen gemacht damit man den 'NULL'-Fall wo überhaupt nicht möglich auch nicht berücksichigen muss
- EffectPass-Interface aufgeräumt
-> Uh, merkte gerade das durch diese säuberungen in der Beispiel-Szene 'PhysicsPlayground.scene' der merkwürdige Grafik-Bug
   mit teils falsch gesetzten States verschwunden ist sobald das Wasser sichtbar wurde... das zeigt mal wieder deutlich das
   es sich definitiv lohnt immer mal wieder klar Schiff zu machen. *g*



>> 19.05.2007
[CO]
PLRenderer:
- SurfacePainter + davon abgeleitete Klassen durchgeschaut und wo nötig Destruktoren hinzugefügt + bestimmte Dinge 'protected'
  oder gar 'private' (wo z.B. nicht weiter abgeleitet werden können soll) gemacht so das die Sichtbarkeit soweit korrekt ist
- GetCustomFlags() & SetCustomFlags() aus dem Renderer-Interface herausgenommen da dies nicht sonderlich universell und
  nur sehr eingeschränkt nutzbar ist (wurde bis heute auch noch nie wirklich verwendet :)



>> 10.05.2007
[CO]
- Sortierte ins Diary so richtig alte Einträge aus "PLSDK/internal/old_diaries.zip" ein



>> 09.05.2007
[CO]
- Alte Diary Einträge von ab "21.03.04" einsortiert



>> 06.05.2007
[CO]
RendererOpenGL:
- RendererOpenGL::GetCombinedMinMipFilter() prüft anfangs ob Mipmaps vorhanden sind, wenn nicht, so wird 'GL_NEAREST' als
  Fallback zurückgegeben damit OpenGL trotzdem noch etwas korrekt ausführen kann
- RendererOpenGL::SetSamplerState() prüft ob überhaupt eine Textur gesetzt ist, ist dem nicht so, so wird der interne Status
  nicht geändert + fügte noch ein paar glGetError()-Abfragen ein damit man Informiert wird wenn etwas nicht klappte



>> 10.04.2007
[CO]
PLRenderer + Backends:
- Einige 'return' entfernt



>> 24.03.2007
[CO]
- PLRendererD3D9 Backend etwas aufgeräumt



>> 21.03.2007
[CO]
- PLRenderer Backends etwas aufgeräumt



>> 17.03.2007
[CO]
PLRenderer:
- Header & Namespace Änderungen wie in z.B. PLBase



>> 03.03.2007
[CO]
PLRendererOpenGL:
- FrameBufferObject: Hat nun ein weiteres Flag Namens 'Color'. Ist dieses nicht vorhanden, handelt es sich um einen reinen
  Tiefenbuffer und es darf KEIN eigener Tiefenbuffer hinzugefügt werden - sonst gibts (zumindestens bei mir) einen üblen
  Treiber Crash :(



>> 21.02.2007
[CO]
PLRenderer:
- ShaderCgBackend::BackupDeviceData(): Statt 'strcpy' wird hier nun memcpy genutzt, wunderbar keine Compiler-Warnung mehr
  (memcpy scheint Sicherer zu sein *g*)
PLRendererOpenGL:
- OpenGLExtensions::CheckExtension() etwas vereinfacht und übersichtlicher gemacht



>> 11.02.2007
[CO]
- Auf VC 2005 umgestellt
PLRendererD3D9:
- Da man hier 'd3dx9.h' einbindet bekam ich zuerst folgende Fehlermeldungen:
    c:\programme\microsoft visual studio 8\vc\platformsdk\include\winnt.h(222) : error C2146: Syntaxfehler: Fehlendes ';' vor Bezeichner 'PVOID64'
    c:\programme\microsoft visual studio 8\vc\platformsdk\include\winnt.h(222) : error C4430: Fehlender Typspezifizierer - int wird angenommen. Hinweis: "default-int" wird von C++ nicht unterstützt.
    c:\programme\microsoft visual studio 8\vc\platformsdk\include\winnt.h(5940) : error C2146: Syntaxfehler: Fehlendes ';' vor Bezeichner 'Buffer'
    c:\programme\microsoft visual studio 8\vc\platformsdk\include\winnt.h(5940) : error C4430: Fehlender Typspezifizierer - int wird angenommen. Hinweis: "default-int" wird von C++ nicht unterstützt.
    c:\programme\microsoft visual studio 8\vc\platformsdk\include\winnt.h(5940) : error C4430: Fehlender Typspezifizierer - int wird angenommen. Hinweis: "default-int" wird von C++ nicht unterstützt.
  -> Fand aber zum Glück recht schnell raus was probleme machte bzw. wie man das 'löst':
  Bei den 'zusätzlichen Include Verzeichnissen' MUSS man
    '$(VCInstallDir)PlatformSDK/include'
  VOR
    'external/win32/dx_9/Include/'
  einfügen, dann gehts. (ich erspare mir weitere MS-Kommentare *g*)



>> 28.01.2007
[CO]
- VC Projekt-Dateien wie besprochen in die jeweiligen Grundordner verschoben



>> 27.01.2007
[SB]
- CMake Projektdateien für alle PLEngine-Projekte hinzugefügt 



>> 11.01.2007
[CO]
PLRendererOpenGL:
- Bugfix: Falls eine Renderer Textur aus einem gegebenen Bild erzeugt werden sollte, konnte es noch zu Format Problemen
  kommen wenn in dieser übergebenen Textur z.B. Level-0 Daten Komprimiert waren, aber die anderen Mipmap Levels nicht. Nun
  kann man frei kombinieren.



>> 22.12.2006
[CO]
Allgemein:
- An ein paar Stellen wurde der Element Typ von Index Buffern nicht korrekt gesetzt da die Anzahl der Indices, und nicht
  die Anzahl der Vertices verwendet wurde... aber der Typ gibt natürlich den größten speicherbaren Vertex Index an. :)
- Nahm einige Code Umformungen vor (hauptsächlich bei for-Schleifen) um die Lesbarkeit zu erhöhen



>> 17.12.2006
[CO]
PLRenderer + Backends:
- In den BackupDeviceData() Funktionen der verschiedenen Resourcen wird das Backup auf NULL gesetzt wenn kein Backup vorhanden
  ist
PLRendererOpenGL:
- Texture3DOpenGL: 'm_nTotalNumOfBytes' wurde bei automatisch erzeugten Mipmaps nicht gesetzt



>> 16.12.2006
[CO]
PLRenderer:
- TextureStageStates.h, RenderStates.h, SamplerStates.h -> Hier wurde 'Config.h' aus PLGeneral includiert obwohl das
  überhaupt nicht nötig ist. Durch das entfernen musste man nun an verschiedenen Stellen z.B. 'Log.h' aus PLGeneral
  includieren was aber durchaus korrekt ist.



>> 01.12.2006
[CO]
PLRenderer + Backends:
- Gleiche Änderung wie in PLPhysics



>> 11.11.2006
[SW]
PLRendererOpenGL:
- in den Funktionene RendererOpenGL::BeginScene() und RendererOpenGL::EndScene() unter linux den aufruf von
  glXWaitX(in BeginScene) und glXWaitGL(in EndScene) hinzugefügt. Diese Funktionen sorgen dafür, das alle vor dem aufruf der Funktion
  entstandenen XEvents(glXWaitX) bzw. OpenGL Events(glXWaitGL) durchgeführt werden.
  Das ganze verbessert etwas das verhalten beim Verschieben/verändern der Größe des Fensters unter Linux.
- PLRenderer: fehlenden Constructor hinzugefügt, hatte zu einem undefined reference beim laden der lib geführt, trat aber nur im debug-build auf.
- In SurfaceWindowLinux das setzen und auslesen der Gamma werte und die Behandlung für die 32bit Farbtiefe eingefügt.



>> 09.11.2006
[CO]
RendererOpenGL:
- SetShaderTexture(): Bugfix: Hier fehlte das aktivieren von Textur-Typen. (z.B. glEnable(GL_TEXTURE_2D)) Lief es mal
  richtig dumm, war eine Textur zwar gesetzt, aber nicht aktiviert. (in z.B. 'plfx_Effects.scene' konnte es dadurch zu
  'Grafik Bugs' kommen)



>> 04.11.2006
[CO]
PLRenderer:
- SurfaceTexture: Neues Flag: Mipmaps: Ist dieses Flag gesetzt, so werden von der GPU Mipmaps 'on the fly' erzeugt.
  (natürlich nur falls dies auch unterstützt wird) Das kostet zwar etwas mehr Performance, jedoch 'pixeln' diese Texturen
  dann nicht mehr wenn diese 'etwas weiter' weg Dargestellt werden. Derzeit klappt das jedoch leider nur für FBO korrekt.
PLRendererOpenGL:
- FrameBufferObject::Initialize(): Tiefen Buffer crasht auf dem neuen Catalyst Treiber 6.10 nicht mehr :)



>> 31.10.2006
[CO]
PLRendererOpenGL:
- TextureCubeOpenGL::TextureCubeOpenGL(Renderer *pRenderer, uint32 nSize, EPixelFormat nFormat, uint32 nFlags):
  Anzahl der Bytes darf hier natürlich nicht durch 6 geteilt werden. :)



>> 20.10.2006
[CO]
PLRendererOpenGL:
- Beim hochladen bereits komprimierter Bilder muss man (neuerdings??) auch prüfen ob wirklich komprimierte Daten vorliegen -
  denn Mipmaps scheinen nicht mehr in komprimierter Form vorzuliegen, auch denn das Hauptbild dieses tut. Sicherlich mal
  wieder so ne DevIL 'änderung', das war zwar nicht fatal da es vom Renderer 'kompensiert' wurde - aber nicht wirklich
  optimal. :(
- RendererOpenGL::ChooseFormats(): Liegt eine Textur bereits Komprimiert vor, es soll aber gerade keine Textur Kompression
  verwendet werden, so wird diese Komprimierung einfach ignoriert.



>> 19.10.2006
[CO]
PLRenderer:
- Renderer: GetLightEnabled() in IsLightEnabled() umbenannt
- Surface: GetSwapY() in IsSwapY() umbenannt
- Surface: GetAPISwapY() in IsAPISwapY() umbenannt
- Surface: GetActive() in IsActive() umbenannt
- Surface: GetWidth() & GetHeight() 'const' eingefügt
- Renderer: GetClipPlaneEnabled() in IsClipPlaneEnabled() umbenannt



>> 14.10.2006
[SW]
Alle Projekte: finale version für das visibility attribute feature vom gcc.



>> 11.10.2006
[SB]
Wieder diverse Anpassungen:
- Überbleibsel aus einem alten Merge-Error aus dieser Datei entfernt
- Unnötigen [DEBUG]-Kommentar entfernt
- PLLOCAL entfernt - dieses Makro nutzen wir nicht!
- Eingefügte Konstruktoren und Destruktoren mit Kommentaren versehen und in die richtige Reihenfolge gebracht



>> 11.10.2006
[SW]
Alle Projekte: Die projekte verwenden das neue visibility feature vom gcc, wenn vorhanden.
- PLRenderer: den Klassen Frame und Window den virtuellen dtor hinzugefügt,
  damit werden die probleme mit dem visibility-feature vom gcc behoben



>> 04.10.2006
[CO]
- An ein paar Stellen (ColorX & VectorX) "String::Format(" durch ".ToString()" ersetzt



>> 28.09.2006
[SW]
- Linux-port Folgende Project an Änderungen von PLBase angepasst: PLRenderer, PLMesh, PLRendererOpenGL
PLRendererNull:
- Linux projekt dateien hinzugefügt.



>> 24.09.2006
[CO]
- PLRenderer + Backends: Fand noch ein paar auf PLBool umzustellende Stellen



>> 22.09.2006
[CO]
- PLRenderer + Backends auf PLBool umgestellt + die anderen Projekte wo es nötig wurde angepasst



>> 14.09.2006
[CO]
- Beseitige Warnungen die erscheinen wenn der Compiler auf Warnungs-Level 4 gestellt wird



>> 13.09.2006
[CO]
- Dort wo PLRenderer::Buffer::Lock verwendet wird sollte immer mit angegeben werden was für Operationen auf dem Buffer stattfinden
  werden so das der Renderer intern das möglichst geschickt handhaben kann. Fügte dort wo das noch nicht der Fall war jeweils
  einen entsprechenden Lock-Typ ein... der jedoch wirklich nur als 'Verwendung-Hinweis' zu verstehen ist. Gibt man 'Read' an
  kann man trotzdem noch Schreiben, aber eventuell nicht mehr ganz sooo Performant - das hängt von einigen Faktoren ab. :)



>> 23.08.2006
[CO]
PLRenderer:
- Frame::SetFullscreenMode(): Nach dem wechsel des Bildschim-Modus wurde die neue Oberfläche des Painers nicht aktualisiert.



>> 09.08.2006
[CO]
PLRendererOpenGL:
- ShaderOpenGL::Init(): Konnte den kleinen GeForce4 Hack entfernen da es bei den neuen Cg Versionen korrekt geht... diesmal
  war es sogar so, das dieser Hack auf meiner GeForce4 einen Crash in cgGLLoadProgram verursachte. :)



>> 08.08.2006
[CO]
PLRendererOpenGL:
- SurfaceTextureOpenGL: Uh, durch irgendeine Umstellung kam hier etwas übel durcheinander... eine kleine Klammer war falsch
  gesetzt, dadurch wurde aber der PBuffer intern als 'not managed' angesehen und der Speicher wurde am Ende nicht freigegeben...



>> 28.07.2006
[CO]
PLRenderer:
- RendererBackend::CheckTextureCube(): Sind die Seiten als einzelnde Bilder übergeben worden, so wird zusätzlich noch geprüft
  ob alle Bilder gleich groß sind und das gleiche Format haben - ansonnsten klappt das nicht.
- Die TextureCube Implementationen erkennen nun ob direkt das erste Image eine Cube Map ist, ist dies der Fall, werden eventuell
  übergebene weitere Images ignoriert.



>> 25.07.2006
[CO]
Renderer:
- Capabilities: Es wird nun zwischen nMaxTextureSize und nMaxRectangleTextureSize unterschieden da diese Werte unterschiedlich
  sein *können*
RendererOpenGL:
- CreateTexture3D() & CreateTextureCube(): Hier fehlte noch eine kleine Abfrage ob dieser Textur Typ unterstützt wird.
- Neben GL_ARB_texture_cube_map wird nun auch GL_EXT_texture_cube_map geprüft, zwar wurde diese Extension scheinbar ziemlich
  schnell zum 'Standard', aber sicher ist sicher.
- Neben GL_ARB_occlusion_query wird nun auch GL_NV_occlusion_query unterstüzt das praktisch identisch ist - nur für alle Fälle.
- Ist GL_ARB_vertex_program nicht verfügbar, wird in VertexBufferOpenGL::MakeCurrent() das gute alte glFogCoordPointerEXT verwendet,
  aber nur wenn GL_EXT_fog_coord vorhanden ist.
- Es wird geprüft ob GL_EXT_secondary_color vorhanden ist
- Schrieb dazu das dies ein OpenGL 1.1 (aus dem Jahre 1992 :) Renderer ist und alles weitere über Extensions reinkommt, so sind wir
  vom Renderer so Abwärtskompatibel wie irgend möglich. So muss man auch keinem erklären wieso man das eine Testen sollte und
  das andere nicht. Noch gibt es jedoch einiges an entsprechenden Abfragen und Fallbacks einzubauen damit das auf so vielen (alten) Karten
  wie möglich läuft. Und dann müsste man sich soetwas wie eine 'Versions-Nummer' ausdenken, wohl D3D9 vergleichbar so das ich als
  User auf einen Schlag prüfen kann auf welcher GPU Generation das hier gerade läuft - um z.B. dann schon gleich beim Programmstart
  abbrechen zu können wenn das die aaalererste GPU Generation ist, ich aber mindestens die dritte erwarte da alles andere keinen
  Sinn machen würde.
- Nahm GL_EXT_polygon_offset heraus da dies bereits in OpenGL 1.1 vorhanden ist, und bei heutigen Karten scheint das überhaupt
  nicht mehr in der Extension Liste aufzutauchen. (Stephan und ich konnten es auf unseren mittlerweile betagten Rechnern nicht finden :)



>> 24.07.2006
[CO]
PLRendererOpenGL:
- Neben GL_EXT_texture_rectangle und GL_NV_texture_rectangle gibts noch GL_ARB_texture_rectangle (jipi, es lebe die Freiheit!)
  welches das gleiche ist, und nur einen anderen Namen hat. Baute noch einen Test auf diese Extension ein damit das wirklich
  sicher erkannt wird ob das Feature verfügbar ist oder nicht.



>> 21.07.2006
[CO]
RendererOpenGL:
- Das mit den OS-abhängigen Funktionen etwas aufgeräumt, so müsste das nun etwas übersichtlicher sein.



>> 09.07.2006
[CO]
PLRenderer:
- Änderte die Funktionen GetDefaultRenderStates() zu GetDefaultRenderState(), GetDefaultSamplerStates() zu GetDefaultSamplerState(),
  GetDefaultTextureStageStates() zu GetDefaultTextureStageState() und GetDefaultMaterialStates() zu GetDefaultMaterialState().
  Statt einen Array mit den Default Werten zu füllen, fragt man nun einzelnde Default Werte ab. Zum einen ist das etwas sicherer
  da es wenn ein Array zu klein war natürlich zu Problemen kam, zum anderen ist man meistens an einzelnen Default Werten interessiert
  und da ist es einfach Handlicher wenn man diese einzelnd anstatt als ganzen Brocken bekommen kann.



>> 07.07.2006
[CO]
PLRenderer:
- Frame: SetFullscreenMode() an die SurfacePainter Änderung angepasst: Hier muss der Surface Painter etwas unschön 'weggespeichert'
  werden da ein zerstören & neu erzeugen hier 'etwas' viel Aufwand für nix wäre.



>> 03.07.2006
[CO]
PLRenderer:
- Nahm wie gestern mit Stefan besprochen den Surface Listener heraus. Fügte SurfacePainter hinzu. Surface um GetPainter() und
  CreatePainter() erweitert. Sobald eine 'Oberfläche' aktualsiert wird, wird der SurfacePainter dieser Oberfläche aufgerufen
  der für das 'Zeichnen' verantwortlich ist. Da diese Klasse an das RTTI gekoppelt ist, ist das die Entwicklung neuer
  'Surface Renderer' recht einfach und universell.



>> 30.06.2006
[CO]
PLRenderer:
- SetViewport() & SetScissorRect(); (0, 0) liegt nun wieder links-oben. Das passt zwar nicht mit unserem 3D Koordinatensystem
  zusammen, allerdings ist rechts-unten an vielen Stellen noch unhandlicher als das umrechnen von y an ein paar Stellen...
  gerade beim ingame gui hätte man viel herumwurschteln müssen und das platzieren von 2D Texten wäre anderst gewesen als das
  platzieren von Gui Texten was eher verwirrend als hilfreich gewesen wäre.



>> 27.06.2006
[CO]
PLRenderer:
- GetViewport(), SetViewport(), GetScissorRect(), SetScissorRect() Arbeiten nun mit der neuen Klasse PLMath::Rectangle. Dadurch
  lässt sich das nun um einiges netter Bedienen. Desweiteren ist der Punkt (0, 0) nun links unten anstatt links oben wie bisher
  -> so passt das auch mit unseren Koordinaten System (rechte Hand) zusammen.



>> 16.06.2006
[CO]
PLRendererOpenGL:
- Wenn die Extension GL_SGIS_generate_mipmap vorhanden ist, so muss man wenn man Texturen hochläd nicht z.B. gluBuild2DMipmaps()
  verwenden um Mipmaps zu erzeugen sondern kann dies der GPU überlassen. Dann kann man sogar eine eventuelle Kompression
  direkt übernehmen... ich hoffe das wir so laangsam mal alles Textur mäßig mögliche & Sinnige drinnen haben...
- Bugfixing: In Parameters::Semantic mussten die Enums noch angepasst werden. Damit Shadow Mapping funktioniert mussten
  ein paar kleine Einstellungen geändert werden.



>> 15.06.2006
[CO]
PLRenderer:
- Parameters: SetParameterTexture(): Der nStage Parameter durfte gehen da er hier überflüssig ist. Cg bindet die Textur selbst
  an eine geeignete Texture Stage welche man dann abfragen muss um die PL Renderer States korrekt zu setzen. In PLMesh::ParameterManager
  konnte man mit dieser Information sowieso nichts anfangen und daher ich bin froh das man diesen Parameter komplett entfernen
  konnte damit alles einheitlich ist. :)
  Da man wenn man Shader verwendet sowieso keine Kontrolle darüber hat wo welche Textur landet, und im Prinzip auch gar keine
  haben muss da es bei Cg-Shadern egal ist, nahm ich die Texture<index>-Semantics heraus... im Effekt wurden diese sowieso
  nicht mehr verwendet da eine Textur in verschiedenen Pässen/Schichten verwendet werden kann und man daher keine feste
  Texture Stage angeben konnte. Die TextureMatrix<index>-Semantic macht dadurch ebenfalls keinen Sinn mehr. Will man Textur
  Matrizen setzen um z.B. eine Textur durch verschieben zu 'animieren', so muss sich der Szene Renderer darum kümmern das
  die Infos korrekt an die Shader weitergegeben werden... falls diese überhaupt Textur Matrizen unterstüzen. :)



>> 13.06.2006
[CO]
PLRendererOpenGL
- RendererOpenGL::Init(): Ighh, kann mich gar nicht dran erinnern hier m_sCapabilities.nMaxClipPlanes auf 5 gesetzt zu haben.
  Das ist natürlich totaler unfüg... hatte mich gerade schon gewundert wieso ich nur 5 Clipping Planes habe... :)
- TextureCubeOpenGL: Da GetNumOfBytes() den Speicherbedarf für ALLE Seiten zusammen für diese Mipmap Stufe zurückgibt, muss
  man an diversen Stellen durch 6 Teilen.



>> 10.06.2006
[CO]
PLRenderer:
- Renderer: CreateVertexShader(), CreateFragmentShader() Funktionen um Parameter für den Programm Einstiegspunkt erweitert -
  falls dieser mal nicht 'main' heißen sollte.... :)
- Stellte auf die aktuellste Cg Version um... da ich mich gerade mit diesem Gebiet befasse sollte das alles so aktuell wie
  möglich sein.



>> 09.06.2006
[CO]
PLRenderer:
- RenderStates & TextureStageStates & SamplerStates: Enumerations werden nun groß/klein geschrieben. Zum einen ist das besser
  Lesbar, aber noch viel wichtiger, diese Namen stimmen nun genau mit den Renderer Einstellungen überein so das man sich den Namen
  nur einmal merken muss. In den Default Einstellungen werden ebenfalls die Enumeration Namen anstatt der Nummer verwendet.



>> 07.06.2006
[CO]
PLRendererOpenGL:
- Bei den Upload/Download Funktionen fehlte natürlich noch das Bind-Textur. Ganz Glücklich bin ich noch nicht mit diesem
  'aktuelle Textur holen, eigene Textur setzen, Operation durchführen und alte Textur wieder herstellen'. Zum einen kann das
  superschnell in supervielen Texture State Changes ausarten wenn man z.B. sich nacheinander alle Mipmaps einer zurückgeben
  lässt, und zum anderen weis ich nicht obs so wie es momentan ist wirklich funktioniert... was, wenn z.B. gerade eine 2D
  Textur gesetzt ist, ich aber momentan mir eine 1D Textur wegsichere - keine Ahnung ob das funkt. :)
  Da werd ich wohl bei Zeiten noch etwas anderes ausprobieren müssen, aber fürs erste kann man es wohl lassen.
  (gibt derzeit wichtigeres zu tun :)



>> 06.06.2006
[CO]
PLRenderer:
- In der Renderer Textur Basisklasse Upload() & Download() hinzugefügt damit man Textur Daten hoch/runterladen kann. GetNumOfBytes()
  um einen Optionalen Parameter erweitert damit es möglich ist sich auch für ein anderes Format den benötigten Speicher zurückgeben
  zu lassen.



>> 02.06.2006
[CO]
PLRenderer:
- Shader um Parameter Typen erweitert. Derzeit gibts nur diese Typ Definitionen + Funktionen um den Typen von seinem String zu
  ermitteln oder den Typen in einen String 'umzuwandeln'.
- Shader: GetSemanticParameter() Funktion hinzugefügt um den Namen des Parameters zu ermitteln der die angebene Semantic hat.
  Eine Semantic kann NUR von einem Parameter verwendet werden, alles andere würde keinen Sinn machen und es zudem nur unnötig
  komplizierter machen.



>> 01.06.2006
[CO]
PLRenderer:
- Arbeite an der Shader Semantic Implementation weiter. Innerhalb der Shader Backend Implementation passiert Semantic mäßig im
  Prinzip nichts, die Basis Klasse selbst übernimmt die gesammte Arbeit. Innerhalb der konkreten Renderer Implementationen
  muss jedesmal wenn sich an einem Render State der auch als Shader Parameter Semantic bekannt ist etwas ändert, so
  muss Shader::RefreshSemanticParameter() aufgerufen werden was intern nur ein 'is Dirty'-Flag setzt. Vor konkreten Zeichen
  Operationen muss intern dann Shader::BindSemanticParameters() aufgerufen werden - alle 'Schmutzigen' Shader Parameter mit
  bekannter Semantic werden dann auf aktuelle Render States gesetzt. Eine 'schönere' Implementation viel mir hier einfach
  nicht ein, man muss einfach die Shader Parameter 'synchronisieren' und das geht wohl kaum besser. :(
  Während das Shader Interface recht übersichtlich ist und auch das mit der Semantic sehr einfach zu verwenden ist, ist die
  Implementation leider etwas weniger 'schön' da ich mit vielen Bit-Operationen, Callback-Funktionen und Maps arbeite damit
  alles so flott wie irgend möglich von dannen geht. Die Shader Parameter mit Semantic werden z.B. erst dann wenn wirklich
  benötigt aktualsiert. Also bitte nicht 'aufschreien' das dies doch kein Mensch lesen oder gar verstehen könnte, wenn jemand
  das besser Implementieren kann OHNE einen totalen Performance Overkill zu produzieren soll er mir einfach bescheit geben. ;-)
  Da Shader mittlerweile sehr wichtig/unverzichtbar geworden sind, MUSS das einfach so flott wie irgend möglich gehen auch
  wenn das dann auf kosten der Lesbarkeit der Implementation geht - an diesen internen Codes haben sowieso keine Fremden
  herumzudoktern, und jemand der dazu berechtig ist, wird wohl sicherlich kein Newbie Coder mehr sein. Die RTTI Codes sind
  für 'Außenstehende' ja auch nicht so ohne weiteres zu durchschauen. ;-)
  Aber dieser Aufwand lohnt definitv, in der Beispiel Szene 'NormalMapping.scene' kann man bereits sehen wie 'mächtig' dieses
  System ist... nun haben endlich die Lichter der Szene einen Einfluss auf die Shader, zumindestens das 'Primäre' Licht, denn
  mit mehrern Lichtern herumzujonglieren ist definitiv der Job eines entsprechenden Szene Renderers. Als nächstes müssen die
  Material Parameter etwas überarbeitet werden, wobei im Material weitere Shader Parameter Semantics hinzukommen werden für z.B.
  Timing, also etwas speziellere Dinge welche im Renderer selbst einfach nix zu suchen haben.
- Lies alle Projekte nach häufigen Englisch Fehlern durchsuchen auf die mich Stefan vor geraumer Zeit hinwies, hauptsächlich
  'kown', 'were' und 'byself'.
- Schaute alle Stellen bei denen in Interfaces '-1' vorkommt durch und dort wo möglich änderte ich es (sammt Implementation)
  in <0 damit das etwas/allgemeiner Sicherer ist.



>> 31.05.2006
[CO]
PLRenderer:
- Überarbeite die Shader im Renderer da die aktuelle Implementation viel zu aufwändig war. Nahm dabei die Shader Parameter
  Klasse heraus da dies totaler Overhead war, also das 'Managen' der Uniform Shader Parameters innerhalb der Shader Klasse
  und das zwischenspeichern ('shadowing') der Einstellungen innerhalb der Shader Parameter Klasse. Die Shader API's bieten
  Funktionen an um einen gesetzten Wert auch wieder auszulesen, und die meisten API's bieten auch 'Shadowing' der Parameter
  an so das man dies wirklich nicht selbst zu machen braucht, zumindestens NICHT direkt im Shader Wrapper - im Renderer selbst
  sollte das so einfach wie irgend möglich sein. Unser Material in PLMesh macht ja genau das gleiche, und so war das am
  Ende auch doppelt gemoppelt. Desweiteren war das auch in der Bedienung nicht so schön da man sich zuerst einen Parameter
  zurückgeben lassen musste um ihn dann setzen/lesen zu können.
  Shader mäßig gibts nun nur noch eine Klasse im Renderer. Diese bietet u.a. Funktionen wie SetParameter2f() um direkt Shader
  Parameter zu setzen oder auszulesen. '2f' etc. am Ende des Namens ist eine gängige Namensgebung und daher machte ich es genauso,
  denn es gibt verschiedene Funktionen für die Shader Parameter, je nachdem um welchen Typ es sich handelt. Im Null Renderer
  gibts keine Shader Implementation. Passte alle Projekte an diese Änderung an. (waren nur minimale Anpassungen nötig :)
- In den PLMesh Materialen kann man ja bereits seit langem Shader Parametern eine 'Semantic' zuweisen so das sobald ein
  Shader gesetzt wird z.B. die aktuelle World Matrix des Renderers einem Shader Parameter übergeben wird so das man quasi
  'automatische Parameter' hat die immer einen aktuellen Wert haben was sich als relativ praktisch herausgestellt hat. Aber
  dieses System war leider nicht so mächtig wie es sein könnte da es erst in PLMesh implementiert wurde und viele Dinge
  wie Nebel oder noch viel wichtiger Licht Einstellungen konnte man nicht so schön dem Shader automatisch übergeben lassen. Und
  da diese 'automatischen Parameter' NUR beim setzen/aktivieren eines Material Passes gesetzt wurden, waren diese Werte natürlich
  nicht mehr korrekt wenn man z.B. die Welt Matrix des Renderer änderte, und dann musste man nochmal selbst schaun das korrekte
  Werte gesetzt waren. Das störte mich gewaltig da hierdurch z.B. der Normal Mapping Shader des Soldaten immer etwas 'außerhalb'
  stand, z.B. war es schlichtweg unmöglich ohne aufwand die Shader Parameter für das Licht einzustellen. Es war auch nicht
  möglich eine kleine Szene zu machen in der nur der Shader Soldat und eine Licht Scene Node waren wobei das Licht auch wirklich
  den Shader Soldaten 'beeinflusste' - denn da es komplett getrennte Systeme waren, konnten diese Dinge auch nicht automatisch
  miteinander Arbeiten. Die einfache Lösung des Problems bestand darin, die 'Parameter Semantic' von PLMesh direkt in die Renderer
  Shader zu verschieben, zumindestens die welche was mit dem Renderer zu tun hatten. Bei D3D 10 gibt es viele Render States
  wie z.B. für Nebel, Licht, Material NICHT mehr, es MUSS also komplett über Shader selbst implementiert werden. Und generell
  ist's ja so das diese Einstellungen auch nur 'verwendet' werden wenn gerade kein Shader aktiv ist - also Fixed Pipeline Render
  States... wobei es soetwas wie 'Fixed Pipeline' heute ja in den GPU's nicht mehr wirklich gibt. In der Renderer Shader Klasse
  kann man nun also wie gehabt 'per Hand' Parameter einstellen, oder ihnen eine Semantic zuweisen wodurch diese dann automatisch
  gesteuert werden - sprich, Set-Funktionen werden ignoriert, Get-Funktionen liefern die aktuellen Render States zurück. Sobald
  man einem Parameter eine Semantic zuweist, hat man also 'richtige' automatische Parameter die automatisch intern mit den aktuellen
  Renderer Einstellungen 'angeglichen' werden. Ändere ich z.B. die Welt Matrix des Renderers, so hat AUTOMATISCH auch gleich
  ein gerade aktiver Shader die aktuelle Welt Matrix als Shader Parameter gesetzt wenn dieser die entsprechende Semantic hat.
  Nun hat man ein mächtiges System welches zudem noch recht Natürlich & Logisch zu bedienen ist. Stell ich nun z.B. in einem
  PLMesh Material eine Parameter Semantic ein, wird intern dieser Parameter mit dem Renderer 'zusammengeschlossen' - und nun haben
  automatisch aktuelle Renderer Einstellungen wie z.B. für Licht 'einfluss' auf den Shader. Im Falle der Szene mit dem Shader
  Soldaten und einem Licht (siehe PLSamples: NormalMapping.scene) 'beeinflusst' diese Licht Scene Node nun tatsächlich wie man
  es auch erwarten würde den Soldaten. Bei mehreren Lichtern muss man auch mehrere Lichter dem Shader übergeben, aber das
  ist wohl selbsterklärend. ;-)
  Shader bietet zwei Statische Hilfsfunktionen Namens SemanticFromString() und SemanticToString() mit denen sich superflott
  ein Semantic String in eine Nummer 'umwandeln' lässt und umgekehrt. Das kann man hauptsächlich beim Laden & Speichern brauchen.
  Renderer Shader kennen derzeit 45 Semantics, das sollte für's erste reichen.
  Dieses System müsste nun auch relativ Zukunftssicher sein, also wenn man später z.B. noch ein D3D 10 Backend schreibt. In dem
  Fall MUSS man halt Shader für z.B. Beleuchtung schreiben, aber es sollte wohl Problemlos möglich sein das IM Renderer Backend
  dann entsprechende Default Shader verwendet werden so das sich alles wie auch bei OpenGL oder D3D 9 bedienen lässt. Und bedient
  wird es immer gleich, es 'sieht' also für den User so aus als obs weiterhin Nebel Einstellungen im Renderer gäbe, ok, es gibt
  diese ja auch, nur werden diese dann im Renderer Backend selbst gemacht anstatt von fertigen API/GPU Funktionen.
  Da das mit den 'nicht automatischen' Shader Parametern nun viel direkter und einfacher zu Bedienen ist, sollte es auch
  viel einfacher als vorher sein einen netten Shader Beleuchtungs Szene Renderer zu schreiben - wo man also direkt im Code diverse
  Shader Parameter einstellt.
  Jipi, durch diesen Eintrag ist das PLEngine Tagebuch nun 300 KB groß - das was ich in diesem Monat erreichen wollte. Hätte nicht
  gedacht das ich heute noch die verbleibenden 5 KB füllen könnte - aber das mit der Renderer Shader Änderung bot ja genug Stoff zum
  Labern. ;-)



>> 30.05.2006
[CO]
PLRenderer:
- RendererBackendCg entfernt, die Dinge welche dort gemacht wurden passieren nun direkt in den konkreten Shader Implementationen.
PLRendererOpenGL
- Codes etwas herausgeputzt: Leerzeichen/Tabs verbessert, überflüssige Includes entfernt, überflüssige 'using namespace'
  entfernt, String Anpassungen, diverse Konstruktoren protected gemacht, ein paar Kommentare verbessert
- Extensions Klasse: Neue Funktion: WriteExtensionStringIntoLog() schreibt einen Extensions String ins Log - da dies
  mittlerweile an mehreren Stellen mit verschiedenen Extensions Strings geschieht, war eine entsprechende Funktion sinnig. :)
- OpenGLExtensions: ShowGeneralOpenGLInformation() & ShowOpenGLShaderInformation() verbessert so das nun immer korrekte
  Informationen im Log stehen.



>> 29.05.2006
[CO]
PLRenderer & PLRendererNull & PLRendererD3D9:
- Codes etwas herausgeputzt: Leerzeichen/Tabs verbessert, überflüssige Includes entfernt, überflüssige 'using namespace'
  entfernt, String Anpassungen, diverse Konstruktoren protected gemacht, ein paar Kommentare verbessert



>> 23.05.2006
[CO]
PLRendererOpenGL:
- BackupDeviceData()/RestoreDeviceData() Implementationen der Texturen überarbeitet. Nun werden auch Mipmaps sammt Kompression
  von der GPU heruntergeladen und danach wieder herauf was sogar ziemlich flott und stabil geht. :)



>> 22.05.2006
[CO]
- Stellen wo Tokenizer::Start() verwendet wird angepasst



>> 21.05.2006
[SB]
- Projekte an FS-Änderungen angepaßt



>> 21.05.2006
[CO]
PLRenderer:
- Texturen um Funktionen erweitert welche zurückgeben wieviele Mipmaps eine Textur hat und wieviel Bytes the Textur zusammem
  mit allen Mipmaps und unter berücksichtung des verwendeten internen Formats (sammt Kompression) benötigt.
  GetNumOfBytes() sowie den Funktionen zum ermitteln der z.B. Textur Breite kann man nun noch die gewünschte Mipmap als
  Parameter übergeben.
- In den Renderer Statistiken steht nun auch wieviele Texturen derzeit auf der GPU sind und wieviel Speicher diese dort
  beanspruchen. Gerade bei großen Szenen ist diese Information wohl ziemlich wichtig damit man abschätzen kann ob gerade
  einfach zuviele & zugroße Texturen verwendet werden oder ob man noch massig Spielraum hat. :)
  Da z.B. OpenGL keine Möglichkeit bietet abzufragen wieviel GPU Speicher gerade belegt ist/noch frei ist, ist es unumgänglich
  selbst diese Infos zu Managen. Ich kann mir sehr gut vorstellen das diese Informationen bei größeren Projekten welche
  Dynamisch Texturen laden und entladen müssen wichtig ist um zu entscheiden ob es nun nötig ist weniger wichtige
  Texturen/gerade nicht verwendete Texturen wieder zu entladen oder nicht.



>> 20.05.2006
[CO]
PLRenderer:
- Texture:EPixelFormat: Neues Texture Kompressions Format 'ATI2N' hinzugefügt. 3Dc ist für Normal Map Kompression 
  gedacht wobei es sich um ein Format mit 2 Farbkomponenten handelt. Es gibt auch noch 'ATI1N' für nur Luminance,
  z.B. für BumpMaps, jedoch gibt es dieses Format unter OpenGL noch nicht und daher fügte ich es nicht hinzu. Testen konnte
  ich 3Dc leider nicht da meine Karte es nicht kann, allerdings 'müsste' es funktionieren. :)
  Änderte DXT1 von RGBA in ein RGB Format, unter OpenGL kann man zwar beides Auswählen, aber normalerweise versteht man unter
  DXT1 ein RGB Format. Musste 'glext.h' um GL_ATI_texture_compression_3dc erweitern.
- Da das übergebene Bild bereits Komprimiert sein kann, kann der Renderer das komprimierte Bild direkt so übernehmen -
  vorausgesetzt natürlich das Kompressions-Format wird unterstützt. Unterstützt der Renderer das Format jedoch nicht, so
  muss 'er' bevor das Bild der GPU übergeben wird das Bild dekomprimieren... sprich, der Renderer KANN beim erzeugen einer
  Texture aus einem gegebenen Bild dieses Bild manipulieren, konkret, es dekomprimieren. Zwar wollte ich es vermeiden das
  der Renderer selbst so ein Bild ändert, aber gerade unter OpenGL bestimmen mehrere Faktoren darüber OB die das komprimierte
  Bild direkt so übernommen werden kann oder nicht... und ich denke das wäre unzumutbar/umständlich die Renderer Capabilities
  so um die entsprechenden Detail Infos zu erweitern so das z.B. PLMesh::Texture dann prüfen kann ob dekomprimiert werden
  muss oder nicht. Wobei, da derzeit im DevIL Bild leider IMMER beim einladen automatisch auch eine Dekomprimierte Version
  angelegt wird, ändert der Renderer ja derzeit nicht wirklich was am Bild. ;-)
- Texture::IsFormatCompressed() entfernt und im Renderer als IsTexturePixelFormatCompressed() eingebaut, so ist das universeller
- Renderer: GetTexturePixelFormat(): Über einen Parameter kann man nun noch bestimmen ob komprimierte Formate erwünscht sind
- Texture: Neues Flag: Compression -> Ist dieses Flag gesetzt, so wird soweit möglich die Textur intern komprimiert auf der GPU
  abgelegt. Wünscht der User beim erzeugen der Textur ein bestimmtes Format, so wird dieses Flag ignoriert.
- Erweiterte in Renderer::CreateTexture1D() die Anmerkungen
PLRendererOpenGL:
- Passte die Textur Klassen an das übernehmen von Image bereitgestellter Mipmaps & Kompression an. Werden die Mipmaps nicht
  bis zu 1x1 herunter Definiert, so ist das ein Fehler und sobald man versucht eine solche Textur mit entsprechendem Filter zu
  verwenden, so bekommt man unter OpenGL normalerweise nur eine weiße Textur zu Gesicht. Dies kann man schön Testen wenn man
  einer dds Textur Mipmaps verpasst die nicht bis 1x1 heruntergehen... baute hier daher gleich eine entsprechende Log Warnung
  ein. BackupDeviceData() und RestoreDeviceData() müssen noch angepasst werden.
- Da das Auswählen der konkret verwendeten Formate nun von einigen Parametern abhängt und das bei jedem Textur Typ benötigt wird,
  fügte ich in RendererOpenGL::ChooseFormats() eine entsprechende 'Auswahl'-Funktion hinzu.



>> 19.05.2006
[CO]
PLRendererOpenGL:
- Durch die kleine Verbesserung in PLGeneral::Image ist es nun möglich die von z.B. einem dds Bild eingeladenen Mipmaps
  direkt an die GPU zu übergeben. (siehe z.B. Texture2DOpenGL)
  Zum einen spart das etwas Zeit beim hochladen der Textur da die Mipmaps nicht noch extra erzeugt werden müssen, aber viel
  wichtiger ist, das nun die Grafiker direkte Kontrolle über diese Mipmaps haben... also diese selbst so anlegen können das
  diese immer Optimal aussehen... oder man kann damit auch einfach nur etwas Umfug treiben so das mit der 'Entfernung' sich
  das Bild der Textur ändert. ;-)
  Hat man z.B. in jeder Mipmap eine andere Farbe, so kann man sehr schön sehen wie die GPU mit der Entfernung verschiedene
  Mipmaps auswählt und filtert.



>> 18.05.2006
[SW]
PLRendererOpenGL:
- Abfragen für die Extension ARB_multisample, ATI_pixel_format_float und NV_float_buffer
  unter Linux hinzugefügt. Zusätzlich habe ich OpenGLExtensions::CheckExtension
  leicht modifiziert, damit auch alle verfügbaren Extension-Strings für die Prüfung
  verwendet werden. Denn unter Linux(GLX) gibt es 2 zusätzlich funktionen,
  neben glGetString(GL_EXTENSIONS), um die vorhandenen Extensions als String zu bekommen.
- Multi Render Target support auch unter Linux deaktiviert, da es zu sporadischen abstürzen führt



>> 16.05.2006
[CO]
- An PLGeneral Änderungen angepaßt



>> 15.05.2006
[CO]
PLRenderer:
- Fehlerhafte -1 zuweisungen verbessert
- ~ShaderParameter() etwas umgebaut damit der gcc Compiler keine Warnung mehr ausspuckt (warning: deleting `void*' is undefined)
PLRendererOpenGL:
- IndexBufferOpenGL: Löschen des Buffers etwas umgebaut damit der gcc Compiler keine Warnung mehr ausspuckt
  (warning: deleting `void*' is undefined)
- Fehlerhafte -1 zuweisungen verbessert



>> 14.05.2006
[SW]
PLRendererOpenGL:
- einen fehler in linux part gefixed, welcher nen abstürtz auf ATI karten geführt hat.
  man sollte halt den RenderContext zum testen der vorhandenen OpenGL Extension nach gebrauch wieder freigeben.



>> 14.05.2006
[SB]
- An PLGeneral Änderungen angepaßt



>> 11.05.2006
[SB]
- An PLGeneral Änderungen angepaßt (DEFINE_GROUP entfernt, GetClasses())



>> 09.05.2006
[SB]
- Externe Libraries nach "external" verschoben und die Projekte entsprechend angepaßt



>> 03.05.2006
[CO]
PLRenderer:
- SetSamplerState(): Wird 'Sampler::MipFilter' gesetzt und hat die gerade aktivie Textur KEINE Mipmaps, so wird automatisch
  als Wert 'TextureFiltering::None' angenommen so das die Texture korrekt Darstellt wird und man nicht selbst einen entsprechenden
  Wert setzen muss wenn eine Textur keine Mipmaps hat.
  Diese Änderung der Einstellung ist jedoch rein intern, wenn der User GetSamplerState() aufruft, so bekommt er seinen gesetzten
  Wert zurück. Sobald eine andere Textur gesetzt wird welche Mipmaps hat und daher die User einstellung gültig ist, wird diese
  automatisch verwendet. Nun wird die Textur immer korrekt Dargestellt, auch wenn man mal 'vergessen' hat einen anderen Filter 
  Modus zu wählen wenn die verwendete Textur keine Mipmaps hat... oder sich darum einfach nicht kümmern wollte. ;-)



>> 23.04.2006
[CO]
PLRenderer:
- Fügte eine SetTransformState() Funktion für eine 3x4 Matrize hinzu damit man seine 3x4 Matrizen direkt so an den Renderer
  übergeben kann. Intern wird dann aber trotzdem eine 4x4 Matrize verwendet und es gibt auch nur eine GetTransformState()
  Funktion welche eine 4x4 Matrize zurückgibt. Aber entsprechende Zuweisungen sind ja in den Matrizen Klassen implementiert.
  Ich wollte hier nur vermeiden das eine extra 4x4 Temp Matrize erzeugt wird wenn man z.B. seine 3x4 Welt Matrize dem
  Renderer übergeben will.



>> 14.04.2006
[CO]
PLRenderer:
- RendererBackend::Get2DCoordinate(): Hier muss noch die World Matrix berücksichtigt werden



>> 08.04.2006
[CO]
PLRenderer:
- Stellte auf 'Cg 1.5 Beta 1' um



>> 31.03.2006
[CO]
PLRenderer:
- Surface: Neue Funktionen: GetSwapY() & SetSwapY(): Da man bei D3D beim Rendern in Texturen die y Achse vertauschen muss, 
  entschloss ich mich dazu das gleich universell zu machen falls mal jemand sein Bild verdreht rendern will. :)
  Intern gibts noch eine virtuelle API abhängige Funktion namens 'GetAPISwapY()', der Renderer selbst verwendet nur diese 
  Funktion. Hier kann man unter z.B. D3D zurückgeben wie 'verdreht' werden soll. Wird verdreht, so muss der Renderer intern 
  auch entsprechend den Cull Mode anpassen.
PLRendererD3D9:
- Wird Reflection Mapping verwendet, so wird die Texture Matrix genauso wie im OpenGL Renderer verändert
- TextureRectangleD3D9: Wird Textur Kompression verwendet, so ist der Inhalt der Texture immer Schrott - noch habe ich 
  nicht herausgefunden wieso das so ist und wie man es besser machen könnte. :(



>> 30.03.2006
[CO]
PLRendererOpenGL:
- SurfaceTextureOpenGL: Implementation etwas übersichtlicher gemacht. Die erzeugung von FBO/PBuffer findet nun in jeweils
  eigenen Funktionen statt, der Rest wie z.B. MakeCurrent() bleibt in einer Funktion. Auch wenn kein FBO und kein PBuffer 
  vorhanden sind kann nun immer noch in eine 'Textur gerendert' werden... über einfaches glCopyTexSubImage2D(). Hier wird 
  zwar der aktuelle Framebuffer Inhalt immer überschrieben und man ist auf die Bildschirmgröße beschränkt, aber besser 
  als nüschts. Allerdings ist dann die Verwendbarkeit sssehr eingeschränkt, nur das RTT Beispiel lief dann korrekt bei mir, 
  bei den anderen Beispielen wurde natürlich immer der aktuelle Bildschirminhalt überzeichnet da man hier nicht wirklich 
  die Reihenfolge wie etwas gerendert wird beeinflussen kann.
PLRendererD3D9:
- Bei Texturen wurde der letzte Pixel nicht korrekt von dem übergebenen Bild übernommen
PLRenderer:
- Neuer Render State: Ambient: (gleicher Name wie bei den beiden API's gängig) Als ich damit anfing den Renderer zu 
  schreiben, hatte ich diesen State ignoriert da er mir überflüssig vorkam... ist er ja auch irgendwie. ;-)
  Jedoch merkte ich, das D3D 9 und OpenGL jeweils andere Voreinstellungen hierfür haben, bei D3D ist alles schwarz wenn 
  kein Licht in der Szene ist, so wie man es eigentlich auch erwartet. Bei OpenGL hinwegen hat die Szene als Voreinstellung 
  etwas Ambient so das selbst wenn kein Licht in der Szene ist man was sehen kann. Damit das aber jeder selbst so einstellen 
  kann wie er will nahm ich diesen Render State nun doch mit auf. Voreinstellung ist bei uns wie bei D3D schwarz.



>> 29.03.2006
[CO]
PLRendererD3D9:
- In Rectangle Texturen rendern funktioniert nun
- In Cube Texturen rendern funktioniert nun
PLRenderer
- RenderState::SlopeScaleDepthBias & RenderState::DepthBias sollte man nach möglichkeit nie verwenden... als ich im D3D 
  Backend etwas nachging das für mich so aussah als ob der Tiefenbuffer Test deaktiviert ist, merkte ich das OpenGL & D3D
  diese 'Polygon Offset' Werte jeweils etwas anderst Interpretiert. Als ich etwas im Netz nachforschte las ich, das sogar 
  sich das Verhalten dieser Werte von GPU zu GPU unterscheidet, es gibt hier scheinbar keine feste Definition wie das zu 
  Handhaben ist... dadurch werden diese zwei Render States praktisch witzlos. Ich denke/hoffe das erklärt wieso bei Jens 
  unberechenbarerweise beim PerPixelLighting Lichter 'flackerten/verschwanden'. Da das 'anheben' von Tiefenbuffer Werten 
  jedoch vorallem dann wenn etwas in meheren Schritten gerendert wird sehr wichtig ist um 'z-fighting' zu verhindern, 
  musste eine Alternative her. Daher fügte ich einen neuen Render State Namens 'RenderState::ZBias' hinzu. Ist hier ein 
  Wert ungleich null gesetzt, manipuliert der Renderer automatisch etwas die Perspective Matrix. Laut diverser Foren hat 
  man so ein Ergebniss das in etwa auf jeder GPU & API gleich ist, und zumindestens bekam ich so nun bei OpenGL & D3D in 
  etwa gleiche Ergebnisse. :)
  Dokumentierte das auch gleich bei diesen Render State Kommentaren. Die 'anderen' zwei States lies ich jedoch drinnen 
  falls jemand diese aus welchem Grund auch immer verwenden will.



>> 28.03.2006
[CO]
- Renderer + Backends: Verbesserte ein paar Tab/Leerzeichen + schaute das überall wo man einen Zeiger auf Zeiger hat 
  auch 'pp' im Variable Name steht.
PLRendererOpenGL:
- Wenn das hochladen komprimierter Texturen nicht funktioniert, muss im Fallback natürlich ein korrektes anderes Format 
  ausgewählt werden...
PLRendererD3D9:
- Dieses Backend unterstützt nun ebenfalls Vertex Streaming. Vor jedem Draw Call wird geprüft ob sich etwas an den Vertex 
  Daten geändert hat. Ist nur ein Vertex Stream aktiv, so wird die Vertex Declaration direkt von diesem Buffer übernommen.
  Sind jedoch mehrere Streams aktiv, so muss eine Vertex Declaration dynamisch erzeugt werden.



>> 21.03.2006
[CO]
PLRenderer:
- TextureCube: Klassen Beschreibung um 2 ASCII Zeichnungen erweitert so das wirklich klar ist welche Cub Map Textur Seite 
  wo ist.
PLRenderer:
- Renderer::SetVertices(): Die Dokumentation von nOffset war nicht korrekt, der Index ist NICHT in Bytes sondern einfach 
  ein Vertex Index. Eine Bytes Angabe so wie es die API's selbst verlangen wäre hier sowieso gefährlich, denn wenn man das 
  nur um ein Byte verschieben würde stimmen die ganzen Vertex Daten ja nicht mehr! Diesen Doku Fehler merkte ich erst als 
  das Terrain unter D3D 9 nicht korrekt Dargestellt wurde, denn im Gegensatz zum OpenGL Backend wurde dieser Vertex Index 
  direkt an die API weitergeleitet ohne ihn erst mit der Vertex größe zu multiplizieren.
- Renderer::GetTransformState(): Standardmäßig wird nun die Matrize zurückgegeben welche man dem Renderer so übergeben 
  hatte, denn normalerweise braucht man sich nicht um die Innereien scheren. Weglassen kann man diesen optionalen Parameter 
  allerdings nicht, PLMesh::MaterialPass::BindShaderParameter() verwendet diesen um Shader Parameter zu füllen, und die 
  brauchen die konkreten API Matrizen!
PLRendererOpenGL:
- Unnnd ein weiterer Sonderfall den unser OpenGL Renderer automatisch behandeln muss: Ist die automatische Textur Generation 
  auf 'reflection map' gesetzt, so muss die Textur Matrix mit der inversen der View Matrix multipliziert werden - macht man 
  dies nicht, so hat man keine Kamera abhängigen Reflektionen! In dem einen PL Beispiel in dem die Umgebung dynamisch über 
  Cube Maps reflektiert wird hatte ich bis jetzt einen Shader für die Reflektion verwendet, dies ist hier nun unnötig und 
  kompakter. :)
  Da es mittlerweile 2 Dinge sind (rectangle textures, reflection map) welche einfluss auf die Textur Matrizen haben,
  packte ich das alles gleich sauber in eine extra Funktion Namens UpdateCurrentOpenGLTextureMatrix().
PLRendererD3D9:
- VertexBufferD3D9 & IndexBufferD3D9: D3DUSAGE_DYNAMIC und D3DPOOL_MANAGED sind lustigerweise NICHT Kompatibel und wenn 
  man es trotzdem versucht, so geht gar nix mehr - wow, was für eine interne D3D Implementation! :)



>> 18.03.2006
[CO]
RendererOpenGL:
- Get3DCoordinate() war noch nicht ok da die abgefragte View Matrix eventuell gerade nicht aktuell war - daher verwende ich nun 
  die in unserem Renderer gespeicherten Matrizen direkt anstatt mir diese von OpenGL zurückgeben zu lassen. Das werd ich 
  wohl später nochmal etwas umbauen da derzeit diese Funktion auch beim Null & D3D Backend nicht richtig implementiert ist.
  Aber für jetzt erstmal nur soweit das das unter OpenGL sauber funktioniert.



>> 12.03.2006
[SW]
PLRenderer(OpenGL):
- nun wieder übersetzbar unter Linux, plus ein paar wgl* aufrufe im linuxteil entfernt(böser Chris ;)).



>> 10.03.2006
[CO]
PLRendererOpenGL:
- Fing damit an Sicherheits-Abfragen einzubauen falls eine Extension nicht vorhanden ist
- RendererOpenGL: DrawPrimitives() und DrawIndexedPrimitives() verwenden nun, wenn der verwendete Vertex Buffer im 
  Software Modus ist und falls die entsprechende Extension vorhanden ist, glLockArraysEXT() und glUnlockArraysEXT() was in 
  diesem Fall die Performance deutlich verbessert... aber insgesammt ist die Performance im Software Modus natürlich 
  langsamer als die VBO Variante.



>> 09.03.2006
[CO]
PLRenderer:
- SetRenderState(), SetSamplerState(), SetTextureStageState(), SetMaterialState(): Haben nun wie besprochen boolsche 
  Rückgabewerte
- WrappersBackend.inl etc. gibt es nicht mehr, das wird nun direkt in z.B. SetRenderState() geprüft - dadurch müsste man 
  besser auf Fehleingaben reagieren können.
- Resource: BackupDeviceData() & RestoreDeviceData() bekommen nun einen Zeiger auf einen Zeiger auf 
  PLGeneral::uint8 als Parameter. Hier können/sollten alle Resourcen ihre Backups anlegen und dann in RestoreDeviceData() 
  auch wieder freigeben. Zum einen muss dadurch nicht mehr ein Zeiger pro Resource auf ein eventuelles Backup gespeichert 
  werden (jipi, wir sparen 4 Byte :), aber der viel größere Vorteil ist, das es nun relativ leicht zu realisieren sein 
  sollte während der Laufzeit von einem Renderer zu einem anderen zu wechseln. (z.B. von Direct3D zu OpenGL) In dem Fall 
  werden einfach die Daten aller Resourcen 'weggespeichert' und dann dem neuen Renderer zum 'Restore' übergeben. WIE genau 
  die jeweiligen Resource Typen ihre Daten wegspeichern ist dabei diesen Resourcen selbst überlassen. Aber fürs erste 
  ist dies wirklich nur zum einfachen Wiederherstellen der Daten nach z.B. dem wechsel des Bildschirm Modus.
- Die einzelnen Texturen haben nun nur noch GetNumOfBytes() anstatt AllocateMemory() Funktionen, diese Funktion gibt nur 
  zurück wie groß ein Buffer sein muss um diese Texture zu speichern und belegt nicht gleich Speicher. Mipmaps oder Texture 
  Kompression werden hier nicht berücksichtigt.



>> 03.03.2006
[CO]
PLRenderer:
- IndexBuffer: MaxVertexIndexUShort (=65536) Konstante hinzugefügt. Hat ein Vertex Buffer weniger als 65536 Vertices, so 
  kann man beim Index Buffer den Typ UShort nehmen.
- 'Renderer Flags'-Definitionen (PLERFlags) in die 'Renderer'-Klasse verschoben
- 'PL_MAX_PIPELINE_CHANNELS'-Definition in die 'VertexBuffer'-Klasse verschoben
- Nahm an einigen stellen wie z.B. 'RendererBackend::GetMaterialState()' unnötige 'Sicherheit-Abfragen' raus... wenn solche 
  Werte kommen, dann läuft gerade wirklich etwas total schief... ;-)
- Renderer Definitionen Umstellungen fertiggestellt, ob die Namen der diversen Namespaces so ok sind, wird sich noch zeigen
- Passte alle Projekte an diese Renderer Änderungen an



>> 02.03.2006
[CO]
- Dort wo möglich werden nun die statischen Objekte von z.B. Quaternion verwendet statt neue Temporäre Objekte zu erzeugen
PLRenderer:
- 'Vertex Attribute Semantic'-Definitionen verschob ich direkt in die 'VertexBuffer'-Klasse da es nur hier verwendet wird
- 'Vertex Attribute Type'-Defintionen direkt in die 'VertexBuffer'-Klasse verschoben. Das alte 'PL_VAT_COLOR' musste ich in 
  'RGBA' umbennen da bereits die Semantic eine 'Color'-Definition hat.
- Die 'Vertex Attribute'-Struktur verschob ich ebenfalls direkt in die 'VertexBuffer'-Klasse
- 'Vertex index type'-Definitionen direkt in 'IndexBuffer'-Klasse verschoben
- 'Resource Types'-Definitionen (PLE_RT) in 'Resource'-Klasse verschoben... man könnte hier Theoretisch diese Resourcen 
  Klassen mit dem RTTI Verwalten, das wäre hier aber meines erachtens unnötiger Overhead. Auch könnte man diese 
  Typ-Definitionen abstrakter halten und z.B. nur 'Buffer' als Resourcen Typ angeben und dann in Buffer weiter zwischen 
  'Index Buffer' etc. unterscheiden, aber auch das wäre ziemlich umständlich. :)
- 'Texture Pixel Formats'-Definitionen (PLE_TPF) in die 'Texture'-Klasse verschoben
- 'Texture Flags'-Definitionen (PLE_TEXTUREFLAGS) in die 'Texture'-Klasse verschoben
- 'Surface Types'-Definitionen (PLE_ST) in die 'Surface'-Klasse verschoben
- 'Shader Parmeter Types'-Definitionen (PLE_SPT) in die 'ShaderParameter'-Klasse verschoben
- 'Texture Surface Flags'-Definitionen (PLETSFlags) in die 'SurfaceTexture'-Klasse verschoben
- Schaute die Header durch um nur nötige Header einzubinden und überall korrekte Predefinitions zu machen
- Passte alle Projekte an diese Renderer Änderungen an
... einige Renderer Definitionen müssen noch umgestellt werden, ist aber wirklich zuviel um alles auf einmal zu machen ;-)



>> 01.03.2006
[CO]
- Änderte wie besprochen im Renderer (Types.h) die Definitionen zu Namespace & Enum Kombinationen so das man alles besser  
  lesen kann. Ein paar gängige Abkürzungen lies ich drinnen wie z.B. 'InvSrcColor' in 'BlendFunc' - hier jedesmal 
  'BlendFunction::InversedSourceColor' zu schreiben wäre heftig. (vorallem wenn Coder Stundenmäßig viel Kohle kosten. ;-)
  Da ich auch gleich wie üblich alle Projekte an diese Änderungen anpasse, wurde ich heute mit dieser Umstellung nicht 
  ganz fertig.



>> 28.02.2006
[CO]
- Ein paar Leerzeichen/Tabs verbessert



>> 25.02.2006
[CO]
- Alles an Quaternion Änderungen angepasst



>> 25.02.2006
[SB]
- Alles an PLGeneral Änderungen angepasst



>> 24.02.2006
[CO]
- Alles an PLGui Änderungen angepasst
- Stellte wie dort wo möglich/sinnig von globalen Definitionen auf Klassen abhängige enum Definitionen um. Beim Renderer 
  hab ich erstmal nichts gemacht da diese Umstellung dort eine größere Sache wird.



>> 23.02.2006
[CO]
- Alles an PLGeneral Änderungen angepasst



>> 22.02.2006
[CO]
- Die Haupt-Header der Projekte haben nun am Anfang des Namens wieder ein PL
- Doxygen Makefiles angepasst
- Alles an PLMath Änderungen angepasst



>> 21.02.2006
[CO]
- Alles an aktuelle PLMath Änderungen angepasst (ein paar Dinge sind noch nicht ganz ok)



>> 10.02.2006
[CO]
- Alles an Stack & PLMath Änderungen angepasst



>> 06.02.2006
[CO]
- Alles auf String::Format() umgestellt + dort wo möglich von %f auf %g umgestellt da dadurch nur das nötigste ausgegeben wird



>> 25.01.2006
[CO]
- PLRenderer auf Namespace umgestellt



>> 23.01.2006
[CO]
- An uint32 Änderungen angepasst



>> 19.01.1006
[CO]
- Alles an PLMath & PLGui Änderungen angepasst



>> 18.01.2006
[CO]
- Alles an PLGeneral Änderungen angepasst



>> 13.01.2006
[CO]
- Stellte alle Projekte 'über' PLGui auf die neue String Klasse um - nur an den stellen wo String Variablen vom RTTI genutzt 
  werden wird noch die alte Klasse verwendet.



>> 01.01.2006
[CO]
- Passte überall das aktuelle Jahr an, also von 2002-2006
PLRendererOpenGL:
- FrameBufferObject::CheckFrameBufferStatus(): Arbeitet nun korrekt - hier muss man zuerst den Draw & Read Buffer auf Null 
  setzen, ansonnsten gibt 'glCheckFramebufferStatusEXT' IMMER einen Fehler zurück.
- Rendern in Cube Texturen funktioniert nun



>> 30.12.2005
[CO]
- Fand in den verschiedenen Projekten noch ein paar Stellen wo nun PLTString verwendet werden kann, und stellte entsprechend 
  um



>> 29.12.2005
[CO]
PLRenderer:
- Verschob ein paar Funktionen der Renderer Backends in die Backend Klasse
- Machte diverse Funktionen der Renderer Resourcen protected - somit sind die Interfaces etwas sauberer und der User 
  MUSS die entsprechenden Renderer Funktionen verwenden anstatt direkt die Resource Funktionen. Das machte zwar die 
  Implementation in den konkreten Renderer Backends teils etwas tricky, aber die Interfaces mit denen der User arbeitet 
  sind denk ich wichtiger.



>> 06.12.2005
[CO]
- PLTRendererShaderD3D9 & PLTRendererShaderOpenGL: RecurseProgramParameters(): Ist ein Shader Parameter ungültig oder 
  wird von Cg ausoptimiert da dieser nicht verwendet wird, so wird dieser Parameter nun komplett irgnoriert und eine 
  entsprechende Nachricht wird ins Log geschrieben... ansonnsten zickte Cg herum wenn dieser Parameter trotzdem verwendet 
  wurde. ;-)
  Desweiteren verwenden nun die Shader auch Hash Tables für einen schnelleren Zugriff auf Parameter über ihren Namen.
- Stellte aktuelles PL SDK zusammen, das vorherige ist schon wieder 2 Monate alt.



>> 05.12.2005
[CO]
- Machte PLTSurfaceListener flexibler: Diese Klasse Rendert nun selbst KEINE Informationen wie FPS oder Gui mehr. Genauso 
  wie z.B. das löschen des aktuellen Frame Buffers wird das nun über spezielle Scene Nodes geregelt. PLTSurfaceListener 
  selbst verwendet nun NUR noch einen Scene Renderer Query... somit ist das mit dem Scene Rendern nun sauber getrennt 
  von den Surface Listenern. Ein 'Scene Renderer' selbst ist nun ein 'Scene Query' was besser ins Design passt und auch 
  recht nett zu bedienen ist. Diese neue Query-Klasse hat nun also wie gehabt EINEN Scene Container für seine Scene die sie 
  Darstellen soll, jedoch wird hier zwischen 'Root' und 'Scene' Container 'unterschieden'. Hier ein Beispiel wie so ein 
  Root-Container in der Praxis aussieht:
    PLTSceneContainer  (Root Container)
      PLTSNClear
      PLTSceneContainer  (Scene Container mit der eigentlichen 'Szene')
        PLTSNCamera
        PLTSNSky
        PLTSNObject
        ...
      PLTSNGui
      PLTSNEngineInformation
      PLTSNConsole
  Somit kann man das was nacheinander gerendert werden soll also selbst komplett bestimmen. Die 'Unterscheidung' zwischen 
  Root & Scene war nötig da es vorkommen kann das die 'eigentliche' Scene für z.B. Reflektionen/Refractionen mehrmals 
  in einem Frame von verschiedenen Perspektiven gerendert werden muss. In diesem Fall ist es aber meistens unpraktisch wenn 
  hier dann auch gleich automatisch die Kamera gesetzt, der Frame Buffer gelöscht und am Ende noch Dinge wie Gui, Engine 
  Informationen oder gar die Konsole gerendert wird. 'Root' enthält also quasi Pre/In/Post-Order Dinge, wobei 'In' 
  die eigentliche Scene ist.
  Zuerst wollte ich Dinge wie PLTSNClear, PLTSNFog die ja nicht 'wirklich richtige' Elemente der Scene sind zu nicht Scene 
  Nodes machen und es dann so handhaben das PLTSurfaceListener das selbst macht. In diesem Fall hätte dieser also noch Dinge 
  wie Frame Buffer löschen/Konsole Darstellen direkt selbst gemacht und der User hätte spezielle Funktionen in dessen 
  Interface gehabt um diese Dinge Einstellen zu können... so ist es üblich bzw. so machen es die meisten. Jedoch wäre das 
  ein unschöner Style-Bruch gewesen und man hätte an Flexibilität verloren, darum die Radikale Variante auch Dinge wie das 
  Ingame Gui gleich über eine Scene Node Darstellen zu lassen.
- Musste PLTSQSceneRenderer noch die Funktion SetRenderTarget() verpassen da es z.B. beim Post Processing nötig ist GLEICH 
  am Anfang eine Textur als neues Render Target zu setzen. Würde dies erst wie gehabt in 'DrawSceneContainer()' passieren, 
  so wäre in dieser Textur Schrott und Grafik-Fehler treten auf... 
- Nahm den Scene Manager heraus da dieser Manager Problematisch war. (der haupt PLTSceneContainer konnte hier ja nicht vom 
  RTTI richtig durch die Singleton-Klasse Initialisiert werden)
  Dafür gibt es nun PL::GetRootSceneContainer() was im Prinzip das gleiche ist, nur das PLTSceneContainer hier vom RTTI 
  erzeugt wird und dadurch auch richtig Initialisiert wird. Eine andere Lösung fällt mir hier nicht ein... aber ich denke 
  das ist ok so - so eine 'Root Node' findet man in vielen Engines. (iiiirrrgendwo muss es ja anfangen ;-)
- PL::GetDefaultSurfaceListener(): Erst wenn diese Funktion zum ersten mal aufgerufen wird, wird der Default Surface 
  Listerner erzeugt - meistens braucht man diesen nicht, nur für kleine Anwendungen ist er praktisch.



>> 04.12.2005
[CO]
- Sobald ein Fragment Shader Texturen verwendet wird es etwas Tricky da man vorher nicht weis in welcher Textur Unit eine 
  Textur von Cg am Ende landet. Daher muss man nach dem setzen des Shader Parameters abfragen in welcher Textur Unit die 
  Textur nun 'sitzt' und den Renderer entsprechend darüber Informieren. Wird dies nicht gemacht sind die Infos über die 
  aktuell gesetzen Texturen eventuell falsch was sich dann in falschen Texturen beim Rendern äußert.



>> 02.12.2005
[CO]
PLRenderer:
- Etwas an den Occlusion Queries gefeilt



>> 22.11.2005
[CO]
PLRendererOpenGL:
- Stefan fand heraus das NVIDIA Karten bei Rectangle Texturen keine Kompression mögen (zumindestens auf den Karten wo wir 
  es Testen konnten: GeForce 4/5) obwohl es laut Dokumentationen gehen müsste...
  Daher erweiterte ich das hochladen der Texturen zur GPU um Anfragen ob gerade Textur Kompression verwendet werden soll und 
  wenn ja, ob das hochladen klappte. Wenn ein Fehler auftrat, so wird automatisch ein Textur Format ohne Kompression als 
  Fallback gewählt.



>> 20.11.2005
[SB]
- Aufrufe von PLTContainer::Add() angepaßt
- Include <Log.h> eingefügt



>> 10.11.2005
[CO]
PLRenderer:
- PLTRendererBuffer: Allocate() kennt nun einen weiteren Parameter welcher angibt ob dieser Buffer 'Managed' ist oder nicht. 
  Ist die Verwendung als PL_USAGE_SOFTWARE Definiert, so hat dieser neue Parameter keine Auswirkung. Im Null Renderer wird 
  dieser Parameter ebenfalls Ignoriert. Im D3D Renderer hingegen wird dann in den Buffern gesagt das D3D diesen Buffer 
  Verwalten soll. Unter OpenGL musste eine eigene Lösung implementiert werden die eine Kopie des Buffers im Arbeitsspeicher 
  hält. Der Performance Gewinn bei 'Managed-Mode' ist leider nicht wirklich sonderlich groß, aber jedes bischn mehr an 
  Performance hilft. Bei Allocate() kann man als letzten Parameter noch angeben ob der aktuelle Buffer Inhalt erhalten 
  bleiben soll oder nicht... meistens braucht man den Inhalt nicht mehr, aber könnte sein das dies mal Praktisch ist.
- PLTRendererBuffer: Wie gestern kurz mit Stefan besprochen, habe ich das Lock/Unlock etwas verändert. Bis jetzt war es so 
  das man nur einmal Lock() aufrufen konnte, war der Buffer bereits gelockt, so wurde NULL zurückgegeben. Wenn es sauber 
  laufen sollte musste man also vorher mit IsLocked() prüfen und wenn der Buffer bereits gelockt war diesen so direkt 
  verwenden - und nur wenn man ihn selbst gelockt hatte musste man ihn auch selbst wieder freigeben... das war ziemlich 
  Fehleranfällig und Umständlich zu bedienen. Nun ist es so, das intern eine art von 'Reference Counter' vorhanden ist. 
  Bei jedem Lock wird um eins erhöht, bei jedem Unlock um eins verringert, intern wird der Buffer selbst korrekt gelockt 
  wenn es der erste Lock ist, und wieder freigegeben wenn es das letzte Unlock war. Die Funktion IsLocked() wurde durch 
  GetLockCount() ersetzt. Passte überall die Codes entsprechend an... so ists nun viel schöner zu Bedienen.
  Einige Funktionen wie Clear() 'erzwingen' intern Unlock(), allerdings lässt sich das leider kaum anderst lösen... man 
  könnte natürlich diese Funktionen wenn der Buffer locked ist 'sperren', aber das könnte gleiche Probleme machen. Der 
  Benutzer muss selbst Lock/Unlock 'gewissenhaft' aufrufen. Also nicht EINMAL Lock und dann sich die Zeiger selbst irgendwo 
  fest speichern und meinen dieser Zeiger wäre immer gültig selbst wenn der Buffer gekillt wird. ;-)
  (auf diese Dinge wird in den Kommentaren deutlich hingewiesen)



>> 08.11.2005
[CO]
PLRenderer:
- PLTRendererFrame: Neue Funktionen: GetFullscreenAltTab(), SetFullscreenAltTab(): Damit ist es möglich unter Windows 
  alt-tab im Vollbild Modus zu unterbinden.
- Fügte 10 neue Texture Formate hinzu welche es unter OpenGL & Direct3D gibt, es gibt zwar noch viele mehr... aber die 
  jeweils andere API kennt diese Texture Formate nicht. Sollte es später mal nötig sein diese Formate welche NUR die eine 
  oder andere API kennt einzubauen, so kann man dies ja immer noch.
- Verbesserte/erweiterte Shader Support: CreateVertexShader()/CreateFragmentShader() nehmen nun weitere optionale Parameter 
  an. Darunter u.a. zusätzliche Definitionen welche dem Shader hinzugefügt werden sollen. Dies kann dann Praktisch werden 
  wenn man z.B. bestimmte 'Features' in einem Shader beim erzeugen 'aktivieren/deaktivieren' will. Die OpenGL/D3D Renderer 
  fügen diesen Definitionen selbst noch etwas hinzu... z.B. '#define OPENGL'/'#define D3D', so 'weis' man im Shader welche 
  API gerade verwendet wird, z.B. MUSS man bei OpenGL 'texRECT' für Textur Zugriffe verwenden wenn es sich um Rectangle 
  Texturen handelt, unter D3D hingegen ist dieser Befehl unbekannt und es muss hier wie bei normalen 2D Texturen 'tex2D' 
  verwendet werden. Innerhalb der Renderer Backends muss der konkrete Shader also 'zusammenkopiert' werden. Passte die 
  Shader in 'PLPostProcessEffects.pak' entsprechend an so das diese auch unter D3D verwendbar sind.



>> 07.11.2005
[CO]
PLRenderer:
- VertexBuffer: Allocate(): Etwas verfeinert da es zulässig sein soll einen bereits angelegten Vertex Buffer nachträglich zu 
  ändern... z.B. die Anzahl der Vertices und/oder die Verwendung. Das hinzufügen neuer Vertex Attribute war ja bereits auch 
  nach Allocate() möglich... diese Dinge sind zwar nicht wirklich Performant da der Inhalt der Buffer umständlich 
  herumkopiert werden muss - möglich sein soll es aber da es hier und da ganz Praktisch ist.



>> 04.11.2005
[CO]
PLTRendererOpenGL
- Clear(): Wenn der ZBuffer gelöscht wird, so wird Z Write Enable zur Sicherheit aktiviert - ansonnsten kann es sein das 
  der Z Buffer nicht gelöscht wird.



>> 29.10.2005
[CO]
PLRenderer:
- Begin2DMode() und End2DMode() ändern keine Render States mehr, dies muss der User schon selbst so machen wie er es braucht 
  und es ist eher ungeschickt diese States hier zu ändern.



>> 28.10.2005
[CO]
PLRendererOpenGL:
- PLTRendererBackendCg: Man kann nun die automatische Fehler Callback Funktion aktivieren/deaktivieren - beim einladen 
  von Shadern ist diese Callback Funktion z.B. ziemlich unpraktisch, denn nach dem Laden ist es Sinnvoll selbst abzufragen
  ob ein Problem auftrat um dann entsprechend darauf zu reagieren.
- PLTRendererShaderOpenGL machte noch etwas Probleme: In Init() gabs bei cgCreateProgram() auf meiner GeForce4 Ti 4200 
  bei machen Fragement Shader einen merkwürdigen Crash wenn das Profile CG_PROFILE_FP20 verwendet wurde. Daher habe ich 
  hier nun einen 'hack' eingebaut der sobald CG_PROFILE_FP20 verwendet werden soll CG_PROFILE_ARBFP1 auswählt welches keinen 
  Crash verursacht - ob der Shader überhaupt auf der Karte läuft oder nicht kann man ja erst danach feststellen. ;-)
  Bei cgGLLoadProgram() wird die automatische Cg Fehler Callback Funktion nun deaktiviert um auf eventuell aufgetretene 
  Fehler reagieren zu können, ansonnsten wurden nicht verwendbare Shader nicht erkannt und verwendet was zu Problemen 
  führen konnte.
- PLTRendererOpenGL::DrawIndexedPrimitives(): glDrawRangeElementsEXT kann nur eine bestimmte Daten Menge verarbeiten, passt 
  man hier nicht auf kann es zu Problemen kommen



>> 27.10.2005
[CO]
PLRenderer:
- Erzeugt man eine Texture in welche man Rendern kann, kann man nun noch optionale Flags mitgeben. Als Standard ist gesetzt 
  das diese Render Targets auch Tiefen & Stencil Buffer haben sollen. Bei z.B. den zwei internen Post Processing Render To 
  Texturen braucht man jedoch keinen Tiefen & Stencil Buffer... und wird kein Stencil Buffer benötigt, so versucht der 
  OpenGL Renderer die schnelleren FBO's zu verwenden. (FBO & Stencil Buffer derzeit leider nix gut) Man sollte hier also 
  immer nur das setzen was man auch wirklich benötigt so das die jeweiligen Renderer hier intern selbst das Optimalste 
  verwenden können. Man MUSS aber nichts genaueres angeben, in dem Fall ist man selbst Schuld wenn die Performance zu 
  wünschen übrig lässt. (wenn man nicht genau sagt was man denn gerne hätte, bekommt man halt irgendwas das den meisten 
  wohl reicht ;-)
  Ist hier nun also ein brauchbarer Kompromiss so das man im günstigen Fall auf das flotte FBO zurückgreifen kann - was der 
  Post Processing Performance deutlich zugute kommt da hier vorallem bei Effekten wie Bloom extrem häuftig Render Targets 
  gewechselt werden müssen was mit pbuffern eine wirklich ziemlich lahme Angelegenheit ist!
  Bei meinen Messungen (PLSampleNewtonCharacterController, 800x600 Fenster, start Ansicht) hatte ich bei aktivem Bloom und 
  mit reinem pbuffer bei aktiven Schatten 28 FPS, ohne Schatten 45. Mit FBO wenn möglich, (also wenn kein Stencil Buffer 
  benötigt wird was beim Post Processing der Fall ist) hatte ich hingegen bei aktiven Schatten 34 FPS, ohne 60. Beim HDR 
  Test hatte ich bei Standard-Einstellungen statt 16, 17 FPS... man merkt also einen 'minimalen' Performance Gewinn, und je 
  mehr FPS man generell hat desto krasser merkt man einen Unterschied zwischen pbuffer & FBO. :)



>> 06.10.2005
[CO]
PLRenderer:
- Hier kann man nun ein paar weitere States 'fixieren' so das diese nicht mehr geändert werden können.



>> 29.09.2005
[CO]
PLRenderer:
- Beim beenden werden die Resourcen & Oberflächen nun korrekt gelöscht, desweiteren wird der Vollbild Modus jetzt korrekt in 
  die Konfiguration zurückgeschrieben. Beim beenden wird einfach geprüft ob noch ein Fenster im Vollbild Modus ist, wenn ja 
  wird in der Konfiguration 'Fullscreen=1' gesetzt.
PLRendererOpenGL:
- Neue unterstützte Extension: GL_ARB_draw_buffers ist die 'offizielle' neue Variante von GL_ATI_draw_buffers
  Diese sind also völlig Identisch - nur halt nen anderer Name. 'Natürlich' friert auch hier nach ein paar Sekunden das 
  System einfach ohne erkennbaren Grund ein, darum ist auch diese Extension erstmal aus Sicherheitsgründen Deaktiviert.



>> 18.09.2005
[CO]
PLRenderer:
- Neue Funktionen: DrawLines2D(), DrawLines3D(), DrawPoints2D() und DrawLines3D() für das relativ Performante Zeichnen mehrer 
  Linien/Punkte auf einmal.
PLRendererOpenGL:
- PLTRendererSurfaceTextureOpenGL & PLTRendererSurfaceWindowOpenGL: Weiteren Bug behoben: Sobald eine Oberfläche zerstört 
  wird, wird nun versucht die Haupt Oberfläche des OpenGL Renderers zu setzen, erst wenn dies nicht funktioniert wird Null 
  als aktuell gesetzt und OpenGL Befehle haben keine Wirkung mehr. Das machte anderst in PixelLab Probleme: Ich hatte zuerst 
  den Mesh Editor offen, schloss diesen und öffnete den Scene Editor - hier viel mir aber dann auf das plötzlich Meshs wie 
  die Pfeile bei den Transformern nicht mehr Darsgestellt wurden und fand heraus das die Vertex Buffer nicht erzeugt wurden - 
  das lag daran das beim schließen des Mesh Editors die Fenster beim zerstören Null als Current setzen und die Mesh Buffer 
  erzeugt wurden während gerade kein aktueller OpenGL Context gesetzt war. Soetwas ungeschicktes kann nun nicht mehr 
  passieren. :)



>> 16.09.2005
[CO]
PLRenderer:
- PLTRendererSurfaceListener: Im Destruktor trägt sich nun dieser Listener wieder bei den Surfaces aus
- Merkte in PLSampleMultiView das es praktisch ist wenn die Fenster nach dem wechsel von Vollbild zu Fenster Modus wieder an 
  ihrer alten Position etc. sind. Daher erweiterte ich PLTRendererFrame entsprechend. So ists möglich in PLSampleMultiView 
  bequem ein Fenster nach dem anderen in den Vollbild Modus und wieder zurück zu schalten.
PLRendererOpenGL:
- RestoreDeviceStates() beachtet nun auch das gesetzte Render Flags das setzen von States verhindern können - hier wollen 
  wir aber ALLES setzen.



>> 15.09.2005
[CO]
PLRendererOpenGL:
- Wechselt man den Bildschirm Modus werden nun auch die Device States korrekt zurückgesetzt
PLRenderer:
- PLTRendererShaderParameter::SetValueTexture() war noch nicht ok, dadurch bekamen Texturen Handler welche aber nicht wieder 
  korrekt abgemeldet wurden. Auch beim Destructor von PLTRendererShaderParameter musste man noch Texture Handler beachten. 
  Diese zwei Dinge konnten heftige Crashs verursachen.
- PLTRendererSurface hatte auch noch so einige heftige Bugs zu bieten: ClearListeners() Informiert nun auch diese Listener 
  und beim Destructor wird nun ClearListeners() aufgerufen.
- Spendierte PLTRendererSurface BackupDeviceData() und RestoreDeviceData. (wie bei Renderer Resourcen)
  PLTRendererSurfaceTextureOpenGL implementiert diese zwei Funktionen um den pbuffer anzugleichen - ansonnsten konnte es 
  zu Problemen kommen.
- Wechselt ein Fenster in den Vollbild Modus, so wird es nun in PLTRendererFrame::InitWindow() links oben Positioniert. 
  (irgendwie sinnig das ;-) 
--> Ich konnte nun keine Probleme mehr feststellen wenn man zwischen Vollbild und Fenster Modus wechselt, egal wie häufig 
    man das macht - am laufenden Band den Fenster Modus ändern ist ein Spaß für groß und klein. ;-)



>> 14.09.2005
[CO]
PLRenderer:
- Etwas am Direct3D Backend geschraubt. Gibt aber immer noch viele Details zu verbessern. Das Rendern in mehrere Texturen 
  gleichzeitig funktioniert allerdings bereits super - im OpenGL hab ich ja noch diese merkwürdigen Crashs.
  Notierte in der PL_API Dokumentation gleich noch diverse Dinge der Renderer Backends wie z.B. nicht Unterstützte 
  Funktionen. Beim erzeugen von Texturen kann man nun noch Flags mitgeben um z.B. Mipmaps Automatisch erzeugen zu lassen 
  oder um eine Texture auch als Color Render Target verwenden zu können.
- OpenGL backend: Verwendet man Rectangle Texturen, so wird nun die Texture Matrix so skaliert das der User selbst IMMER 
  mit normalisierten Texture Koordinaten arbeitet. Es hatte mich schon immer genervt das es hier eine so unhandliche 
  Texture Koordinaten unterscheidung gibt. Das einzige wo man hier aufpassen muss ist, wenn man Rectangle Texturen mit 
  Shader verwendet muss man in den Vertex Shadern die Texture Matrixen berücksichtigen - ansonnsten stimmen die Texture 
  Koordinaten nicht. (denn die GPU will hier nicht normalisierte haben)
  Zuerst wollte ich diese Texture Matrix Manipulation im D3D Backend machen, denn dieses macht hier keine Unterscheidung - 
  aber dann merkte ich das dies irgendwie anderst herum praktischer ist. ;-)
  U.a. musste ich den Post Process Manager und PLPostProcessEffects.pak umstellen.
- Renderer Statistiken um weitere Werte erweitert
- Post Process Manager: Intern beim Zeichnen einen kleinen Offset hinzugefügt der verhindert das z.B. bei Bloom man oben 
  und rechts Farben ins Schwarze ausblenden sieht



>> 03.09.2005
[CO]
PLRenderer:
- Camera & frustum Funktionen aus dem Renderer entfernt, mittlerweile hat das hier nichts mehr zu suchen, das ist Sache des
  Scene Systems :)



>> 27.08.2005
[CO]
PLRenderer:
- Beim erzeugen etc. von Texturen wird nun PLTImage übergeben anstatt wie bisher direkt die Daten + Informationen wie groß 
  etwas ist etc. Dies hat mehrere Vorteile:
  - Wurde z.B. ein dds Bild eingeladen ist es möglich das die Daten bereits in einem bekannten komprimierten Format wie z.B. 
    DXT5 vorliegen und so muss die GPU nicht mehr selbst komprimieren was den Texture erzeugungs Vorgang deutlich 
    beschleunigt. Somit ist auch endlich sauber geregelt welches Interne Texture Format verwendet werden soll - das war bis 
    jetzt ziemlich chaotisch da ich einfach nicht so recht wusste wie ich wo alle verschiedenen Infos übergeben soll, dank
    PLTImage kein Problem mehr und alles ist sauber verschnürrt.
  - In PLTImage können bereits MipMaps liegen, in dem Fall können diese direkt an die GPU übergeben werden welche diese nicht 
    mehr selbst erzeugen muss. So kann z.B. auch der Grafiker direkt über z.B. das dds Format eigene MipMaps übergeben.
    Allerdings funktioniert das mit diesen eigenen Mipmaps anscheinend noch nicht - scheint irgendwie an DevIL zu liegen. 
    Muss das bei Zeiten mal genauer Untersuchen...
  - Generell ist so das Interface dank weniger zu übergebende Parameter schicker ;-)
- Neue Funktion: GetTexturePixelFormat() -> Gibt das passende Renderer Texture Format eins übergebenen Bildes (PLTImage) 
  zurück



>> 24.08.2005
[CO]
PLRenderer:
- Fand heraus das meine Radion 9600 auch Two Sided Stencil Tests kann, das läuft hier nur nicht unter GL_EXT_stencil_two_side 
  sondern unter einer ATI eigenen Extension Names 'ATI_separate_stencil'. Erweiterte den Renderer intern so das er diese 
  Extension nutzen kann - ein Grund mehr für so nen eigenen Renderer, man muss sich nicht mehr drum kümmern unter welcher 
  GPU man welche Extensions nutzen muss. ;-)
  Bin mal gespannt ob ich dadurch bei mir bei den Shadow Volumes nen kleinen Performance Gewinn feststellen kann...
PLRendererOpenGL:
- Sortierte Extensions nach WGL, SGIS, EXT, ARB, ATI - so ists nun etwas Übersichtlicher
- PLTRendererOpenGLExtensions::Init() in Linux & Win32 cpp Dateien aufgeteilt - so ist es übersichtlicher. Hier komplett 
  getrennte Klassen/Ableitungen zu machen schien mir als etwas zu viel Aufwand, denn ifdef muss man so oder so machen, wenn 
  nicht hier dann beim konkreten verwenden einer solch abgeleiteten Klasse.
- Das gleiche bei PLTRendererSurfaceWindowOpenGL, statt abgeleiter Klasse einfach getrennte cpp Dateien - ansonnsten müsste 
  man jedesmal wenn man PLTRendererSurfaceWindowOpenGL verwendet casten um z.B. bestimmte Plattform abhängige Dinge zu 
  bekommen. (wäre ebenfalls nur verschobener Aufwand :)
- Die neue angedachte Plattform Klasse hab ich erstmal weggelassen da mir das momentan als etwas zuviel Aufwand für zuwenig 
  Nutzen erschien - im Prinzip läge dort derzeit eigentlich nur MakeCurrent drinnen welches aber unter Linux mehr Parameter 
  hat als unter Windows und man es daher nicht so ohne weiteres in ein einheitliches Interface quetschen könnte. Generell 
  sind recht wenig Plattform abhängige ifdefs drinen so das dies noch recht Übersichtlich ist. Das einzig unübersichtliche 
  war eigentlich das mit den Extensions und Window da hier mehr als nur eine Zeile Code je Plattform anderst ist. ;-)



>> 20.08.2005
[CO]
PLRendererOpenGL:
- PLTRendererOpenGL::SetRenderTarget(): Licht & allgemeine OpenGL Einstellungen werden nun ebenfalls korrekt gesetzt wenn 
  PBuffer verwendet werden - damit verschwindet endlich ein nervender 'Grafik Fehler' bei z.B. Post Processing Effekten.



>> 01.08.2005
[CO]
PLRenderer:
- Accumulation Buffer Funktionen hinzugefügt welche zumindestens unter OpenGL verwendet werden können



>> 18.07.2005
[CO]
PLRenderer:
- Stellte den Renderer auf Cg 1.4 um. Danach traten sehr merkwürdige Texture Probleme auf. Als ich der Sache genauer auf 
  den Grund ging stellte ich fest das in PLTRendererShaderParameterOpenGL::SetValueTexture() (und D3D0) noch eine Abfrage
  für PL_RT_TEXTURERECTANGLE fehlte - desweiteren muss man am Ende diesen Sampler noch mit cgGLEnableTextureParameter()
  aktivieren. (aber nur unter OpenGL) Lustig das dies erst ab der neuen Cg Version Probleme bereitete. :)
  PLTMaterialPass::BindShaderParameter() übergebe ich Cg nun die aktuelle gesetzte Texture anstatt der Textur des Material
  Passes - denn es kann sein das das Material bestimmte Texturen nicht setzt da diese 'global' vom aktuellen Renderer
  gesetzt werden.
- ATI Unterstützt nun ENDLICH in seinen Treibern FBO! (EXT_framebuffer_object) Ist diese Extension vorhanden, so wird nun 
  diese anstatt des lngsamen und total umständlichen pbuffers verwendet. Leider machen noch floating point buffer und 
  Rectangle Texturen Ärger und ich kann einfach nicht herausfinden wieso dies so ist - hoffentlich 'nur' ein Treiber
  Bug dieser neuen Extension. Desweiteren werden Stencil Buffer wie in der Extension Spezifikation angegeben ist noch 
  nicht... schade das es hier noch solche Probleme mit den FBO gib, denn diese sind wirklich eine sehr feine Sache. :)
  Daher hab ich die verwendung von FBO erstmal in PLTRendererOpenGLExtensions::Init() deaktiviert bis das richtig 
  funktioniert.
- Musste OpenGL Header (gl.zip) aktualisieren
- Erweiterte den Renderer um die Möglichkeit in mehrere Texturen gleichzeitig zu rendern. (GL_ATI_draw_buffers, auch NV) 
  Die aktuelle Implementation ist noch eher Experimentell - im Endeffekt 'müsste' man das Rendern in Texturen im Renderer
  nun neu Designen da der FBO sehr universell ist - genauso wie diese Dinge in D3D9. Z.B. können sich mehrere Render Targets
  Tiefen und Stencil Buffer 'teilen'... und die neusten Karten können gar soweit ich mitbekommen habe in Vertex Buffer 
  'rendern'. Aber fürs erste reicht diese Experimentielle Implementation.
  Alles was man machen muss ist, nach dem setzen des Render Targets noch die Texturen als Color Render Targets angeben in 
  die gleichteitig gerendert werden soll. Danach kann man in Fragment Shadern als Ergebniss nicht nur COLOR sondern COLOR0, 
  COLOR1 etc. angeben - jede entspricht dann einer dieser Texturen. Man kann dann also damit in nur einem Render Schritt 
  in einem Shader sehr viel mehr Daten ausgeben als dies mit nur einer Textur möglich wäre. So kann man in einer Textur die 
  normalen Farben ausgeben, in der anderen die Positionen, Normalen etc. Mit diesen Daten kann man dann noch coolere Post
  Processing Effekte wie z.B. Tiefenunschärfe ohne ZU VIEL AUFWAND Realisieren. Ansonnsten müsste man die komplette Szene
  ein paar mal neu Rendern nur in jeweils andere Texturen mit anderen Shadern um die gewünschten Informationen in Textur 
  Form zu bekommen die man dann an den Post Process Manager übergeben müsste.
  Leider funktioniert die FBO Implementation von MRT noch nicht so recht - es gibt keine Fehler/Warnungen... das erwartete
  Ergebniss bleibt einfach aus. Und die PBuffer Implementation ist irgendwie ebenfalls Buggy - bin ich im Debug Modus
  und lasse das Programm bei jedem Frame 'anhalten' so geht alles gut. Lasse ich es aber so laufen friert das gesammte
  System nach ein paar Sekunden ein und der Bildschirm wird ein paar Sekunden später schwarz so das ich das ich den 
  Rechner neu starten muss. Ein MRT Demo welches ich am laufen hatte und welches im Code anscheinend nichts anderst macht 
  ging jedoch merkwürdigerweise - ohman, ich HASSE solche Probleme. Da weis man nie obs nen Treiberbug ist oder ob an 
  iirrrgendeiner Stelle etwas nicht zu 100% Passt - aber dann gleich das ganze System ohne ersichtlichen Grund lamgelegt 
  ist schon hart. :(
  Daher deaktiverte ich MRT erstmal in PLTRendererOpenGLExtensions::Init() - sicher ist sicher. :)



>> 15.07.2005
[CO]
- Ein paar Ordner wie 'lib3ds' oder 'TriStripper' haben nun vorne ein '_'. Steht am Anfang eines Namens ein '_' oder '.' so
  werden diese vom 'CreateSDK.py'-Skript ignoriert



>> 07.07.2005
[SB]
PLRendererOpenGL:
- pbuffer.cpp: Habe <glut.h> aus den Includes entfernt, da wir diese Library nicht benötigen
  und sie daher auch nicht bei den libs mit dabei ist. Durch das Einbinden dieser Include-Datei
  jedoch wurden alle GL-Libs automatisch dazugelinkt, inklusive GLUT. Hab außerdem das Projekt
  für PLRendererOpenGL angepaßt, daß die GL-Libraries nun im Projekt dazugelinkt werden.



>> 22.06.2005
[CO]
PLRendererOpenGL:
- DrawBox() und SetTexture() etwas Optimiert



>> 14.06.2005
[CO]
- PLRenderer: PN-Triangles (TRUFORM) Support hinzugefügt. Gibts zwar nur auf ATI Karten (MUSS desweiteren im Treiber 
  aktiviert sein) und mit GPU Skinned Meshs wirds Probleme geben (da die Matrix Indices nicht Interpoliert werden 
  können :) - ist aber trotzdem nen nettes Feature und recht leicht zu verwenden... eigentlich nur aktivieren und 
  Tesselation Level setzen. (Vertex Normalen MÜSSEN vorhanden sein und passen)
  Fügte entsprechendes PN Triangles Beispiel Programm hinzu.
  Bei Zeiten muss ich mir mal was im Material mit den Render-States etc. überlegen - denn mittlerweile haben wir gut
  50 solcher Einstellungen und die jedesmal prüfen etc. wird sicherlich auf dauer etwas Lam.



>> 11.06.2005
[CO]
PLRendererOpenGL:
- Um WGL_EXT_swap_control erweitert mit dem man unter Windows V-Sync aktivieren/deaktivieren kann



>> 11.05.2005
[CO]
OpenGL Renderer:
- Render To Texture kann nun auch Optional beim PBuffer glCopyTexSubImage2D() verwenden um die Textur zu
  füllen falls das direkte Füllen nicht funktioniert. (ist bei mir z.B. bei Rectangle Textures der Fall)



>> 01.05.2005
[CO]
PLRendererOpenGL:
- Render To Texture überarbeitet - es wird nun eine extra PBuffer Klasse verwendet welche einigermaßen
  handhabbar ist und zumdem auch unter Linux laufen müsste. Aber was immer noch ziemlich doof ist, das 
  jeder pbuffer seinen eigenen Context hat... nicht sonderlich Performant und man muss jedesmal beim setzen eines
  Render Targets alle aktuellen Render States Updaten - in PLTRendererOpenGL::SetRenderTarget() fehlte noch das zurück
  setzen der Texturen und Shader... einfach nur Ärgerlich. (ich brauchte einige Zeit bis ich diesen 'Bug' gefunden hatte)
  Sobald die aktuelle FBO Extension auch von den ATI Treibern unterstützt wird werd ich dann, wenn diese FBO verfügbar sind
  diese anstatt pbuffer verwenden.



>> 30.04.2005
[CO]
- PLTRendererShaderOpenGL & PLTRendererShaderD3D9 können nun auch Programm Parameter des Typs 
  CG_STRUCT & CG_ARRAY Registrieren



>> 19.04.2005
[CO]
PLRenderer:
- In Cube Maps Rendern müsste nun korrekt funktionieren, bis jetzt fehlte bei SetRenderTarget() noch die Optionale
  Cube Map Textur in welche gerendert werden soll. (teste ich die Tage mal aus wenn ich Dynamische Cube Maps
  austeste :)
  Desweiteren implementierte ich noch Support für Rectangle Texturen deren Größe kein vielfaches von 2 sein muss.
  Dafür haben diese Texturen ein paar Nachteile da die GPU's dort diverse Features nicht unterstützen, desweiteren
  sind die Textur Koordinaten dort nicht nomalisiert was die Verwendung leider etwas umständlich macht. Aber 
  zumindestens für Ingame Guis kann man es sehr gut gebrauchen. :)



>> 06.04.2005
[CO]
PLRenderer:
- PLTRendererSurfaceWindow: Fügte die Funktionen GetGamma() und SetGamma() hinzu



>> 03.04.2005
[CO]
PLRendererOpenGL:
- PLTRendererOpenGLExtensions spuckt nun noch etwas mehr Informationen über OpenGL aus - hilft beim Auffinden
  von z.B. Shader Problemen wenn man genau weis was die verwendete Hardware so kann. ;-)



>> 29.03.2005
[CO]
PLRenderer:
- PLTRendererBuffer::Allocate() kann nun auch aufgerufen werden wenn der Buffer bereits gefüllt ist. In diesem Fall wird
  er bei bedarf neu gefüllt.



>> 22.03.2005
[CO]
- PLRenderer auf neuen Kommentar-Style umgestellt



>> 16.03.2005
[CO]
PLRenderer:
- Stellte auf Cg 1.3 um. In PLRuntime liegen die aktuellen Cg dll's.
- PLeRFlagLockScissorTestStates hinzugefügt falls erwünscht ist das sich die Scissor Test Render States 
  NICHT ändern dürfen



>> 04.03.2005
[CO]
PLRenderer:
- Unterhalb der Zeichen-Funktionen ist nun ein Block mit 'Selektions'-Funktionen. Dort sind nun diverse neue
  Funktionen welche es in OpenGL Standardmäßig gibt und einem z.B. das Selektieren enorm erleichtern.
  BuildSelectionPlaneSet() befindet sich nun in PLTPlaneSet::CreateSelectionPlanes() - es stellte sich einfach
  heraus das diese Dinge universell Andwendung finden. Im Renderer selbst sind nur noch die 'luxus' Funktionen
  PickMatrix() und CreateSelectionPlanes() welche aktuelle Viewport, Projection- & View-Matrix Einstellungen 
  verwenden, so spart man sich Schreibarbeit wenn man mit den Standard-Einstellungen arbeiten will.



>> 01.03.2005
[CO]
- Begin2DMode() wenn alle Parameter 0 sind werden die aktuellen Viewport Einstellungen verwendet
- Get2DCoordinate() überarbeitet



>> 25.02.2005
[CO]
PLRendererOpenGL:
- DrawTriangle() und DrawQuad() wird nun direkt über OpenGL Befehle gezeichnet anstatt über die allgemeinen
  Vertex Buffer welche unter Direct3D nötig sind.



>> 23.02.2005
[CO]
- Musste in PLTRenderStates leider alle Variablen welche vorher auf bool standen auf uint32 umstellen da die
  Typen unterschiedliche größen haben und dadurch die Werte nicht korrekt gesetzt wurden... nun hat man im
  ClassView leider nicht automatisch ne ComboBox wo man 'false/true' auswählen kann. Darum sage ich nun 
  ClassView über die Annotations wenn eine Variable als boolean behandelt werden soll.



>> 22.02.2005
[CO]
PLRenderer:
- Verpasste PLTRenderStates, PLTSamplerStates und PLTTextureStageStates nettere Namen was nun ja dank Stefans 
  letzter RTTI Erweiterung möglich ist. 'FillMode' liest und schreibt sich netter als 'm_nRS[PL_RS_FILLMODE]'. :)



>> 22.02.2005
[SB]
- Alle Projekte an die neuen RTTI-Makros angepaßt



>> 20.02.2005
[CO]
PLRenderer:
- Fügte RTTI Wrapper Klassen für Render-States etc. hinzu. Diese Klassen werden u.a. vom Material verwendet 
  um diese Einstellmöglichkeiten komfortabler/universeller Handhaben zu können.
  (PLTRenderStates, PLTSamplerStates, PLTTextureStageStates)



>> 18.02.2005
[CO]
PLRenderer:
- Entferne PLTMaterialBase und PLTMaterialBaseFactory aus dem Renderer da nun überflüssig.
- GetStandardMaterial(), SetStandardMaterial(), UseStandardMaterial() entfernt da dafür der Material Manager in der ModelLib
  verantwortlich ist.



>> 13.02.2005
[CO]
PLRenderer:
- Da das Mesh Format geändert wurde hab ich gleich PLE_VAS in die bessere Reihenfolge gebracht.



>> 08.02.2005
[CO]
PLRenderer:
- Neue Vertex Attribute Semantics: PL_VAS_BLENDINDICES & PL_VAS_BLENDWEIGHTS -> Darüber wird man dann für das
  Hardware Skinning (oder auch Matrix Palette Skinning genannt) die Vertex Weights und Vertex Weight Indices
  übergeben. Bei D3D sind diese gleich Definiert, bei OpenGL aber versteckt... darum fand ich erst jetzt heraus
  wie es unter OpenGL geht. Desweiteren noch diverse weitere Semantics eingetagen welche bei D3D so Standard 
  sind und auch bei Cg. Unter OpenGL muss die Extension GL_ARB_vertex_program vorhanden sein damit diese neuen 
  Semantics verwendet werden können.
- Die Reihenfolge von PLE_VAS wird, wenn ich das nächste mal das Mesh Format ändere ebenfalls geändert so wie 
  es üblich ist. Mit dieser neuen Reihenfolge kommt die GPU angeblich noch besser zurecht da intern nicht 
  so viel im Speicher herumgesprungen werden muss.
- GetVertices() & SetVertices() so erweitert das man nun mehrere Vertex Buffer gleichzeitig verwenden kann. 
  Dies ist Praktisch wenn Beispielsweise die Textur Koordinaten immer gleich bleiben, die Positionen & Normalen 
  aber durch Animation sich ständig ändern so das man Position & Normale von Frame 0 und Frame 1 in einem 
  Shader interpolieren muss. Dann von Frame 1 und Frame 2 etc. Da das verwenden mehrer Vertex Buffer nicht so
  performant ist sollte man das wo immer es möglich ist vermeiden. Darum war es mir wichtig das sich 
  GetVertices() und SetVertices() weiterhin so einfach wie möglich verwenden lassen.
  Nun müsste der Renderer alles können was man für Hardware Skinning braucht - auch könnte man nun über Vertex
  Shader die GeoMipmaps des Terrains interpolieren lassen so das es kein 'poppen' mehr gibt. :)



>> 05.02.2005
[CO]
PLRenderer:
- BuildSelectionFrustum() in BuildSelectionPlaneSet() umbenannt



>> 26.01.2005
[CO]
- PLTSurfaceListener::PLTSurfaceListener: Da die Kamera dummerweise von PLTRendererCamera angeleitet wird, was man nie machen
  sollte muss man hier per Hand diese Resource dem Renderer hinzufügen/entfernen, dann ist der Crash beim beenden wech.
  Bei Zeiten muss ich das mit der Kamera mal komplett überarbeiten. :)



>> 18.01.2005
[CO]
- PLTRendererFrame: Von OnMessage() auf OnKeyPressed() umgestellt



>> 11.01.2005
[CO]
- Machte ein paar kleinere Bug-Fixes



>> 09.01.2005
[CO]
- Alles noch an ein paar Änderungen angepasst.



>> 26.12.2004
[CO]
- Diverse kleine Bugfixes... die Listen umstellung war wirklich heftig ;-)



>> 25.12.2004
[CO]
- Kleinere Bugs durch das umstellen auf PLContainer in PLRenderer und PLModelLib behoben - nun müssten diese zwei Projekte
  eigentlich wieder soweit funktionieren - auf jedenfall laufen die entsprechenden Test Projekte. ;-)



>> 22.12.2004
[CO]
- PLRenderer an neue Container Klassen angepasst, bei ModelLib auch gleich alles auf das neue FS
  umgestellt damit diese Lib unabhängig von der Engine ist. Da ich es nicht Testen konnte ist es möglich das hier 
  und da noch Fehler drin sind, hab mich zwar angestrengt möglichst nichts zu übersehen, aber das gelingt ja meistens
  nur sehr selten. :(
- Renderer Backends aus dem Renderer Ordner nach PLEngine/Source verschoben



>> 19.12.2004
[CO]
- PLRenderer & Backends: main.cpp an Plugin in Module Makro Umbenennung angepasst



>> 14.12.2004
[SB]
- Plugin-Definitionen der Renderer-Plugins sowie der Sound-Plugins teilweise wiederhergestellt sowie Includes angepaßt,
  bei den Plugin-Definitionen war wohl einiges durcheinander gekommen
- PLRenderer: Nanu?? Wer behauptet denn, man könne abstrakte Basisklassen nicht korrekt am RTTI registrieren??
              Habe PLRenderer wieder entfernt und statt dessen PLTRenderer korrekt am RTTI registriert sowie
              die abgeleiteten Klassen angepasst :-)



>> 13.12.2004
[CO]
PLRenderer:
- Passte alles an RTTI Änderungen an. PLTRenderer wird nun von PLRenderer abgeleitet da PLTRenderer selbst
  eine Abstrakte Klasse ist und es daher nicht möglich ist diese Klasse korrekt im RTTI zu regestrieren.
  Entweder lassen wir das so oder wir basteln PLTRenderer so um das die Klasse nicht mehr abstrakt ist - was
  ich aber nicht soo schön fände. Hm, andererseits haben wir mehere vergleichbare Klasse die einerseits abstrakt
  sind, andererseits aber als Basis (& Gruppe) dienen sollen. (PLTSceneManager, TPixelLabPlugin in PixelLab etc.)



>> 03.12.2004
[CO]
PLRenderer:
- Fügte ein Null-Backend hinzu - dieses verhält sich wie ein normales Renderer Backend, nur verwendet es keine
  API wie D3D/OpenGL sondern versucht so viel wie möglich selbst zu realsieren, richtig Rendern kann dieses 
  Backend jedoch nicht.
- Renderer Backend Dinge werden nicht mehr direkt in den Renderer eingebunden, somit ist die Renderer Dll selbst
  nun auch unabhängig von Cg - die Codes in diesem Ordner sind ja 'nur' ein Angebot das man als Basis für sein 
  Backend verwenden kann damit man nicht mehr ALLES komplett neu schreiben muss. PLTRendererBackendCg erweitert
  die Grund Klasse um Cg initialisierung etc. Später werd ich diesen Shader Teil wohl leicht umschreiben so das
  auch problemlos andere Shader Sprachen verwenden kann. (dafür muss ich ja nur kleine Teile neu Designen :)



>> 28.11.2004
[CO]
PLRenderer:
- PL::Config wird nun nicht mehr verwendet - stellte alles aus PLTConfig aus PLGeneral um. Für das konkrete
  laden/speichern der Einstellungen wird dann wohl die Engine zuständig sein.
  -> Der Renderer ist somit nun komplett unabhängig von der Engine



>> 26.11.2004
[CO]
PLRenderer:
- Passte den Renderer an die von uns in PLGeneral selbst definierten Datentypen an.
  -> PLMaterialPass.h & PLTextureHandler.h in der Engine wurden aktualisiert.



>> 19.11.2004
[CO]
PLRenderer:
- Füge BackupDeviceObjects() & RestoreDeviceObjects() Funktionen im Direct3D Backend hinzu, noch nicht komplett implementiert.
- D3D: PLTRendererVertexBufferD3D9 & PLTRendererIndexBufferD3D9 um PL_USAGE_SOFTWARE erweitert - dies Dient nur als Software Speicher
  mit dem NICHT gerendert werden kann sondern nur als Zwischenspeicher oder so dienen kann. Das OpenGL Backend kann zwar damit auch
  Rendern - wird aber nur verwendet wenn die Hardware keine VBOs kann, D3D macht das intern selbst.
- Überall PL::Log. in PLTLog::GetInstance()-> geändert



>> 15.11.2004
[CO]
PLRenderer:
- Neue Funktionen: BackupDeviceObjects() & RestoreDeviceObjects() -> Werden z.B. beim wechseln des Fenstermodus verwendet
  um aktuelle Device Objekt Daten zu sichern und wiederherzustellen. Dabei muss jeder Resourcen Typ selbst seine Daten in 
  einen Buffer sichern, bei vielen Daten könnte das zwar dann probleme mit den Datenmengen machen, mir viel jedoch keine
  andere möglichkeit ein da man die Daten in Texturen, (beispielsweise dynamisch erzeugte) Vertex Buffern etc. nicht
  einfach wieder nachladen kann. So wie es aussieht klappt das mit dem Bildschirm Modus wechseln + Resourcen aktualsieren
  im OpenGL Backend. Zumindestes bei mir scheint das mit dem Wechsel nun ziemlich gut zu funktionieren, nur in Jens Grabkammer
  Welt scheint noch irgendetwas zu sein was bei Wechsel einen Crash verursacht - der Sache werd ich morgen auf den Grund gehen.



>> 14.11.04
[CO]
PLRenderer:
- Das setzen der Sampler States im OpenGL Backend funktioniert nun besser (z.B. Mipmapping)
- Das wecheln in den Vollbild Modus ist implementiert. PLTRendererSurfaceWindow und dessen Backend implementationen
  machen die Hauptarbeit - dabei bekommt es beim Erzeugen seinen Bildschirm Modus (vollbild oder nicht) und kann diesen
  nicht mehr ändern. Dies ist aber kein Problem da es sich bei dieser Renderer Oberfläche ja nicht um das eigentliche
  Fenster sondern 'nur' um einen Ausgabebereich handelt. Im normallfall arbeitet man nur mit PLTRendererWindow und
  PLTRendererFrame wobei das letztere das mit dem Vollbild/nicht Vollbild automatisch implementiert - also NUR Frames
  lassen sich zwischen Vollbild oder Fenster Modus umschalten, kann man später natürlich ändern aber ich denke das wäre
  nicht so sinnig.
  Das eventuelle Aktualisieren von z.B. Texturen ist noch nicht implementiert - wie es scheint muss man selbst den Device
  Context dann neu anlegen, daher klappt das umschalten des Modus noch nicht wirklich.



>> 11.11.04
[CO]
- An das RTTI angepasst



>> 07.11.04
[CO]
PLRendererD3D9:
- Das Direct3D Backend läuft nun zu ca. 80% korrekt - Auch die Shader funktionieren bereits. :)



>> 05.11.04
[CO]
PLRendererD3D9:
- Das Direct3D Backend läuft nun zu ca. 70% korrekt



>> 20.10.04
[CO]
PLRenderer:
- Neue Texture Formate: PL_TPF_D16, PL_TPF_D24 und PL_TPF_D32 -> Nötig wenn man nur Tiefenwerte in eine Textur
  rendern will (für z.B. ShadowMapping braucht man eine solche 'Depth Map' :)
  Die Textur selbst lässt sich dann wie PL_TPF_L8/PL_TPF_L16 beim Rendern verwenden - also als Textur mit nur einem
  Farbkanal.



>> 05.10.04
[CO]
PLRenderer:
- PLTRendererVertexBufferOpenGL::GetData() -> Scheint nun zu korrekt funktionieren - bei Jens verursachte meine kleine Offset Optimierung
  zuvor lustige Textur Fehler. :)



>> 04.10.04
[CO]
PLRenderer:
- Neue Funktion: DrawPlane() -> Zum Visualisieren einer Ebene was zu Testzwecken recht nützlich sein kann. :)



>> 03.10.04
[CO]
PLRenderer:
- PLTRendererIndexBuffer: Neue Funktionen: GetData() & SetData() zum auslesen und setzen von Indices ohne das man sich um den internen Index Typ
  kümmern muss -> Diese Funktionen sollte man nach möglichkeit IMMER verwenden!
  Passte gleich alle Codes daran an, nun kann man problemlos auch USHORT verwenden wenn das ausreichend ist - gibt mehr Performance!
- Neue Funktion: PLTRenderer: MakeScreenshot() -> Macht einen Screenshot vom aktuellen Render Target



>> 22.09.04
[CO]
- Behob fehler in PLTSurfaceListener::DrawProfiling()



>> 18.09.04
[CO]
PLRenderer:
- Um zu prüfen ob Dynamische VBOs extrem langsam sind und ob es nicht schneller ginge wenn man das wie früher hochläd
  baute ich in PLTRendererIndexBufferOpenGL und PLTRendererVertexBufferOpenGL eigene Buffer ein welche die VBOs übernehmen.
  Aber selbst Dynamische VBOs sind dann noch schneller als die 'alte Methode' wenn diese ständig aktualisiert werden.
  Naja, das Experiment hatte den Nebeneffekt das diese Buffer nun auch funktionieren wenn die Karte keine VBOs kann - 
  was aber glaub ich jede Karte mittlerweile unterstützt. ;-)
- Optimierte PLTRendererVertexBufferOpenGL::GetData() etwas durch das vorspeichern der Offsets - das brachte mir
  bei meinem momenten extrem Vertex reichen Wasser Test das doppelte an FPS. (12 statt 6 ;-)
  (hm, beim importieren von 3ds modellen scheint es probleme zu machen... darum erstmal die optimierung rauskommentiert
  bis ich rausgefunden hab wieso das nur dort so ist :)



>> 17.09.04
[CO]
PLRenderer:
- 1D Texturen funktionieren nun richtig



>> 11.09.04
[CO]
PLRendererOpenGL:
- OpenGL Header aktualisiert (siehe gl.zip)
- Neues Feature: Unterstützung von Depth Bounds Test (GL_EXT_depth_bounds_test) welches quasi eine Erweiterung
  der Scissor Tests in 'der Tiefe' ist. Kann mit der Renderer Funktion GetDepthBounds() & SetDepthBounds() abgefragt
  und gesetzt werden. Konnte diese Extension ebenfalls nicht testen aber wenn diese vorhanden ist spart diese beim
  aufwendigen PerPixelLighting & Shadow Volumes nochmal etwas Füllrate welche bei dieser Technik ja der Flaschenhals
  ist.



>> 10.09.04
[CO]
PLRenderer:
- Two sided stencil tests implementiert - werden bereits wenn verfügbar von den Shadow Volumes verwendet. (GL_EXT_stencil_two_side)
  Es sind dafür 5 neue Render States hinzugekommen. Konnte dieses Feature zwar nicht selbst testen da es keine meiner
  mittlerweile etwas veralteren Grafikkarten kann - aber auf allen neuen Karten müsste es funktionieren. :)
  Stefan, du hast ja ne GeForce5 - wäre super wenn du mal PLTShadowVolume::DrawZPass() und PLTShadowVolume::DrawZFail()
  testen könntest, im Prinzip siehst du sofort obs geht oder nicht da es normalerweise wenn verfügbar Automatisch
  verwendet wird. :)
- Neue Funktion: GetViewportCorners() -> Gibt einen die aktuellen Viewport Ecken zurück - quasi das 'Fenster' durch
  welches man in die Welt schaut. Wird für diverse Dinge immer mal wieder gebraucht, u.a. bei den Shadow Volumes um zu
  prüfen ob sich die Kamera im Schatten befindet oder nicht.



>> 09.09.04
[CO]
- Neben CalculateBoundingBox() zum berechnen der Bounding Box eines VertexBuffers/Meshs gibt es nun noch
  CalculateBoundingSphere() welche die Bounding Sphere berechnet.
  In PLTObject und dem ODE äquivalent wird nun der Entity Kollisions Radius mit hilfe dieser neuen Funktion berechnet anstatt den
  Radius der Bounding Box zu nehmen welcher meist größer ist.



>> 06.09.04
[CO]
- Neue Funktionen: GetFlags(), SetFlags(), GetCustomFlags(), SetCustomFlags() -> Flags welche z.B. in der Engine
  gesetzt werden wenn gerade etwas spezielles gerendert wird. (ambient(lighting pass, projective texturing etc.)
  Damit kann man unterbinden das Texturen, Shader, spezielle Render States etc. gesetzt werden.
  Mir viel bis jetzt keine bessere Lösung ein wo man das machen könnte, darum implementierte ich das nun universell
  in den Renderer, und wenn man noch etwas braucht erweitert man es dort halt entsprechend. Zuerst wollte ich mit 
  Hilfe der Custom Render Flage in der Engine vermerken in welchem Render Modus man gerade ist, jedoch stellte sich 
  recht schnell heraus das dies im Chaos und Gehacke geendet hätte.
  Im Scene Manager PLTSMPerPixelLighting werden diese Flags bereits recht umfangreich benötigt.



>> 28.08.04
[CO]
PLRenderer:
- PLRendererTypes.h -> PLColor3.h und PLColor4.h eingebunden da die Farben nun eigenständige Klassen sind



>> 12.08.04
[CO]
PLRenderer:
- Neue Funktion:BuildSelectionFrustum() -> Erzeugt einen Frustum dem man zum Selektieren mit hilfe eines Rechtecks
  auf dem Bildschirm verwenden kann.



>> 11.08.04
[CO]
PLRenderer:
- PLTRendererSurfaceListenerHandler eingebaut der in PLTEntityCamera benötigt wird... bei Zeiten könnte man all diese Handler
  in einer Basis-Klasse vereinen...



>> 10.08.04
[CO]
- Musste die Fix-Pass Renderer Light überarbeiten da man Positionen etc. nicht wirklich gut über DWORD managen kann.
- Neuer Render-State: PL_RS_FIXEDFILLMODE -> Ist dieser Status gesetzt bestimmt er allein den verwendeten Füll-Modus,
  damit kann man z.B. immer einen Wireframe Modus erzwingen egal was ein Material für einen Füllmodus setzt.



>> 07.08.04
[CO]
PLRenderer:
- PLTRendererSurface -> Kann nun aktiviert/deaktiviert werden
- PLTRendererWindow & PLTRendererFrame aktivieren/deaktivieren automatisch ihr Surface
- Stellt auf neues Log in PLGeneral um



>> 03.08.04
[CO]
- PLTRendererOpenGL::Get3DCoordinate() funktioniert nun richtig



>> 02.08.04
[CO]
PLRenderer:
- 3D texturen funktionieren nun korrekt
- Unterstützt nun Point Sprites mit denen z.B. Partikel gezeichnet werden können
- SetRenderState() etc. geben nun die alten Werte zurück und -1 bei einem Fehler, so geht das Speichern
  der alten Einstellungen leichter



>> 01.08.04
[CO]
PLRenderer:
- Vertex und Index Buffer kann man nun nur noch über SetVertices()/SetIndices() und nicht mehr direkt über
  MakeCurrent() setzen



>> 27.07.04
[CO]
PLRenderer:
- VertexBuffer: Vertex Element in Vertex Attribute umbenannt um Namensverwechslungen mit der Anzahl an Elementen
  in einem Buffer zu vermeiden. Das zog zwar einige Anpassungen nach sich - nun ist es aber wesentlich einsichtiger
  was gemeint ist.
- Render To Texture System überarbeitet so das es nun wesentlich einfacher ist in Texturn zu Rendern. Einfach
  mit z.B. CreateSurfaceTexture2D() eine entsprechende Textur erzeugen. Mit SetRenderTarget() setzen und später
  kann man die konkrete Textur welche man über PLTRendererSurfaceTexture::GetTexture() wie alle anderen Texturen auch
  verwenden.
- Texture pixel formats (PLE_TPF) erweitert, u.a. gibt es nun auch floating point pixel buffer in welche man z.B.
  Rendern kann. Diese floating point buffer gewinnen immer mehr an Bedeutung da sich damit viele fortschrittliche
  Techniken wie Realtime HDRI realisieren lassen...
PLRendererOpenGL:
- wglext.h in gl.zip aktualisiert -> Muss wie üblich bei den VC Includes aktualisiert werden



>> 24.07.04
[CO]
PLRenderer:
- Neuen Render State: PL_RS_INVCULLMODE -> Damit kann man den API Cull Mode invertieren, praktisch wenn man
  Reflektionen rendert bei denen durch die Reflection Matrix die Vertex Anordnung vertauscht wird!



>> 20.07.04
[CO]
- Vertex Buffer können nun optional bei MakeCurrent oder SetVertices einen Offset haben



>> 08.07.04
[CO]
PLRenderer:
- DrawBitmap, DrawPoint und DrawLine werden nun im OpenGL Backend direkt mit OpenGL Befehlen dargestellt was
  die Performance mehr 4 mal verbesserte da man für einzelne Punkte etc. nicht mehr extra umständlich einen
  Buffer einstellen muss. (lohne nur wirklich für viele Primitives!)
  Im Direct3D Backend kann man es aber anscheinend nicht anderst machen.
  Somit lassen sich nun auch Ingame GUIs flüssig darstellen. (sie PLSampleLarge)
- Neue Funktion: GetOcclusionQuery() -> Damit kann man eine standard Occlusion Query Instance bekommen falls
  es sich nicht lohnt eigene Objekte zu erzeugen - wird erst wirklich nötig wenn man mehre Tests gleichzeitig
  machen will.


>> 07.07.04
[CO]
PLRenderer:
- Implementierte eine Occlusion Query Klasse welche z.B. benötigt wird um zu prüfen ob ein Portal derzeit
  komplett verdeckt ist und somit nicht sichtbar ist oder nicht. (komplett Dynamischer zusätzlicher Test :)
  Über Occulision Tests wird in Zukunft auch geprüft ob ein Licht gerade verdeckt ist oder nicht - somit
  braucht man die Funktion ReadDepthComponent() nicht mehr welche unter Direct3D derzeit noch nicht geht...
  (bei Zeiten könnte man diese Funktion vielleicht ganz aus dem Renderer nehmen :)



>> 22.06.04
[CO]
PLRenderer:
- Neue Funktionen zum abfragen der Anzahl der Oberflächen und Resourcen. Mit PLTRenderer::GetConfigs() erhält
  man die Renderer Einstellungen welche früher noch direkt von der Engine abgefragt wurden... ist zwar noch nicht
  die schönste Lösung erfüllt aber fürs erste ihren Zweck bis man sich da was schickes ausgedacht hat. :)
  Desweiteren ist der Renderer nun unabhängig von der Engine - müsste die Log zugriffe dafür rauskommentieren -
  sollte man wieder reinnehmen sobald das Log in PLGeneral ist.
  Musste bei PLTRendererCamera das Entity binding herausgeben. In der Engine ist nun eine Ableitung davon namens
  PLTCamera welche noch Entity Binding implementiert. Wird die Engine verwendet wird immer nur diese Camera
  verwendet und nicht PLTRendererCamera direkt!
- PLTMaterialBase -> Abstraktes Material Interface für z.B. die Model Lib damit diese von der Engine nichts
  zu wissen braucht. Dafür gibt es PLTMaterialBaseFactory welche Materialien erzeugen kann.



>> 10.06.04
[CO]
PLRenderer:
- PLTRendererVertexBuffer: Neue Funktion: GetMinMaxPos() -> ermittelt die Bounding Box des Vertex Buffers
  (das wird man sicherlich immer mal wieder brauchen :)



>> 27.05.04
[CO]
- PLTRendererBuffer: Neue Funktion: IsLocked()
- PLTRendererVertexBuffer::AddVertexElement()  funktioniert nun korrekt beim hinzufügen von Vertex Elementen
  nach dem anlegen des Buffers



>> 26.05.04
[CO]
- Diverse kleinere Fehler im Renderer etc. behoben so das nun die Shader wieder soweit funktionieren. In PLTests gibts
  nun nen neues Entity welches zum Mesh testen da ist und mit dem sich auch z.B. BumpMapping testen lässt.



>> 25.05.04
[CO]
PLRenderer:
- PLTRendererVertexBuffer::AddVertexElement() kann nun auch nachdem ein Buffer bereits angelegt wurde dem Buffer
  neue Vertex Elemente wie z.B. Normalen Daten hinzufügen. In diesem Fall muss intern der Buffer umkopiert werden.
  Auf RemoveElement() funktionen werde ich erstmal versichten da mir dies momentan unnötig viel Arbeit erscheint
  für etwas was im normalfall niemals gemacht wird.



>> 21.05.04
[CO]
- Vertex und Index Buffer haben nun Copy-Operatoren



>> 20.05.04
[CO]
PLRenderer:
- Bemerkte das ich im Renderer teils bei SRC einen dreher drin hatte und SCR geschrieben hatte -> Behoben



>> 15.05.04
[CO]
PLRenderer:
- SetTextureStageState() -> Diverse Detailverbesserungen



>> 14.05.04
[CO]
- Das Renderer Test Projekt wurde nun gelöscht da dieses Dinge nun in PLSampleLarge sind.
  (Backup in Backups/TestProjects/PLRendererTest.zip)



>> 13.05.04
[CO]
PLRenderer:
- Neue Funktionen: DrawTriangle(), DrawQuad(), DrawBox(), DrawSphere() -> Diese Funktionen zeichnen ein 
  Dreieck, Rechteck, eine Box und eine Sphere was für Debugging zwecke hilfreich ist da man dann nicht 
  erst umständlich jedesmal Vertex, Index Buffer etc. erzeugen und einstellen musss
  -> In PLTests ein paar Testfunktionen für diese neuen Renderer Dinge.
- Neue Funktion: ReadDepthComponent() -> Kann aus dem Tiefen Buffer lesen -> vorerst ist die Funktion noch
  nicht komplett durchdacht da ich in z.B. Direct3D keine glReadPixels ähnliche Funktion finden konnte -
  aber nun kann man z.B. endlich wieder einfach prüfen ob ein Licht verdeckt wird oder nicht :)
- Neue States: TextureStageState -> Damit lässt sich für jede Textureinheit Mischfunktionen und Texture
  Koordinaten erzeugung (z.B. EnvironmentMapping) einstellen.



>> 12.05.04
[CO]
PLRenderer:
- Neue Funktion: Reset() -> Setzt alle Renderer Einstellungen zurück auf Default
- SetTexture() -> Wird als Texture Stage -1 übergeben so betrift die Einsellung ALLE Texture Stages.
  Bei SetClipPlaneEnabled() und SetClipPlane() ist es nun genauso.
- Neue Funktionen: GetDefaultRenderStates(), GetDefaultSamplerStates(), GetDefaultLightStates() -> Diese
  Funktionen sind praktisch damit man z.B. in PLTMaterial
  nicht erneut die Standard Einstellungen Definiern muss. :)
- Verbesserte diverse intere Design Dinge im Renderer (u.a. States setzen etc)
- Neue Funktionen: GetPointSize(), SetPointSize(), GetLineWidth(), SetLineWidth() -> zum setzen/abfragen der
  Punkt größe und Linien Breite, dieses Funktionen gibt es anscheinend in Direct3D nicht... jedoch sind diese
  für Debug zwecke sehr hilfreich daher entschloss ich mich diese Funktionen im Renderer zu implementieren



>> 11.05.04
[CO]
PLRenderer:
- Neue Funktion: GetCamera() gibt die zuletzt gesetzte Renderer Kamera zurück, manchmal ist es praktisch zu
  wissen mit welchen Daten die aktuelle View Matrix etc. erzeugt wurde - desweiteren muss man hin und wieder zur
  z.B. bestimmung einer Entfernung die Position der Kamera wissen
  PLTRendererCamera ist nun ebenfalls eine Renderer Resource - anderst wäre es zu umständlich und meist wird
  sowieso ein Renderer unabhängiges Kamera Entitie verwendet. :)



>> 05.05.04
[CO]
PLRenderer:
- Neue Funktionen: GetColor() & Set Color() -> damit stellt man die aktuelle Farbe von z.B. Text, Linien, Bitmaps
  etc. ein.



>> 04.05.04
[CO]
PLRenderer:
- Neue Funktionen: DrawPoint() und DrawLine()



>> 21.03.04
[SB]
PLRenderer:
- Neue Klassen PLTVertexBuffer und PLTIndexBuffer hinzugefügt,
  welche in den neuen Modell-Klassen und im Renderer Verwendung finden werden



>> 15.03.04
[CO]
PLRenderer:
- Neue Funktionen: GetMax3DTextureSize() & GetMaxCubeMapTextureSize() liefert die Maximale Textur größe dieser
  Texture Typen zurück - diese werden auch ins Log geschrieben.
- PLTTexture: Neue Funktionen: GetMaxTextureSize() -> liefert die maximale Texture größe für den aktuelle Textur Typ



>> 25.02.04
[CO]
PLRenderer:
- PLTTexture::Load -> Wandelt nun intern BGR Texturen in RGB um
PLRendererOpenGL:
- Nun sind alle GL_ARB_multitexture Extension Funktionen verwendbar



>> 20.01.04
[CO]
- PLTRendererHandler löscht nicht mehr selbst Standardmäßig den Bildschirm Puffer. Dies sollte im normalfall ein Clear-Entity
  übernehmen oder im Fall der Editoren wird der Renderer Handler angewiesen den Bildschirm Puffer selbst zu löschen



>> 03.01.04
[CO]
PLRendererOpenGL:
- Neue Extensions werden verwendet: GL_EXT_texture_rectangle & GL_NV_texture_rectangle -> diese machen beide das gleiche
  und werden auch auf die gleiche art verwendet. Damit kann man auch Texturen welche kein vielfaches von 2 (z.B. 465x234)
  verwenden. Über das plt-Format kann man in General -> Rectangle=1 eine Textur als Rectangle markieren.
  Diese spezielle Textur Art kann man z.B. hervorragend für Menüs etc. verwenden da man dann die Orginal Texturen verwenden
  kann was die Bildquailtät deutlich verbessert. Jedoch hat diese Textur art einige Einschränkungen. Siehe
  http://oss.sgi.com/projects/ogl-sample/registry/NV/texture_rectangle.txt für mehr Informationen.
  -> API Dokumentation im Material Kapitel um einen Textur Teil erweitert.



>> 25.12.03
[CO]
PLRendererOpenGL:
- Neue Extension wird verwendet: GL_EXT_draw_range_elements
- PLTGeometry: Von glDrawElements() auf glDrawRangeElementsEXT() umgestellt da Effektiver.
  Wenn über GetPointer() Geometry Indices verändert wurden MUSS man nun die Funktion UpdateMinMaxIndex()
  aufrufen welche die neuen min/max Indices ermittelt. Entsprechende Stellen in allen Projekt-Codes aktualisiert.
  (war nur bei PLTEntities und ME und in der Engine selbst nötig :)
- Nahm Extension NV_vertex_array_range heraus da mittlerweile durch ARB_vertex_buffer_object ersetzt



>> 23.12.03
[CO]
PLRendererOpenGL:
- Warf GL_HP_occlusion_test über Bord und stellte PLTRenderer::OcclusionTest() auf die neue GL_ARB_occlusion_query Extension
  um. Mit dieser neuen Extension welche es erst seit kurzem gibt kann man nun auch herausbekommen wieviele der gezeichneten
  Pixel sichtbar sind
- glext.h um GL_ARB_occlusion_query erweitert, aktuelle Datei wie üblich im Libs-Ordner (gl.zip)



>> 20.12.03
[CO]
PLRenderer:
- PLTRenderFrame -> GuiFrame Base Funktionen werden nun aufgerufen
- PLTRenderWindow -> GuiWindow Base Funktionen werden nun aufgerufen
- PLTRenderFrame: Neue Funktionen: SetToggleFullscreenMode() & GetToggleFullscreenMode() -> Damit kann man Einstellen ob es
  erlaubt ist den Vollbild-Modus des Fenster über Alt-Return zu wechseln
- PLTRenderFrame: Sobald das Fenster den Fokus verliert wird nun auch dessen Input Handler deaktiviert



>> 13.12.03
[CO]
PLRenderer:
- PLTRenderFrame setzt nun auch Variable PL::Config.m_bFullscreen damit der Fullscreen-Status gespeichert werden kann. Das
  macht zwar nur Sinn wenn man ein Render Frame hat aber wenn man mehere Frames verwendet so laufen diese überlicherweise
  immer im Fenster Modus. In 'normalen' Projekten hat man nur einen Render Frame und dann ist es sehr komfortabel wenn der
  Vollbild Modus gespeichert wird.



>> 04.12.03
[CO]
PLRendererOpenGL:
- Renderer: Neue Extension wird verwendet: GL_ARB_texture_mirrored_repeat -> Damit ist ein neuer Texture Wrap Modus möglich:
  PL_MIRRORED_REPEAT welcher mit PL_REPEAT vergleichbar ist, die Textur aber zusätzlich noch spiegelt
  -> Modell Editor angepasst -> PL User Guide angepasst



>> 29.11.03
[CO]
- In fast allen Projekten gab es durch empfindlichere Compiler Einstellungen diverse Warnungen welche nun behoben sind



/*********************************************************\
 *  Einträge aus altem Diary, damals noch ohne genaue Datum angaben. (oben -> unten = neuer -> älter)
\*********************************************************/



[CO] PL::Renderer: Neue Funktion: GetMaxTextureSize() -> gibt die größt mögliche Texture größe zurück
[SB] PLTRenderer: Für die 2D Funktionen kann nun angegeben werden, auf welcher Z-Position sie zeichnen sollen. Dieser
     Wert wird durch Set2DZPosition gesetzt und steht normaler Weise auf 0
[SB] PLTFont wurde erweitert, um an eine bestimmte Z-Position zu zeichnen. Dieser Parameter hat einen Default-Wert von
     0 und kann daher ignoriert werden, wenn er nicht explizit verwendet werden soll
[CO] In PLTTexture::LoadData() wird nun überprüft ob die Texture größe ok ist... notfalls wird diese passend gemacht ->
     ansonnsten kann die Textur u.a. nicht von der Grafik-Karte verwendet werden und die Textur bleibt weis (oder andere
     fehler könnten auftreten...)
[CO] Erste Version von PLTRendererStates implementiert (ist bereits ein leichter Performance zuwachs zu bemerken :)
[CO] PLTRenderer: Neue Funktion: OcclusionTest() -> Prüft ob eine Bounding Box von etwas anderem komplett verdeckt wird
     oder nicht -> mehr Performance da der Overdraw reduziert wird! :)
[CO] Neue Extension wird verwendet: GL_HP_occlusion_test -> Damit lässt sich Hardware mäßig schnell prüfen ob etwas das
     gerendert werden soll von etwas anderem komplett verdeckt wird oder nicht
[CO] Zum Texturen Laden wird nun DevIL (openil.sourceforge.net) verwendet, dadurch kann man nun sehr viel mehr Textur
     Formate einlesen und speichern -> Datei PLTextureLoad.cpp gelöscht
[CO] Neue Extension wird verwendet: GL_EXT_texture_edge_clamp -> Ähnlich wie GL_ARB_texture_border_clamp -> Material
     entsprechend um PL_CLAMP_TO_EDGE erweitert
[CO] PLTTextureHandler um neue Funktion erweitert: GetTexEnvCombineParameters() -> Damit bekommt man zugriff auf diverse
     Combine Parameter mit denen man größere Kontrolle darüber hat wie die verschiedenen Textur Schichten kombiniert
     werden
[CO] Neue Extension wird verwendet: GL_ARB_texture_border_clamp -> GL_CLAMP_TO_BORDER_ARB ist eine weitere Texture
     Wrapping Funktion neben CLAMP und REPEAT -> Wird im Material mit CLAMP_TO_BORDER gesetzt
[CO] Neue Extension wird verwendet: GL_EXT_texture_lod_bias -> Damit kann man den Textur Filter einstellen und eine Textur
     z.B. verwaschener darstellen -> Lässt sich im Textur Handler mit der Funktion SetTexLodBias() einstellen -> Könnte
     man sogar Animieren und hätte damit einen weiteren möglichen Textur Effekt! :)  -> PLSamples neues Beispiel Entity:
     EntityTexLodBiasAni -> Test:   EntityTexLodBiasAni m_szModelFilename="farn"  -> sieht nüsch übel aus ;-)
[CO] PLTRenderChild gelöscht da unnötig
[CO] PLTRendererHandler: ShowInfos() -> Informationen können Standardmäßig eingeblendet werden. Nur in ausnahmefällen
     sind diese nicht Erwünscht... wie z.B. bei der Textur Ansicht im Debug Dialog
[CO] PLTRendererHandler -> Über Debug-Flags kann man nun einstellen ob die Koordianten Axen, Ebenen usw. eingeblendet
     werden sollen -> lässt sich Global über PL::Config und nun auch individuell Einstellen
[SB] Einige kleinere Anpassungen in PlRenderer vorgenommen
[CO] PLTRendererHandler -> Lässt sich nun Aktivieren oder Deaktivieren, PLTRenderWindow deaktiviert seinen Renderer
     Handler automatisch sobald es unsichbar wird
[CO] PLTRenderWindow: Neue Funktion: GetInputHandler()
[CO] PLTRenderFrame::OnMessage() reagiert auf ALT-RETURN um den Bildschirm Modus umzuschalten (Fenster/Vollbild)
[SB] Fullscreen mode umgeschrieben: Das Schalten in den Vollbildmodus und zurück ist nun Aufgabe von PLTRenderFrame,
     dabei reagiert das Fenster darauf, wann es aktiviert oder deaktiviert wird. Dies ermöglicht auch mehreren
     Render-Fenstern gleichzeitig, noch korrekt zu funktionieren. Im Moment gibt es jedoch ein Problem mit der
     Farbtiefe, wodurch nach dem Umschalten des Modus evtl. fehlerhafte Grafik dargestellt wird
[SB] Der RendererHandler wurde überarbeitet (z.B. Schalten in den Fullscreen-Mode)
[SB] Das unsichtbare Fenster, welches den Device-Kontext erstellt, ist nun vom Typ PLTRenderWindow und wurde außerdem
     in m_pRenderWindow umbenannt (um Verwechslungen mit dem Application-Main-Window zu vermeiden)
[SB] Neue Klassen für Render-Fenster eingebaut: PLTRenderWindow als Basis, davon abgeleitet PLTRenderFrame für
     eigenständige Fenster und PLTRenderChild für eingebettete Render-Fenster
[CO] Verwendung neuer Extension eingebaut: ARB_vertex_buffer_object -> Gibt es erst seit kurzem und daher muss man die
     neusten Treiber haben. Diese Extension wird engeblich von fast allen Karten unterstützt. Kann mit
     NV_vertex_array_range verglichen werden der die Vertex Daten direkt in der Hardware speichert was einen enormen
     Performance gewinn für Statische Dinge bringe. Jedoch muss man sich bei der neuen Extension nicht mehr um einen
     eigenen Vertex Manager bemühen da es im gegensatz zu der alten Extension problemlos möglich ist viele kleine Vertex
     Arrays zu haben! (das worauf ich schon seit längerem wartete!! :)
[CO] PLTRendererHandler -> Projective Texturing -> Nur Entities im Licht FOV werden neu gerendert
[CO] PLTRenderer: SetBlendMode() herausgenommen da normalerweise über Material eingestellt, zudem ist die derzeitige
     implementation unzureichend... später beim Überarbeiten des Renderes kann man diese Funktion ja neu implementieren
     (derzeit aber nicht benötigt... und vorallem nicht in der Form :)
[CO] PLTExtensions: wglMakeContextCurrentARB & wglGetCurrentReadDCARB wieder herausgenommen da anscheinend nicht mehr
     unterstützt (problem des teilen von Daten zwischen verschiedenen Rendering context lässt sich auch mit
     wglShareLists() lösen)
[CO] Neue Extensions wird unterstützt: GL_EXT_separate_specular_color -> für besseres Specular highlighting
[CO] Das Rendern in Texturen über den PBuffer klappt nun! -> Im Modell Editor ist eine kleine Demo implementation welche
     zeigt wie man das Rendern in Texturen macht... lässt sich genauso verwenden wie das normale Rendern in Fenster :)
[CO] Der RendererHandler kann nun auch in eine Textur Rendern. (über den Hardware PBuffer) Dazu muss man beim
     Initialisieren eines Renderer Handlers statt eines Window Handlers einfach NULL angeben, dann noch die Textur
     einstellen in welche gerendert werden soll et voila ;-)
[CO] Neue Extensions werden verwendet: GL_SGIS_generate_mipmap & WGL_ARB_pbuffer & WGL_ARB_pixel_format &
     WGL_ARB_render_texture, desweiteren PLTRendererExtensions übersichtlicher gestaltet
[CO] PLTRenderer: InitOpenGL() & DeInitOpenGL() & ConfigOpenGL() in PLTRendererHandler verschoben
[SB] Get2DCoordinate() berechnet nun selbst die Projektion (ohne GLU), außerdem wird durch vorher gespeicherte Matrizen
     ein Auslesen aus OpenGL vermieden, was sowohl Geschwindigkeitsvorteile bringt als auch die Fehleranfälligkeit
     verringert (Die OpenGl-Matrizen können nicht immer gelesen werden und werden außerdem durch evtl. Rendering-Vorgänge
     beeinflußt)
[SB] PLTRenderer: Neue Funktion zum Anzeigen einer orientierten Bounding Box (OBB) eingebaut. Die anderen Methoden
     zeigen eine axis-aligned Bounding Box an, welche durch zwei Punkte bestimmt ist. Eine OBB ist jedoch durch zwei
     Punkte nicht eindeutig bestimmt, daher dient diese Methode zum Anzeigen einer OBB.
[CO] PLTRenderer: Der Renderer hat hat nun sein ein eigenes Haupt-Fenster welches quasi als 'Anker' dient. Nötig falls
     gerade z.B. eine OpenGL Textur angelegt werden soll und kein Fenster vorhanden ist! Jedoch ist dieses
     Renderer-Fenster 'unsichtbar', stört also nicht! :)
[CO] Wird ein Fenster geschlossen so werden nun alle Renderer Handler welche dieses verwendeten de-initialisiert... und beim
     Fenster-Modus umstellen mit dem neuen Fenster Handle wieder neu initialisiert :)  -> War auch ursache für einen
     lästigen Crash!! :)
[CO] PLTRendererHandler -> Jeder Renderer Handler hat nun eine Priorität mit welcher man einfluss darauf nehmen kann vor
     welchen anderen Renderer Handlern dieser gerendert werden soll
[CO] PLTRendererHandler::GetSceneManager() liefert nun den standard scene manager zurück falls kein scene manager
     gesetzt wurde
[CO] Der Rendering Contex wird nun bei der Renderer De-Initialisierung und nicht mehr beim beenden eines Renderer
     Handlers aufgelöst
[CO] PL::Renderer.Clear() Funktion nimmt nun Engine eigene Parameter an
[CO] Windows Struktur DEVMODE in Renderer zum Speichern der Bildschirmauflösungen durch eigenen Struktur namens
     PLTDisplayMode ersetzt.
[SB] PLTFont: Die Anzeige von Schrift ist nun mit in die übrigen 2D Funktionen eingebaut und kann damit mit einer beliebigen
     virtuellen Auflösung arbeiten
[SB] PLTRenderer: Funktion zum Setzen des Blend Modes eingebaut, die möglichen Einstellungen sind Alpha, Additive und Off
[CO] Baute Funktionen PL::Renderer.Get3DCoordinate() & PL::Renderer.Get2DCoordinate() ein
[SB] Baute die Funktionen Begin2DMode() und End2DMode() in den Renderer ein
[SB] Änderungen im Fenster/Renderer-Code, es wird nun GetClientRect() verwendet, damit im Fenstermodus das Renderbild komplett
     zu sehen ist und nicht ein Teil von der Titelleiste verdeckt wird
